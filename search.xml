<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>solidity-library</title>
      <link href="/2023/07/08/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-library/"/>
      <url>/2023/07/08/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-library/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity-library"><a href="#solidity-library" class="headerlink" title="solidity-library"></a>solidity-library</h1><p>库函数是一种特殊的合约，为了提升solidity代码的复用性和减少gas而存在。库合约一般都是一些好用的函数合集（库函数），由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。</p><p>他和普通合约主要有以下几点不同：</p><ul><li>不能存在状态变量</li><li>不能够继承或被继承</li><li>不能接收以太币</li><li>不可以被销毁</li></ul><h1 id="声明库"><a href="#声明库" class="headerlink" title="声明库"></a>声明库</h1><p>使用library关键字声明库，一般都是独立到单独的文件中，下面简单的实现了一个减法方法，减去的结果必须大于等于0，否则报错</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;library Math &#123;    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) &#123;        uint256 result = _x - _y;        require(result &gt;= 0, &quot;&quot;);        return result;    &#125;&#125;</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>我们先要import库合约，使用库函数有两种方法；</p><h2 id="利用using-for指令"><a href="#利用using-for指令" class="headerlink" title="利用using for指令"></a>利用using for指令</h2><p>第一种是使用 <code>using A for B</code>，可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;import &quot;./Math.sol&quot;;contract testMath &#123;    using Math for uint256;        function subXY1(uint256 _x, uint256 _y) public pure returns (uint256) &#123;        return _x.sub(_y);    &#125;&#125;</code></pre><h2 id="通过库合约名称调用库函数"><a href="#通过库合约名称调用库函数" class="headerlink" title="通过库合约名称调用库函数"></a>通过库合约名称调用库函数</h2><p>直接通过库合约名调用</p><pre><code class="solidity">    function subXY2(uint256 _x, uint256 _y) public pure returns (uint256) &#123;        return Math.sub(_x, _y);    &#125;</code></pre><h1 id="部署测试"><a href="#部署测试" class="headerlink" title="部署测试"></a>部署测试</h1><p>正常使用，两种方式都能正确的运行<br><img src="/images/69cc1434-c327-412b-b983-776362d6099f-image.png" alt="69cc1434-c327-412b-b983-776362d6099f-image.png" title="69cc1434-c327-412b-b983-776362d6099f-image.png"></p><p>如果结果小于0，则报错回退<br><img src="/images/477a4f5d-643b-4510-9c81-fa118c499ca2-image.png" alt="477a4f5d-643b-4510-9c81-fa118c499ca2-image.png" title="477a4f5d-643b-4510-9c81-fa118c499ca2-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity-接收和发送eth</title>
      <link href="/2023/07/08/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81eth/"/>
      <url>/2023/07/08/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81eth/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity-接收和发送eth"><a href="#solidity-接收和发送eth" class="headerlink" title="solidity-接收和发送eth"></a>solidity-接收和发送eth</h1><h1 id="接收eth"><a href="#接收eth" class="headerlink" title="接收eth"></a>接收eth</h1><h2 id="receive"><a href="#receive" class="headerlink" title="receive"></a>receive</h2><p>Solidity支持两种特殊的回调函数，receive()和fallback()，他们主要在两种情况下被使用：</p><ul><li>接收ETH </li><li>处理合约中不存在的函数调用（代理合约proxy contract）</li></ul><p>注意⚠️：在solidity 0.6.x版本之前，语法上只有 fallback() 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，solidity才将 fallback() 函数拆分成 receive() 和 fallback() 两个函数。</p><p>我们这一讲主要讲接收ETH的情况。</p><p>receive() 只用于处理接收ETH。一个合约最多只能有一个 receive() 函数，声明方式与一般函数不一样，不需要 function   关键字：<code>receive() external payable &#123; ... &#125;</code>。receive()函数不能有任何的参数，不能返回任何值，必须包含external 和 payable。</p><p>当合约接收ETH的时候，receive() 会被触发。receive() 最好不要执行太多的逻辑因为如果别人用 send 和 transfer 方法发送ETH的话，gas会限制在2300，receive() 太复杂可能会触发<code>Out of Gas</code>报错；如果用 call 就可以自定义 gas 执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。</p><p>我们可以在receive()里发送一个event，例如：</p><pre><code class="solidity">    // 定义事件    event Received(address Sender, uint Value);    // 接收ETH时释放Received事件    receive() external payable &#123;        emit Received(msg.sender, msg.value);    &#125;</code></pre><p>有些恶意合约，会在 receive() 函数（老版本的话，就是 fallback() 函数）嵌入恶意消耗gas的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。</p><h2 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h2><p>fallback() 函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。fallback()声明时不需要 function 关键字，必须有 external 修饰，一般也会用payable修饰，用于接收ETH:<br><code>fallback() external payable &#123; ... &#125;</code>。</p><p><strong>当存在calldata的时候，调用的本合约的fallback，而不是目标合约的fallbacl，这点需要注意</strong></p><p>我们定义一个fallback()函数，被触发时候会释放fallbackCalled事件，并输出msg.sender，msg.value和msg.data:</p><pre><code class="solidity">    // fallback    fallback() external payable &#123;        emit fallbackCalled(msg.sender, msg.value, msg.data);    &#125;</code></pre><h2 id="receive和fallback的区别"><a href="#receive和fallback的区别" class="headerlink" title="receive和fallback的区别"></a>receive和fallback的区别</h2><p>receive和fallback都能够用于接收ETH，他们触发的规则如下：</p><p><img src="/images/ebc6e2c7-1312-4c32-a4d0-2c9f2e1390fa-receive_fallback.jpg" alt="ebc6e2c7-1312-4c32-a4d0-2c9f2e1390fa-receive_fallback.jpg" title="ebc6e2c7-1312-4c32-a4d0-2c9f2e1390fa-receive_fallback.jpg"></p><p>简单来说，合约接收ETH时，msg.data为空且存在receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为 payable。</p><p>receive()和payable fallback()均不存在的时候，向合约直接发送ETH将会报错（你仍可以通过带有payable的函数向合约发送ETH）。</p><p>演示示例等我们介绍完发送eth之后再一起看。</p><h1 id="发送eth"><a href="#发送eth" class="headerlink" title="发送eth"></a>发送eth</h1><p>Solidity有三种方法向其他合约发送ETH，他们是：transfer()，send()和call()，其中call()是被鼓励的用法。</p><p>我们先写一个接受eth的合约用来测试，很简单，定义了 receive 和 fallback 函数，一个获取余额的方法以及Log事件用来记录转账的来源地址和转了多少代币</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract ReceiveETH &#123;    // 收到eth事件，记录amount和gas    event Log(address from, uint256 amount);    // receive方法，接收eth时被触发    receive() external payable &#123;        emit Log(msg.sender, msg.value);    &#125;    fallback() external payable &#123;        emit Log(msg.sender, msg.value);    &#125;    // 返回合约ETH余额    function getBalance() public view returns (uint256) &#123;        return address(this).balance;    &#125;&#125;</code></pre><p>:::danger<br>我们将实现三种方法向ReceiveETH合约发送ETH。我们在发送ETH合约SendETH中实现payable的构造函数和receive()，让我们能够在部署时可以给一定数量的初始代币。（下面代码中第6行的payable）</p><p>否则合约里面如果没有足够的代币，将会发送失败。<br>:::</p><h2 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h2><ul><li>用法是<code>接收方地址</code>.transfer(发送ETH数额)。</li><li>transfer()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。</li><li>transfer()如果转账失败，会自动revert（回滚交易）。</li></ul><p><strong>如果想要给目标合约发送代币，则目标合约的地址必须加上payable修饰符，否则无法转账。</strong></p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract SendETH &#123;    // 构造函数，payable使得部署的时候可以转eth进去    constructor() payable &#123;&#125;    // receive方法，接收eth时被触发    receive() external payable &#123;&#125;    fallback() external payable &#123;&#125;    // 用transfer()发送ETH    function transferETH(address payable _to, uint256 amount) external &#123; // 目标地址必须加上payable修饰符        _to.transfer(amount);    &#125;    // 返回合约ETH余额    function getBalance() public view returns (uint256) &#123;        return address(this).balance;    &#125;&#125;</code></pre><p>部署的时候我们给1000个代币，此时接收的合约代币为0，发送的合约代币为1000<br><img src="/images/3bf2181e-2d63-42f2-8acc-ee5191c9f23d-image.png" alt="3bf2181e-2d63-42f2-8acc-ee5191c9f23d-image.png" title="3bf2181e-2d63-42f2-8acc-ee5191c9f23d-image.png"></p><p>然后转100个代币给接收合约，通过下图可以看到已经转账成功，并且receive()被触发，并记录了Log<br><img src="/images/ff577069-2207-4ebf-bbf1-1d6b7c6a8a04-image.png" alt="ff577069-2207-4ebf-bbf1-1d6b7c6a8a04-image.png" title="ff577069-2207-4ebf-bbf1-1d6b7c6a8a04-image.png"></p><p>如果我们再转999个代币，此时余额只剩900个了，那么就无法转账，最终revert<br><img src="/images/c8595195-3d31-4ebe-a6c5-85101479d4bf-image.png" alt="c8595195-3d31-4ebe-a6c5-85101479d4bf-image.png" title="c8595195-3d31-4ebe-a6c5-85101479d4bf-image.png"></p><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><ul><li>用法是<code>接收方地址</code>.send(发送ETH数额)。</li><li>send()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。</li><li>send()如果转账失败，不会revert。</li><li>send()的返回值是bool，代表着转账成功或失败，需要额外代码处理一下。</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract SendETH &#123;    // 构造函数，payable使得部署的时候可以转eth进去    constructor() payable &#123;&#125;    // receive方法，接收eth时被触发    receive() external payable &#123;&#125;    fallback() external payable &#123;&#125;    // send()发送ETH    function sendETH(address payable _to, uint256 amount) external &#123; // 目标地址必须加上payable修饰符        // 处理下send的返回值，如果失败，revert交易并发送error        bool success = _to.send(amount);        if (!success) &#123;            revert();        &#125;    &#125;    // 返回合约ETH余额    function getBalance() public view returns (uint256) &#123;        return address(this).balance;    &#125;&#125;</code></pre><p>然后转100个代币给接收合约，通过下图可以看到已经转账成功，并且receive()被触发，并记录了Log<br><img src="/images/92d57913-d72d-4e2e-839d-431f37daa46c-image.png" alt="92d57913-d72d-4e2e-839d-431f37daa46c-image.png" title="92d57913-d72d-4e2e-839d-431f37daa46c-image.png"></p><p>如果我们再转999个代币，此时余额只剩700个了（转了3次100），那么就无法转账，最终revert<br><img src="/images/f12270b2-c253-424f-ac26-33474a062e04-image.png" alt="f12270b2-c253-424f-ac26-33474a062e04-image.png" title="f12270b2-c253-424f-ac26-33474a062e04-image.png"></p><h2 id="call（推荐）"><a href="#call（推荐）" class="headerlink" title="call（推荐）"></a>call（推荐）</h2><ul><li>用法是<code>接收方地址</code>.call{value: 发送ETH数额}(“”)。</li><li>call()没有gas限制，可以支持对方合约fallback()或receive()函数实现复杂逻辑。</li><li>call()如果转账失败，不会revert。</li><li>call()的返回值是(bool, data)，其中bool代表着转账成功或失败，需要额外代码处理一下。</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract SendETH &#123;    // 构造函数，payable使得部署的时候可以转eth进去    constructor() payable &#123;&#125;    // receive方法，接收eth时被触发    receive() external payable &#123;&#125;    fallback() external payable &#123;&#125;    function callETH(address payable _to, uint256 amount) external &#123; // 目标地址必须加上payable修饰符        (bool success, ) = _to.call&#123;value: amount&#125;(&quot;&quot;);        if (!success) &#123;            revert();        &#125;    &#125;    // 返回合约ETH余额    function getBalance() public view returns (uint256) &#123;        return address(this).balance;    &#125;&#125;</code></pre><p>然后转100个代币给接收合约，通过下图可以看到已经转账成功，并且receive()被触发，并记录了Log<br><img src="/images/75d3374a-27ce-4aca-a73e-fe1fdd549743-image.png" alt="75d3374a-27ce-4aca-a73e-fe1fdd549743-image.png" title="75d3374a-27ce-4aca-a73e-fe1fdd549743-image.png"></p><p>如果我们再转999个代币，此时余额只剩900个了，那么就无法转账，最终revert<br><img src="/images/6f44c496-e4fb-4f5a-ba9a-3235aaa45b6c-image.png" alt="6f44c496-e4fb-4f5a-ba9a-3235aaa45b6c-image.png" title="6f44c496-e4fb-4f5a-ba9a-3235aaa45b6c-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity-调用已部署合约</title>
      <link href="/2023/07/08/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E8%B0%83%E7%94%A8%E5%B7%B2%E9%83%A8%E7%BD%B2%E5%90%88%E7%BA%A6/"/>
      <url>/2023/07/08/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E8%B0%83%E7%94%A8%E5%B7%B2%E9%83%A8%E7%BD%B2%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="调用已部署合约"><a href="#调用已部署合约" class="headerlink" title="调用已部署合约"></a>调用已部署合约</h1><p>开发者写智能合约来调用其他合约，这让以太坊网络上的程序可以复用，从而建立繁荣的生态。很多web3项目依赖于调用其他合约，比如收益农场（yield farming）。这一讲，我们介绍如何在已知合约代码（或接口）和地址情况下调用目标合约的函数。</p><h1 id="目标合约"><a href="#目标合约" class="headerlink" title="目标合约"></a>目标合约</h1><p>我们先写一个简单的合约OtherContract来调用，并定义了接口</p><p>这个合约包含一个状态变量_x，一个事件Log在收到ETH时触发，三个函数：</p><ul><li>getBalance(): 返回合约ETH余额。</li><li>setX(): external payable函数，可以设置_x的值，并向合约发送ETH。</li><li>getX(): 读取_x的值。</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;interface IOtherContract &#123;    function getBalance() external view returns (uint256);    function setX(uint256 x) external payable;    function getX() external view returns (uint256 x);&#125;contract OtherContract is IOtherContract &#123;    uint256 private _x = 0; // 状态变量_x    // 收到eth的事件，记录amount和gas    event Log(uint256 amount, uint256 gas);    // 返回合约ETH余额    function getBalance() public view returns (uint256) &#123;        return address(this).balance;    &#125;    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)    function setX(uint256 x) external payable &#123;        _x = x;        // 如果转入ETH，则释放Log事件        if (msg.value &gt; 0) &#123;            emit Log(msg.value, gasleft());        &#125;    &#125;    // 读取_x    function getX() external view returns (uint256 x) &#123;        x = _x;    &#125;&#125;</code></pre><h1 id="调用OtherContract合约"><a href="#调用OtherContract合约" class="headerlink" title="调用OtherContract合约"></a>调用OtherContract合约</h1><p>我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：<code>_Name(_Address)</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址。然后用合约的引用来调用它的函数：<code>_Name(_Address).f()</code>，其中f()是要调用的函数。</p><p>下面我们介绍4个调用合约的例子，在remix中编译合约后，分别部署OtherContract和CallContract：</p><h2 id="传入合约地址"><a href="#传入合约地址" class="headerlink" title="传入合约地址"></a>传入合约地址</h2><p>我们可以在函数里传入目标合约地址，通过接口生成目标合约的引用，然后调用目标函数。以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，传入已部署好的OtherContract合约地址_Address和setX的参数x：</p><blockquote><p>这里说明一下，不通过接口，直接通过目标合约代码也是可以生成目标合约的引用，但是一般都是通过接口。</p></blockquote><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;import &#123;IOtherContract&#125; from &quot;./OtherContract.sol&quot;;contract CallContract &#123;    function callSetX(address _Address, uint256 x) external &#123;        IOtherContract(_Address).setX(x);    &#125;&#125;</code></pre><p><img src="/images/3b0a5fa0-77b9-4d03-a8db-c3a63efc55bf-image.png" alt="3b0a5fa0-77b9-4d03-a8db-c3a63efc55bf-image.png" title="3b0a5fa0-77b9-4d03-a8db-c3a63efc55bf-image.png"></p><h2 id="传入合约变量"><a href="#传入合约变量" class="headerlink" title="传入合约变量"></a>传入合约变量</h2><p>我们可以直接在函数里传入合约的引用，只需要把上面参数的address类型改为目标合约名，比如OtherContract。下面例子实现了调用目标合约的getX()函数。</p><p>注意该函数参数<code>IOtherContract _Address</code>底层类型仍然是address，生成的ABI中、调用callSetX时传入的参数都是address类型</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;import &#123;IOtherContract&#125; from &quot;./OtherContract.sol&quot;;contract CallContract &#123;    function callSetX(IOtherContract _Address, uint256 x) external &#123;        _Address.setX(x);    &#125;&#125;</code></pre><p><img src="/images/4425e9dc-83fd-4c8a-843e-2af39b04d048-image.png" alt="4425e9dc-83fd-4c8a-843e-2af39b04d048-image.png" title="4425e9dc-83fd-4c8a-843e-2af39b04d048-image.png"></p><h2 id="创建合约变量"><a href="#创建合约变量" class="headerlink" title="创建合约变量"></a>创建合约变量</h2><p>我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量oc存储了OtherContract合约的引用：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;import &#123;IOtherContract&#125; from &quot;./OtherContract.sol&quot;;contract CallContract &#123;    function callSetX(address _Address, uint256 x) external &#123;        IOtherContract oc = IOtherContract(_Address);        oc.setX(x);    &#125;&#125;</code></pre><p><img src="/images/2ab7952f-845f-4150-8a34-61d46e2f1193-image.png" alt="2ab7952f-845f-4150-8a34-61d46e2f1193-image.png" title="2ab7952f-845f-4150-8a34-61d46e2f1193-image.png"></p><h2 id="调用合约并发送ETH"><a href="#调用合约并发送ETH" class="headerlink" title="调用合约并发送ETH"></a>调用合约并发送ETH</h2><p>如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：_Name(_Address).f{value: _Value}()，其中_Name是合约名，_Address是合约地址，f是目标函数名，_Value是要转的ETH数额（以wei为单位）。</p><p>OtherContract合约的setX函数是payable的，在下面这个例子中我们通过调用setX来往目标合约转账。</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;import &#123;IOtherContract&#125; from &quot;./OtherContract.sol&quot;;contract CallContract &#123;    function callSetX(address _Address, uint256 x) external payable &#123;        IOtherContract oc = IOtherContract(_Address);        oc.setX&#123;value: msg.value&#125;(x);    &#125;&#125;</code></pre><p><img src="/images/08db2187-e0fa-4849-aff1-91d66216a6be-image.png" alt="08db2187-e0fa-4849-aff1-91d66216a6be-image.png" title="08db2187-e0fa-4849-aff1-91d66216a6be-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity-异常 error require assert</title>
      <link href="/2023/07/07/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E5%BC%82%E5%B8%B8%20error%20require%20assert/"/>
      <url>/2023/07/07/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E5%BC%82%E5%B8%B8%20error%20require%20assert/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity-异常"><a href="#solidity-异常" class="headerlink" title="solidity-异常"></a>solidity-异常</h1><p>写智能合约经常会出bug，solidity中的异常命令帮助我们debug，并且加强我们合约的健壮性</p><h1 id="error-revert"><a href="#error-revert" class="headerlink" title="error&amp;revert"></a>error&amp;revert</h1><p>error是solidity 0.8版本新加的内容，方便且高效（省gas）地向用户解释操作失败的原因。人们可以在contract之外定义异常。在执行当中，error必须搭配revert（回退）命令使用。</p><p>也可以直接使用 revert 抛出异常，而不用定义 error ，也可以 revert 自定义的error，同时可以进行传参</p><pre><code class="solidity">function testError(uint256 amount) public view &#123;    if (_balance[msg.sender] &lt; amount) &#123;        revert(&quot;error Insufficient balance&quot;);    &#125;&#125;error amountError(string errMsg, uint256 amount); // 也可以写在合约代码块外面function testCustomError(uint256 amount) public view &#123;    if (_balance[msg.sender] &lt; amount) &#123;        revert amountError(&quot;custom error&quot;, amount);    &#125;&#125;</code></pre><h1 id="require"><a href="#require" class="headerlink" title="require"></a>require</h1><p>require命令是solidity 0.8版本之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高。使用方法：require(检查条件，”异常的描述”)，当检查条件不成立的时候，就会抛出异常。</p><pre><code class="solidity">function testReqiure(uint256 amount) public view &#123;require(_balance[msg.sender] &gt; amount, &quot;require: balance must more than amount&quot;); // 当不满足前面的条件时，抛出异常，并显示自定义信息&#125;</code></pre><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>assert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）。它的用法很简单，assert(检查条件），当检查条件不成立的时候，就会抛出异常。</p><pre><code class="solidity">function testAssert(uint256 amount) public view &#123;    assert(_balance[msg.sender] &gt; amount); // 当不满足前面的条件时，抛出异常&#125;</code></pre><h1 id="部署测试"><a href="#部署测试" class="headerlink" title="部署测试"></a>部署测试</h1><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;error amountError(string errMsg, uint256 amount);contract errorTest &#123;    mapping(address =&gt; uint256) public _balance;    constructor() &#123;        _balance[msg.sender] = 100;    &#125;    function testError(uint256 amount) public view &#123;        if (_balance[msg.sender] &lt; amount) &#123;            revert(&quot;error Insufficient balance&quot;);        &#125;    &#125;    function testCustomError(uint256 amount) public view &#123;        if (_balance[msg.sender] &lt; amount) &#123;            revert amountError(&quot;custom error&quot;, amount);        &#125;    &#125;    function testReqiure(uint256 amount) public view &#123;        require(            _balance[msg.sender] &gt; amount,            &quot;require: balance must more than amount&quot;        ); // 当不满足前面的条件时，抛出异常，并显示自定义信息    &#125;    function testAssert(uint256 amount) public view &#123;        assert(_balance[msg.sender] &gt; amount); // 当不满足前面的条件时，抛出异常    &#125;&#125;</code></pre><p>只要我们的余额小于amount，就会抛出异常</p><ul><li>error<br><img src="/images/d12656c8-899d-479b-9f9e-7401a3cf3dec-image.png" alt="d12656c8-899d-479b-9f9e-7401a3cf3dec-image.png" title="d12656c8-899d-479b-9f9e-7401a3cf3dec-image.png"></li><li>自定义error<br><img src="/images/4a098772-403f-476c-81b1-8d47c89be1bb-image.png" alt="4a098772-403f-476c-81b1-8d47c89be1bb-image.png" title="4a098772-403f-476c-81b1-8d47c89be1bb-image.png"></li><li>require<br><img src="/images/f06b6b8f-20c4-4954-a0fc-cf016273a3ab-image.png" alt="f06b6b8f-20c4-4954-a0fc-cf016273a3ab-image.png" title="f06b6b8f-20c4-4954-a0fc-cf016273a3ab-image.png"></li><li>assert<br><img src="/images/468fa0e9-9090-411a-a77a-01e8e5e3ab00-image.png" alt="468fa0e9-9090-411a-a77a-01e8e5e3ab00-image.png" title="468fa0e9-9090-411a-a77a-01e8e5e3ab00-image.png"></li></ul><h1 id="消耗gas对比"><a href="#消耗gas对比" class="headerlink" title="消耗gas对比"></a>消耗gas对比</h1><ul><li>error <code>2886</code>gas</li><li>自定义error <code>3005</code>gas</li><li>require <code>2945</code>gas</li><li>assert <code>2645</code>gas</li></ul><p>gas的消费不是固定的，由于assert没有打印任何信息，消费的gas最少，但是如果error不打印任何信息，消耗的gas才是最少的。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity-事件</title>
      <link href="/2023/07/06/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/07/06/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity-事件"><a href="#solidity-事件" class="headerlink" title="solidity-事件"></a>solidity-事件</h1><p>Solidity中的事件（event）是EVM上日志的抽象，它具有两个特点：</p><ul><li>响应：应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。</li><li>经济：事件是EVM上比较经济的存储数据的方式，每个大概消耗2000 gas；相比之下，链上存储一个新变量至少需要20000 gas。</li></ul><h1 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h1><p>事件的声明由 event 关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以ERC20代币合约的Transfer事件为例：</p><pre><code class="solidity">event Transfer(address indexed from, address indexed to, uint256 value);</code></pre><p><img src="/images/6cde8a24-9c3d-438b-a8f9-2fcee7a7ac67-image.png" alt="6cde8a24-9c3d-438b-a8f9-2fcee7a7ac67-image.png" title="6cde8a24-9c3d-438b-a8f9-2fcee7a7ac67-image.png"><br><img src="/images/ce086240-750b-45dc-8255-35fe605de811-image.png" alt="ce086240-750b-45dc-8255-35fe605de811-image.png" title="ce086240-750b-45dc-8255-35fe605de811-image.png"></p><p>我们可以看到，Transfer事件共记录了3个变量from，to和value，分别对应代币的转账地址，接收地址和转账数量。</p><p>同时from和to前面带着indexed关键字，每个indexed标记的变量可以理解为检索事件的索引“键”，在以太坊上单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件最多有3个带indexed的变量。每个 indexed 变量的大小为固定的256比特。事件的哈希以及这三个带indexed的变量在EVM日志中通常被存储为topic。其中topic[0]是此事件的keccak256哈希，topic[1]到topic[3]存储了带indexed变量的keccak256哈希。</p><p>value 不带 indexed 关键字，会存储在事件的 data 部分中，可以理解为事件的“值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 data 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 topic 部分中，也是以哈希的方式存储。另外，data 部分的变量在存储上消耗的gas相比于 topic 更少。</p><p>我们可以在函数里释放事件。在下面的例子中，每次用_transfer()函数进行转账操作的时候，都会释放Transfer事件，并记录相应的变量。</p><h1 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h1><p>假设我们有一个很简单的合约模拟转账，部署合约的时候给创建人发10000个币，然后有一个_Transfer方法，来进行代币转移，并且转移的时候触发事件</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract TransferContract &#123;    mapping(address =&gt; uint256) public _balance;    event Transfer(address indexed from, address indexed to, uint256 value);    constructor() &#123;        _balance[msg.sender] = 10000;    &#125;    function _Transfer(address from, address to, uint256 amount) external &#123;        _balance[from] -= amount;        _balance[to] += amount;        emit Transfer(from, to, amount);    &#125;&#125;</code></pre><h1 id="部署测试"><a href="#部署测试" class="headerlink" title="部署测试"></a>部署测试</h1><p>我们把这个合约部署到 <code>Sepolia</code>测试网，可以看到我们已经有10000个币了<br><img src="/images/b6551387-33f8-4129-af27-06b9e97c7700-image.png" alt="b6551387-33f8-4129-af27-06b9e97c7700-image.png" title="b6551387-33f8-4129-af27-06b9e97c7700-image.png"></p><p>然后我们用这个账号给其他账号发送币，随便在测试网上找一个账号发送就行，我们发送的地址是<code>0x8aFa169D45cc17EB61AA2F5D8658A2C37Ac4B22b</code>，并且可以在debug中看到日志已经被记录<br><img src="/images/17f707cb-2188-4282-8198-f83a2ac86532-image.png" alt="17f707cb-2188-4282-8198-f83a2ac86532-image.png" title="17f707cb-2188-4282-8198-f83a2ac86532-image.png"></p><p>然后我们去浏览器上看看，可以看到，浏览器已经记录了我们触发的日志，发送人和接收人都没有问题<br><img src="/images/e43fc44a-6b64-4f0c-acf5-be675110494b-image.png" alt="e43fc44a-6b64-4f0c-acf5-be675110494b-image.png" title="e43fc44a-6b64-4f0c-acf5-be675110494b-image.png"></p><p><img src="/images/a4250ce8-72f9-46cb-bf50-f0aca2894268-image.png" alt="a4250ce8-72f9-46cb-bf50-f0aca2894268-image.png" title="a4250ce8-72f9-46cb-bf50-f0aca2894268-image.png"></p><h1 id="事件topic的作用"><a href="#事件topic的作用" class="headerlink" title="事件topic的作用"></a>事件topic的作用</h1><p>接下来我们说说日志的topic有什么作用，topic的作用就是可以跟踪触发了这个事件的所有交易记录，一个事件的topic都是一样的，并不会随着触发事件而改变</p><p>比如我们再转100代币给<code>0x51bE6c7d69E16325b23b174e57C672c99FBcC572</code>这个地址<br><img src="/images/1d680397-b75d-4cf0-8036-9c4d85662adc-image.png" alt="1d680397-b75d-4cf0-8036-9c4d85662adc-image.png" title="1d680397-b75d-4cf0-8036-9c4d85662adc-image.png"></p><p>此时就会产生两条交易触发了此事件，我们就可以通过这个topic来找到所有交易，上面我们的两个交易就都查到了，并且topic都是一样的。<br><img src="/images/b3126cb8-3c26-4355-a220-aa6dcbc64315-image.png" alt="b3126cb8-3c26-4355-a220-aa6dcbc64315-image.png" title="b3126cb8-3c26-4355-a220-aa6dcbc64315-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sodility-call&amp;delegatecall&amp;代理合约</title>
      <link href="/2023/07/05/%E5%8C%BA%E5%9D%97%E9%93%BE/sodility-call&amp;delegatecall&amp;%E4%BB%A3%E7%90%86%E5%90%88%E7%BA%A6/"/>
      <url>/2023/07/05/%E5%8C%BA%E5%9D%97%E9%93%BE/sodility-call&amp;delegatecall&amp;%E4%BB%A3%E7%90%86%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="sodility-call和delegatecall"><a href="#sodility-call和delegatecall" class="headerlink" title="sodility call和delegatecall"></a>sodility call和delegatecall</h1><p>call 和 delegatecall 都是 address 类型的低级成员函数，它用来与其他合约交互。它的返回值为(bool, data)，分别对应 call 是否成功以及目标函数的返回值。</p><h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>先来说说call</p><ul><li>call是solidity官方推荐的通过触发fallback或receive函数发送ETH的方法，<code>_to.call&#123;value: AMOUNT&#125;(&quot;&quot;)</code>，<strong>后面的传参直接为空，就是发送代币，而不是调用合约方法</strong>。</li><li>不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数。</li><li>当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数。</li></ul><p>我们可以利用结构化编码函数abi.encodeWithSignature来帮我们生成编码code，然后再通过call来进行调用合约方法。具体的可以看<a href="https://baihuzi.com/article/7a1e32e9-621e-434e-83e9-d0afdb5b8d03" title="solidity用abi调用智能合约的方法详解">solidity用abi调用智能合约的方法详解</a>一文。</p><p>另外call在调用合约时可以指定交易发送的ETH数额和gas：<br><code>_address.call&#123;value:发送数额, gas:gas数额&#125;(二进制编码)</code>;</p><p>我们来看下具体怎么用，下面是一个简单的合约 call.sol ，foo函数用来接收参数x和msg.value，注意当需要接收外部的代币时，需要指定方法为payable。</p><pre><code class="solidity">// SPDX-License-Identifier: MIT// call.solpragma solidity ^0.8.17;contract Callled &#123;    uint256 public x;    uint256 public balance;    function foo(uint256 _x) external payable returns (string memory) &#123;        x = _x;        balance = msg.value;        return &quot;foo called&quot;;    &#125;&#125;</code></pre><p>再来看看调用合约，用法就是这么简单，Call方法里的address需要是call合约的地址，而如果需要通过call发送代币，则需要加上payable修饰符，且在call方法后面加个大括号，传入需要发送的代币量，此时call合约中的foo方法就可以直接拿到传递过去的msg.value了，同时我们还可以再大括号中指定用多少gas</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract CallFoo &#123;    function Call(address _address, uint256 _num) external payable &#123;        (bool success, ) = _address.call&#123;value: msg.value, gas: 300000&#125;(            abi.encodeWithSignature(&quot;foo(uint256)&quot;, _num)        );        require(success, &quot;call fail&quot;);    &#125;&#125;</code></pre><p>部署测试<br><img src="/images/b568959a-34eb-4a1e-80eb-00ba2f730095-image.png" alt="b568959a-34eb-4a1e-80eb-00ba2f730095-image.png" title="b568959a-34eb-4a1e-80eb-00ba2f730095-image.png"></p><h1 id="delegatecall"><a href="#delegatecall" class="headerlink" title="delegatecall"></a>delegatecall</h1><p>delegatecall与call类似，是solidity中地址类型的低级成员函数。delegate中是委托&#x2F;代表的意思，那么delegatecall委托了什么？</p><p>当用户A通过合约B来call合约C的时候，执行的是合约C的函数，语境(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。<br><img src="/images/93d7ab52-f732-48ce-8809-fe7e8677fa59-image.png" alt="93d7ab52-f732-48ce-8809-fe7e8677fa59-image.png" title="93d7ab52-f732-48ce-8809-fe7e8677fa59-image.png"></p><p>而当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是语境仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。也就是说合约c只是处理逻辑，修改的状态结果最终会保存在B合约上。<br><img src="/images/adb12196-7334-423c-9e67-835a9c2f08f4-image.png" alt="adb12196-7334-423c-9e67-835a9c2f08f4-image.png" title="adb12196-7334-423c-9e67-835a9c2f08f4-image.png"></p><p>使用方式基本上和call一样，但有一点不一样，就这一点至关重要，<strong>delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额</strong></p><blockquote><p>注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p></blockquote><h1 id="什么情况下会用到delegatecall"><a href="#什么情况下会用到delegatecall" class="headerlink" title="什么情况下会用到delegatecall?"></a>什么情况下会用到delegatecall?</h1><p>目前delegatecall主要有两个应用场景：</p><ul><li><p>代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行。因为合约一旦部署上链，是没有办法再进行修改的，此时我们就可以通过代理合约，来进行合约升级，此时只需要将代理合约地址指向新的升级后的逻辑合约即可。</p></li><li><p>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合约的代理合约。</p></li></ul><h1 id="合约升级"><a href="#合约升级" class="headerlink" title="合约升级"></a>合约升级</h1><p>就代理合约，下面来举个例子看看：</p><p>假设我有一个代理合约delegateContrace.sol，一个逻辑合约A.sol，代码分别如下，有一点需要注意，代理合约和逻辑合约的变量类型以及顺序必须完全一致，并且虽然逻辑合约中修改的状态最终作用于代理合约，但是我们仍然需要声明变量类型，否则编译会报错。</p><ul><li><p>delegateContrace.sol<br>&#96;&#96;&#96;solidity<br>&#x2F;&#x2F; SPDX-License-Identifier: MIT<br>  pragma solidity ^0.8.17;</p><p>  contract delegateContract {<br>  uint256 public x;<br>  string public y;<br>  address public sender;<br><br>  function setXY(<br>      address _address,<br>      uint256 _x,<br>      string memory _y<br>  ) external returns (bool) {<br>      sender &#x3D; msg.sender;<br>      (bool success, ) &#x3D; _address.delegatecall(<br>          abi.encodeWithSignature(“setXY(uint256,string)”, _x, _y)<br>      );<br>      return success;<br>  }<br>  }<br>&#96;&#96;&#96;</p></li><li><p>A.sol<br>&#96;&#96;&#96;solidity<br>  &#x2F;&#x2F; SPDX-License-Identifier: MIT<br>  pragma solidity ^0.8.17;</p><p>  contract A {<br>  uint256 public x;<br>  string public y;<br>  address public sender;<br><br>  function setXY(<br>      uint256 _x,<br>      string memory _y<br>  ) external payable returns (string memory) {<br>      sender &#x3D; msg.sender;<br>      x &#x3D; _x;<br>      y &#x3D; _y;<br>      return “setXY called”;<br>  }<br>  }<br>&#96;&#96;&#96;</p></li></ul><p>先分别部署测试一下，我们可以看到，逻辑合约中变量都是初始变量，并没有改变，而代理合约中的变量已经被修改了。<br><img src="/images/79308089-1632-4923-a6cc-044035a9bd4e-image.png" alt="79308089-1632-4923-a6cc-044035a9bd4e-image.png" title="79308089-1632-4923-a6cc-044035a9bd4e-image.png"></p><p>当然，不通过代理合约，我们也可以直接调用逻辑合约A的方法，此时A的变量会改变成为新的值，但是代理合约中的变量并不会随之更改，如下图所示<br><img src="/images/784031f6-4739-40a4-b851-f5c36607731f-image.png" alt="784031f6-4739-40a4-b851-f5c36607731f-image.png" title="784031f6-4739-40a4-b851-f5c36607731f-image.png"></p><p>之前就说了，代理合约可以用来做合约升级，那如果我的处理逻辑需要改变，此时A合约就已经不适用了，那我们需要重新部署一个新合约B，来进行合约升级.</p><p>同样的，变量类型及顺序需要完全一致，我们修改了处理逻辑，把数字x加了1，而把字符串前面拼接了new string，下面是合约B的代码</p><ul><li>B.sol<pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract B &#123;    uint256 public x;    string public y;    address public sender;    function setXY(        uint256 _x,        string memory _y    ) external payable returns (string memory) &#123;        sender = msg.sender;        x = _x + 1;        bytes memory _ba = bytes(_y);        bytes memory _bb = bytes(&quot;new string &quot;);        string memory ret = new string(_ba.length + _bb.length);        bytes memory bret = bytes(ret);        uint k = 0;        for (uint i = 0; i &lt; _bb.length; i++) bret[k++] = _bb[i];        for (uint i = 0; i &lt; _ba.length; i++) bret[k++] = _ba[i];        y = string(ret);        return &quot;setXY called&quot;;    &#125;&#125;</code></pre></li></ul><p>此时只需要我们把代理合约的地址指向新的逻辑合约B，即可实现合约的升级，此时我们可以看到结果，代理合约中的变量已经变成了 <code>101</code> 和 <code>new string hello</code>，这说明我们的处理逻辑已经变成了新的，并且代理合约中的变量并没有重置，而是在原有的基础上进行的修改，这样我们就通过delegatecall代理合约是现实了合约升级。<br><img src="/images/0b256ea6-e0da-4bd1-af43-cc3b3731c069-image.png" alt="0b256ea6-e0da-4bd1-af43-cc3b3731c069-image.png" title="0b256ea6-e0da-4bd1-af43-cc3b3731c069-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity-用abi调用智能合约的方法详解</title>
      <link href="/2023/07/05/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E7%94%A8abi%E8%B0%83%E7%94%A8%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/07/05/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-%E7%94%A8abi%E8%B0%83%E7%94%A8%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity用abi调用智能合约的方法详解"><a href="#solidity用abi调用智能合约的方法详解" class="headerlink" title="solidity用abi调用智能合约的方法详解"></a>solidity用abi调用智能合约的方法详解</h1><p>首先来看看调用一个智能合约的方法需要哪些东西，按照我们以往的经验，我们要调用一个方法，首先我们需要知道该方法的名称，以及需要传入的参数，还有该方法是在哪里调用的。</p><p>调用智能合约的方法也不例外， 我们同样需要该智能合约有哪些方法和该方法需要的参数，以及智能合约的地址，在强类型的语言中，同时我们还需要知道参数的类型。</p><h1 id="什么是abi"><a href="#什么是abi" class="headerlink" title="什么是abi"></a>什么是abi</h1><p>那我们去哪知道一个智能合约到底有哪些方法呢，这时我们就需要一个叫abi的东西，abi描述了一个智能合约的各个信息，以及描述了该合约有哪些方法，方法的可见性等信息。</p><p>以下面的一个简单的合约举例</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract Callled &#123;    uint256 public x;    function foo(uint256 _x) external returns (string memory) &#123;        x = _x;        return &quot;foo called&quot;;    &#125;&#125;</code></pre><p>我们对其进行编译，那么在项目的<code>artifacts</code>目录下会自动为我们生成合约的描述文件，里面就包含了abi的信息，abi是一个数组，描述了有哪些方法，需要注意的是，编译过后，如果变量是外部可见的，那么会自动给我们生成一个访问变量的方法，也会被记录到abi中。比如下面的 x。</p><p>每个abi中input描述了入参的名称和类型，是个数组，表示多个，而output则描述了返回参数的名称和类型，如果不具名返回，则name为空。</p><pre><code class="json">&#123;  &quot;_format&quot;: &quot;hh-sol-artifact-1&quot;,  &quot;contractName&quot;: &quot;Callled&quot;,  &quot;sourceName&quot;: &quot;contracts/call.sol&quot;,  &quot;abi&quot;: [    &#123;      &quot;inputs&quot;: [        &#123;          &quot;internalType&quot;: &quot;uint256&quot;,          &quot;name&quot;: &quot;_x&quot;,          &quot;type&quot;: &quot;uint256&quot;        &#125;      ],      &quot;name&quot;: &quot;foo&quot;,      &quot;outputs&quot;: [        &#123;          &quot;internalType&quot;: &quot;string&quot;,          &quot;name&quot;: &quot;&quot;,          &quot;type&quot;: &quot;string&quot;        &#125;      ],      &quot;stateMutability&quot;: &quot;nonpayable&quot;,      &quot;type&quot;: &quot;function&quot;    &#125;,    &#123;      &quot;inputs&quot;: [],      &quot;name&quot;: &quot;x&quot;,      &quot;outputs&quot;: [        &#123;          &quot;internalType&quot;: &quot;uint256&quot;,          &quot;name&quot;: &quot;&quot;,          &quot;type&quot;: &quot;uint256&quot;        &#125;      ],      &quot;stateMutability&quot;: &quot;view&quot;,      &quot;type&quot;: &quot;function&quot;    &#125;  ],  &quot;bytecode&quot;: &quot;0x608060405234801561001057600080fd5b5061024f806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80630c55699c1461003b5780632fbebd3814610059575b600080fd5b610043610089565b60405161005091906100ee565b60405180910390f35b610073600480360381019061006e919061013a565b61008f565b60405161008091906101f7565b60405180910390f35b60005481565b6060816000819055506040518060400160405280600a81526020017f666f6f2063616c6c6564000000000000000000000000000000000000000000008152509050919050565b6000819050919050565b6100e8816100d5565b82525050565b600060208201905061010360008301846100df565b92915050565b600080fd5b610117816100d5565b811461012257600080fd5b50565b6000813590506101348161010e565b92915050565b6000602082840312156101505761014f610109565b5b600061015e84828501610125565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b838110156101a1578082015181840152602081019050610186565b60008484015250505050565b6000601f19601f8301169050919050565b60006101c982610167565b6101d38185610172565b93506101e3818560208601610183565b6101ec816101ad565b840191505092915050565b6000602082019050818103600083015261021181846101be565b90509291505056fea2646970667358221220bd1204a1c1c8297de8b2d64fa78f44fc6c9030f68b4b89951ad9b3a38c6f131664736f6c63430008120033&quot;,  &quot;deployedBytecode&quot;: &quot;0x608060405234801561001057600080fd5b50600436106100365760003560e01c80630c55699c1461003b5780632fbebd3814610059575b600080fd5b610043610089565b60405161005091906100ee565b60405180910390f35b610073600480360381019061006e919061013a565b61008f565b60405161008091906101f7565b60405180910390f35b60005481565b6060816000819055506040518060400160405280600a81526020017f666f6f2063616c6c6564000000000000000000000000000000000000000000008152509050919050565b6000819050919050565b6100e8816100d5565b82525050565b600060208201905061010360008301846100df565b92915050565b600080fd5b610117816100d5565b811461012257600080fd5b50565b6000813590506101348161010e565b92915050565b6000602082840312156101505761014f610109565b5b600061015e84828501610125565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b838110156101a1578082015181840152602081019050610186565b60008484015250505050565b6000601f19601f8301169050919050565b60006101c982610167565b6101d38185610172565b93506101e3818560208601610183565b6101ec816101ad565b840191505092915050565b6000602082019050818103600083015261021181846101be565b90509291505056fea2646970667358221220bd1204a1c1c8297de8b2d64fa78f44fc6c9030f68b4b89951ad9b3a38c6f131664736f6c63430008120033&quot;,  &quot;linkReferences&quot;: &#123;&#125;,  &quot;deployedLinkReferences&quot;: &#123;&#125;&#125;</code></pre><p>有了这些信息，我们就可以写另外一个合约，来调用这个合约的abi，</p><h1 id="调用合约方法（拆解）"><a href="#调用合约方法（拆解）" class="headerlink" title="调用合约方法（拆解）"></a>调用合约方法（拆解）</h1><p>以下是拆解做法：</p><p>首先我们通过getFunctionByte4来获取函数名，以及参数的类型，这是固定写法，注意都是有顺序要求的，先用keccak256进行编码，再截取前4个字节。这个等于就是方法的签名。<strong>如果调用合约的方法没有入参，例如<code>foo()</code>，那么call方法里可以直接传<code>bytes4(keccak256(&quot;foo()&quot;))</code></strong></p><p>然后我们再通过abi.encode获取参数的编码，有多少个参数依次再后面追加即可。</p><p>拿到之后我们把这两个参数进行拼接，得到calldata，就可以使用Call合约的地址进行调用了。</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract CallFoo &#123;    function getFunctionByte4() public pure returns (bytes4) &#123;        return bytes4(keccak256(&quot;foo(uint256)&quot;));    &#125;    function getParamsBytes(uint256 _num) public pure returns (bytes memory) &#123;        return abi.encode(_num);    &#125;    function callFoo(        address _address,        bytes calldata _data    ) public returns (bool) &#123;        (bool success, ) = _address.call(_data);        return success;    &#125;&#125;</code></pre><p>实操一下，先同时部署两个合约，我这里直接使用remix部署，先用 CallFoo 的 getFunctionByte4 方法获取方法签名的编码<br><img src="/images/6b2fabfb-4cbd-41e0-915b-dc19a684d6f9-image.png" alt="6b2fabfb-4cbd-41e0-915b-dc19a684d6f9-image.png" title="6b2fabfb-4cbd-41e0-915b-dc19a684d6f9-image.png"></p><p>再用 CallFoo 的 getParamsBytes 方法获取参数的编码，我们把入参设置为1000<br><img src="/images/379a489b-bde2-4a34-878a-fcc6912462fe-image.png" alt="379a489b-bde2-4a34-878a-fcc6912462fe-image.png" title="379a489b-bde2-4a34-878a-fcc6912462fe-image.png"></p><p>有了这两个参数之后，把两者进行拼接，拼接的结果是<code>0x2fbebd3800000000000000000000000000000000000000000000000000000000000003e8</code></p><p>注意把入参编码的<code>0x</code>开头删掉，然后放到callFoo中进行调用，同时地址需要填入Call合约的地址，结果如下，可以看到已经正常调用。<br><img src="/images/b8b36cac-52a9-4af5-8956-f468c9f65120-image.png" alt="b8b36cac-52a9-4af5-8956-f468c9f65120-image.png" title="b8b36cac-52a9-4af5-8956-f468c9f65120-image.png"></p><p>Call合约中的x已经被设置为了1000<br><img src="/images/ae148659-5db4-4c09-9226-cfdc24148f8b-image.png" alt="ae148659-5db4-4c09-9226-cfdc24148f8b-image.png" title="ae148659-5db4-4c09-9226-cfdc24148f8b-image.png"></p><h1 id="调用合约方法（encodeWithSignature）"><a href="#调用合约方法（encodeWithSignature）" class="headerlink" title="调用合约方法（encodeWithSignature）"></a>调用合约方法（encodeWithSignature）</h1><p>当然我们不可能每调用一次都手动去进行数据的拼接，那么我们此时就可以使用abi的内置方法 encodeWithSignature ， 帮我们同时做这两件事</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract CallFoo &#123;    // function getFunctionByte4() public pure returns (bytes4) &#123;    //     return bytes4(keccak256(&quot;foo(uint256)&quot;));    // &#125;    // function getParamsBytes(uint256 _num) public pure returns (bytes memory) &#123;    //     return abi.encode(_num);    // &#125;    // function callFoo(    //     address _address,    //     bytes calldata _data    // ) public payable returns (bool) &#123;    //     (bool success, ) = _address.call&#123;value: msg.value&#125;(_data);    //     return success;    // &#125;    function test(uint256 _num) public pure returns (bytes memory) &#123;        return abi.encodeWithSignature(&quot;foo(uint256)&quot;, _num);    &#125;    function Call(address _address, uint256 _num) external &#123;        (bool success, ) = _address.call(            abi.encodeWithSignature(&quot;foo(uint256)&quot;, _num)        );        require(success, &quot;call fail&quot;);    &#125;&#125;</code></pre><p>我们来试一试，我们把num也设置成1000，重新部署合约测试，也是完全没有问题的，此时 Call 合约中的 x 已经被设置为了1000，而在我们test方法中获取到的结果，和我们手动拼出来的结果是一模一样的，由此可见，abi.encodeWithSignature 方法实际上就是把上面两个步骤合成了一个，方便用户使用。<br><img src="/images/9ab92a09-9079-4d39-b58b-86ff3851fa0a-image.png" alt="9ab92a09-9079-4d39-b58b-86ff3851fa0a-image.png" title="9ab92a09-9079-4d39-b58b-86ff3851fa0a-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hardhat</title>
      <link href="/2023/07/02/%E5%8C%BA%E5%9D%97%E9%93%BE/hardhat/"/>
      <url>/2023/07/02/%E5%8C%BA%E5%9D%97%E9%93%BE/hardhat/</url>
      
        <content type="html"><![CDATA[<h1 id="hardhat使用的链"><a href="#hardhat使用的链" class="headerlink" title="hardhat使用的链"></a>hardhat使用的链</h1><p>hardhat内置开发链是in-process链，不独立启动运行，随同一个测试或者脚本进程而产生销毁</p><p>测试用的是内置链，脚本如果不指定–network，则用的是内置链</p><p>内置链的名称是hardhat，所以运行脚本时指定network参数为hardhat，跟不指定参数效果相同</p><p>脚本运行时可以指定预定义的本地网络localhost，指向<code>http://127.0.0.1:8545/</code>，但是需要我们使用<code>npx hardhat node</code>命令启动本地节点</p><pre><code class="bash">$ npx hardhat nodeStarted HTTP and WebSocket JSON-RPC server at http://127.0.0.1:8545/Accounts========WARNING: These accounts, and their private keys, are publicly known.Any funds sent to them on Mainnet or any other live network WILL BE LOST.Account #0: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 (10000 ETH)Private Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80Account #1: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 (10000 ETH)Private Key: 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d</code></pre><pre><code class="bash">$ npx hardhat run scripts/deploy.js --network localhostLock with 0.001ETH and unlock timestamp 1688291793 deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3</code></pre><p>部署的后，在node节点上会打印相关的信息</p><pre><code class="bash">eth_accountshardhat_metadata (20)eth_blockNumbereth_getBlockByNumbereth_feeHistoryeth_sendTransaction  Contract deployment: Lock  Contract address:    0x5fbdb2315678afecb367f032d93f642f64180aa3  Transaction:         0x8e2ef479bd412546f808857d5face604328e529b747b632a236161c4c03546e4  From:                0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266  Value:               0.001 ETH  Gas used:            326112 of 30000000  Block #1:            0x2ccccbce4394758f05491733af0758585ed067ff7f5fb1293ad9ad84b464db7aeth_getTransactionByHasheth_getTransactionReceipteth_blockNumber</code></pre><p>hardhat有两个内置的网络，一个是hardhat，另一个就是上面提到的localhost，hardhat不能配置url，使用的是内置链，而localhost可以配置任意url进行覆盖，比如我们部署到Ganache链上，指定Ganache端口为7545，那我们可以这样配置</p><pre><code class="javascript">// hardhat.config.jsmodule.exports = &#123;  solidity: &quot;0.8.18&quot;,  networks: &#123;    localhost: &#123;      url: &#39;http://localhost:7545/&#39;    &#125;  &#125;&#125;;</code></pre><pre><code class="bash">$ npx hardhat run scripts/deploy.js --network localhostLock with 0.001ETH and unlock timestamp 1688292407 deployed to 0xa8233a432D5Ca4C011FBdc76DD476A55De08d08B</code></pre><p>可以看到在Ganeche里面创建了合约，地址和控制台里输出的地址是相同的<br><img src="/images/e6afc8f7-41f6-438b-901c-17f43ba5adde-image.png" alt="e6afc8f7-41f6-438b-901c-17f43ba5adde-image.png" title="e6afc8f7-41f6-438b-901c-17f43ba5adde-image.png"></p><h1 id="使用hardhat部署测试网合约"><a href="#使用hardhat部署测试网合约" class="headerlink" title="使用hardhat部署测试网合约"></a>使用hardhat部署测试网合约</h1><p>除了可以部署在hardhat内置链和Ganache，我们还可以部署到测试网上，部署到测试网我们需要先获取到连接测试网的url，可以在<a href="https://infura.io/" title="Infura">Infura</a>或者<a href="https://alchemy.com/" title="Alchemy">Alchemy</a>去申请。</p><p>然后我们可以在hardhat配置中进行配置，我这里使用Sepolia的测试网部署。在Alchemy中申请Sepolia测试网的url和API KEY。<br><img src="/images/0c29a8a3-53d6-4694-8845-ef9fca3c2171-image.png" alt="0c29a8a3-53d6-4694-8845-ef9fca3c2171-image.png" title="0c29a8a3-53d6-4694-8845-ef9fca3c2171-image.png"></p><p>同时我们还需要一个账号，确保里面有足够的币，否则无法部署成功，Sepolia测试网的币可以去这个<a href="https://sepoliafaucet.com/" title="sepoliafaucet.com">sepoliafaucet.com</a>水龙头获取，每天可以领0.5个eth。<strong>！！！请确保私钥不要暴露了！！！</strong>。</p><p>有了这两个东西之后我们就可以修改hardhat的配置，如下</p><ul><li>ALCHEMY_API_KEY从Alchemy申请，</li></ul><pre><code class="javascript">const ALCHEMY_API_KEY = &quot;zOWf......7XDj&quot;;const account = &#39;9adf......ed7c&#39;/** @type import(&#39;hardhat/config&#39;).HardhatUserConfig */module.exports = &#123;  solidity: &quot;0.8.18&quot;,  networks: &#123;    localhost: &#123;      url: &#39;http://localhost:7545/&#39;    &#125;,    sepoliaTest: &#123;      url: `https://eth-sepolia.g.alchemy.com/v2/$&#123;ALCHEMY_API_KEY&#125;`,      accounts: [account]    &#125;  &#125;&#125;;</code></pre><p>然后我们进行部署</p><pre><code class="bash">$ npx hardhat run scripts/deploy.js --network sepoliaTestLock with 0.001ETH and unlock timestamp 1688311413 deployed to 0x1C5B6228a81011F680e6a46aB433c72Ff761E0dC</code></pre><p>部署的地址为 <code>0x1C5B6228a81011F680e6a46aB433c72Ff761E0dC</code>，我们可以去etherscan上看看合约有没有部署成功<br><img src="/images/f7aae224-f1ac-45c9-818c-37b69c3a4eb5-image.png" alt="f7aae224-f1ac-45c9-818c-37b69c3a4eb5-image.png" title="f7aae224-f1ac-45c9-818c-37b69c3a4eb5-image.png"></p><p><img src="/images/18059e71-283d-4146-9756-e75228826924-image.png" alt="18059e71-283d-4146-9756-e75228826924-image.png" title="18059e71-283d-4146-9756-e75228826924-image.png"></p><p>可以看到合约已经成功部署，是我们hardhat初始的Lock合约</p><p>主网和测试网的部署方式基本相同，也是按照这个配置来进行部署</p><h1 id="verify源代码"><a href="#verify源代码" class="headerlink" title="verify源代码"></a>verify源代码</h1><p>当我们部署合约之后，我们需要上传源代码以供别人进行查看，别人会对你的代码进行审查，如果你的代码写的不好或者被找到bug，那么别人就不会用你的合约，你发行的代币将会没有任何价值，所以这一步是非常重要的。</p><blockquote><p>细心的朋友就会发现，我们上面的Lock合约部署了，为什么会直接看到源代码呢，那是因为Lock合约已经verify过了，想同的合约，代码不发生任何变化，hash就不会变，就不需要重新verify了，部署之后就可以直接看到。 </p></blockquote><p>我们可以手动verify源代码，也可以通过hardhat进行。</p><h2 id="手动verify"><a href="#手动verify" class="headerlink" title="手动verify"></a>手动verify</h2><p>手动verify很简单，找到部署的合约地址，可以看到我们的Contract是不可读的，按照下面的步骤进行代码上传就行了。</p><p>但是有个问题是手动部署合约，只适用于部署单文件的合约，如果你的合约引用了 openzeppelin 的合约，那么你就需要一个一个手动传，非常麻烦，这里就不做演示了，按照下面一步一步来就可以了。</p><p><img src="/images/090658e1-005a-455b-af8c-4ae487aacf71-image.png" alt="090658e1-005a-455b-af8c-4ae487aacf71-image.png" title="090658e1-005a-455b-af8c-4ae487aacf71-image.png"><br><img src="/images/420b0d68-fd7f-4cea-b0ed-0a6b65573fdc-image.png" alt="420b0d68-fd7f-4cea-b0ed-0a6b65573fdc-image.png" title="420b0d68-fd7f-4cea-b0ed-0a6b65573fdc-image.png"><br><img src="/images/3c01250d-815a-4844-bd0c-4a5f2010f818-image.png" alt="3c01250d-815a-4844-bd0c-4a5f2010f818-image.png" title="3c01250d-815a-4844-bd0c-4a5f2010f818-image.png"></p><h2 id="使用hardhat-verify"><a href="#使用hardhat-verify" class="headerlink" title="使用hardhat verify"></a>使用hardhat verify</h2><p>假如我们的合约是，引用好了几个 openzeppelin 的包，这样手动上传就不合适了，因为 openzeppelin 的包还可以引用它里面其他的包，层层引用，手动verify十分低效</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;contract EchoCoin is ERC20 &#123;    constructor(        string memory name_,        string memory symbol_    ) ERC20(name_, symbol_) &#123;        _mint(msg.sender, 100000000000000000000);    &#125;&#125;</code></pre><p>先来部署下，下面是部署脚本，十分简单</p><pre><code class="javascript">// We require the Hardhat Runtime Environment explicitly here. This is optional// but useful for running the script in a standalone fashion through `node &lt;script&gt;`.//// You can also run a script with `npx hardhat run &lt;script&gt;`. If you do that, Hardhat// will compile your contracts, add the Hardhat Runtime Environment&#39;s members to the// global scope, and execute the script.const hre = require(&quot;hardhat&quot;);async function main() &#123;  const EC = await hre.ethers.deployContract(&quot;EchoCoin&quot;, [&quot;EchoCoin&quot;, &quot;EC&quot;]);  await EC.waitForDeployment();  console.log(`deployed to $&#123;EC.target&#125;`)// We recommend this pattern to be able to use async/await everywhere// and properly handle errors.main().catch((error) =&gt; &#123;  console.error(error);  process.exitCode = 1;&#125;);</code></pre><p>执行部署不成功，合约地址是<code>0xDD9aE44307f47102fBd227B57c98e4d720C2339c</code>，源代码并不可见。</p><pre><code class="bash">$ npx hardhat run scripts/deploy.js  --network sepoliaTestCompiled 1 Solidity file successfullydeployed to 0xDD9aE44307f47102fBd227B57c98e4d720C2339c</code></pre><p><img src="/images/bf087bde-c7d5-4eb5-ad5c-03dfcdbb2c88-image.png" alt="bf087bde-c7d5-4eb5-ad5c-03dfcdbb2c88-image.png" title="bf087bde-c7d5-4eb5-ad5c-03dfcdbb2c88-image.png"></p><p>我们可以执行hardhat命令来进行verify</p><pre><code class="bash">$$ npx hardhat verify --contract contracts/EchoCoin.sol:EchoCoin 0xA3140E22B8252f46168c52A476EB89f8959Ad3de --network sepoliaTestThe contract 0xA3140E22B8252f46168c52A476EB89f8959Ad3de has already been verified.https://sepolia.etherscan.io/address/0xA3140E22B8252f46168c52A476EB89f8959Ad3de#code</code></pre><p>可以看到我们已经verify成功，并为我们打印出了合约代码的url地址，我们上去看一下，可以看到 openzeppelin 里的代码也帮我们上传了，不需要我们手动一个一个上传了。<br><img src="/images/60f1763b-606c-4981-b014-fa45f93958b7-image.png" alt="60f1763b-606c-4981-b014-fa45f93958b7-image.png" title="60f1763b-606c-4981-b014-fa45f93958b7-image.png"></p><p>还会为我们生成abi<br><img src="/images/6b4cd867-bc4f-4334-bdad-acb710b6b1d4-image.png" alt="6b4cd867-bc4f-4334-bdad-acb710b6b1d4-image.png" title="6b4cd867-bc4f-4334-bdad-acb710b6b1d4-image.png"></p><p>如果我们再重新部署一下这个合约，那么Contract源代码是直接可以看到的，因为我们合约没有改变过，新部署的合约地址<code>0xaB2BB7058aF71A6616173448Ce25F416b24E2F03</code></p><pre><code class="bash">$ npx hardhat run scripts/deploy.js  --network sepoliaTestCompiled 1 Solidity file successfullydeployed to 0xaB2BB7058aF71A6616173448Ce25F416b24E2F03</code></pre><p><img src="/images/2c9312a6-7bc7-49e2-a708-14403875927c-image.png" alt="2c9312a6-7bc7-49e2-a708-14403875927c-image.png" title="2c9312a6-7bc7-49e2-a708-14403875927c-image.png"></p><p>更多用发可以查看官方文档<a href="https://hardhat.org/hardhat-runner/docs/guides/verifying" title="Verifying your contracts">Verifying your contracts</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>助记词、私钥、公钥、地址</title>
      <link href="/2023/06/26/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8A%A9%E8%AE%B0%E8%AF%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5%E3%80%81%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/06/26/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8A%A9%E8%AE%B0%E8%AF%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5%E3%80%81%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="通过熵来生成助记词"><a href="#通过熵来生成助记词" class="headerlink" title="通过熵来生成助记词"></a>通过熵来生成助记词</h1><p>熵的生成是完全随机的，多少位根据不同的规范来，但必须是32的整数倍</p><p>以生成12个助记词来举个例子，12个助记词一共需要132位的二进制串来生成，因为一个助记词11位，总共需要11乘以12得到132位，那么熵要是几位呢，是132位吗，肯定不行，因为132不是32的整数倍，最近的是128位，那么还差4位来补全，这里的4位，就是checksum</p><p>又有个疑问，为什么助记词需要11位，因为<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#user-content-Generating_the_mnemonic" title="bip39">bip39</a>规范助记词是由2048个不同的单词组成，11位的二进制数正好可以包含2048，2的11次方正好是2048，<a href="https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md" title="助记词列表">助记词列表</a></p><p>checksum是怎么得来的呢，个数又是怎么确定的？bip39规范里明确指出，checksum的长度就是 ent &#x2F; 32，正好是4。</p><p>下面这个表格可以很清晰的得出几者的对应关系</p><blockquote><p>CS &#x3D; ENT &#x2F; 32<br>MS &#x3D; (ENT + CS) &#x2F; 11</p></blockquote><table><thead><tr><th>ENT（熵）</th><th>CS（checksum）</th><th>ENT+CS</th><th>MS（助记词个数）</th></tr></thead><tbody><tr><td>128</td><td>4</td><td>132</td><td>12</td></tr><tr><td>160</td><td>5</td><td>165</td><td>15</td></tr><tr><td>192</td><td>6</td><td>198</td><td>18</td></tr><tr><td>224</td><td>7</td><td>231</td><td>21</td></tr><tr><td>256</td><td>8</td><td>264</td><td>24</td></tr></tbody></table><p>那么具体怎么通过熵来生成助记词的呢，以12个助记词为例，首先我们获取一个完全随机的128位二进制数，这个就是熵，然后对这个熵进行sha256哈希，再截取前4位，这个4位就是checksum，然后把熵和checksum拼接，得到132位的二进制数，再按照每11位分组，得到12组11位的二进制数，再对把每个二进制数转为10进制，再按照wordlist取每个对应的助记词，得到一个12个单词组成的助记词</p><p>整体流程可以通过下图直观的体现<br><img src="/images/039dd96b-7b12-4f63-ac78-7529f5def047-mnemonic.jpg" alt="039dd96b-7b12-4f63-ac78-7529f5def047-mnemonic.jpg" title="039dd96b-7b12-4f63-ac78-7529f5def047-mnemonic.jpg"><br>用js代码实现</p><pre><code class="javascript">// 生成助记词const utils_1 = require(&quot;@noble/hashes/utils&quot;);const sha256_1 = require(&quot;@noble/hashes/sha256&quot;);const wordlist = require(&#39;./english_wordlist.json&#39;);function lpad(str, padString, length) &#123;    while (str.length &lt; length) &#123;        str = padString + str;    &#125;    return str;&#125;function bytesToBinary(bytes) &#123;    return bytes.map((x) =&gt; lpad(x.toString(2), &#39;0&#39;, 8)).join(&#39;&#39;);&#125;function binaryToByte(bin) &#123;    return parseInt(bin, 2);&#125;function deriveChecksumBits(entropyBuffer) &#123;    const ENT = entropyBuffer.length * 8;    const CS = ENT / 32;    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));       // 对熵进行sha256哈希    return bytesToBinary(Array.from(hash)).slice(0, CS);                // 然后截取4位作为checksum&#125;function generateEntropy(strength) &#123;    strength = strength || 128;    if (strength % 32 !== 0) &#123;        throw new TypeError(INVALID_ENTROPY);    &#125;    const randomBytes = Buffer.from(utils_1.randomBytes(strength / 8)); // 16字节的随机数 (128位)    const entropyBits = bytesToBinary(Array.from(randomBytes));         // 将16字节的随机数转为二进制    const checksumBits = deriveChecksumBits(randomBytes);               // 获得4位的checksum，先将熵进行sha256计算，然后截取4位，长度根据熵的长度计算  ent / 32    return &#123; entropyBits, checksumBits&#125;&#125;function entropyToMnemonic(entropy,checksumBits, wordlist) &#123;    const bits = entropy + checksumBits;    const chunks = bits.match(/(.&#123;1,11&#125;)/g);                            // 按11位进行分组，得到12组11位的二进制数    const words = chunks.map((binary) =&gt; &#123;        const index = binaryToByte(binary);                             // 根据二进制数获取助记词的index        console.log(index, binary)        return wordlist[index];    &#125;);    return words&#125;const entropy = generateEntropy(128)console.log(entropy)const &#123;entropyBits, checksumBits&#125; = entropyconst mnemonic = entropyToMnemonic(entropyBits, checksumBits, wordlist)console.log(mnemonic)</code></pre><p>运行结果，每次运行的结果都会不一样<br><img src="/images/06ad7dc8-0a84-4d0c-88bb-f1e8d855ae55-image.png" alt="06ad7dc8-0a84-4d0c-88bb-f1e8d855ae55-image.png" title="06ad7dc8-0a84-4d0c-88bb-f1e8d855ae55-image.png"></p><p>怎么验证我们生成的助记词是正确的呢，<a href="https://iancoleman.io/bip39/" title="Mnemonic Code Converter">Mnemonic Code Converter</a>这个网站可以线上进行生成助记词，我们只需要把我们生成的熵填进去，他就会帮我们生成助记词</p><p><img src="/images/64f1f429-6557-49bf-b91d-63d3772d8ed1-image.png" alt="64f1f429-6557-49bf-b91d-63d3772d8ed1-image.png" title="64f1f429-6557-49bf-b91d-63d3772d8ed1-image.png"></p><h1 id="通过助记词来生成seed"><a href="#通过助记词来生成seed" class="headerlink" title="通过助记词来生成seed"></a>通过助记词来生成seed</h1><p>有了助记词，我们生成私钥和地址之前，还需要生成seed，私钥和地址是通过seed来生成的</p><p>seed是一个512位的hash值，通过<a href="https://baike.baidu.com/item/PBKDF2/237696" title="pbkdf2">pbkdf2</a>算法来生成，下面函数中有一个salt方法，这个是用户自己定义的密码，默认密码是<code>mnemonic</code>固定值，如果我们填了自己的密码，那么就直接拼到默认密码的后面，然后把助记词和这个密码一起进行pbkdf2计算，hash算法是sha512，迭代次数2048，生成64字节的值，然后转为16进制，最终得到最后的seed</p><p>如图所示<br><img src="/images/e880a356-c872-4f2d-8173-0cbc3f33c766-seed.jpg" alt="e880a356-c872-4f2d-8173-0cbc3f33c766-seed.jpg" title="e880a356-c872-4f2d-8173-0cbc3f33c766-seed.jpg"><br><strong>代码实现</strong></p><pre><code class="javascript">const pbkdf2_1 = require(&quot;@noble/hashes/pbkdf2&quot;);const sha512_1 = require(&quot;@noble/hashes/sha512&quot;);function salt(password) &#123;    return &#39;mnemonic&#39; + (password || &#39;&#39;);&#125;function mnemonicToSeedSync(mnemonic, password) &#123;    const mnemonicBuffer = Uint8Array.from(Buffer.from(mnemonic, &#39;utf8&#39;));    const saltBuffer = Uint8Array.from(Buffer.from(salt(password), &#39;utf8&#39;));    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, &#123;        c: 2048,        dkLen: 64,    &#125;);    return Buffer.from(res).toString(&#39;hex&#39;);&#125;const entropy = generateEntropy(128)const &#123;entropyBits, checksumBits&#125; = entropyconst mnemonic = entropyToMnemonic(entropyBits, checksumBits, wordlist)const seed = mnemonicToSeedSync(mnemonic.join(&#39; &#39;), &#39;123&#39;)console.log(seed)</code></pre><p>由于我们每次生成的助记词不一样，所以下面获取到的结果会和上面不一样，当然你也可以手动保存之前生成的熵继续进行操作</p><p><img src="/images/a52876e7-abab-4a50-9736-a8f055c52171-image.png" alt="a52876e7-abab-4a50-9736-a8f055c52171-image.png" title="a52876e7-abab-4a50-9736-a8f055c52171-image.png"></p><p><img src="/images/4d64144c-05dd-4b52-a85e-366435026105-image.png" alt="4d64144c-05dd-4b52-a85e-366435026105-image.png" title="4d64144c-05dd-4b52-a85e-366435026105-image.png"></p><h1 id="通过seed来生成私钥公钥和地址"><a href="#通过seed来生成私钥公钥和地址" class="headerlink" title="通过seed来生成私钥公钥和地址"></a>通过seed来生成私钥公钥和地址</h1><p>有了seed之后，私钥和地址的生成，需要我们遵循bip32的协议，先生成一个Master Private Key，再用这个Master Private Key派生出来无数个地址和私钥。</p><p>Master Key的生成同样使用HMAC-SHA512算法，我们需要加上一个key，即<code>Bitcoin seed</code>，把这个key和seed一起进行HMAC-SHA512，最后得到一个64bytes的Master Private Extended Key，然后把这个64 bytes的key两等分，前32 bytes就是我们的Master Private Key，后32 bytes是我们的Master Chain Code。</p><p>有了Master Key，我们可以使用椭圆算法secp256k1计算出Master Public Key，注意这里计算出来的结果是33 bytes。</p><p>如下图所示<br><img src="/images/74b87cd3-ba30-46b4-985b-50a4f3ab99cf-seedToKey.jpg" alt="74b87cd3-ba30-46b4-985b-50a4f3ab99cf-seedToKey.jpg" title="74b87cd3-ba30-46b4-985b-50a4f3ab99cf-seedToKey.jpg"><br>代码实现</p><pre><code class="javascript">function hmacSHA512(key, seed) &#123;    var hmac = crypto.createHmac(&quot;sha512&quot;, key);    var signed = hmac.update(seed).digest(&#39;hex&#39;);    return signed&#125;// 椭圆算法生成公钥function secp256k1ToPublicKey(IL) &#123;    return Buffer.from(secp256k1.getPublicKey(Buffer.from(IL, &#39;hex&#39;))).toString(&#39;hex&#39;)&#125;function seedToKey(key, seed) &#123;    const I = hmacSHA512(Buffer.from(key, &#39;utf-8&#39;), Buffer.from(seed, &#39;hex&#39;));    const IL = I.slice(0, 64);    const IR = I.slice(64);    // 椭圆算法生成public key    const publicKey = secp256k1ToPublicKey(IL)    const extendedPrivateKey = I.toString(&#39;hex&#39;)    const masterPrivateKey = IL.toString(&#39;hex&#39;)    const masterChainCode = IR.toString(&#39;hex&#39;)    return &#123;        extendedPrivateKey,        masterPrivateKey,        masterChainCode,        publicKey    &#125;&#125;const &#123; masterPrivateKey, masterChainCode, publicKey &#125; = seedToKey(&#39;Bitcoin seed&#39;,&#39;aae763e1121f0055f66e7f7405d1ea2caa040fd7c6b85ce381c1662c1f1ee705d99f03310363c8581d4bbc0ceb3a7e8a4dcfb2eebfa64e05724d99298be400f7&#39;)console.log(masterPrivateKey)  // e9ec65a12ecc438c3e2177e925cd65df5b7c49c4130d670fe495d6cbd3ccbec6console.log(masterChainCode)   // 59c345d031203b83b632a95b278731b50c324458b7d4c17ae2e03e6877db7207console.log(publicKey)   // 02bffc59925aa6ffd7ec3d132a180de94bf4ef50a9c910c68aa62297446957be63</code></pre><h1 id="派生私钥和地址"><a href="#派生私钥和地址" class="headerlink" title="派生私钥和地址"></a>派生私钥和地址</h1><p>有了Master Key扩展秘钥之后，我们就可以派生出大量的私钥和公钥，我们有两种派生方式，一种是normal派生，一种是hardened派生，通过一个index标记是noraml派生还是hardened派生，normal派生的index取值在0到2^31 -1之间，而hardend派生的index在2^31 到 2^32 -1之间</p><p>normal派生和hardened派生除了index的取值不同之外，其内部实现的算法也有一点点稍微不用，hardened派生使用的是私钥，而normal派生使用的是公钥，下面两图分别展示其实现的方式</p><h2 id="normal派生"><a href="#normal派生" class="headerlink" title="normal派生"></a>normal派生</h2><p><img src="/images/151a29fd-c67a-4e54-aada-82193f10cb27-deriveNormalChild.jpg" alt="151a29fd-c67a-4e54-aada-82193f10cb27-deriveNormalChild.jpg" title="151a29fd-c67a-4e54-aada-82193f10cb27-deriveNormalChild.jpg"></p><p>代码实现</p><pre><code class="javascript">const BigNumber = require(&#39;bignumber.js&#39;);const &#123; secp256k1 &#125; = require(&#39;@noble/curves/secp256k1&#39;)const n = secp256k1.CURVE.n  // 115792089237316195423570985008687907852837564279074904382605163141518161494337nfunction hmacSHA512(key, seed) &#123;    var hmac = crypto.createHmac(&quot;sha512&quot;, key);    var signed = hmac.update(seed).digest(&#39;hex&#39;);    return signed&#125;// 椭圆算法生成公钥function secp256k1ToPublicKey(IL) &#123;    return Buffer.from(secp256k1.getPublicKey(Buffer.from(IL, &#39;hex&#39;))).toString(&#39;hex&#39;)&#125;function deriveNormalChild(privateKey, publicKey, chainCode, index) &#123;    if (index &gt;= 2 ** 31 || index &lt; 0) &#123;        throw new Error(&#39;index 只能在 [0,2147483648)，即 (2**0 - 2**31-1) 之间取值&#39;)    &#125;    // 公钥和index拼接（16进制下拼接），对于normalChild，index在 2**0 - 2**31 之间取值    const data = Buffer.alloc(37);    Buffer.from(publicKey, &#39;hex&#39;).copy(data, 0)    data.writeUInt32BE(index, 33);    const I = hmacSHA512(Buffer.from(chainCode, &#39;hex&#39;), Buffer.from(data, &#39;hex&#39;))    const IL = I.slice(0, 64);    const IR = I.slice(64);    const normal_child_private_key = new BigNumber(IL, 16).plus(new BigNumber(privateKey, 16)).modulo(new BigNumber(n)).toString(16) // (IL + parent_key) % n    const normal_child_public_key = secp256k1ToPublicKey(normal_child_private_key)    const normal_child_chain_code = IR    return &#123;        normal_child_private_key,        normal_child_public_key,        normal_child_chain_code    &#125;&#125;</code></pre><h2 id="hardened派生"><a href="#hardened派生" class="headerlink" title="hardened派生"></a>hardened派生</h2><p><img src="/images/77ef4223-e522-4827-a3a5-a64912ae8536-deriveHardenedChild.jpg" alt="77ef4223-e522-4827-a3a5-a64912ae8536-deriveHardenedChild.jpg" title="77ef4223-e522-4827-a3a5-a64912ae8536-deriveHardenedChild.jpg"></p><p>代码实现</p><pre><code class="javascript">// 需引入与normal派生相同的公共代码function deriveHardenedChild(privateKey, chainCode, index) &#123;    if (index &gt;= 2 ** 32 || index &lt; 2 ** 31) &#123;        throw new Error(&#39;index 只能在 [2147483648,4294967296)，即 (2**31 - 2**32-1) 之间取值&#39;)    &#125;    // 公钥和index拼接（16进制下拼接）    const data = Buffer.alloc(37);    data[0] = 0x00;    Buffer.from(privateKey, &#39;hex&#39;).copy(data, 1)  // 0x00 + private_key + index    data.writeUInt32BE(index, 33);    const I = hmacSHA512(Buffer.from(chainCode, &#39;hex&#39;), Buffer.from(data, &#39;hex&#39;))    const IL = I.slice(0, 64);    const IR = I.slice(64);    const hardened_child_private_key = new BigNumber(IL, 16).plus(new BigNumber(privateKey, 16)).modulo(new BigNumber(n)).toString(16) // (IL + parent_key) % n    console.log(&#39;hardened_child_private_key&#39;, hardened_child_private_key)    const hardened_child_public_key = secp256k1ToPublicKey(hardened_child_private_key)    const hardened_child_chain_code = IR    return &#123;        hardened_child_private_key,        hardened_child_public_key,        hardened_child_chain_code    &#125;&#125;</code></pre><h1 id="bip32-path"><a href="#bip32-path" class="headerlink" title="bip32 path"></a>bip32 path</h1><p>由于我们的派生机制，每层都可以派生出2^32个地址（包含normal 和 hardened），理论上可以无限派生，如下图所示<br><img src="/images/20257296-e9f2-44b3-bdcd-8befcdc141bd-image.png" alt="20257296-e9f2-44b3-bdcd-8befcdc141bd-image.png" title="20257296-e9f2-44b3-bdcd-8befcdc141bd-image.png"></p><p>为了规范秘钥的使用方式，bip44约定了各个层级代表的含义，即<code>m / purpose&#39; / coin_type&#39; / account&#39; / change / address_index</code>，路径规范中用<code>&#39;</code>标记的表示是hardened派生，没有的则为normal派生，下面来看看路径每层分别表示什么东西</p><ul><li>第一层是m，即master Key，只会存在一个，由seed生成，然后在这个master key下再进行派生</li><li>第二层是purpose，是一个常量，用来标记是使用何种规范，44表示使用的是bit43提案来</li><li>第三层是coin type，标记使用的是何种加密货币，需要去<a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md" title="SLIP-0044 : Registered coin types for BIP-0044">SLIP-0044 : Registered coin types for BIP-0044</a>注册</li><li>第四层是account，这一层将密钥空间分割为独立的用户身份，钱包就永远不会混合不同帐户之间的代币</li><li>第五层是change，只有两个值，0或者1，常量0用于外链，常量1用于内链，外部链用于在钱包外部可见的地址，内部链用于钱包外部不可见的地址，用于返回交易更改。</li><li>第六层是address_index，地址从索引 0 开始按顺序递增的方式编号。该数字用作 BIP32 推导中的子索引</li></ul><p>更详细的请看<a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki" title="bip44">bip44</a></p><p>有了这个规范我们来验证一下我们代码的实现有没有问题<br>下面贴出全量代码，里面注释的计算结果部分可以忽略，因为每次生成的都不一样</p><pre><code class="javascript">const crypto = require(&#39;crypto&#39;)const &#123; secp256k1 &#125; = require(&#39;@noble/curves/secp256k1&#39;)const BigNumber = require(&#39;bignumber.js&#39;);const base_1 = require(&quot;@scure/base&quot;);const sha256_1 = require(&quot;@noble/hashes/sha256&quot;);const sha3 = require(&quot;js-sha3&quot;);const &#123; ethers, utils &#125; = require(&quot;ethers&quot;)const utils_1 = require(&quot;@noble/hashes/utils&quot;);const wordlist = require(&#39;./english_wordlist.json&#39;);const pbkdf2_1 = require(&quot;@noble/hashes/pbkdf2&quot;);const sha512_1 = require(&quot;@noble/hashes/sha512&quot;);function lpad(str, padString, length) &#123;    while (str.length &lt; length) &#123;        str = padString + str;    &#125;    return str;&#125;function bytesToBinary(bytes) &#123;    return bytes.map((x) =&gt; lpad(x.toString(2), &#39;0&#39;, 8)).join(&#39;&#39;);&#125;function binaryToByte(bin) &#123;    return parseInt(bin, 2);&#125;function deriveChecksumBits(entropyBuffer) &#123;    const ENT = entropyBuffer.length * 8;    const CS = ENT / 32;    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));       // 对熵进行sha256哈希    return bytesToBinary(Array.from(hash)).slice(0, CS);                // 然后截取4位作为checksum&#125;function generateEntropy(strength) &#123;    strength = strength || 128;    if (strength % 32 !== 0) &#123;        throw new TypeError(INVALID_ENTROPY);    &#125;    const randomBytes = Buffer.from(utils_1.randomBytes(strength / 8)); // 16字节的随机数 (128位)    const entropyBits = bytesToBinary(Array.from(randomBytes));         // 将16字节的随机数转为二进制    const checksumBits = deriveChecksumBits(randomBytes);               // 获得4位的checksum，先将熵进行sha256计算，然后截取4位，长度根据熵的长度计算  ent / 32    return &#123; entropyBits, checksumBits &#125;&#125;function entropyToMnemonic(entropy, checksumBits, wordlist) &#123;    const bits = entropy + checksumBits;    const chunks = bits.match(/(.&#123;1,11&#125;)/g);                            // 按11位进行分组，得到12组11位的二进制数    const words = chunks.map((binary) =&gt; &#123;        const index = binaryToByte(binary);                             // 根据二进制数获取助记词的index        return wordlist[index];    &#125;);    return words&#125;const entropy = generateEntropy(128)const &#123; entropyBits, checksumBits &#125; = entropylet Mnemonic = entropyToMnemonic(entropyBits, checksumBits, wordlist)function salt(password) &#123;    return &#39;mnemonic&#39; + (password || &#39;&#39;);&#125;function mnemonicToSeedSync(mnemonic, password) &#123;    const mnemonicBuffer = Uint8Array.from(Buffer.from(mnemonic, &#39;utf8&#39;));    const saltBuffer = Uint8Array.from(Buffer.from(salt(password), &#39;utf8&#39;));    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, &#123;        c: 2048,        dkLen: 64,    &#125;);    return Buffer.from(res).toString(&#39;hex&#39;);&#125;// Mnemonic = [//     &#39;slam&#39;, &#39;banner&#39;,//     &#39;pattern&#39;, &#39;result&#39;,//     &#39;resist&#39;, &#39;release&#39;,//     &#39;call&#39;, &#39;sure&#39;,//     &#39;sustain&#39;, &#39;engine&#39;,//     &#39;symbol&#39;, &#39;assist&#39;// ]console.log(Mnemonic.join(&#39; &#39;))const seed = mnemonicToSeedSync(Mnemonic.join(&#39; &#39;))console.log(&#39;seed&#39;, seed)const _bs58check = (0, base_1.base58check)(sha256_1.sha256);const bs58check = &#123;    encode: (data) =&gt; _bs58check.encode(Uint8Array.from(data)),    decode: (str) =&gt; Buffer.from(_bs58check.decode(str)),&#125;;const n = secp256k1.CURVE.n  // 115792089237316195423570985008687907852837564279074904382605163141518161494337n// 通过seed生成Extended Keyfunction hmacSHA512(key, seed) &#123;    var hmac = crypto.createHmac(&quot;sha512&quot;, key);    var signed = hmac.update(seed).digest(&#39;hex&#39;);    return signed&#125;// 椭圆算法生成公钥function secp256k1ToPublicKey(IL) &#123;    return Buffer.from(secp256k1.getPublicKey(Buffer.from(IL, &#39;hex&#39;))).toString(&#39;hex&#39;)&#125;function seedToKey(key, seed) &#123;    const I = hmacSHA512(Buffer.from(key, &#39;utf-8&#39;), Buffer.from(seed, &#39;hex&#39;));    const IL = I.slice(0, 64);    const IR = I.slice(64);    // 椭圆算法生成public key    const publicKey = secp256k1ToPublicKey(IL)    const extendedPrivateKey = I.toString(&#39;hex&#39;)    const masterPrivateKey = IL.toString(&#39;hex&#39;)    const masterChainCode = IR.toString(&#39;hex&#39;)    return &#123;        extendedPrivateKey,        masterPrivateKey,        masterChainCode,        publicKey    &#125;&#125;function deriveNormalChild(privateKey, publicKey, chainCode, index) &#123;    if (index &gt;= 2 ** 31 || index &lt; 0) &#123;        throw new Error(&#39;index 只能在 [0,2147483648)，即 (2**0 - 2**31-1) 之间取值&#39;)    &#125;    // 公钥和index拼接（16进制下拼接），对于normalChild，index在 2**0 - 2**31 之间取值    const data = Buffer.alloc(37);    Buffer.from(publicKey, &#39;hex&#39;).copy(data, 0)    data.writeUInt32BE(index, 33);    const I = hmacSHA512(Buffer.from(chainCode, &#39;hex&#39;), Buffer.from(data, &#39;hex&#39;))    const IL = I.slice(0, 64);    const IR = I.slice(64);    const normal_child_private_key = new BigNumber(IL, 16).plus(new BigNumber(privateKey, 16)).modulo(new BigNumber(n)).toString(16) // (IL + parent_key) % n    const normal_child_public_key = secp256k1ToPublicKey(normal_child_private_key)    const normal_child_chain_code = IR    return &#123;        normal_child_private_key,        normal_child_public_key,        normal_child_chain_code    &#125;&#125;function deriveHardenedChild(privateKey, chainCode, index) &#123;    if (index &gt;= 2 ** 32 || index &lt; 2 ** 31) &#123;        throw new Error(&#39;index 只能在 [2147483648,4294967296)，即 (2**31 - 2**32-1) 之间取值&#39;)    &#125;    // 公钥和index拼接（16进制下拼接）    const data = Buffer.alloc(37);    data[0] = 0x00;    Buffer.from(privateKey, &#39;hex&#39;).copy(data, 1)  // 0x00 + private_key + index    data.writeUInt32BE(index, 33);    const I = hmacSHA512(Buffer.from(chainCode, &#39;hex&#39;), Buffer.from(data, &#39;hex&#39;))    const IL = I.slice(0, 64);    const IR = I.slice(64);    const hardened_child_private_key = new BigNumber(IL, 16).plus(new BigNumber(privateKey, 16)).modulo(new BigNumber(n)).toString(16) // (IL + parent_key) % n    console.log(&#39;hardened_child_private_key&#39;, hardened_child_private_key)    const hardened_child_public_key = secp256k1ToPublicKey(hardened_child_private_key)    const hardened_child_chain_code = IR    return &#123;        hardened_child_private_key,        hardened_child_public_key,        hardened_child_chain_code    &#125;&#125;function deriveNormalChildByPublicKey(publicKey, chainCode, index) &#123;    if (index &gt;= 2 ** 31 || index &lt; 0) &#123;        throw new Error(&#39;index 只能在 [0,2147483648)，即 (2**0 - 2**31-1) 之间取值&#39;)    &#125;    const data = Buffer.alloc(37);    Buffer.from(publicKey, &#39;hex&#39;).copy(data, 0)    data.writeUInt32BE(index, 33);    const I = hmacSHA512(Buffer.from(chainCode, &#39;hex&#39;), Buffer.from(data, &#39;hex&#39;))    const IL = I.slice(0, 64);    const IR = I.slice(64);    const publicKey_child_chain_code = IR    const point_hmac = secp256k1ToPublicKey(IL)    const Point = secp256k1.ProjectivePoint;    const public_potint = Point.fromHex(publicKey)    const hmac_point = Point.fromHex(point_hmac)    const a = hmac_point.add(public_potint)    const publicKey_child_public_key = a.toHex()    return &#123;        publicKey_child_public_key,        publicKey_child_chain_code    &#125;&#125;// 序列化格式// 扩展的公钥和私钥如下序列化：// 4字节：版本字节（mainnet：0x0488B21E public，0x0488ADE4 private; testnet：0x043587CF public，0x04358394 private）// 1字节：深度：主节点为0x00，级别1派生密钥为0x01。// 4字节：父密钥的指纹（如果主密钥为0x00000000）// 4字节：子数字。这是对于i在xi = xpar / i中的ser32（i），其中xi是键序列化。 （如果主密钥为0x00000000）// 32字节：链码// 33字节：公钥或私钥数据（公钥的serP（K），私钥的0x00 || ser256（k））const network = &#123;    public: 0x0488b21e,    private: 0x0488ade4,    testPublic: 0x04358394,    testPrivate: 0x043587cf&#125;function serialize(net = &#39;public&#39;, depth = 0x00, parentFingerprint = 0x00000000, index = 0x00000000, chainCode, key, isPrivateKey = true) &#123;    const version = network[net]    const buffer = Buffer.allocUnsafe(78);    // 4 bytes: version bytes    buffer.writeUInt32BE(version, 0);    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....    buffer.writeUInt8(depth, 4);    // 4 bytes: the fingerprint of the parent&#39;s key (0x00000000 if master key)    buffer.writeUInt32BE(parentFingerprint, 5);    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.    // This is encoded in big endian. (0x00000000 if master key)    buffer.writeUInt32BE(index, 9);    // 32 bytes: the chain code    Buffer.from(chainCode, &#39;hex&#39;).copy(buffer, 13);    // 33 bytes: the public key or private key data    if (isPrivateKey) &#123;        // 0x00 + k for private keys        buffer.writeUInt8(0, 45);        Buffer.from(key, &#39;hex&#39;).copy(buffer, 46);    &#125;    else &#123;        // encoding for public keys        Buffer.from(key, &#39;hex&#39;).copy(buffer, 45);    &#125;    return bs58check.encode(buffer);&#125;// const &#123; masterPrivateKey, masterChainCode, publicKey &#125; = seedToKey(&#39;Bitcoin seed&#39;,&#39;aae763e1121f0055f66e7f7405d1ea2caa040fd7c6b85ce381c1662c1f1ee705d99f03310363c8581d4bbc0ceb3a7e8a4dcfb2eebfa64e05724d99298be400f7&#39;)// serialize(&#39;private&#39;, 0x00, 0x00000000, 0x00000000, &#39;59c345d031203b83b632a95b278731b50c324458b7d4c17ae2e03e6877db7207&#39;, &#39;e9ec65a12ecc438c3e2177e925cd65df5b7c49c4130d670fe495d6cbd3ccbec6&#39;, true)  // xprv9s21ZrQH143K2xC1jNamwmpgTJBwApRyYd8knmoADFbS6LWQ6S3tfCQQqTrpoffTTCMW1regwrydv5zdEhydoHMiLAJKS7CsBtsZnz8JjcD// deriveNormalChild(masterPrivateKey, publicKey, masterChainCode, 0)// deriveNormalChildByPublicKey(publicKey, masterChainCode, 0)// deriveHardenedChild(masterPrivateKey, masterChainCode, 2147483648)// bip44// 派生路径  m / 44&#39; / 60&#39; / 0&#39; / 0 / 0// m const &#123; masterPrivateKey: m_masterPrivateKey, masterChainCode: m_masterChainCode &#125; = seedToKey(&#39;Bitcoin seed&#39;, seed)console.log(&#39;m&#39;)console.log(&#39;master private key\t&#39;, m_masterPrivateKey)                 //e9ec65a12ecc438c3e2177e925cd65df5b7c49c4130d670fe495d6cbd3ccbec6console.log(&#39;master chain code\t&#39;, m_masterChainCode)                   //59c345d031203b83b632a95b278731b50c324458b7d4c17ae2e03e6877db7207console.log(&quot;\n&quot;)// m / 44&#39;console.log(`m / 44&#39;`)const &#123;    hardened_child_private_key: m_44_hardened_child_private_key,    hardened_child_public_key: m_44_hardened_child_public_key,    hardened_child_chain_code: m_44_hardened_child_chain_code&#125; = deriveHardenedChild(m_masterPrivateKey, m_masterChainCode, 2147483648 + 44)console.log(&#39;private key\t&#39;, m_44_hardened_child_private_key)       // ae73d6d803b8b33226a0932381fde2b560da61b84b1d28e581054b88ccddec35console.log(&#39;public key\t&#39;, m_44_hardened_child_public_key)         // 02d4233f730c1ecfeed512e474ae5cdcc5762a626dd4f9c7c1e1498e43fbed58f4console.log(&#39;chain code\t&#39;, m_44_hardened_child_chain_code)         // 9011690ea7eec3fad3177de3ab67b652c1d1676807879aff8784633e950d6790console.log(&quot;\n&quot;)// m / 44&#39; / 60&#39;console.log(`m / 44&#39; / 60&#39;`)const &#123;    hardened_child_private_key: m_44_60_hardened_child_private_key,    hardened_child_public_key: m_44_60_hardened_child_public_key,    hardened_child_chain_code: m_44_60_hardened_child_chain_code&#125; = deriveHardenedChild(m_44_hardened_child_private_key, m_44_hardened_child_chain_code, 2147483648 + 60)console.log(&#39;private key\t&#39;, m_44_60_hardened_child_private_key)     // a60917bd2d2b742b74922ab851cc70c180d2db2f1ffd31602f2d5b8d464ab9ddconsole.log(&#39;public key\t&#39;, m_44_60_hardened_child_public_key)       // 03648dce0172f2cf3f21b55a61927d8f0348e38c5b387721a66bf053f9e781e364console.log(&#39;chain code\t&#39;, m_44_60_hardened_child_chain_code)       // c0da7f9aab3ee03f4dd7b07b1afe036a2c79b44feb59e4d1ac7f9acc0170ac59console.log(&quot;\n&quot;)// m / 44&#39; / 60&#39; / 0&#39;console.log(`m / 44&#39; / 60&#39; / 0&#39;`)console.log(m_44_60_hardened_child_private_key, m_44_60_hardened_child_chain_code)const &#123;    hardened_child_private_key: m_44_60_0_hardened_child_private_key,    hardened_child_public_key: m_44_60_0_hardened_child_public_key,    hardened_child_chain_code: m_44_60_0_hardened_child_chain_code&#125; = deriveHardenedChild(m_44_60_hardened_child_private_key, m_44_60_hardened_child_chain_code, 2147483648)console.log(&#39;private key\t&#39;, m_44_60_0_hardened_child_private_key)       // 316ff35d15955ed1bc846d73397f9df8c11d2bc8d73d9c8119f536eccfeec54bconsole.log(&#39;public key\t&#39;, m_44_60_0_hardened_child_public_key)         // 033098fb7a20647516022f9badc21e32c8c1ae49051a7026ea9609a0f3b110c66cconsole.log(&#39;chain code\t&#39;, m_44_60_0_hardened_child_chain_code)         // ab69fce2ac6afe4a5e453debb702b3fb5edad621e8fdd40f05a228ab5dd4b7f2console.log(&quot;\n&quot;)// m / 44&#39; / 60&#39; / 0&#39; / 0console.log(`m / 44&#39; / 60&#39; / 0&#39; / 0`)const &#123;    normal_child_private_key: m_44_60_0_0_normal_child_private_key,    normal_child_public_key: m_44_60_0_0_normal_child_public_key,    normal_child_chain_code: m_44_60_0_0_normal_child_chain_code&#125; = deriveNormalChild(m_44_60_0_hardened_child_private_key, m_44_60_0_hardened_child_public_key, m_44_60_0_hardened_child_chain_code, 0)console.log(&#39;private key\t&#39;, m_44_60_0_0_normal_child_private_key)       // 7c17cb84ad65ce2c4ee939fd2bb3bde3b11bd8026aaa470014e0813361fdace2console.log(&#39;public key\t&#39;, m_44_60_0_0_normal_child_public_key)         // 03db321ab2fad6d13d243cced48ebfd2134689e33f35b5dab4c118a845a623b325console.log(&#39;chain code\t&#39;, m_44_60_0_0_normal_child_chain_code)         // 9d9a962d748e34a22d0fc6bafb768a5a580a7936891497929f8f78196ce458efconsole.log(&quot;\n&quot;)// m / 44&#39; / 60&#39; / 0&#39; / 0 / 0             ===&gt; address 1console.log(`m / 44&#39; / 60&#39; / 0&#39; / 0 / 0 \t\t address1`)const &#123;    normal_child_private_key: m_44_60_0_0_0_normal_child_private_key,    normal_child_public_key: m_44_60_0_0_0_normal_child_public_key,    normal_child_chain_code: m_44_60_0_0_0_normal_child_chain_code&#125; = deriveNormalChild(m_44_60_0_0_normal_child_private_key, m_44_60_0_0_normal_child_public_key, m_44_60_0_0_normal_child_chain_code, 0)console.log(&#39;private key\t&#39;, m_44_60_0_0_0_normal_child_private_key)     // 82366d0c8da4fdd0e0466b0458fe5dc7d63dff2753b890e79968e10e2ade5a33     ==&gt; 0xae61f8662B52E78FB8246A1EBb5b6a853a2E1180console.log(&#39;public key\t&#39;, m_44_60_0_0_0_normal_child_public_key)       // 027771e7a5d367fe8390a51a29d277b1ce4de23034c68c551a83f927f4da6381edconsole.log(&#39;chain code\t&#39;, m_44_60_0_0_0_normal_child_chain_code)       // 700a8c04ccff4d820bbd5857c94d1ef7b82223355e9842bcfa2b7a9f2a694bc6console.log(&#39;address \t&#39;, new ethers.Wallet(m_44_60_0_0_0_normal_child_private_key).address)console.log(&quot;\n&quot;)// m / 44&#39; / 60&#39; / 0&#39; / 0 / 1             ===&gt; address 2console.log(`m / 44&#39; / 60&#39; / 0&#39; / 0 / 1 \t\t address2`)const &#123;    normal_child_private_key: m_44_60_0_0_1_normal_child_private_key,    normal_child_public_key: m_44_60_0_0_1_normal_child_public_key,    normal_child_chain_code: m_44_60_0_0_1_normal_child_chain_code&#125; = deriveNormalChild(m_44_60_0_0_normal_child_private_key, m_44_60_0_0_normal_child_public_key, m_44_60_0_0_normal_child_chain_code, 1)console.log(&#39;private key\t&#39;, m_44_60_0_0_1_normal_child_private_key)     // f4e7a23354f92209bfde311b4e23bbf49cd33180a42ba413ee32117904e4bebf     ==&gt; 0x3403064DB6E3Bc9EB8E3779Bea018d760488B61aconsole.log(&#39;public key\t&#39;, m_44_60_0_0_1_normal_child_public_key)       // 02ee93da25a8b498f1c325b5db18ad5bb1b02fe83b1da48bbf96fca3acffcaea70console.log(&#39;chain code\t&#39;, m_44_60_0_0_1_normal_child_chain_code)       // dde70e0b0f1045ba36ba2c21d3ae957f249f715b42bdeaad319b16aa0b62b97dconsole.log(&#39;address \t&#39;, new ethers.Wallet(m_44_60_0_0_1_normal_child_private_key).address)console.log(&quot;\n&quot;)// m / 44&#39; / 60&#39; / 0&#39; / 0 / 2             ===&gt; address 3console.log(`m / 44&#39; / 60&#39; / 0&#39; / 0 / 2 \t\t address3`)const &#123;    normal_child_private_key: m_44_60_0_0_2_normal_child_private_key,    normal_child_public_key: m_44_60_0_0_2_normal_child_public_key,    normal_child_chain_code: m_44_60_0_0_2_normal_child_chain_code&#125; = deriveNormalChild(m_44_60_0_0_normal_child_private_key, m_44_60_0_0_normal_child_public_key, m_44_60_0_0_normal_child_chain_code, 2)console.log(&#39;private key\t&#39;, m_44_60_0_0_2_normal_child_private_key)     // 37b8d8babc074af0289c0ca08db9f157295450f083c9b8ed257dc6638897a48a     ==&gt; 0x5BABEbEacBB48cb89169b026163567C2766d522aconsole.log(&#39;public key\t&#39;, m_44_60_0_0_2_normal_child_public_key)       // 03c5b5c1812d9158ba9f1603ff49664ab5e124ac0bf23b9565f8d77231ab32fee1console.log(&#39;chain code\t&#39;, m_44_60_0_0_2_normal_child_chain_code)       // 9f4da6bf7b5cb56d1d31b15c59f3864c168d7446f64bcc85b580b4062fee0de0console.log(&#39;address \t&#39;, new ethers.Wallet(m_44_60_0_0_2_normal_child_private_key).address)console.log(&quot;\n&quot;)// ...// 使用ethers.js进行地址验证// const private_key = &quot;1f760218ed5e78469c2f5629f435c5e8125559444d80f77fb18050ac856d2305&quot;;// const my_wallet = new ethers.Wallet(private_key)// const address = my_wallet.address// console.log(address) // 0xae61f8662B52E78FB8246A1EBb5b6a853a2E1180  0xd796160F39B8FCAeeB9bb33aDF2597b7e9A375F0// const publicKey = my_wallet.publicKey// console.log(publicKey)</code></pre><p>注意我们的执行过程，每一层都是根据上一层的结果来的，并且我们的coin type是60，代表的是以太坊</p><pre><code class="bash">Mnemonic         champion cabbage toy struggle gesture hat thing weasel door digital hard skullseed             fc72cb09fe4945760c07d58c8d6ca0b41096e832620ceaec6f45b000cffc3dd730c31dffa9da0dbbbcc6b0cbca0baea68a90ccef166a36db5d3064e78be3e1c0mmaster private key       7b195fbe3c22e4a5bea3dec458d569dcfc651b5f3d0deb4726ff941841a80e8dmaster chain code        73e2e8c403b81b7519b4397b04f6fec33842671d590743dc6d314a7b568710d6m / 44&#39;private key      29821685d17b9290c7673cc2023f5483b985e37a0417393e3d99d17fa3d520d4public key       0371db0a35a9663b94149c2c67264b0118b43ab3582ba9ea786529155eb27a1e1cchain code       0bacc0445d5b07157019057629a489f55b1c692931b7768a51fddf8104098704m / 44&#39; / 60&#39;private key      7fd9c8d8a4f08d89d040d73cacaa226ead205f5935658d4d18621b7d4515509fpublic key       027709505e63414854e726c4f5dc41692c78124bf2b31408e12c9e02f2b12aedbdchain code       ae3dcd9307342354a3d78ebacd787f0106e8ea61a8b1546ae83815159527529em / 44&#39; / 60&#39; / 0&#39;private key      8ac2b9b018f5bccae139fcaf30b4da0a991137a55f1af2f89dc61265d42cbd3dpublic key       037407142f6a78b29da97caa84890cf68fc41185dea144ebc2c9d426cbf88acd13chain code       0776d860eb346f070fdf11aeff5266aa3e1c107bbef038a9886d2064e9648f7fm / 44&#39; / 60&#39; / 0&#39; / 0private key      1a52ada38fbbbf012b8f4687eed2a1866a30ee0ddfa5580285fa47c99821b207public key       0321f4cd9f9b7612c5df4a35c2efb89344569fd180a1f2d6bbcf9fa3669eadfffcchain code       392e55acd44d827b22151ebcdd79e667f51b245468a429dfbb08516c97b5a04bm / 44&#39; / 60&#39; / 0&#39; / 0 / 0               address1private key      5d59d31e3a267fb8f6bb7b7ac4a77d539285efe878264254cc9dd83a77c5e8f2public key       02bb3b7a4cd7925966e568dd723229b6728e23bee5c2cefa2301652c6b05662333chain code       f8e1d50841da90ea94fc262f930167e254fe83d87bed64560d56129cff935bebaddress          0xa63e0541B6139ED1f49572AD4701C2bfB62085d6m / 44&#39; / 60&#39; / 0&#39; / 0 / 1               address2private key      3fdb30a1380601a7b526e040340f6043461e43890a833cd4c9062e04a01ce8b5public key       024f25e1c9255510f2be83a1ed49d370c1072e66de54781a61d2a2d063d8340d69chain code       18783873a4314ab8afb2e155b5d1b89898990b8688e736b215bf6e8c3bd4af8baddress          0xFfee95e8803C42B77655D28Ea9af0126b2f4E9d9m / 44&#39; / 60&#39; / 0&#39; / 0 / 2               address3private key      a3d8a45d84e3145b20530b052fd3f172c960a2f307aac1448d94cf0b47400dc9public key       0325b422277388f364a1ff49e3b282b41b93cfefaa6d10d8b30c71ed168233f151chain code       4506027ab095aa232304f1be2369d80111b5040dac977ebe3e00b0ee497afcc0address          0x9a1aeDB88cd378b6cCaf94CEa4D3aeb639Cea77E</code></pre><p>我们把结果中的助记词导入到小狐狸钱包中，小狐狸钱包默认是从0开始生成地址的，那我们导入之后，也生成三个地址，结果应该是和上面的三个address相同才对</p><p><img src="/images/8964f95f-cf93-491e-9d90-1e5fdc62d5d9-image.png" alt="8964f95f-cf93-491e-9d90-1e5fdc62d5d9-image.png" title="8964f95f-cf93-491e-9d90-1e5fdc62d5d9-image.png"></p><p><img src="/images/48a56678-84c6-4f95-b94d-766caae6b97c-image.png" alt="48a56678-84c6-4f95-b94d-766caae6b97c-image.png" title="48a56678-84c6-4f95-b94d-766caae6b97c-image.png"></p><p><img src="/images/5ac02627-988a-44da-b243-34a43ddb4618-image.png" alt="5ac02627-988a-44da-b243-34a43ddb4618-image.png" title="5ac02627-988a-44da-b243-34a43ddb4618-image.png"></p><p>我们看到，地址和我们自己生成的地址是一样的。</p><h1 id="使用web3-js"><a href="#使用web3-js" class="headerlink" title="使用web3.js"></a>使用web3.js</h1><p>我们洋洋洒洒的写了一大篇，其实我们写的程序还是有很多考虑不足的地方，不过好在已经有人帮我们造好了轮子，我们不需要重复的造，上面的代码只作为学习，不能在生产开发中使用，在生产中我们还是使用现成的库比较好一点，会更加安全，这里介绍一下web3.js。</p><p>使用web3.js，我们生成地址只需要调用一个方法</p><pre><code class="javascript">const &#123; Web3 &#125; = require(&#39;web3&#39;)const web3 = new Web3()const accounts = web3.eth.accounts.wallet.create(3)console.log(accounts)</code></pre><p>我们创建了3个钱包地址，并且每个地址都会有签名和加密的方法，十分方便。</p><pre><code class="bash">Wallet(3) [  &#123;    address: &#39;0x2274356Ce5764CeFF5D4753D0e52034187E0ff2f&#39;,    privateKey: &#39;0x2767973bc6a101bb7c7b5719caf500df8fc37274cea552b36122acb5786a96d9&#39;,    signTransaction: [Function: signTransaction],    sign: [Function: sign],    encrypt: [Function: encrypt]  &#125;,  &#123;    address: &#39;0x20a619b5F97603d761e396AfB312D008B5383fE7&#39;,    privateKey: &#39;0x36a382a825fb4744e69556062061d3dda21e143df849f2baad38ada63dcf0dca&#39;,    signTransaction: [Function: signTransaction],    sign: [Function: sign],    encrypt: [Function: encrypt]  &#125;,  &#123;    address: &#39;0xfC3B3a08Ed47060E7201c271040d3442385d6Cc4&#39;,    privateKey: &#39;0x59c6929e9fb9137ab11d2fb59d8ec3a667fb6915df886ca305d03caf8e26a1d4&#39;,    signTransaction: [Function: signTransaction],    sign: [Function: sign],    encrypt: [Function: encrypt]  &#125;,  _accountProvider: &#123;    create: [Function: createWithContext],    privateKeyToAccount: [Function: privateKeyToAccountWithContext],    decrypt: [Function: decryptWithContext]  &#125;,  _addressMap: Map(3) &#123;    &#39;0x2274356ce5764ceff5d4753d0e52034187e0ff2f&#39; =&gt; 0,    &#39;0x20a619b5f97603d761e396afb312d008b5383fe7&#39; =&gt; 1,    &#39;0xfc3b3a08ed47060e7201c271040d3442385d6cc4&#39; =&gt; 2  &#125;,  _defaultKeyName: &#39;web3js_wallet&#39;]</code></pre><h1 id="ether-js"><a href="#ether-js" class="headerlink" title="ether.js"></a>ether.js</h1><pre><code class="javascript"></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity-ABI编码函数</title>
      <link href="/2023/06/25/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-ABI%E7%BC%96%E7%A0%81%E5%87%BD%E6%95%B0/"/>
      <url>/2023/06/25/%E5%8C%BA%E5%9D%97%E9%93%BE/solidity-ABI%E7%BC%96%E7%A0%81%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity-ABI编码函数"><a href="#solidity-ABI编码函数" class="headerlink" title="solidity-ABI编码函数"></a>solidity-ABI编码函数</h1><ul><li>abi.encode(…) returns (bytes)：计算参数的 ABI 编码。自动补全32位</li><li>abi.encodePacked(…) returns (bytes)：计算参数的紧密打包编码</li></ul><p>计算函数选择器和参数的 ABI 编码</p><ul><li>abi.encodeWithSignature(string signature, …) returns (bytes)</li><li>abi.encodeWithSelector(bytes4(keccak256(signature), …)</li></ul><h1 id="测试合约代码"><a href="#测试合约代码" class="headerlink" title="测试合约代码"></a>测试合约代码</h1><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract ABI_Test &#123;    uint256 x = 10;    address addr = 0x7bf58A323CEA52c66E098B273D9FFA27e2bCd6C2;    string str = &quot;This is abi test&quot;;    uint256[3] arr = [1, 2, 3];    function test_encode() public view returns (bytes memory) &#123;        return abi.encode(x, addr, str, arr);    &#125;    // 0x    // 000000000000000000000000000000000000000000000000000000000000000a    // 0000000000000000000000007bf58a323cea52c66e098b273d9ffa27e2bcd6c2    // 00000000000000000000000000000000000000000000000000000000000000c0    // 0000000000000000000000000000000000000000000000000000000000000001    // 0000000000000000000000000000000000000000000000000000000000000002    // 0000000000000000000000000000000000000000000000000000000000000003    // 0000000000000000000000000000000000000000000000000000000000000010    // 5468697320697320616269207465737400000000000000000000000000000000    function test_encodePacked() public view returns (bytes memory) &#123;        return abi.encodePacked(x, addr, str, arr);    &#125;    // 0x    // 000000000000000000000000000000000000000000000000000000000000000a    // 7bf58a323cea52c66e098b273d9ffa27e2bcd6c2    // 54686973206973206162692074657374    // 0000000000000000000000000000000000000000000000000000000000000001    // 0000000000000000000000000000000000000000000000000000000000000002    // 0000000000000000000000000000000000000000000000000000000000000003    function test_encodeWithSignature() public view returns (bytes memory) &#123;        return abi.encodeWithSignature(&quot;core(uint256,address,string,uint256[3])&quot;, x, addr, str, arr);    &#125;    // 0x    // 9545b557    // 000000000000000000000000000000000000000000000000000000000000000a    // 0000000000000000000000007bf58a323cea52c66e098b273d9ffa27e2bcd6c2    // 00000000000000000000000000000000000000000000000000000000000000c0    // 0000000000000000000000000000000000000000000000000000000000000001    // 0000000000000000000000000000000000000000000000000000000000000002    // 0000000000000000000000000000000000000000000000000000000000000003    // 0000000000000000000000000000000000000000000000000000000000000010    // 5468697320697320616269207465737400000000000000000000000000000000    function test_encodeWithSelector() public view returns (bytes memory) &#123;        return abi.encodeWithSelector(bytes4(keccak256(&quot;core(uint256,address,string,uint256[3])&quot;)), x, addr, str, arr);    &#125;    // 0x    // 9545b557    // 000000000000000000000000000000000000000000000000000000000000000a    // 0000000000000000000000007bf58a323cea52c66e098b273d9ffa27e2bcd6c2    // 00000000000000000000000000000000000000000000000000000000000000c0    // 0000000000000000000000000000000000000000000000000000000000000001    // 0000000000000000000000000000000000000000000000000000000000000002    // 0000000000000000000000000000000000000000000000000000000000000003    // 0000000000000000000000000000000000000000000000000000000000000010    // 5468697320697320616269207465737400000000000000000000000000000000        function test_decode() public view returns (uint256 _x, address _addr, string memory _str, uint256[3] memory _arr) &#123;        bytes memory result = test_encode();        return abi.decode(result, (uint256, address, string, uint256[3]));    &#125;    // uint256: _x 10    // address: _addr 0x7bf58A323CEA52c66E098B273D9FFA27e2bCd6C2    // string: _str This is abi test    // uint256[3]: _arr 1,2,3&#125;</code></pre><h1 id="abi-encode"><a href="#abi-encode" class="headerlink" title="abi.encode"></a>abi.encode</h1><p>将给定参数利用ABI 规则编码。ABI 被设计出来跟智能合约交互，他将每个参数转填充为 32 位的数据，并拼接在一起。如果你要和合约交互，你要用的就是 <code>abi.encode</code> 。</p><p>编码的结果为：</p><pre><code class="bash">## encode测试结果 0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007bf58a323cea52c66e098b273d9ffa27e2bcd6c200000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000105468697320697320616269207465737400000000000000000000000000000000</code></pre><p>由于 <code>abi.encode</code> 将每个数据都填充为 32 位，中间有很多 0。将其分割开，则有：</p><pre><code class="bash">0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007bf58a323cea52c66e098b273d9ffa27e2bcd6c200000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000105468697320697320616269207465737400000000000000000000000000000000</code></pre><ul><li>第1个32位存储了x，0xa16进制转为10进制就是10，它就是uint256 x &#x3D; 10；</li><li>第2个32位存储了addr，即address addr &#x3D; 0x7bf58a323cea52c66e098b273d9ffa27e2bcd6c2；</li><li>第3个32位存储了动态类型string的存储位置，0xc0即192位，即说明string类型存储在了192位的位置，以0位开始计数，往后推192位，即6个32，则第7个32位开始存储string类型的信息；</li><li>第4个32位存储了arr的第一个值arr[0]；</li><li>第5个32位存储了arr的第一个值arr[1]；</li><li>第6个32位存储了arr的第一个值arr[1]；</li><li>第7个32位存储了str的长度，值为0x10，即10进制的16，是我们这里<code>This is abi test</code>的长度；</li><li>第8个32位即是<code>This is abi test</code>的内容本身。</li></ul><h1 id="abi-encodePacked"><a href="#abi-encodePacked" class="headerlink" title="abi.encodePacked"></a>abi.encodePacked</h1><p>将给定参数根据其所需最低空间编码。它类似 abi.encode，但是会把其中填充的很多 0 省略。比如，只用 1 位来编码 uint 类型。当你想省空间，并且不与合约交互的时候，可以使用 abi.encodePacked，例如算一些数据的 hash 时。</p><p>编码的结果为：</p><pre><code class="bash">## encodePacked测试结果 0x000000000000000000000000000000000000000000000000000000000000000a7bf58a323cea52c66e098b273d9ffa27e2bcd6c254686973206973206162692074657374000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</code></pre><p>将其分割开，则有：</p><pre><code class="bash">0x000000000000000000000000000000000000000000000000000000000000000a7bf58a323cea52c66e098b273d9ffa27e2bcd6c254686973206973206162692074657374000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</code></pre><p>可以看到这里没有要与EVM底层执行的格式适配，就仅仅是实际存储内容的拼接加密，所以没有多余的要凑齐256位字长的0值。</p><h1 id="abi-encodeWithSignature"><a href="#abi-encodeWithSignature" class="headerlink" title="abi.encodeWithSignature"></a>abi.encodeWithSignature</h1><p>与 abi.encode 功能类似，只不过第一个参数为函数签名，比如”foo(uint256,address)”。当调用其他合约的时候可以使用。</p><p>编码的结果为：</p><pre><code class="bash">## encodeWithSignature测试结果 0x9545b557000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007bf58a323cea52c66e098b273d9ffa27e2bcd6c200000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000105468697320697320616269207465737400000000000000000000000000000000</code></pre><p>等同于在 abi.encode 编码结果前加上了 8 位的函数选择器。<br>将其分割开，则有：</p><pre><code class="bash">0x9545b557000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007bf58a323cea52c66e098b273d9ffa27e2bcd6c200000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000105468697320697320616269207465737400000000000000000000000000000000</code></pre><p>这里的第一行的<code>9545b557</code>是函数签名对<code>core(uint256,address,string,uint256[3])</code>进行keccak256运算后取前8位的结果，这样的结果作为一种函数选择器，作为函数的唯一标识。剩下的就跟abi.encode结果一样了，所以说，abi.encode是用于合约交互的，因为合约交互就涉及到函数的调用，函数的调用就需要abi.encode这种对数据的编码格式。</p><h1 id="abi-encodeWithSelector"><a href="#abi-encodeWithSelector" class="headerlink" title="abi.encodeWithSelector"></a>abi.encodeWithSelector</h1><p>与 abi.encodeWithSignature 功能类似，只不过第一个参数为函数选择器，为函数签名 Keccak 哈希的前8位。</p><p>编码的结果为：</p><pre><code class="bash">## encodeWithSelector测试结果 0x9545b557000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007bf58a323cea52c66e098b273d9ffa27e2bcd6c200000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000105468697320697320616269207465737400000000000000000000000000000000</code></pre><p>将其分割开，则有：</p><pre><code class="bash">0x9545b557000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007bf58a323cea52c66e098b273d9ffa27e2bcd6c200000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000105468697320697320616269207465737400000000000000000000000000000000</code></pre><p>这个从结果上是跟encodeWithSignature一样的，就是用法上存在差别：</p><pre><code class="solidity"># 用法差异abi.encodeWithSignature(&quot;core(uint256,address,string,uint256[3])&quot;, x, addr, str, arr);abi.encodeWithSelector(bytes4(keccak256(&quot;core(uint256,address,string,uint256[3])&quot;)), x, addr, str, arr);</code></pre><h1 id="abi-decode"><a href="#abi-decode" class="headerlink" title="abi.decode"></a>abi.decode</h1><p>abi.decode 用于解码 abi.encode 生成的二进制编码，将它还原成原本的参数。<br><img src="/images/2c18cb77-399b-438a-87a8-c77a0cfd1ab8-image.png" alt="2c18cb77-399b-438a-87a8-c77a0cfd1ab8-image.png" title="2c18cb77-399b-438a-87a8-c77a0cfd1ab8-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链技术-签名与验签</title>
      <link href="/2023/06/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF-%E7%AD%BE%E5%90%8D%E4%B8%8E%E9%AA%8C%E7%AD%BE/"/>
      <url>/2023/06/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF-%E7%AD%BE%E5%90%8D%E4%B8%8E%E9%AA%8C%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链技术-签名与验签"><a href="#区块链技术-签名与验签" class="headerlink" title="区块链技术-签名与验签"></a>区块链技术-签名与验签</h1><p>先对消息进行hash，再通过私钥将此hash进行签名，</p><h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><h2 id="1-对消息进行hash"><a href="#1-对消息进行hash" class="headerlink" title="1.对消息进行hash"></a>1.对消息进行hash</h2><h2 id="2-对hash的消息进行私钥签名"><a href="#2-对hash的消息进行私钥签名" class="headerlink" title="2.对hash的消息进行私钥签名"></a>2.对hash的消息进行私钥签名</h2><h1 id="验签"><a href="#验签" class="headerlink" title="验签"></a>验签</h1><h2 id="1-对hash的消息进行二次hash"><a href="#1-对hash的消息进行二次hash" class="headerlink" title="1.对hash的消息进行二次hash"></a>1.对hash的消息进行二次hash</h2><h2 id="2-获取r-s-v"><a href="#2-获取r-s-v" class="headerlink" title="2.获取r,s,v"></a>2.获取r,s,v</h2><h2 id="3-验签"><a href="#3-验签" class="headerlink" title="3.验签"></a>3.验签</h2><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8;contract VerifySignature &#123;    // 签名    /*        对内容进行hash        对hash进行签名（用私钥）    */    // 验证签名    /*        重新对内容进行hash        重建签名，对比解密后的地址    */    function getMessageHash(string memory _to, uint _amount, string memory _message, uint _nonce) public pure returns (bytes32) &#123;        return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));    &#125;    function getEthSignedMessageHash(bytes32 _messageHash) private pure returns (bytes32) &#123;        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, _messageHash));    &#125;    function verify(string memory _to, uint _amount, string memory _message, uint _nonce, bytes32 r, bytes32 s, uint8 v) external view returns (bool) &#123;        bytes32 messageHash = getMessageHash(_to, _amount, _message, _nonce);        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);        return ecrecover(ethSignedMessageHash, v, r, s) == msg.sender;    &#125;&#125;// const provider = new _ethers.providers.Web3Provider(window.ethereum)// const signer = provider.getSigner()// const messageHashBytes = _ethers.utils.arrayify(&quot;&quot;)// const flatSig = await signer.signMessage(messageHashBytes)// _ethers.utils.splitSignature(flatSig)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sodility-call和delegatecall</title>
      <link href="/2023/06/17/%E5%8C%BA%E5%9D%97%E9%93%BE/sodility-call%E5%92%8Cdelegatecall/"/>
      <url>/2023/06/17/%E5%8C%BA%E5%9D%97%E9%93%BE/sodility-call%E5%92%8Cdelegatecall/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity基础语法"><a href="#solidity基础语法" class="headerlink" title="solidity基础语法"></a>solidity基础语法</h1><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h1 id="modifier"><a href="#modifier" class="headerlink" title="modifier"></a>modifier</h1><h1 id="call-delegatecall"><a href="#call-delegatecall" class="headerlink" title="call &amp; delegatecall"></a>call &amp; delegatecall</h1><h1 id="sender-transfer"><a href="#sender-transfer" class="headerlink" title="sender&amp;transfer"></a>sender&amp;transfer</h1><h1 id="receive-fallback"><a href="#receive-fallback" class="headerlink" title="receive&amp;fallback"></a>receive&amp;fallback</h1><h1 id="钱包提现的三种方法"><a href="#钱包提现的三种方法" class="headerlink" title="钱包提现的三种方法"></a>钱包提现的三种方法</h1><h1 id="角色的分配和应用"><a href="#角色的分配和应用" class="headerlink" title="角色的分配和应用"></a>角色的分配和应用</h1><h1 id="用合约创建合约"><a href="#用合约创建合约" class="headerlink" title="用合约创建合约"></a>用合约创建合约</h1><h1 id="encode几个方法"><a href="#encode几个方法" class="headerlink" title="encode几个方法"></a>encode几个方法</h1><h1 id="合约代理-升级"><a href="#合约代理-升级" class="headerlink" title="合约代理&amp;升级"></a>合约代理&amp;升级</h1><h1 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h1><h1 id="DEX"><a href="#DEX" class="headerlink" title="DEX"></a>DEX</h1><h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><h1 id="中本聪共识"><a href="#中本聪共识" class="headerlink" title="中本聪共识"></a>中本聪共识</h1><h1 id="区块链网络"><a href="#区块链网络" class="headerlink" title="区块链网络"></a>区块链网络</h1><h1 id="私钥、公钥、助记词、钱包地址"><a href="#私钥、公钥、助记词、钱包地址" class="headerlink" title="私钥、公钥、助记词、钱包地址"></a>私钥、公钥、助记词、钱包地址</h1><h1 id="交易模型-UTXO-Account"><a href="#交易模型-UTXO-Account" class="headerlink" title="交易模型  UTXO  Account"></a>交易模型  UTXO  Account</h1><h1 id="三明治攻击、重放攻击"><a href="#三明治攻击、重放攻击" class="headerlink" title="三明治攻击、重放攻击"></a>三明治攻击、重放攻击</h1><h1 id="合约自毁"><a href="#合约自毁" class="headerlink" title="合约自毁"></a>合约自毁</h1><h1 id="hardhat部署工具"><a href="#hardhat部署工具" class="headerlink" title="hardhat部署工具"></a>hardhat部署工具</h1>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang标准包sync</title>
      <link href="/2023/04/15/Golang/golang%E6%A0%87%E5%87%86%E5%8C%85sync/"/>
      <url>/2023/04/15/Golang/golang%E6%A0%87%E5%87%86%E5%8C%85sync/</url>
      
        <content type="html"><![CDATA[<h1 id="golang标准包sync"><a href="#golang标准包sync" class="headerlink" title="golang标准包sync"></a>golang标准包sync</h1>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang数组切片的容量</title>
      <link href="/2023/04/07/Golang/golang%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E7%9A%84%E5%AE%B9%E9%87%8F/"/>
      <url>/2023/04/07/Golang/golang%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E7%9A%84%E5%AE%B9%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="golang数组切片的容量"><a href="#golang数组切片的容量" class="headerlink" title="golang数组切片的容量"></a>golang数组切片的容量</h1><pre><code class="go">arr := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;slice1 := arr[2:5]</code></pre><p>切片从2到5，此时切片没有超过数组的长度，则容量为数组的length - startIndex  &#x3D;&gt; 10 - 2 &#x3D; 8</p><pre><code class="go">fmt.Println(slice1, len(slice1), cap(slice1)) // [3 4 5] 3 8</code></pre><p>由于切片是由数组切出来的，因此底层会共享该数组的内存空间，此时如果把切片修改一下，则数组也会随之修改</p><pre><code class="go">slice1 = append(slice1, 100)fmt.Println(slice1, arr) // [3 4 5 100] [1 2 3 4 5 100 7 8 9 10]</code></pre><p>反之，修改数组也会导致切片随之修改</p><pre><code class="go">arr[2] = 100fmt.Println(slice1, arr) // [100 4 5 100] [1 2 100 4 5 100 7 8 9 10]</code></pre><hr><p>详细看下切片的容量是按照什么规则来的<br>1、直接进行切片，切片的容量即数组的length - startIndex &#x3D;&gt; 5 - 2 &#x3D; 3</p><pre><code class="go">arr2 := [5]int&#123;1, 2, 3, 4, 5&#125;slice2 := arr2[2:4]fmt.Println(slice2, len(slice2), cap(slice2)) // [3 4] 2 3</code></pre><p>2、容量为3，切片占了两个，还剩余一个还可以继续存值，此时不会重新申请内存空间，而是直接使用原数组共享的空间，因此此时会像上面说的那样，修改数组或切片，两者会互相影响</p><pre><code class="go">slice2 = append(slice2, 100)arr2[2] = 333fmt.Println(arr2, slice2, len(slice2), cap(slice2)) // [1 2 333 4 100] [333 4 100] 3 3</code></pre><p>3、如果继续向切片中添加元素，此时容量已经不够了，此时会重新申请内存空间，将原数组的元素拷贝过来，容量会在原来的基础上进行翻倍，即 3 * 2 &#x3D; 6</p><p>同时，由于重新申请了内存空间，此时修改原数组或者切片，两者不会互相影响了，可以看得到下面我们修改了arr2的 4 &#x3D;&gt; 444，而切片并没有随之修改</p><pre><code class="go">slice2 = append(slice2, 200)arr2[3] = 444fmt.Println(arr2, slice2, len(slice2), cap(slice2)) // [1 2 333 444 100] [333 4 100 200] 4 6</code></pre><p>4、再继续再切片中新增元素，如果容量不够，又会进行扩容，在原来的基础上进行翻倍</p><pre><code class="go">slice2 = append(slice2, 300)slice2 = append(slice2, 400)slice2 = append(slice2, 500)fmt.Println(arr2, slice2, len(slice2), cap(slice2)) // [1 2 333 444 100] [333 4 100 200 300 400 500] 7 12</code></pre><p>!!! 如果数组切片都会互相影响，可能会导致一些异常bug，此时我们可以在切片的时候传入第三个参数，表示容量end， endIndex &lt;&#x3D; 容量end &lt;&#x3D; 数组长度</p><p>即容量最多保留到哪里</p><pre><code class="go">arr3 := [5]int&#123;1, 2, 3, 4, 5&#125;slice3 := arr3[2:4:4] // 此时容量end为4，即不预留容量，添加一个元素的话，会重新申请一个内存空间，此时修改数组或切片，两者是不会互相影响的（但是如果不添加一个元素，就不会重新申请内存，此时直接修改arr或者切片，两者还是会互相影响，这点需要注意）slice3 = append(slice3, 100)arr3[2] = 333fmt.Println(arr3, slice3, len(slice3), cap(slice3)) // [1 2 333 4 5] [3 4 100] 3 4   这里容量是4，因为重新申请了内存，容量在原来基础上翻倍，即 2 * 2 = 4</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang类型别名与类型定义</title>
      <link href="/2023/04/07/Golang/golang%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/04/07/Golang/golang%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="golang类型别名与自定义类型"><a href="#golang类型别名与自定义类型" class="headerlink" title="golang类型别名与自定义类型"></a>golang类型别名与自定义类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名规定：Type Alias只是Type 的别名，本质上Type Alias 与Type是同一个类型，即基本数据类型是一致的。好比如我们小时家里人给我们起的小名，上学后英语老师给起的英文名字，但是这个名字都是指的我们自己。<br>语法：<code>type type_alias = Type</code></p><p>类型别名实际上是一样的，类型之间可以互相赋值，</p><pre><code class="go">type myInt = intfunc main() &#123;    var int1 int = 10    var int2 myInt = 20    fmt.Println(reflect.TypeOf(int1)) // int    fmt.Println(reflect.TypeOf(int2)) // int    fmt.Println(int1, int2) // 10 20    int2 = int1    fmt.Println(int1, int2) // 10 10&#125;</code></pre><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>自定义类型是依据基本类型声明一个新的数据类型。</p><p>自定义类型不能直接和原类型进行互相赋值，会编译报错，但是可以通过强制类型转换来进行赋值</p><pre><code class="go">type myInt intfunc main() &#123;    var int1 int = 10    var int2 myInt = 20    fmt.Println(reflect.TypeOf(int1)) // int    fmt.Println(reflect.TypeOf(int2)) // main.myInt    fmt.Println(int1, int2) // 10 20    // int2 = int1             // 编译报错 cannot use int1 (variable of type int) as myInt value in assignment    // 可以通过类型转换来进行赋值    var int3 myInt    int3 = myInt(int1)    fmt.Println(int3)&#125;</code></pre><p>从上面的结果我们可以看出，int2 的类型是 main.myInt，表示main 包下定义的myInt 类型。生成了新的数据类型。</p><p>我们应该尽量避免使用自定义类型，实际上类型别名已经足够满足我们的开发需求了，比如json相关的操作中，经常用到<code>map[string]interface &#123;&#125;</code>这种类型，写起来很繁琐，没关系，给它起个简单的别名，这样就很方便了。</p><pre><code class="go">type strMap2Any = map[string]interface &#123;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang整型计算类型转换</title>
      <link href="/2023/04/07/Golang/golang%E6%95%B4%E5%9E%8B%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/04/07/Golang/golang%E6%95%B4%E5%9E%8B%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="golang整型计算类型转换"><a href="#golang整型计算类型转换" class="headerlink" title="golang整型计算类型转换"></a>golang整型计算类型转换</h1><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    // go 语言中不会对变量进行类型转换，需要自己手动转换    // 例如 int 和 int8 相加时，就不能相加，需要转换成一致的类型    var (        d1 int  = 10        d2 int8 = 10    )    // fmt.Println(d1 + d2) // 报错：invalid operation: d1 + d2 (mismatched types int and int8)    // 上面会报错，因为 int 类型和 int8 类型不能直接相加，需要进行转换，例如    fmt.Println(d1 + int(d2))    fmt.Println(int8(d1) + d2)    // 注意！在转换的时候，如果是把范围大的类型转换为范围小的类型，需要注意转换的范围是否合适    // 例如 int 转 int8，64位系统 int 有64位，取值很大，而 int8 只能取 -128-127，如果 int 类型的数字为1000，转为 int8 结果就不对，短的位会进行截取    var (        d3 int  = 1000        d4 int8 = 100    )    fmt.Println(int8(d3))      // 1000 int 类型转 int8 类型的值为 -24    fmt.Println(int8(d3) + d4) // 76 这里的结果是76，而不是1100，因为 1000 转int8 的结果并不是1000. int8 最大只能取值127&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var、let、const声明过程</title>
      <link href="/2023/04/07/JavaScript/var%E3%80%81let%E3%80%81const%E5%A3%B0%E6%98%8E%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/04/07/JavaScript/var%E3%80%81let%E3%80%81const%E5%A3%B0%E6%98%8E%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="var、let、const声明过程"><a href="#var、let、const声明过程" class="headerlink" title="var、let、const声明过程"></a>var、let、const声明过程</h1><p>先抛出结论：<br>js使用<code>var</code>、<code>let</code>、<code>const</code>声明变量的时候，会有两个步骤，一个是提升变量声明，一个是初始化（初始化为undefined）。</p><ul><li><code>var</code> 会提升变量的申明和初始化</li><li><code>let</code> 会提升变量申明，但不会提升初始化</li><li><code>const</code> 和 <code>let</code> 一样，但是<code>const</code>不能像<code>var</code>、<code>let</code>那样使用<code>var a</code>、<code>let b</code>这样初始化，只能<code>const c = 1</code>这种同时申明并初始化</li></ul><span id="more"></span><h1 id="var"><a href="#var" class="headerlink" title="var"></a>var</h1><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  var x = 1;  console.log(&#39;结果：&#39; + x);&#125;</code></pre><p>输出结果：</p><pre><code>结果：undefined结果：1</code></pre><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  var x;&#125;</code></pre><p>输出结果：</p><pre><code>结果：undefined</code></pre><p>从结果不难看出，<code>var</code>的声明被提升了，并初始化为了<code>undefined</code>，然后再将<code>1</code>赋值给<code>x</code></p><h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  let x = 1;  console.log(&#39;结果：&#39; + x);&#125;</code></pre><p>输出结果：</p><pre><code>Uncaught ReferenceError: Cannot access &#39;x&#39; before initialization</code></pre><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  let x;&#125;</code></pre><p>输出结果：</p><pre><code>Uncaught ReferenceError: Cannot access &#39;x&#39; before initialization</code></pre><p>从结果可以看出，<code>let</code>和<code>var</code>结果不一样，正是因为<code>let</code>仅仅提升了变量的声明，并不会提升初始化，所以这里在<code>let</code>之前访问<code>x</code>会报错，在初始化之前无法访问<code>x</code>,这里有一个官方叫法，叫暂存死区（<code>temporal dead zone</code>）</p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  const x = 1;  console.log(&#39;结果：&#39; + x);&#125;</code></pre><p>输出结果：</p><pre><code>Uncaught ReferenceError: Cannot access &#39;x&#39; before initialization</code></pre><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  const x;&#125;</code></pre><p>输出结果：</p><pre><code>Uncaught SyntaxError: Missing initializer in const declaration</code></pre><p>从结果可以看出，<code>const</code>和<code>let</code>都有暂存死区问题，但是报错信息不同，<code>const</code>在声明的同时必须赋值；</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>在浏览器环境中，<code>var</code>定义的<strong>全局变量</strong>都属于<code>window</code>对象，而let定义的<strong>全局变量</strong>，部署于<code>window</code>对象</p><pre><code class="javascript">var attr1 = &#39;tom&#39;console.log(window.attr1); // tom</code></pre><p>在浏览器环境中，let定义的全局变量，不属于window对象</p><pre><code class="javascript">var attr2 = &#39;jerry&#39;console.log(window.attr2); // undefined</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 基础语法</title>
      <link href="/2023/04/07/TypeScript/Typescript%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/04/07/TypeScript/Typescript%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-基础语法"><a href="#Typescript-基础语法" class="headerlink" title="Typescript 基础语法"></a>Typescript 基础语法</h1><p>推荐阅读<a href="https://www.tslang.cn/docs/handbook/basic-types.html" title="title">官方文档</a></p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><pre><code class="typescript">let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744;</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code class="typescript">let username: string = `Gene`;let sentence: string = `Hello, my name is $&#123;username&#125;`</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code class="typescript">let list1: number[] = [1, 2, 3];let list2: Array&lt;number&gt; = [1, 2, 3];</code></pre><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><pre><code class="typescript">let isDone: boolean = false;</code></pre><h3 id="null-undefine"><a href="#null-undefine" class="headerlink" title="null, undefine"></a>null, undefine</h3><p>这两个类型只能赋值给 null 或 undefined<br>注意：在之前ts的版本中 null 或 undefined 是其他类型的子类型，可以赋值给其他类型，但是后面的版本修改了，只能是 null 或 undefined，更加安全</p><pre><code class="typescript">let n: null = null;let u: undefined = undefined</code></pre><h3 id="元组tuple【ts新增】"><a href="#元组tuple【ts新增】" class="headerlink" title="元组tuple【ts新增】"></a>元组tuple【ts新增】</h3><p>ts新增，元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p><pre><code class="typescript">let tuple: [string, number] = [&#39;abc&#39;, 10]// let tuple: [string, number] = [100, 10]  // 错的</code></pre><h3 id="枚举enum【ts新增】"><a href="#枚举enum【ts新增】" class="headerlink" title="枚举enum【ts新增】"></a>枚举enum【ts新增】</h3><p>ts新增，enum类型是对JavaScript标准数据类型的一个补充</p><pre><code class="typescript">enum Gender &#123; male = 0, female = 1, unknow = -1 &#125;let g: number = Gender.maleconsole.log(g)  // 0// 如果没有指定默认值，则默认值为索引下标，默认从0开始，例如：enum weekday &#123;sunday, monday&#125;let d: number = weekday.mondayconsole.log(d)  // 1let day: weekday = weekday.sundayconsole.log(day) // 0// 也可以通过索引来找到对应的值let day1: string = weekday[0]console.log(day1)   // sunday </code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><pre><code class="typescript">let num: 1 | 2 | 3num = 1// num = 4   // error</code></pre><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><pre><code class="typescript">let notSure: any = 4;   // noSure可以是任意js对象let list3: any[] = [1, true, &quot;free&quot;];  // 由任意对象组成的数组let list4: Array&lt;any&gt; = [1, true, &quot;free&quot;];  // 由任意对象组成的数组</code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>没有任何类型，当函数没有返回值时，可以设置为void</p><pre><code class="typescript">function warnUser(): void &#123;  console.log(&quot;This is my warning message&quot;);&#125;</code></pre><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>返回never的函数必须存在无法达到的终点</p><pre><code class="typescript">function error(message: string): never &#123;  throw new Error(message);&#125;function fail() &#123;  return error(&quot;Something failed&quot;);&#125;function infiniteLoop(): never &#123;  while (true) &#123;&#125;&#125;</code></pre><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>能确定变量类型的话，就可以使用断言</p><ul><li>“尖括号”语法<pre><code class="typescript">let someValue: any = &#39;some message&#39;;let strLength: number = (&lt;string&gt;someValue).length;</code></pre></li><li>as语法<br>  在TypeScript里使用JSX时，只有 as 语法断言是被允许的，因为&lt;&gt;语法在jsx中会解析成为元素或组件<pre><code class="typescript">let someValue1: any = &quot;this is a string&quot;;let strLength2: number = (someValue as string).length;</code></pre></li></ul><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， <code>Person &amp; Student &amp; Gender</code>同时是 <code>Person 和 Student 和 Gender</code>。 就是说这个类型的对象同时拥有了这三种类型的成员。<br><strong>需要合并的需要是接口类型</strong></p><pre><code class="typescript">interface Person &#123;    name: string    age: number&#125;interface Student &#123;    school: string&#125;interface Gender &#123;    gender: &#39;male&#39; | &#39;female&#39;&#125;type StudentInfo = Person &amp; Student &amp; Gender// 正确let stu: StudentInfo = &#123;  name: &#39;jerry&#39;,  age: 18,  school: &#39;xxx&#39;,  gender: &#39;male&#39;&#125;// 错误，缺少genderlet stu1: StudentInfo = &#123;  name: &#39;jerry&#39;,  age: 18,  school: &#39;xxx&#39;&#125;</code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型表示一个值可以是几种类型之一。 我们用竖线（ <code>|</code>）分隔每个类型，所以 <code>number | string | boolean</code>表示一个值可以是 <code>number</code>， <code>string</code>，或 <code>boolean</code>。</p><pre><code class="typescript">let value: string | number | boolean = &#39;123&#39;;value = &#39;string&#39;value = 100value = true// value = new Date()    // ERROR</code></pre><p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p><pre><code class="typescript">interface Type1 &#123;    func1(): void;    func2(): void;&#125;interface Type2 &#123;    func3(): void;    func2(): void;&#125;class Type1Class implements Type1 &#123;    func1(): void &#123;        console.log(&#39;func1 run&#39;);    &#125;    func2(): void &#123;        console.log(&#39;func2 run&#39;);    &#125;&#125;class Type2Class implements Type2 &#123;    func3(): void &#123;        console.log(&#39;func1 run&#39;);    &#125;    func2(): void &#123;        console.log(&#39;func2 run&#39;);    &#125;&#125;function getSomeType(type: string): Type1 | Type2 &#123;    if (type === &#39;1&#39;) &#123;        return new Type1Class();    &#125;    if (type === &#39;2&#39;) &#123;        return new Type2Class();    &#125;    throw new Error(`Excepted Type1Class or Type2Class, got $&#123;type&#125;`);&#125;let type = getSomeType(&#39;1&#39;);type.func2();type.func1(); // 报错type.func3(); // 报错</code></pre><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>假设我想把接口<code>Person</code>里的所有属性都设置为只读的或者可选的类型，我们需要重新定义接口吗？其实不用，我们可以使用映射类型，来基于已有的接口，映射出其他的类型</p><pre><code class="typescript">interface Person &#123;  name: string  age: number&#125;// 这里 in keyof 可以理解为for循环，把每个泛型属性拿出来，添加上只读修饰符type personReadonly&lt;T&gt; = &#123;  readonly [P in keyof T]: T[P];&#125;type personPartial&lt;T&gt; = &#123;  [P in keyof T]?: T[P];&#125;// 使用上面定义的映射，重新声明一个类型type PersonPartial = personPartial&lt;Person&gt;;type ReadonlyPerson = personReadonly&lt;Person&gt;;</code></pre><p>一个更简单的例子</p><pre><code class="typescript">type Keys = &#39;option1&#39; | &#39;option2&#39;;type Flags = &#123; [K in Keys]: boolean &#125;;// 这里Flags 和 Flags1是等效的type Flags1 = &#123;  option1: boolean;  option2: boolean;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 接口</title>
      <link href="/2023/04/07/TypeScript/Typescript%20%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/04/07/TypeScript/Typescript%20%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-接口"><a href="#Typescript-接口" class="headerlink" title="Typescript 接口"></a>Typescript 接口</h1><hr><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h2><p>这里的<code>&#123; label: string &#125;</code>就是一个接口，规范<code>labelledObj</code>必须有一个<code>label</code>为字符串的属性<br>编译器只会检查那些必需的属性是否存在，并且其类型是否匹配<br>类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以</p><pre><code class="typescript">function printLabell(labelledObj: &#123; label: string &#125;) &#123;  console.log(labelledObj.label);&#125;let myObj = &#123; size: 10, label: &quot;Size 10 Object&quot; &#125;;printLabell(myObj);</code></pre><h2 id="使用interface关键字"><a href="#使用interface关键字" class="headerlink" title="使用interface关键字"></a>使用interface关键字</h2><p>接口可以单独声明出来，注意接口分隔符写 <code>,</code> 和 <code>;</code> 都可以，推荐分号，和对象区分</p><pre><code class="typescript">interface LabelledValue &#123;  label: string;  name: string;&#125;function printLabel1(labelledObj: LabelledValue) &#123;  console.log(labelledObj.label);&#125;let myObj1 = &#123; name: &#39;10&#39;, label: &quot;Size 10 Object&quot; &#125;;printLabel1(myObj1);</code></pre><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>属性后面加个<code>?</code>表示此属性可选</p><pre><code class="typescript">interface xyz &#123;  x?: number;  y?: number;  z?: number;&#125;function logXYZ(xyzObj: xyz): &#123; x: number; y: number; z: number &#125; &#123;  let xyz = &#123; x: 100, z: 100, y: 100 &#125;  // 不关心顺序  return xyz&#125;let xyzObj = &#123; x: 1000, ss: 100, y: 1000, z: 10000 &#125;logXYZ(xyzObj)</code></pre><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>属性前面加上<code>readonly</code>表示此属性只读</p><pre><code class="typescript">interface Point &#123;  readonly x: number;  readonly y: number;&#125;let p1: Point = &#123; x: 10, y: 20 &#125;;// p1.x = 5; // error!let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;// ro[0] = 12;          // error!// ro.push(5);          // error!// ro.length = 100;     // error!// a = ro;              // error!   注意这里，ro是只读的，即使是重新赋值给另外一个变量，也是不允许的a = &lt;Array&lt;number&gt;&gt;ro   // 但是可以使用断言来重写</code></pre><h1 id="额外属性检查"><a href="#额外属性检查" class="headerlink" title="额外属性检查"></a>额外属性检查</h1><pre><code class="typescript">interface Label &#123;  label: string&#125;function printLabel(labelledObj: Label) &#123;  console.log(labelledObj.label);&#125;let myObj2 = &#123; size: 10, label: &quot;Size 10 Object&quot; &#125;;printLabel(myObj2);</code></pre><p>上面的接口允许我们传递除了label的额外属性，上面这样写没有问题，但是当我们把myObj2直接写到函数中，ts会校验不通过，<strong>这是因为对象字面量会被特殊对待而且会经过额外的属性检查</strong></p><pre><code class="typescript">printLabel(&#123; size: 10, label: &quot;Size 10 Object&quot; &#125;);   </code></pre><p>解决这个可以使用断言</p><pre><code class="typescript">printLabel(&lt;Label&gt;&#123; size: 10, label: &quot;Size 10 Object&quot; &#125;)</code></pre><p>但是注意一下，只有在断言后面直接设置的时候，才能添加额外的属性，下面这样使用会报错</p><pre><code class="typescript">let obj = &lt;Label&gt;&#123;&#125;obj.label = &#39;string&#39;// obj.size = 10  // 这里报错</code></pre><p>也可以像上面一样，把对象参数单独保存为一个变量，也可以绕过检查</p><pre><code class="typescript">let myObj3 = &#123; size: 10, label: &quot;Size 10 Object&quot; &#125;;printLabel(myObj3);</code></pre><p>最佳方案，添加字符串索引签名，接收任意类型的参数，只要不是label属性，则不关心其类型到底是什么</p><pre><code class="typescript">interface NewLabel &#123;  label: string;  // 属性名是string，值是任意值都可以，规定类型为any  [propName: string]: any&#125;function newpPrintLabel(labelledObj: NewLabel) &#123;  console.log(labelledObj.label);&#125;newpPrintLabel(&#123; size: 10, label: &quot;Size 10 Object&quot; &#125;)</code></pre><h1 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h1><p>假设有个函数，有两个参数，<code>source</code>和<code>subString</code>，都是字符串类型，返回值是布尔类型</p><ul><li>通过接口定义，先声明一个函数，指定接口类型，再定义函数<pre><code class="typescript">interface SearchFunc &#123;  (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function (source: string, subString: string) &#123;  let result = source.search(subString);  return result &gt; -1;&#125;</code></pre></li><li>在定义函数的时候声明接口类型<pre><code class="typescript">interface SearchFunc &#123;  (source: string, subString: string): boolean;&#125;let mySearch1: SearchFunc = function (source: string, subString: string) &#123;  let result = source.search(subString);  return result &gt; -1;&#125;</code></pre></li></ul><p>ts的类型系统会自动检查，函数的参数会逐个进行检查，要求对应位置的参数类型是相同的，形参不用和接口里的相同，也可以不指定类型</p><pre><code class="typescript">let mySearch2: SearchFunc = function (src, sub) &#123; // 这里入参不用手动添加类型，ts会自动检查  let result = src.search(sub);  return result &gt; -1;&#125;</code></pre><p>注意！函数类型的接口里面没有函数名，如果有函数名，就是类接口。并且函数的参数只能少些，不能多写，多写了就会报错</p><h1 id="混合类型接口"><a href="#混合类型接口" class="headerlink" title="混合类型接口"></a>混合类型接口</h1><p>函数上是可以绑定实例属性的，我们可以队这些属性做接口规范，例如一个函数上可以有<code>interval</code>属性和<code>reset</code>属性，值分别为<code>number</code>和函数，此时我们可以这样定义接口：</p><pre><code class="typescript">interface Counter &#123;  (start: number): string;  interval: number;  reset(): void;&#125;// 这里定义一个myCounter，要符合接口的定义，let myCounter: Counter = &lt;Counter&gt;function (start: number) &#123; &#125;myCounter.interval = 100myCounter.reset = function () &#123; &#125;myCounter.func = function () &#123; &#125; // 报错</code></pre><h1 id="类接口"><a href="#类接口" class="headerlink" title="类接口"></a>类接口</h1><p>在类中，使用接口需要使用implements关键字继承，并且需要先指定实例属性的类型，和接口中的保持一致<br>下面定义的接口只能用于类实例上，对于静态属性是无效的。如果想要约束静态属性的类型，往下看静态属性部分。</p><pre><code class="typescript">interface PersonInterface &#123;  gender: string;  age: number;  eat(food: string): string;&#125;class Student implements PersonInterface &#123;  // 和ES6不同的是，TS中属性必须声明，需要指定类型，不写的话ts检查失败  gender: string  age: number  // 声明好属性之后，属性必须赋值一个默认值或者在构造函数中进行初始化  constructor(gender: string, age: number) &#123;    this.gender = gender    this.age = age  &#125;  eat(food: string) &#123;    console.log(food)    return food  &#125;&#125;let jerry = new Student(&#39;male&#39;, 18)console.log(jerry.gender)console.log(jerry.age)jerry.eat(&#39;米饭&#39;)</code></pre><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p><code>implements</code>后面使用,可以继承多个接口</p><pre><code class="typescript">interface interface1 &#123;&#125;interface interface2 &#123;&#125;class Cls1 implements interface1, interface2 &#123;&#125;</code></pre><h2 id="定义构造函数的接口"><a href="#定义构造函数的接口" class="headerlink" title="定义构造函数的接口"></a>定义构造函数的接口</h2><p>当定义类接口中的<code>constructor</code>函数时，有特殊写法，构造函数需要单独写一个接口，定义构造函数的入参类型，以及返回类型是类的接口类型</p><pre><code class="typescript">interface constructorInterface &#123;  new (name: string): interface3 &amp; interface4;&#125;interface interface3 &#123;  name: string  log():string&#125;interface interface4 &#123;  show(): string&#125;const Cls3:constructorInterface = class implements interface3,interface4 &#123;  name: string  constructor(name: string) &#123;    this.name = name;  &#125;  log()&#123;    return &#39;loggggg&#39;  &#125;  show()&#123;    return &#39;showwww&#39;  &#125;&#125;</code></pre><h1 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h1><p>定义索引<code>key</code>为<code>number</code>类型，索引值为<code>string</code>类型<br>这个索引签名表示了当用 <code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。<code>index</code>可以是任意名字，不一定必须是<code>index</code></p><pre><code class="typescript">interface StringArray &#123;  [index: number]: string;&#125;let myArray: StringArray;myArray = [&quot;Bob&quot;, &quot;Fred&quot;];let myArray1: StringArraymyArray1 = &#123; 1: &#39;jack&#39;, 2: &#39;rose&#39; &#125;let myStr: string = myArray[0];</code></pre><h1 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h1><p>一个接口可以继承自另外一个接口，使用<code>extends</code>关键字</p><pre><code class="typescript">interface AnimalInterface &#123;  color: string  age: number  [propsName: string]: any&#125;interface DogInterface extends AnimalInterface &#123;  jiao(): void&#125;class Dog implements DogInterface &#123;  color: string  age: number  name: string  constructor(name: string, color: string, age: number) &#123;    this.color = color    this.age = age    this.name = name  &#125;  jiao() &#123;    console.log(&#39;wangwang~&#39;)  &#125;&#125;let daHuang = new Dog(&#39;大黄&#39;, &#39;red&#39;, 3)daHuang.jiao()</code></pre><h2 id="接口多重继承"><a href="#接口多重继承" class="headerlink" title="接口多重继承"></a>接口多重继承</h2><pre><code class="typescript">interface Shape &#123;  color: string;&#125;interface PenStroke &#123;  penWidth: number;&#125;interface Square extends Shape, PenStroke &#123;  sideLength: number;&#125;</code></pre><p>先断言再赋值，如果使用了断言，则属性只能设置为接口中定义了的属性</p><pre><code class="typescript">let square = &lt;Square&gt;&#123;&#125;;square.color = &quot;blue&quot;;square.sideLength = 10;square.penWidth = 5.0;// square.someOtherProp = &#39;someOtherProp&#39;;    // Error</code></pre><p>但如果直接在断言的对象中赋值，则可以赋额外的属性</p><pre><code class="typescript">let square1 = &lt;Square&gt;&#123;  color: &quot;blue&quot;,  sideLength: 10,  penWidth: 5.0,  someOtherProp: &#39;someOtherProp&#39;&#125;</code></pre><p>如果直接赋值，则一次性必须赋值所有，不能少也不能多</p><pre><code class="typescript">let mySquare: Square = &#123;  color: &quot;blue&quot;,  sideLength: 10,  penWidth: 5.0,&#125;</code></pre><h1 id="静态属性部分"><a href="#静态属性部分" class="headerlink" title="静态属性部分"></a>静态属性部分</h1><p>这里声明的接口只能作用于实例部分，无法作用于静态部分</p><pre><code class="typescript">interface CarInterface &#123;  run(): void  size: number&#125;class Car implements CarInterface &#123;  // CarInterface接口只对实例部分生效，如果实例部分没有定义相应的属性或方法，ts则会报错  // 下面的代码注释将会报错  size: number  constructor(size: number) &#123;    this.size = size  &#125;  run() &#123;    console.log(&#39;跑&#39;)  &#125;  // 上面接口定义的规则只对实例属性和实例方法有效，对静态属性和静态方法都无效  // 因此这里的size有没有都不会发生报错  static size = 1000  static run() &#123;    console.log(&#39;跑&#39;)  &#125;&#125;</code></pre><p>上面的<code>static size = 1000</code> 这部分其实并没有被接口约束，因为他是静态属性，而上面我们定义的接口只能作用于实例属性，因此这里有没有都不会发生错误，我们需要改造一下，再声明一个类类型的接口，里面包含了构造函数、静态实例、静态方法，再将构造函数的返回值指向实例部分的接口就可以了</p><pre><code class="typescript">// 这里面都是实例部分的属性和方法interface CarInterface1 &#123;  piaoyi(): void  name: string&#125;// 声明一个类接口，声明静态方法，其中包含构造函数，静态属性以及静态方法// 其中构造函数的返回值指向实例部分的类接口interface CarStatic &#123;  new(name: string): CarInterface1  size: number  run(a: string): void&#125;class Car1 implements CarInterface1 &#123;  name: string  constructor(name: string) &#123;    this.name = name  &#125;  piaoyi() &#123;    console.log(&#39;漂移~~~&#39;)  &#125;  static size = 1000  static run() &#123;    console.log(&#39;跑&#39;)  &#125;&#125;let bmw = new Car1(&#39;宝马&#39;);console.log(bmw)console.log(bmw.name)</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 泛型</title>
      <link href="/2023/04/07/TypeScript/Typescript%20%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/04/07/TypeScript/Typescript%20%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-泛型"><a href="#Typescript-泛型" class="headerlink" title="Typescript 泛型"></a>Typescript 泛型</h1><p>当我们的参数是一个不确定的数据类型的时候，且返回值和传入的参数是同一种数据类型，我们就可以使用泛型，我们也可以使用any，但是any不能确保输入和输出是同一种数据类型，会丢失一些信息</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>下面是一个最简单的泛型例子，<code>T</code>可以是任何名字，可以当它是一个变量。</p><pre><code class="typescript">function identity&lt;T&gt;(arg: T): T &#123;  return arg;&#125;</code></pre><p>使用的时候，指定具体的泛型变量类型，即可保证输出也是<code>string</code>类型</p><pre><code class="typescript">let output = identity&lt;string&gt;(&#39;hello&#39;)console.log(output)</code></pre><p>我们不需要手动指定泛型的变量类型，<code>ts</code>会帮我们自动检测传过去的是什么类型</p><pre><code class="typescript">let output1 = identity(&#39;world&#39;)console.log(output1);</code></pre><p>使用泛型变量，下面的代码会报错，因为<code>arg</code>指定类型是<code>T</code>，但是<code>T</code>是泛型，不确定传进来的是很么类型，如果是数字就没有<code>length</code>属性，因此会报错</p><pre><code class="typescript">function getLength&lt;T&gt;(arg: T): T &#123;  console.log(arg.length);  return arg&#125;</code></pre><p>使用<code>&lt;T&gt;</code>指定了泛型，传入的参数规定为泛型组成的数组，返回值也是一样，就可以使用了</p><pre><code class="typescript">function getLength1&lt;T&gt;(arg: T[]): T[] &#123;  console.log(arg.length);  return arg&#125;// 这种方式也可以function getLength2&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123;  console.log(arg.length);  return arg&#125;</code></pre><p>箭头函数形式</p><pre><code class="typescript">const getLength3 = &lt;U&gt;(arg: Array&lt;U&gt;): Array&lt;U&gt; =&gt; &#123; return arg &#125;let len = getLength3([1, &#39;2&#39;, true])console.log(len);</code></pre><h1 id="在泛型里使用类类型"><a href="#在泛型里使用类类型" class="headerlink" title="在泛型里使用类类型"></a>在泛型里使用类类型</h1><p>以下代码函数<code>create</code>接收一个名为<code>C</code>的类，返回<code>C</code>的实例，如果不是传入的类，代码将会报错</p><pre><code class="typescript">function create(C) &#123;   return new C()&#125;</code></pre><p>使用泛型队该函数进行约束，参数<code>c</code>后面<code>&#123;new ()&#125;</code> 表示<code>c</code>是一个类，可以<code>new</code>，再加上一个传入类型和返回类型，就可以这么写</p><pre><code class="typescript">function createC&lt;T&gt;(c: &#123; new(): T &#125;): T &#123;  return new c();&#125;</code></pre><h1 id="泛型函数接口"><a href="#泛型函数接口" class="headerlink" title="泛型函数接口"></a>泛型函数接口</h1><p>定义泛型函数接口，可以有以下两种形式</p><ol><li>泛型定义在函数中，这种写法的特点是用户调用的时候，可以给定任意数据类型<pre><code class="typescript">interface ConfigFn &#123;  &lt;T&gt;(value: T): T;&#125;function getData&lt;T&gt;(value: T): T &#123;  console.log(value);  return value&#125;const myGetData: ConfigFn = getData// 函数实现myGetData&lt;string&gt;(&#39;baihuzi.com&#39;)myGetData&lt;number&gt;(10086)</code></pre></li><li>泛型定义在接口中，推荐这种写法，这种方式提前指定泛型的数据类型<pre><code class="typescript">interface ConfigFn1&lt;T&gt; &#123;  (value1: T): T;  // 泛型接口&#125;// 函数实现，箭头函数写法// 提前执行函数需要的数据类型，这里使用的时候只能传字符串类型的数据const myGetData1: ConfigFn1&lt;string&gt; = value1 =&gt; &#123;  console.log(value1);  return value1&#125;myGetData1(&#39;www.baihuzi.com&#39;)// myGetData1(123)   // error</code></pre></li></ol><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p>泛型类使用<code>&lt;&gt;</code>括起泛型类型，跟在类名后面。</p><pre><code class="typescript">class GenericNumber&lt;T&gt; &#123;  zeroValue: T;  constructor(value: T)&#123;    this.zeroValue = value  &#125;  show():T &#123;    return this.zeroValue  &#125;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;(123);  myGenericNumber.zeroValue = 0;myGenericNumber.show()let stringNumeric = new GenericNumber&lt;string&gt;(&#39;string&#39;);stringNumeric.zeroValue = &quot;&quot;;myGenericNumber.show()</code></pre><h1 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h1><p>泛型约束规定泛型必须要有哪些属性，使用<code>extends</code>关键字进行定义，理解起来就是泛型<code>T</code>继承自<code>BoxConf</code>，因此泛型<code>T</code>上必须要有<code>size</code>和<code>length</code>属性，我们在传参的时候就需要带上这些属性</p><pre><code class="typescript">interface BoxConf &#123;  size: string  length: number&#125;// 泛型约束,必须要包含JJ中的属性function createHuman&lt;T extends BoxConf&gt;(what: T): T &#123;  return what&#125;createHuman(&#123;  name: &#39;Jack&#39;,  age: 18,  size: &#39;large&#39;,  // 缺少这个会报错  length: 18  // 缺少这个也会报错&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 类</title>
      <link href="/2023/04/07/TypeScript/Typescript%20%E7%B1%BB/"/>
      <url>/2023/04/07/TypeScript/Typescript%20%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-类"><a href="#Typescript-类" class="headerlink" title="Typescript 类"></a>Typescript 类</h1><p><code>ts</code>中的类和<code>js</code>中的是差不多的，只不过<code>ts</code>中有一些关键字及特性是<code>js</code>中没有的</p><h1 id="公私有和受保护的修饰符"><a href="#公私有和受保护的修饰符" class="headerlink" title="公私有和受保护的修饰符"></a>公私有和受保护的修饰符</h1><p>访问修饰符：指的就是可以在类的成员前通过添加关键字来设置当前成员的访问权限</p><ul><li>public： 公开的，默认，所有人都可以进行访问，包括实例，当前类以及子类</li><li>private： 私有的， 只能在当前类中进行访问，子类和实例中都不能用</li><li>protected： 受保护的，只能在当前类或者子类中进行访问，实例不能访问<pre><code class="typescript">class Cat &#123;  // 注意，ts中的类在使用属性的时候都需要提前对属性进行类型定义和访问修饰符定义  public color: string = &#39;white&#39;  // public 默认可省略  // 私有属性只能在当前类中访问，实例也没有该属性  private type: string  // 受保护的属性只能在当前类或子类中访问  protected size: string  constructor(type: string, size: string) &#123;    this.type = type    this.size = size  &#125;  // 获取信息API，外界无法拿到的信息通过api暴露出去  getInfo() &#123;    console.log(this.type, this.size, this.color)  &#125;&#125;let mimi = new Cat(&#39;jiafei&#39;, &#39;big&#39;)console.log(mimi.color)       // white// console.log(mimi.type)     // Error，type是私有的// console.log(mimi.size)     // Error，size是受保护的mimi.getInfo()                // jiafei big white</code></pre></li></ul><p>在子类中访问看看</p><pre><code class="typescript">class Jiafei extends Cat &#123;  color: string  constructor(type: string, size: string, color: string) &#123;    super(type, size)    this.color = color  &#125;  getInfo() &#123;    super.getInfo()    console.log(this.color)  &#125;&#125;let xiaoJiagei = new Jiafei(&#39;xiaojiafei&#39;, &#39;mid&#39;, &#39;orange&#39;)console.log(xiaoJiagei.color)       // orange// console.log(xiaoJiagei.type)     // Error，type是私有的// console.log(xiaoJiagei.size)     // Error，size是受保护的xiaoJiagei.getInfo()                // xiaojiafei mid orange                                    // orange</code></pre><h1 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h1><p>在类中，我们不能将所有的属性都设置为<code>public</code>的，这样做非常不安全，我们需要定义为<code>private</code>私有属性，但是此时，私有属性只能由类自身访问和设置，在其子类或者实例中是无法访问或修改的，此时我们就可以定义访问器，控制私有属性的访问和设置，如下例子所示</p><pre><code class="typescript">type gender = &#39;male&#39; | &#39;female&#39;;class Person1 &#123;    name: string;    age: number;    private _gender: gender;    // 性别保密    constructor(name: string, age: number, _gender: gender)&#123;        this.name = name;        this.age = age;        this._gender = _gender;    &#125;   // 下面两个的函数名必须相同，并且在外部访问或设置属性的时候，不是用的类里面定义的 _gender 属性名，而是使用这里的函数名   // ts会将这两个函数编译到Object.defineProperty里去，而函数名则作为Object.defineProperty的第二个参数   // public 可以省略，且get函数可以设置函数的返回值类型，但set函数不能设置函数返回值类型，在另一个例子中有体现    public get gender()&#123;        return this._gender    &#125;    public set gender(g: gender)&#123;        this._gender = g    &#125;&#125;let jerry1 = new Person1(&#39;jerry&#39;, 180, &#39;male&#39;)console.log(jerry1.gender) // malejerry1.gender = &#39;female&#39;console.log(jerry1.gender) // female</code></pre><blockquote><p>在使用tsc编译的时候可能会报错：<br>error TS1056: Accessors are only available when targeting ECMAScript 5 and higher.<br>注意在编译的时候，需要编译成为ECMAScript5（即ES6）的代码，因为ts本身是不具备做到get 和 set的能力的<br>需要借助js中的Object.defineProperty方法来完成，因此最低只能编译到ES6，否则没有Object.defineProperty方法<br>tips: ts默认编译到ES4<br>命令：tsc –target ES5 xxx.ts (这里的ES5即ECMAScript5)</p></blockquote><p>另一个例子</p><pre><code class="typescript">class People &#123;    private _name: string = &quot;&quot;    // 属性的存取器    get name(): string &#123;      return this._name;    &#125;      set name(value: string) &#123;      // 设置器中可以添加相关的校验逻辑      if (value.length &lt; 2 || value.length &gt; 5) &#123;        throw new Error(&quot;名字不合法，不许使用！&quot;)      &#125;      this._name = value;    &#125;  &#125;    var p = new People();   p.name = &quot;hello&quot;    console.log(p.name);  // &quot;hello&quot;</code></pre><p>编译后的文件（编译后的文件是带注释的，我这里手动删了）：</p><pre><code class="typescript">var Person1 = /** @class */ (function () &#123;    function Person1(name, age, _gender) &#123;        this.name = name;        this.age = age;        this._gender = _gender;    &#125;    Object.defineProperty(Person1.prototype, &quot;gender&quot;, &#123;        get: function () &#123;            return this._gender;        &#125;,        set: function (g) &#123;            this._gender = g;        &#125;,        enumerable: false,        configurable: true    &#125;);    return Person1;&#125;());var jerry1 = new Person1(&#39;jerry&#39;, 180, &#39;male&#39;);console.log(jerry1.gender);jerry1.gender = &#39;female&#39;;console.log(jerry1.gender);var People = /** @class */ (function () &#123;    function People() &#123;        this._name = &quot;&quot;;    &#125;    Object.defineProperty(People.prototype, &quot;name&quot;, &#123;        get: function () &#123;            return this._name;        &#125;,        set: function (value) &#123;            if (value.length &lt; 2 || value.length &gt; 5) &#123;                throw new Error(&quot;名字不合法，不许使用！&quot;);            &#125;            this._name = value;        &#125;,        enumerable: false,        configurable: true    &#125;);    return People;&#125;());var p = new People();p.name = &quot;hello&quot;;console.log(p.name);</code></pre><h1 id="只读和静态属性"><a href="#只读和静态属性" class="headerlink" title="只读和静态属性"></a>只读和静态属性</h1><p>类中的<code>readonly</code>修饰符定义实例属性是只读的，无法被实例修改，<code>readonly</code>的属性可以在声明属性的时候就给定一个初始值，或者在<code>constructor</code>构造器中进行初始化</p><pre><code class="typescript">class Octopus &#123;  readonly name: string;  readonly numberOfLegs: number = 8;  constructor(theName: string) &#123;    this.name = theName;  &#125;&#125;let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);// dad.name = &quot;Man with the 3-piece suit&quot;; // 错误! name 是只读的.</code></pre><p><code>static</code> 修饰符定义属性或方法是一个类属性或者类方法，没有用<code>static</code>定义的都是实例属性或实例方法</p><p>类属性或类方法可以直接在构造函数上进行调用，例如<code>Math.ceil</code>，<code>Math.floor</code>，<code>Array.from</code> 等</p><p>同样的，<code>static</code>静态属性可以在声明属性的时候就给定一个初始值，或者在<code>constructor</code>构造器中进行初始化</p><p>不论是静态属性还是静态方法，都能被继承，同样，被继承后静态属性或静态方法还是只能被构造函数访问，不能被实例访问</p><pre><code class="typescript">class Man &#123;  static manName: string;  static manAge: number = 18;  constructor(manName: string)&#123;    Man.manName = manName  &#125;&#125;let tom1 = new Man(&#39;tom&#39;);// console.log(tom1.manName)     // errorconsole.log(Man.manName)      // tom// console.log(tom1.manAge)      // errorconsole.log(Man.manAge)       // 18</code></pre><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。</p><p>不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。</p><p>抽象方法必须包含 abstract关键字并且可以包含访问修饰符。</p><pre><code class="typescript">abstract class Department &#123;  constructor(public name: string) &#123;  &#125;  printName(): void &#123;    console.log(&#39;Department name: &#39; + this.name);  &#125;  abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123;  constructor() &#123;    super(&#39;Accounting and Auditing&#39;); // 在派生类的构造函数中必须调用 super()  &#125;  printMeeting(): void &#123;    console.log(&#39;The Accounting Department meets each Monday at 10am.&#39;);  &#125;  generateReports(): void &#123;    console.log(&#39;Generating accounting reports...&#39;);  &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用// department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();// department.generateReports(); // 错误: 方法在声明的抽象类中不存在</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 类型守卫</title>
      <link href="/2023/04/07/TypeScript/Typescript%20%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB/"/>
      <url>/2023/04/07/TypeScript/Typescript%20%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-类型守卫"><a href="#Typescript-类型守卫" class="headerlink" title="Typescript 类型守卫"></a>Typescript 类型守卫</h1><pre><code class="typescript">type UserInfo = &#123;    name: string;    age: number;&#125;function showUser(arg: UserInfo)&#123;    console.log(arg.name, arg.age)&#125;// 正常情况let jerry: UserInfo = &#123;name: &#39;jerry&#39;, age: 18&#125;showUser(jerry)// 非正常情况let tom = 111;showUser(tom)    // 如果这里的tom不是UserInfo类型，这里将会报错</code></pre><p>如果确定<code>tom</code>是对的，不想让<code>ts</code>报错，则需要使用类型守卫，主要的是 <code>arg is UserInfo</code> 返回类型</p><p>只要<code>isUser</code>函数体中的返回值是<code>true</code>，则满足<code>UserInfo</code>类型，为<code>false</code>则不满足</p><p>注意，返回类型必须是 <code>arg is UserInfo</code>，不能是<code>boolean</code>类型</p><p>注意，如果<code>tom</code>不符合<code>UserInfo</code>类型，<code>ts</code>不会报错，只是编译后执行的时候不会执行该代码</p><p>通常对于后端请求过来的数据，我们可以通过这个方法来进行校验，如果不符合定义的类型，则不会进行相关操作</p><pre><code class="typescript">function isUser(arg: any): arg is UserInfo &#123;    if( typeof arg.name === &#39;string&#39; &amp;&amp; typeof arg.age === &#39;number&#39; )&#123;        return true    &#125;else &#123;        return false    &#125;&#125;if (isUser(tom))&#123;    showUser(tom)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux的使用</title>
      <link href="/2023/04/07/React/Redux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/07/React/Redux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Redux的使用"><a href="#Redux的使用" class="headerlink" title="Redux的使用"></a>Redux的使用</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Redux</code> 是一个使用叫做“<code>action</code>”的事件来管理和更新应用状态的模式和工具库 它以集中式<code>Store</code>（<code>centralized store</code>）的方式对整个应用中使用的状态进行集中管理，其规则确保状态只能以可预测的方式更新。</p><p>为什么要使用 <code>Redux</code>？<br><code>Redux</code> 帮你管理“全局”状态 - 哪些应用程序的许多部分都需要的状态。</p><p><code>Redux</code> 提供的模式和工具使您更容易理解应用程序中的状态何时、何地、为什么以及如何更新，以及当这些更改发生时您的应用程序逻辑将如何表现。 <code>Redux</code> 指导您编写可预测和可测试的代码，这有助于让您确信您的应用程序将按预期工作。</p><p>不像<code>Vuex</code>，<code>Redux</code>是一个独立的工具库，不仅可以在<code>React</code>中使用，还可以在其他框架中使用，甚至可以直接用<code>script</code>标签的形式在页面中直接使用</p><span id="more"></span><h1 id="Redux使用"><a href="#Redux使用" class="headerlink" title="Redux使用"></a>Redux使用</h1><p>我们就通过一个简单的计数器页面来了解<code>Redux</code>该怎么使用，我们先不在<code>react</code>项目中使用，先看看最原始的<code>redux</code>要怎么用。后面再看看怎么在<code>react</code>中使用。</p><p>基础的<code>html</code>页面如下，需要引用<code>redux</code>的<code>umd</code>包（使用<code>jquery</code>来方便我们操作<code>dom</code>）</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;https://cdn.bootcss.com/redux/4.0.0/redux.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;p&gt;&lt;span id=&quot;count&quot;&gt;&lt;/span&gt;&lt;/p&gt;    &lt;button&gt;+&lt;/button&gt;    &lt;button&gt;-&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>引用了<code>redux</code>，会在<code>Window</code>上挂载一个<code>Redux</code>全局对象，我们首先需要定义一个<code>reducer</code>，<code>reducer</code> 是一个函数，接收当前的 <code>state</code> 和一个 <code>action</code> 对象，必要时决定如何更新状态，并返回新状态。函数签名是：<code>(state, action) =&gt; newState</code>。 你可以将 <code>reducer</code> 视为一个事件监听器，它根据接收到的 <code>action</code>（事件）类型处理事件。</p><pre><code class="javascript">$(document).ready(function() &#123;  const reducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;    switch (action.type) &#123;      case &#39;INCREMENT&#39;:        return &#123;...state, count: state.count + 1&#125;      case &#39;DECREMENT&#39;:        return &#123;...state, count: state.count - 1&#125;        default:        return state     &#125;  &#125;&#125;)</code></pre><p><code>action</code> 是一个具有 <code>type</code> 字段的普通 <code>JavaScript</code> 对象。你可以将 <code>action</code> 视为描述应用程序中发生了什么的事件。<code>type</code> 字段是一个字符串，给这个 <code>action</code> 一个描述性的名字，比如<code>&quot;todos/todoAdded&quot;</code>。我们通常把那个类型的字符串写成“域&#x2F;事件名称”，其中第一部分是这个 <code>action</code> 所属的特征或类别，第二部分是发生的具体事情。</p><p><code>action</code> 对象可以有其他字段，其中包含有关发生的事情的附加信息。按照惯例，我们将该信息放在名为 <code>payload</code> 的字段中。</p><p>在定义<code>reducer</code>的时候，注意返回的状态必须是一个全新的状态，不能直接使用和之前相同的引用，例如使用<code>obj.a</code>直接修改<code>a</code>的值，或者<code>array.push</code>一个新的值</p><p>此时有了<code>reducer</code>，我们就可以使用全局的<code>Redux</code>创建一个<code>store</code>，</p><pre><code class="javascript">$(document).ready(function() &#123;  const reducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;    switch (action.type) &#123;      case &#39;INCREMENT&#39;:        return &#123;...state, count: state.count + 1&#125;      case &#39;DECREMENT&#39;:        return &#123;...state, count: state.count - 1&#125;        default:        return state     &#125;  &#125;  const store = Redux.createStore(reducer)  console.log(store)&#125;)</code></pre><p>我们可以看看store上有哪些API<br><img src="/images/redux1.png"></p><p>发现上面有<code>dispatch</code>、<code>getState</code>、<code>replaceReducer</code>、<code>subscribe</code>这四个<code>API</code>，下面我们都会用到。</p><h1 id="store-getState"><a href="#store-getState" class="headerlink" title="store.getState()"></a>store.getState()</h1><p>通过上图可以发现，我们的页面<code>count</code>字段是没值的，那我们要怎么获取到<code>store</code>中的<code>state</code>呢？此时就可以使用<code>store.getState()</code>来获取<code>store</code>中的状态了，我们获取到<code>state</code>然后渲染到页面中</p><pre><code class="javascript">$(document).ready(function() &#123;  const reducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;    switch (action.type) &#123;      case &#39;INCREMENT&#39;:        return &#123;...state, count: state.count + 1&#125;      case &#39;DECREMENT&#39;:        return &#123;...state, count: state.count - 1&#125;        default:        return state     &#125;  &#125;  const store = Redux.createStore(reducer)  console.log(store.getState()) // &#123;count: 0&#125;  $(&#39;#count&#39;).text(store.getState().count)&#125;)</code></pre><h1 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch"></a>store.dispatch</h1><p>此时页面就已经有了<code>count</code>的值了，那怎么修改<code>state</code>呢？此时我们就可以使用<code>dispatch</code>来派发一个<code>action</code>，然后在<code>reducer</code>中根据<code>action</code>的<code>type</code>值，来判断需要怎么处理<code>state</code></p><pre><code class="javascript">$(document).ready(function() &#123;  // ...  $(&#39;button&#39;).eq(0).click(function() &#123;    store.dispatch(&#123;type: &#39;INCREMENT&#39;&#125;)    console.log(store.getState())  &#125;)  $(&#39;button&#39;).eq(1).click(function() &#123;    store.dispatch(&#123;type: &#39;DECREMENT&#39;&#125;)    console.log(store.getState())  &#125;)&#125;)</code></pre><p>我们点击按钮<code>+</code>，通过<code>store</code> <code>dispatch</code> 一个<code>action</code> <code>&#123;type: &#39;INCREMENT&#39;&#125;</code>，然后<code>reducer</code>中就会按照<code>action</code>的<code>type</code>类型，去更新<code>state</code>，点击按钮<code>-</code>也是一样</p><p>我们看看效果<br><img src="/images/redux3.gif"></p><h1 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe"></a>store.subscribe</h1><p>此时<code>state</code>是确实被更新了，但是页面为什么没有改变呢？这是因为<code>state</code>确实是改变了，但是<code>redux</code>并没有告诉我<code>state</code>改变了啊，所以我们需要知道<code>state</code>变化了，再执行一些动作。此时就可以使用<code>store</code>的<code>subscribe</code>来订阅一个监听器，一旦<code>state</code>改变了，<code>redux</code>就去执行那个监听器，做相应的更改。</p><p><code>subscribe</code>接收一个函数作为参数，我们将我们需要做的操作传进去，一旦<code>redux</code>检测到<code>state</code>发生了变化，就会去调用这个函数</p><pre><code class="javascript">$(document).ready(function() &#123;  // ...  store.subscribe(function() &#123;    $(&#39;#count&#39;).text(store.getState().count)  &#125;)&#125;)</code></pre><p><img src="/images/redux4.gif"></p><p><code>subscribe</code>还接收一个返回值，用来取消订阅，这个返回值是一个方法，我们直接调用这个方法就可以取消订阅了，后续<code>state</code>的修改不会去触发监听器函数，但是<code>redux</code>内部<code>state</code>的状态还是会持续更新</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;!-- ... --&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;p&gt;&lt;span id=&quot;count&quot;&gt;&lt;/span&gt;&lt;/p&gt;    &lt;button&gt;+&lt;/button&gt;    &lt;button&gt;-&lt;/button&gt;    &lt;button&gt;取消订阅&lt;/button&gt;  &lt;/div&gt;  &lt;script&gt;        $(document).ready(function() &#123;      // ...      const cancelSub = store.subscribe(function() &#123;        $(&#39;#count&#39;).text(store.getState().count)      &#125;)      $(&#39;button&#39;).eq(2).click(function() &#123;        cancelSub()      &#125;)    &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/redux5.gif"></p><p>最主要的几个<code>API</code>我们已经用到了，剩下的几个<code>api</code>我们分别来说说</p><h1 id="Redux-combineReducers"><a href="#Redux-combineReducers" class="headerlink" title="Redux.combineReducers"></a>Redux.combineReducers</h1><p>由于不建议创建多个<code>store</code>，因此如果有多个<code>reducer</code>，需要利用这个<code>API</code>来组合<code>reducer</code>，</p><p><code>combineReducers</code> 辅助函数的作用是，把一个由多个不同 <code>reducer</code> 函数作为 <code>value</code> 的 <code>object</code>，合并成一个最终的 <code>reducer</code> 函数，然后就可以对这个 <code>reducer</code> 调用 <code>createStore</code> 方法。</p><p>合并后的 <code>reducer</code> 可以调用各个子 <code>reducer</code>，并把它们返回的结果合并成一个 <code>state</code> 对象。 由 <code>combineReducers()</code> 返回的 <code>state</code> 对象，会将传入的每个 <code>reducer</code> 返回的 <code>state</code> 按其传递给 <code>combineReducers()</code> 时对应的 <code>key</code> 进行命名。</p><pre><code class="javascript">const countReducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;INCREMENT&#39;:      return &#123;...state, count: state.count + 1&#125;    case &#39;DECREMENT&#39;:      return &#123;...state, count: state.count - 1&#125;      default:      return state   &#125;&#125;const priceReducer = (state = &#123;price : 10&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;INCREMENT&#39;:      return &#123;...state, price: state.price + 1&#125;    case &#39;DECREMENT&#39;:      return &#123;...state, price: state.price - 1&#125;      default:      return state   &#125;&#125;const combinedReducers = Redux.combineReducers(&#123;countReducer: countReducer, priceReducer: priceReducer&#125;)const store = Redux.createStore(combinedReducers)console.log(store.getState())</code></pre><p><img src="/images/redux6.png"><br>可以看到我们组合了<code>countReducer</code>和<code>priceReducer</code>，最终会按照传入<code>combineReducers</code>对象的<code>key</code>进行命名区分，因此我们之前的代码需要改为</p><pre><code class="javascript">$(&#39;#count&#39;).text(store.getState().countReducer.count)const cancelSub = store.subscribe(function() &#123;  $(&#39;#count&#39;).text(store.getState().countReducer.count)&#125;)</code></pre><p><img src="/images/redux7.png"></p><p>我们发现一个问题，为什么我派发了一个<code>action</code>，两个<code>state</code>都会发生变化？其实是因为我们的<code>action</code>都是<code>INCREMENT</code>，由于两个<code>reducer</code>中的<code>type</code>设置的是一样的，这样的话就会导致这个问题，一般为了解决这个问题，我们都是把那个类型的字符串写成“域&#x2F;事件名称”，例如<code>COUNT/INCREMENT</code>，用于区分不同的<code>reducer</code>。</p><p>再修改一下代码</p><pre><code class="javascript">// ...const countReducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;COUNT/INCREMENT&#39;:      return &#123;...state, count: state.count + 1&#125;    case &#39;COUNT/DECREMENT&#39;:      return &#123;...state, count: state.count - 1&#125;      default:      return state   &#125;&#125;const priceReducer = (state = &#123;price : 10&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;PRICE/INCREMENT&#39;:      return &#123;...state, price: state.price + 1&#125;    case &#39;PRICE/DECREMENT&#39;:      return &#123;...state, price: state.price - 1&#125;      default:      return state   &#125;&#125;// ...$(&#39;button&#39;).eq(0).click(function() &#123;  store.dispatch(&#123;type: &#39;COUNT/INCREMENT&#39;&#125;)  console.log(store.getState())&#125;)$(&#39;button&#39;).eq(1).click(function() &#123;  store.dispatch(&#123;type: &#39;COUNT/INCREMENT&#39;&#125;)  console.log(store.getState())&#125;)</code></pre><p>现在就正常了<br><img src="/images/redux8.png"></p><h1 id="Redux-applyMiddleware"><a href="#Redux-applyMiddleware" class="headerlink" title="Redux.applyMiddleware"></a>Redux.applyMiddleware</h1><p>我们可以在<code>Redux</code>中使用各种插件，以增强我们的功能，比如我在每次修改<code>state</code>的时候，不用自己手动打印，而是自动打印，此时我们可以使用<code>redux-logger</code>插件</p><pre><code class="html">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/redux-logger/4.0.0/redux-logger.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // ...  const logger = reduxLogger.createLogger()  const store = Redux.createStore(combinedReducers, Redux.applyMiddleware(logger))&lt;/script&gt;</code></pre><p><img src="/images/redux9.png"></p><h1 id="Redux-bindActionCreators"><a href="#Redux-bindActionCreators" class="headerlink" title="Redux.bindActionCreators"></a>Redux.bindActionCreators</h1><p>一般情况下你可以直接在 <code>Store</code> 实例上调用 <code>dispatch</code>。如果你在 <code>React</code> 中使用 <code>Redux</code>，<code>react-redux</code> 会提供 <code>dispatch</code> 函数让你直接调用它 。</p><p>把一个 <code>value</code> 为不同 <code>action creator</code> 的对象，转成拥有同名 <code>key</code> 的对象。同时使用 <code>dispatch</code> 对每个 <code>action creator</code> 进行包装，以便可以直接调用它们。</p><p>惟一会使用到 <code>bindActionCreators</code> 的场景是当你需要把 <code>action creator</code> 往下传到一个组件上，却不想让这个组件觉察到 <code>Redux</code> 的存在，而且不希望把 <code>dispatch</code> 或 <code>Redux store</code> 传给它。</p><p>为方便起见，你也可以传入一个函数作为第一个参数，它会返回一个函数。</p><p>上面的解释理解起来可能有些难以理解，下面我们用例子说明：</p><p>什么是<code>action creator</code>，就是返回<code>action</code>的函数，例如：</p><pre><code class="javascript">const incrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/INCREMENT&#39; &#125;&#125;</code></pre><p>定义了如上<code>action creator</code>，然而我们派发<code>action</code>的时候仍然需要使用<code>store.dispatch</code>进行派发，例如<code>store.dispatch(incrementActionCreator())</code>，这样写未免有些累赘了，此时我们就可以使用<code>bindActionCreators</code>方法，将<code>action creator</code>和<code>store.diapatch</code>传进去，返回一个函数，可以直接派发 <code>action</code>，例如:</p><pre><code class="javascript">const incrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/INCREMENT&#39; &#125;&#125;const increment = Redux.bindActionCreators(incrementActionCreator, store.diapatch)increment() // 这里直接会派发action</code></pre><p>同时，<code>Redux.bindActionCreators</code>的第一个参数还可以接受一个由<code>action creator</code>组成的对象，对象的<code>key</code>随便指定，此时会返回和<code>key</code>相同的一组对象，对象的值就是可以直接派发<code>action</code>的函数，例如:</p><pre><code class="javascript">const incrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/INCREMENT&#39; &#125;&#125;const decrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/DECREMENT&#39; &#125;&#125;let actions = Redux.bindActionCreators(&#123; increment: incrementActionCreator, decrement: decrementActionCreator &#125;, store.dispatch)// 此时使用这种方式直接派发actions.increment()actions.decrement()</code></pre><p>我们将之前的例子改写成这种形式，注意下面使用了两种形式，可以更好地看出区别</p><pre><code class="javascript">// ...const incrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/INCREMENT&#39; &#125;&#125;const decrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/DECREMENT&#39; &#125;&#125;let increment = Redux.bindActionCreators(incrementActionCreator, store.dispatch)let actions = Redux.bindActionCreators(&#123; increment: incrementActionCreator, decrement: decrementActionCreator &#125;, store.dispatch)$(&#39;button&#39;).eq(0).click(function() &#123;  increment()&#125;)$(&#39;button&#39;).eq(1).click(function() &#123;  actions.decrement()&#125;)</code></pre><p><img src="/images/redux10.png"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL备份-LOAD DATA</title>
      <link href="/2023/04/06/Mysql/MySQL%E5%A4%87%E4%BB%BD-LOAD%20DATA/"/>
      <url>/2023/04/06/Mysql/MySQL%E5%A4%87%E4%BB%BD-LOAD%20DATA/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL备份-LOAD-DATA"><a href="#MySQL备份-LOAD-DATA" class="headerlink" title="MySQL备份-LOAD DATA"></a>MySQL备份-LOAD DATA</h1><p>注意，使用load data备份恢复方式，表结构必须存在；</p><p>使用<code>select ...into outfile</code>备份数据</p><p>语法格式如下：</p><pre><code>select 语句 into outfile BACKFILE  [OPTIONS]</code></pre><span id="more"></span><p>[OPTIONS]</p><ul><li>fields terminated by ‘字符串’ ： 字符串分割符，默认是制表符’\t’</li><li>fileds escaped by ’字符‘ ： 转义字符，默认是’\‘</li><li>fileds [optionally] enclose by 字符’‘： 字段引用符，负责向字段值两端加上字段引用符。如果使用optionally 选项，则表示字符串类型上添加字段分隔符。</li><li>lines starting by ‘字符串’，每条记录前添加该字段。</li><li>lines terminated by ’字符串‘，每条记录后添加该字符串，默认是换行符 ‘\n’</li></ul><p>例如：</p><pre><code class="sql">mysql&gt; select * from test.t1 into outfile &#39;/data/mysql/t1_bak&#39;;Query OK, 3 rows affected (0.01 sec)</code></pre><p>结果会生成在<code>/data/mysql/</code>目录下，对应的数据库目录下面。可以直接使用cat命令查看。</p><pre><code>[root@lyucan ~]# cat /data/mysql/t1_bak1      张三   12     南京2      李四   21     北京3      王五   23     上海</code></pre><p>恢复表数据：</p><p>使用<code>load data infile...</code>快速地从一个指定格式的文本文件中读取数据到一个数据库表中。</p><p>语法：</p><pre><code>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE db2.my_table;</code></pre><p>例如：</p><pre><code class="sql">mysql&gt; delete from test.t1;Query OK, 3 rows affected (0.00 sec)mysql&gt; LOAD DATA INFILE &#39;/data/mysql/t1_bak&#39; INTO TABLE test.t1;Query OK, 3 rows affected (0.00 sec)Records: 3  Deleted: 0  Skipped: 0  Warnings: 0mysql&gt; select * from test.t1;+----+--------+-----+--------+| id | name   | age | addr   |+----+--------+-----+--------+|  1 | 张三   |  12 | 南京   ||  2 | 李四   |  21 | 北京   ||  3 | 王五   |  23 | 上海   |+----+--------+-----+--------+3 rows in set (0.00 sec)</code></pre><blockquote><p>注意：如果导出数据的时候后面使用了分隔符，导入的时候不需要加，还是按照上面的方式导；</p></blockquote><p>更复杂的配置就不写了，没什么必要，还增加大脑的负担。等用到的时候，去网上查找具体的参数即可，我们并不擅长记忆这些并不常用的选项。 一句话概括这种逻辑备份的精要：怎么吃我的，怎么给我吐出来。怎么吐出来来，怎么给我装进去。选用了什么样的分割选项，导入数据的时候就需要使用对应的分割选项去导入数据。 结合我自己平时的工作内容与实践，基本上不使用这种方式导出。反而使用mysqldump 更多一点。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browserslist的作用</title>
      <link href="/2023/04/06/JavaScript/browserslist%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/04/06/JavaScript/browserslist%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="browserslist的作用"><a href="#browserslist的作用" class="headerlink" title="browserslist的作用"></a>browserslist的作用</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>browserslist</code> 实际上就是声明了⼀段浏览器的集合，我们的⼯具可以根据这段集合描述，针对性的输出兼容性代码。</p><p><code>browserslist</code>就是帮助我们来设置⽬标浏览器的⼯具。<code>browserslist</code> 被⼴泛的应⽤到 <code>Babel</code>、<code>postcsspreset-env``、autoprefixer</code> 等开发⼯具上。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>browserslist</code> 的配置可以放在<code> package.json</code> 中，也可以单独放在配置⽂件 <code>.browserslistrc</code> 中。所有的⼯具都会主动查找 <code>browserslist</code> 的配置⽂件，根据 <code>browserslist</code> 配置找出对应的⽬标浏览器集合。</p><p><code>browserslist</code> 的数据都是来⾃<a href="https://browserl.ist/">Can I Use</a>，可惜⽹站关闭了，现在需要⼿动检测：</p><pre><code>npx browserslist &quot;last 1 version, &gt;1%&quot;</code></pre><p>在 <code>package.json</code> 中的配置是增加⼀个 <code>browserslist</code> 数组属性：</p><pre><code class="json">&#123; &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;maintained node versions&quot;, &quot;notie &lt; 11&quot;]&#125;</code></pre><p>或者在项⽬的根⽬录下创建⼀个 <code>.browserslistrc</code> ⽂件：</p><pre><code># 注释是这样写的，以#号开头# 每⾏⼀个浏览器集合描述last 2 version&gt; 1%maintained node versionsnot ie &lt; 11</code></pre><span id="more"></span><h1 id="常⻅集合范围说明"><a href="#常⻅集合范围说明" class="headerlink" title="常⻅集合范围说明"></a>常⻅集合范围说明</h1><table><thead><tr><th>范围</th><th>说明</th></tr></thead><tbody><tr><td><code>last 2 versions</code></td><td><a href="https://caniuse.com/">caniuse.com</a>⽹站跟踪的最新两个版本，假如 iOS 12 是最新版本，那么向后兼容两个版本就是 iOS 11 和 iOS 12</td></tr><tr><td><code>&gt; 1%</code></td><td>全球超过 1%⼈使⽤的浏览器，类似 <code>&gt; 5% in US</code> 则指代美国 5%以上⽤户</td></tr><tr><td><code>cover 99.5%</code></td><td>覆盖 99.5%主流浏览器</td></tr><tr><td><code>chrome &gt; 50</code> 或 <code>ie 6-8</code></td><td>指定某个浏览器版本范围</td></tr><tr><td><code>unreleased versions</code></td><td>所有浏览器的 beta 版本</td></tr><tr><td><code>not ie &lt; 11</code></td><td>排除 ie11 以下版本不兼容</td></tr><tr><td><code>since 2013</code> 或 <code>last 2 years</code></td><td>某时间范围发布的所有浏览器版本</td></tr><tr><td><code>maintained node versions</code></td><td>所有被 node 基⾦会维护的 node 版本</td></tr><tr><td><code>current node</code></td><td>当前环境的 node 版本</td></tr><tr><td><code>dead</code></td><td>通过 last 2 versions 筛选的浏览器中，全球使⽤率低于 0.5% 且官⽅声明不在维护或者事实上已经两年没有再更新的版本</td></tr><tr><td><code>defaults</code></td><td>默认配置， <code>&gt; 0.5%</code> <code>last 2 versions</code> <code>Firefox ESR</code> <code>not dead</code></td></tr></tbody></table><h1 id="浏览器名称列表（⼤⼩写不敏感）"><a href="#浏览器名称列表（⼤⼩写不敏感）" class="headerlink" title="浏览器名称列表（⼤⼩写不敏感）"></a>浏览器名称列表（⼤⼩写不敏感）</h1><ul><li>Android ：安卓 webview 浏览器；</li><li>Baidu ： 百度浏览器；</li><li>BlackBerry &#x2F; bb ：⿊莓浏览器；</li><li>Chrome ：chrome 浏览器；</li><li>ChromeAndroid &#x2F; and_chr ：chrome 安卓移动浏览器；</li><li>Edge ：微软 Edge 浏览器；</li><li>Electron ：Electron；</li><li>Explorer &#x2F; ie ：ie 浏览器；</li><li>ExplorerMobile &#x2F; ie_mob ：ie 移动浏览器；</li><li>Firefox &#x2F; ff ：⽕狐浏览器； * FirefoxAndroid &#x2F; and_ff ：⽕狐安卓浏览器；</li><li>iOS &#x2F; ios_saf ：iOS Safari 浏览器；</li><li>Node ：nodejs；</li><li>Opera ：opera 浏览器；</li><li>OperaMini &#x2F; op_mini ：operaMini 浏览器；</li><li>OperaMobile &#x2F; op_mob ：opera 移动浏览器；</li><li>QQAndroid &#x2F; and_qq ：QQ 安卓浏览器；</li><li>Samsung ：三星浏览器；</li><li>Safari ：桌⾯版本 Safari；</li><li>UCAndroid &#x2F; and_uc ：UC 安卓浏览器</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie session token详解</title>
      <link href="/2023/04/06/JavaScript/cookie%20session%20token%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/04/06/JavaScript/cookie%20session%20token%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="cookie-session-token详解"><a href="#cookie-session-token详解" class="headerlink" title="cookie session token详解"></a>cookie session token详解</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>cookie</code>、<code>session</code> 和 <code>token</code>是前端开发中很重要的概念，很多朋友并不真正了解这三者有什么区别，或者这三者到底是个什么的东西，面试的时候也只能模模糊糊的说一点，不能很清晰的讲明白，这里我们就这三个东西讨论下，彻底搞懂。</p><h1 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h1><p>众所周知，<code>http</code>协议本身是一个无连接的协议，<code>web</code>早期只是用来浏览文档，不需要交互，每次<code>http</code>请求都是一个全新的请求，服务端并不关心到底是谁在访问，但是随着交互式<code>web</code>应用的发展，我们必须要识别客户端到底是谁，否则根本无法进行交互，比如商城应用，后端服务必须要知道是谁在买东西，每个客户端要区分开，这时候就需要客户端要和服务端能够进行数据的相互传递，有时还需要在不同的域名下实现数据共享，<code>cookie</code>就是用来解决这一问题的。</p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p><code>cookie</code>是一个真实存在的东西，保存在客户端浏览器中，当一个请求发起后，后端如果想要设置<code>cookie</code>，则在响应头中添加一个<code>Set-Cookie</code>字段，浏览器识别到此响应头，就把里面的数据存放到浏览器本地，当下次再次请求的时候，将该<code>cookie</code>放到请求头中，发送给后端，实现前后端的交互。<br><img src="/images/cookie.png"></p><p>cookie是有大小和数量限制的，根据浏览器的不同这个有所差异；</p><p>Set-Cookie响应头类似于<code>Set-Cookie: username=daryl; path=/; expires=Thu, 26 Aug 2021 16:37:43 GMT; domain=localhost; samesite=none; secure; httponly</code></p><p>这个值是后端设置的，可选的属性有以下几种</p><ul><li><p>maxAge</p><p>用来告诉浏览器此<code>cookie</code>多久过期（单位是毫秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。</p></li><li><p>expires</p><p>失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。</p></li><li><p>path</p><p>表示这个cookie影响到的路径，浏览器跟会根据这项配置，向指定域中匹配的路径发送cookie。</p></li><li><p>domain</p><p>cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：<code>yq.aliyun.com</code>)，也可以不包含它(如：<code>.aliyun.com</code>，则对于<code>aliyun.com</code>的所有子域都有效).</p></li><li><p>secure</p><p>安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置</p></li><li><p>secureProxy?: boolean | undefined;</p><p>“secureProxy” option is deprecated; use “secure” option, provide “secure” to constructor if needed</p></li><li><p>httpOnly?: boolean | undefined;</p><p>a boolean indicating whether the cookie is only to be sent over HTTP(S),<br>and not made available to client JavaScript (true by default).</p></li><li><p>sameSite?: ‘strict’ | ‘lax’ | ‘none’ | boolean | undefined;</p><p>a boolean or string indicating whether the cookie is a “same site” cookie (false by default).<br>This can be set to ‘strict’, ‘lax’, or true (which maps to ‘strict’).</p></li><li><p>signed</p><p>是否对cookie进行签名（默认为false），如果设置为true，还将发送附加的另一个同名的后缀是.sig的cookie ，值类似于<code>Set-Cookie: username.sig=yuJIW4DxsPvY4BoKAP2YMpH5p5k; path=/; expires=Thu, 26 Aug 2021 16:37:43 GMT; domain=localhost; samesite=none; secure; httponly</code>，此签名密钥用于在下次收到cookie时检测篡改。</p></li><li><p>overwrite</p><p>是否覆盖以前的设置同名cookies（默认为false）</p></li></ul><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p><code>session</code>实际上是一个概念，即会话；<code>session</code>的实现有很多方式，最常见的是基于<code>cookie</code>的方式，后端生成一个<code>session</code>，有一个唯一的<code>session id</code>，标识唯一性，然后把这个<code>session id</code>通过<code>cookie</code>发送给客户端，客户端保存起来，下次请求的时候再携带包含<code>session id</code>值的<code>cookie</code>发送给后端，后端拿到后再去通过<code>session id</code>值查找对应的<code>session</code>；所以<code>session</code>实际上是保存在后端的，而发送给客户端的只是一个<code>session id</code>。</p><p><code>session</code>这种方式的弊端在于服务器必须要保存<code>session</code>，无论是保存在文件里还是数据库里，都是一个很大的开销，并且一旦用户量过于庞大，<code>session</code>也会非常庞大，做负载均衡的话如果请求负载到了不同的机器，会造成<code>session</code>失效。</p><h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p><code>token</code>这种方案现在已经被广泛应用了，相比于<code>cookie + session</code>的实现方式，<code>token</code>不需要保存在服务器上，而是将数据签名，然后发送给客户端（可以通过<code>cookie</code>也可以通过其他方式），下次请求的时候再校验<code>token</code>的合法性，如果合法，则响应成功，如果不合法，则响应失败，这种方式就是用计算资源来节省空间资源，好处是我们不需要关心<code>token</code>的存储，而只需要扩展机器增加算力即可。</p><p>详细的token解决方案，可以阅读<a href="https://www.baihuzi.com/2021/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/">深入理解token</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js ES6新增数据类型Set、Map、Symbol</title>
      <link href="/2023/04/06/JavaScript/js%20ES6%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSet%E3%80%81Map%E3%80%81Symbol/"/>
      <url>/2023/04/06/JavaScript/js%20ES6%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSet%E3%80%81Map%E3%80%81Symbol/</url>
      
        <content type="html"><![CDATA[<h1 id="js-ES6新增数据类型Set-Map-Symbol"><a href="#js-ES6新增数据类型Set-Map-Symbol" class="headerlink" title="js ES6新增数据类型Set&#x2F;Map&#x2F;Symbol"></a>js ES6新增数据类型Set&#x2F;Map&#x2F;Symbol</h1><p><a href="https://es6.ruanyifeng.com/#docs/set-map">本文参考阮一峰ES6基础教程</a></p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p><code>ES6</code> 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p><code>Set</code>本身是一个构造函数，用来生成 <code>Set</code> 数据结构。</p><p><code>Set</code>函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化</p><pre><code class="javascript">// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll(&#39;div&#39;));set.size // 56// 类似于const set = new Set();document .querySelectorAll(&#39;div&#39;) .forEach(div =&gt; set.add(div));set.size // 56</code></pre><span id="more"></span><p><code>Set</code>中没有重复的值，里面包含了各个item和一个size属性</p><pre><code class="javascript">let set = new Set([1, 1, 2, 2, 3, 3])console.log(set);</code></pre><p><img src="/images/set.gif"></p><p>基于这一特性，我们可以进行去重处理</p><pre><code class="javascript">// 去除数组的重复成员[...new Set([1, 2, 3, 3, 3])]// [1, 2, 3][...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)// &quot;abc&quot;vxcx</code></pre><p><strong>注意</strong>，两个对象是不相等的，而<code>NaN</code>，<code>null</code>，<code>undefined</code>都视为相等的，<code>Set</code>内部判断两个值是否不同，使用的算法叫做<code>Same-value-zero equality</code>，它类似于精确相等运算符（<code>===</code>）</p><pre><code class="javascript">let set1 = new Set();set1.add(NaN).add(NaN);console.log(set1);  // Set结构 &#123;NaN&#125;let set2 = new Set();set2.add(null).add(null);console.log(set2);  // Set结构 &#123;null&#125;let set3 = new Set();set3.add(undefined).add(undefined);console.log(set3);  // Set结构 &#123;undefined&#125;let set4 = new Set();set4.add(&#123;&#125;).add(&#123;&#125;);console.log(set4);  // Set结构 &#123;&#123;&#125;, &#123;&#125;&#125;</code></pre><p><code>Set</code>数据结构的<code>key</code>和<code>value</code>是相同的；</p><pre><code class="javascript">for (let item of colorSet.keys()) &#123;    console.log(item);&#125;// red// green// bluefor (let item of colorSet.values()) &#123;    console.log(item);&#125;// red// green// bluefor (let item of colorSet.entries()) &#123;    console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;]</code></pre><h2 id="Set结构的实例属性和方法"><a href="#Set结构的实例属性和方法" class="headerlink" title="Set结构的实例属性和方法"></a><code>Set</code>结构的实例属性和方法</h2><p><code>Set</code>结构的实例有以下属性</p><ul><li><code>Set.prototype.constructor</code>   构造函数，默认就是Set函数。</li><li><code>Set.prototype.size</code>          返回Set实例的成员总数。</li></ul><p><code>Set</code>实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p><ul><li><code>Set.prototype.add(value)</code>        添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>     删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>        返回一个布尔值，表示该值是否为Set的成员。</li><li><code>Set.prototype.clear()</code>           清除所有成员，没有返回值。</li></ul><h2 id="Set的遍历"><a href="#Set的遍历" class="headerlink" title="Set的遍历"></a><code>Set</code>的遍历</h2><ol><li><code>keys()</code>，<code>values()</code>，<code>entries()</code></li></ol><pre><code class="javascript">for (let item of colorSet.keys()) &#123;    console.log(item);&#125;// red// green// bluefor (let item of colorSet.values()) &#123;    console.log(item);&#125;// red// green// bluefor (let item of colorSet.entries()) &#123;    console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;]</code></pre><ol start="2"><li><code>forEach()</code><br><code>Set</code>结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</li></ol><pre><code class="javascript">let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))// 1 : 1// 4 : 4// 9 : 9</code></pre><ol start="3"><li><code>Set</code>结合遍历的应用<br>数组的<code>map</code>和<code>filter</code>方法也可以间接用于<code>Set</code>。</li></ol><pre><code class="javascript">let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125;</code></pre><p>使用 <code>Set</code> 可以很容易地实现并集（<code>Union</code>）、交集（<code>Intersect</code>）和差集（<code>Difference</code>）。</p><pre><code class="javascript">let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// （a 相对于 b 的）差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125;</code></pre><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>ES6</code>提供了<code>Map</code>数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，<code>Object</code>结构提供了“字符串—值”的对应，<code>Map</code> 结构提供了“值—值”的对应，是一种更完善的<code>Hash</code>结构实现。如果你需要“键值对”的数据结构，<code>Map</code>比 <code>Object</code>更合适。</p><p><code>Map</code>构造函数传入的参数一定要是一个可迭代对象;</p><pre><code class="javascript">let map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2]])let map1 = new Map(new Set([[&#39;c&#39;, 3], [&#39;d&#39;, 4]]))console.log(map, map1);</code></pre><p><img src="/images/map.png"></p><p>也可以对一个<code>map</code>实例动态添加，任何数据类型都可以作为<code>Map</code>的<code>key</code></p><pre><code class="javascript">let map = new Map();map.set(1, &#39;1&#39;)map.set(Symbol(), &#39;hello&#39;)map.set(&#123; key: true &#125;, &#39;value&#39;)map.set(false, &#39;false&#39;)console.log(map);console.log(map.has(false));        // trueconsole.log(map.has(Symbol()));     // false，注意这里是false，因为symbol很特殊，其值是唯一的，即使两个symbol声明方式一样，他们也是两个不同的数据console.log(map.get(1));            // 1console.log(map.get(Symbol()));     // undefined 原因和上面相同</code></pre><p><img src="/images/map2.png"></p><h2 id="Map实例的属性和操作方法"><a href="#Map实例的属性和操作方法" class="headerlink" title="Map实例的属性和操作方法"></a><code>Map</code>实例的属性和操作方法</h2><ul><li><code>size</code>                                <code>size</code>属性返回 <code>Map</code> 结构的成员总数。</li><li><code>Map.prototype.set(key, value)</code>       <code>set</code>方法设置键名key对应的键值为<code>value</code>，然后返回整个 <code>Map</code> 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li><li><code>Map.prototype.get(key)</code>              <code>get</code>方法读取key对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li><li><code>Map.prototype.has(key)</code>              <code>has</code>方法返回一个布尔值，表示某个键是否在当前 <code>Map</code> 对象之中。</li><li><code>Map.prototype.delete(key)</code>           <code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li><li><code>Map.prototype.clear()</code>               <code>clear</code>方法清除所有成员，没有返回值。</li></ul><h1 id="WeakSet-WeakMap"><a href="#WeakSet-WeakMap" class="headerlink" title="WeakSet &amp; WeakMap"></a>WeakSet &amp; WeakMap</h1><p><a href="https://es6.ruanyifeng.com/#docs/set-map#WeakSet">WeakSet</a></p><p><a href="https://es6.ruanyifeng.com/#docs/set-map#WeakMap">WeakMap</a></p><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p><code>ES6</code>引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 <code>JavaScript</code> 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）。</p><p><code>Symbol</code>值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的<code>Symbol</code>类型。凡是属性名属于 <code>Symbol</code> 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><p>新建一个<code>symbol</code>数据不能使用<code>new</code>的方式，因为<code>new</code>出来的是一个对象，而<code>symbol</code>并不是对象;</p><p><code>Symbol()</code>可以传一个字符串作为标识，这里的字符串仅作为标识，用于区分不同的<code>symbol</code>，因为默认<code>symbol</code>打印出来就是<code>Symbol()</code>，无法正常区分</p><pre><code class="javascript">let sym = Symbol(&#39;sym&#39;);let sym1 = Symbol(&#39;sym1&#39;);</code></pre><p>当<code>symbol</code>作为属性名是，需要使用<code>[]</code>包起来，否则会认为<code>sym</code>是字符串而不是<code>symbol</code>数据</p><pre><code class="javascript">let sym = Symbol(&#39;sym&#39;);let sym1 = Symbol(&#39;sym1&#39;);let obj = &#123;    [sym]: sym1&#125;// 或者，注意下面的sym没有引号let obj1 = &#123;&#125;;obj1[sym] = sym1</code></pre><p>可以使用<code>description</code>属性打印出<code>symbol</code>的标识</p><pre><code class="javascript">console.log(sym.description);   // &#39;sym&#39;console.log(sym1.description);  // &#39;sym1&#39;</code></pre><p>即使标识符相同，也是两个不同的数据</p><pre><code class="javascript">let s1 = Symbol(&#39;aaa&#39;);let s2 = Symbol(&#39;aaa&#39;);console.log(s1 === s2);     // false</code></pre><p><code>symbol</code>还可以作为属性值，这能确保属性值都是唯一的，且不关心值到底是什么</p><pre><code class="javascript">let obj2 = &#123;    red: Symbol(&#39;red&#39;),    yellow: Symbol(&#39;yellow&#39;),    blue: Symbol(&#39;blue&#39;),&#125;;</code></pre><p>使用<code>Symbol</code>作为对象的属性名，可以隐藏某些属性</p><pre><code class="javascript">let jerry = &#123; name: &#39;jerry&#39;, age: 18, [Symbol(&#39;salary&#39;)]: 1000 &#125;let json = JSON.stringify(jerry)    // 这里不会转化Symbol的属性console.log(json);                  // &#123;&quot;name&quot;:&quot;jerry&quot;,&quot;age&quot;:18&#125;</code></pre><p>获取到的属性名也没有包含<code>Symbol</code>的</p><pre><code class="javascript">let props = Object.getOwnPropertyNames(jerry)console.log(props);                 // [&#39;name&#39;, &#39;age&#39;]</code></pre><p>要获取<code>Symbol</code>属性名，需要使用<code>Object.getOwnPropertySymbols</code>方法</p><pre><code class="javascript">let symbolProps = Object.getOwnPropertySymbols(jerry)console.log(symbolProps);           // [Symbol(salary)]console.log(jerry[symbolProps[0]]); // 1000</code></pre><p>使用<code>Reflect.ownKeys</code>可以获取到所有的属性名，包括<code>Symbol</code>的</p><pre><code class="javascript">let allProps = Reflect.ownKeys(jerry)console.log(allProps);              // [&quot;name&quot;, &quot;age&quot;, Symbol(salary)]</code></pre><p><code>Symbol</code>值不能与其他类型的值进行运算，会报错</p><pre><code class="javascript">let sym = Symbol(&#39;My symbol&#39;);&quot;your symbol is &quot; + sym// TypeError: can&#39;t convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can&#39;t convert symbol to string</code></pre><p>但是，<code>Symbol</code> 值可以显式转为字符串。</p><pre><code class="javascript">let sym = Symbol(&#39;My symbol&#39;);String(sym) // &#39;Symbol(My symbol)&#39;sym.toString() // &#39;Symbol(My symbol)&#39;</code></pre><p>另外，<code>Symbol</code> 值也可以转为布尔值，但是不能转为数值。</p><pre><code class="javascript">let sym = Symbol();conole.log(Boolean(sym)) // trueconole.log(!sym)  // falseif (sym) &#123;  // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js Promise</title>
      <link href="/2023/04/06/JavaScript/js%20Promise/"/>
      <url>/2023/04/06/JavaScript/js%20Promise/</url>
      
        <content type="html"><![CDATA[<h1 id="js-Promise"><a href="#js-Promise" class="headerlink" title="js Promise"></a>js Promise</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Promise</code>是<code>js</code>里一种异步编程解决方案，比较传统的是回调函数和事件，熟悉<code>nodejs</code>的都知道，在<code>Promise</code>还没出现之前，一切异步编程都是通过回调函数来实现的，包括文件读取，数据库操作等，很容易造成回调地狱，而<code>Promise</code>可以帮我们很好的解决这个问题。</p><p><code>Promise</code>可以看做是一个容器，里面存放着未来某个时间才会结束的异步操作，其内部有三种状态，分别是<code>pending</code>（进行中），<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有内部异步操作的结果，会影响这三种状态，其他任何操作都无法影响这三种状态。</p><p><code>Promise</code>对象的状态改变，只可能有两种可能：<code>pending -&gt; fulfilled</code>或者<code>pending -&gt; rejected</code>。只要状态改变了，就不会再改变了。</p><span id="more"></span><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><code>Promise</code>是一个构造函数，用来生成<code>Promise</code>实例，<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己指定。如果<code>Promise</code>内部的异步操作成功，则调用<code>resolve</code>函数，把<code>Promise</code>内部的状态由<code>pending</code>变为<code>fulfilled</code>，并把结果作为参数抛出去，否则调用<code>reject</code>函数把<code>Promise</code>内部的状态由<code>pending</code>变为<code>rejected</code>，把错误作为参数抛出去。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);// 1、创建promise对象，一经创建，立马执行new Promise((resolve, reject) =&gt; &#123;    fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        if (err) &#123;            reject(err);        &#125; else &#123;            // 请求成功时，调用.then()里面自己写的resolve函数            resolve(data);        &#125;    &#125;);&#125;)</code></pre><p>抛出去的结果我们可以使用<code>Promise</code>的<code>then</code>方法进行接收，<code>Promise</code>的<code>then</code>方法接收两个回调函数作为参数，第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);// 1、创建promise对象，一经创建，立马执行new Promise((resolve, reject) =&gt; &#123;    fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        if (err) &#123;            reject(err);        &#125; else &#123;            resolve(data);        &#125;    &#125;);&#125;).then(    // 下面这个函数式作为上面Promise的resolve使用    (data) =&gt; &#123; // 这里的参数就是上面Promise里resolve传出来的参数        console.log(data.toString());    &#125;,    // 这个作为reject使用    (err) =&gt; &#123;        console.log(err)    &#125;)</code></pre><p>使用Promise的注意点</p><ul><li>调用resolve或reject并不会终结 Promise 的参数函数的执行。</li></ul><pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;  resolve(1);  console.log(2);&#125;).then(r =&gt; &#123;  console.log(r);&#125;);// 2// 1</code></pre><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即<code>resolved</code>的<code>Promise</code>是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说一旦<code>Promise</code>内部调用r<code>esolve</code>或者<code>reject</code>之后，它的任务就完成了，不应该继续在后面执行其他任务，因此我们最好再<code>resolve</code>和<code>reject</code>前面加上return</p><pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;  return resolve(1);  // 后面的语句不会执行  console.log(2);&#125;)</code></pre><h1 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h1><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><p>第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);// then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。// 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。new Promise((resolve, reject) =&gt; &#123;    fs.readFile(&#39;./data/a.txt&#39;, (err, data) =&gt; &#123;        if (!err) &#123;            resolve(data)        &#125; else &#123;            reject(err)        &#125;    &#125;)&#125;)    .then((data) =&gt; &#123;        console.log(data.toString());        return &#39;在.then()中返回的结果，会传入下一个then的参数中&#39;    &#125;)    .then((data) =&gt; &#123;        console.log(data);        return 1    &#125;)    .then((data) =&gt; &#123;        console.log(data);    &#125;)    .catch((err) =&gt; &#123;        console.log(&#39;err&#39;, err);    &#125;)</code></pre><p>输出</p><pre><code class="javascript">aaaaaaaaaaaaaaaaaaaaaa // 文件a.txt的内容在.then()中返回的结果，会传入下一个then的参数中1</code></pre><h1 id="Promise封装"><a href="#Promise封装" class="headerlink" title="Promise封装"></a>Promise封装</h1><p>假如我们要依次地区文件的内容，我们可能会像下面这样编码</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);new Promise((resolve, reject) =&gt; &#123;    fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        if (err) &#123;            reject(err);        &#125; else &#123;            resolve(data);        &#125;    &#125;);&#125;).then((data) =&gt; &#123;    console.log(data.toString());    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(__dirname + &#39;/data/b.txt&#39;, (err, data) =&gt; &#123;            if (err) &#123;                reject(err);            &#125; else &#123;                resolve(data);            &#125;        &#125;);    &#125;)&#125;).then((data) =&gt; &#123;    console.log(data.toString());    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;            if (err) &#123;                reject(err);            &#125; else &#123;                resolve(data);            &#125;        &#125;);    &#125;)&#125;).then((data) =&gt; &#123;    console.log(data.toString());&#125;);</code></pre><p>这样写没问题，但是充斥了大量的重复代码，因此我们可以对读取文件的Promise进行一层封装，改造成以下代码</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);function readFiles(...args) &#123;    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(...args, (err, data) =&gt; &#123;            if (err) &#123;                reject(err);            &#125; else &#123;                resolve(data);            &#125;        &#125;)    &#125;)&#125;readFiles(__dirname + &#39;/data/a.txt&#39;, &#39;utf8&#39;)    .then((data) =&gt; &#123;        console.log(data);        return readFiles(__dirname + &#39;/data/b.txt&#39;, &#39;utf8&#39;);    &#125;)    .then((data) =&gt; &#123;        console.log(data);        return readFiles(__dirname + &#39;/data/c.txt&#39;, &#39;utf8&#39;);    &#125;)    .then((data) =&gt; &#123;        console.log(data);        return readFiles(__dirname + &#39;/data/a.txt&#39;, &#39;utf8&#39;);    &#125;)    .then((data)=&gt;&#123;        console.log(data);    &#125;);</code></pre><p>我们封装了一个<code>readFiles</code>函数，返回一个读取文件的<code>Promise</code>对象，在链式调用中，<code>then</code>函数返回的也是一个<code>Promise</code>对象，因此可以一层一层往下调用</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p><code>Promise</code>的错误处理有两种方式，一种是在<code>then</code>函数的第二个回调函数参数中进行处理，另一种是使用<code>Promise.catch</code>进行错误捕获。</p><p>例如：</p><pre><code class="javascript">let p = new Promise(...)p.then(null, reject =&gt; console.log(reject))</code></pre><p>或者</p><pre><code class="javascript">let p = new Promise(...)p.then(resolve =&gt; console.log(resolve)) .catch(err =&gt; console.log(err))</code></pre><p><code>Promise.catch</code>具有”冒泡”性质，意思是无论<code>then</code>链式调用了多少层，<code>Promise.catch</code>都能捕获到其中任意一层发生的错误</p><pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;  return getJSON(post.commentURL);&#125;).then(function(comments) &#123;  // some code&#125;).catch(function(error) &#123;  // 处理前面三个Promise产生的错误&#125;);</code></pre><p>因此我们推荐总是使用<code>Promise.catch</code>进行异常捕获</p><h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><p>不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的<code>Promise</code>状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于<code>Promise</code>的执行结果。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;读取文件b.txt出错了&#39;)&#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.all([P1, P2, P3])    .then(res =&gt; &#123;        console.log(res);        res.map(file =&gt; console.log(file.toString()))    &#125;)    .catch(err =&gt; console.log(err))    .finally(() =&gt; console.log(&#39;文件读取完毕&#39;))</code></pre><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p><code>Promise.all</code>可以把多个<code>Promise</code>实例，组装成一个<code>Promise</code>实例，此时只有当所有的<code>Promise</code>的状态都变为<code>fulfilled</code>时，<code>Promise.all</code>实例的状态才会变为<code>fulfilled</code>，只要其中有一个实例状态变为了<code>rejected</code>，最终<code>Promise.all</code>实例的状态就会变成<code>rejected</code>。</p><p><code>Promise.all</code>我们常用来并发的执行异步操作，比如我们想要同时读取三个文件，使用<code>Promise</code>链式调用会逐一读取，会造成一定的性能损失。</p><p><code>Promise.all</code>接收一个<code>Promise</code>的数组（不一定是数组，只要有<code>iterator</code>接口就行）作为参数，返回包装后的<code>Promise</code>实例，实例的<code>then</code>方法接收的结果是所有<code>Promise</code>实例结果的数组。无论异步操作哪个先执行完毕，结果数组的顺序和<code>Promise.all</code>传入的<code>Promise</code>实例数组的顺序相同</p><blockquote><p>再次强调一下，<code>Promise.all</code>入参不一定是数组，只要有iterator接口就行</p></blockquote><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/b.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.all([P1, P2, P3]).then(res =&gt; &#123;    console.log(res);    res.map(file =&gt; console.log(file.toString()))&#125;)</code></pre><p>输出</p><pre><code>[  &lt;Buffer 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61&gt;,  &lt;Buffer 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62&gt;,  &lt;Buffer 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63&gt;]aaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccccc</code></pre><p>注意，如果作为参数的<code>Promise</code>实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;读取文件b.txt出错了&#39;)&#125;).catch(err =&gt; err);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.all([P1, P2, P3])    .then(res =&gt; &#123;        console.log(res);        res.map(file =&gt; console.log(file.toString()))    &#125;)    .catch(err =&gt; console.log(err))</code></pre><p>结果</p><pre><code class="javascript">aaaaaaaaaaaaaaaaaaaaaaError: 读取文件b.txt出错了cccccccccccccccccccccc</code></pre><p>如果P2没有自己的catch方法，错误则会被Promise.all捕获</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;读取文件b.txt出错了&#39;)&#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.all([P1, P2, P3])    .then(res =&gt; &#123;        console.log(res);        res.map(file =&gt; console.log(file.toString()))    &#125;)    .catch(err =&gt; console.log(err))</code></pre><p>结果报错</p><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h1><p><code>Promise.race</code>，顾名思义，<code>race</code>是竞赛的意思，<code>Promise.race</code>里包装的<code>Promise</code>实例，只要有一个实例的状态率先改变了，那么<code>Promise.race</code>的状态就随之改变，那个率先改变状态的返回值，将作为<code>Promise.race``then</code>函数的入参，无论那个实力是成功或者失败，<code>Promise.race</code>的状态都会随之改变</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/b.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.race([P1, P2, P3]).then(res =&gt; &#123;    console.log(res.toString())&#125;).catch(err =&gt; console.log(err));</code></pre><p><code>Promise.race</code>额错误处理与<code>Promise.all</code>有着相同的特性，如果作为参数的<code>Promise</code>实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，就不会触发<code>Promise.race()</code>的<code>catch</code>方法。</p><h1 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h1><p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束，和前面的方法不同的是，<code>Promise.allSettled</code>的返回值，不是结果数组，而是一个<code>&#123;status: &#39;fulfilled&#39; | &#39;rejected&#39;, [reason|value]: VALUE&#125;</code>对象的数组，如果<code>status</code>是<code>fulfilled</code>，表示该<code>Promise</code>实例成功，那么第二个属性是<code>value</code>，值是异步操作的结果，如果<code>status</code>是<code>rejected</code>，表示该<code>Promise</code>实例有异常，那么第二个属性是<code>reason</code>，值是异常信息。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;错了&#39;)&#125;);const P2 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;错了&#39;)&#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.allSettled([P1, P2, P3]).then(res =&gt; &#123;    console.log(res)&#125;).catch(err =&gt; console.log(err));</code></pre><p>结果</p><pre><code>[  &#123;    status: &#39;rejected&#39;,    reason: Error: 错了        at C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\Promise        ...  &#125;,  &#123;    status: &#39;rejected&#39;,    reason: Error: 错了        at C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\Promise        ...  &#125;,  &#123;    status: &#39;fulfilled&#39;,    value: &lt;Buffer 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63&gt;  &#125;]</code></pre><blockquote><p>往往我们需要自己手动筛选出成功的结果或失败的结果，根据需要自行处理</p></blockquote><h1 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h1><p>只要参数实例有任何一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 <code>Promise</code>变成<code>rejected</code>状态而结束。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&quot;bluebird&quot;);const P1 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;错了&#39;)&#125;);const P2 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/b.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.any([P1, P2, P3]).then(res =&gt; &#123;    console.log(res.toString())&#125;).catch(err =&gt; console.log(err));</code></pre><p>结果</p><pre><code>bbbbbbbbbbbbbbbbbbbbbb</code></pre><blockquote><p>如果<code>c.txt</code>文件优先读取完毕，那么结果就是<code>c.txt</code>文件的内容</p></blockquote><p>需要注意的是，<code>Promise.any</code>还只是草案里的特性，不能直接使用，我们可以引用社区的<code>Promise</code>库<code>bluebird</code>来使用</p><h1 id="Promise-resolve-Promise-reject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve &amp; Promise.reject"></a>Promise.resolve &amp; Promise.reject</h1><p><code>Promise.resolve</code>可以直接把一个对象转化为<code>Promise</code>对象。</p><p>传入不同的对象，<code>Promise.resolve</code>有不同的行为</p><ol><li><p>传入<code>Promise</code>实例<br>如果参数是<code>Promise</code>实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p></li><li><p>参数是一个<code>thenable</code>对象<br><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p></li></ol><pre><code class="javascript">let thenable = &#123;    then: (resolve, reject) =&gt; &#123;        resolve(42);    &#125;&#125;;</code></pre><p><code>Promise.resolve()</code>方法会将这个对象转为<code>Promise</code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><pre><code class="javascript">let thenable = &#123;    then: (resolve, reject) =&gt; &#123;        resolve(42);    &#125;&#125;;  let p1 = Promise.resolve(thenable); // 此时p1的状态已经变成fulfilled了p1.then(val =&gt; console.log(val));   // 42</code></pre><pre><code class="javascript">let thenable = &#123;    then: (resolve, reject) =&gt; &#123;        reject(42);    &#125;&#125;;  let p1 = Promise.resolve(thenable); // 此时p1的状态已经变成rejected了p1.catch(err =&gt; console.log(err));</code></pre><pre><code class="javascript">let thenable = &#123;    then: (resolve, reject) =&gt; &#123;        throw new Error(&#39;出错了&#39;)    &#125;&#125;;  let p1 = Promise.resolve(thenable); // 此时p1的状态已经变成rejected了p1.catch(err =&gt; console.log(err));  // Error: 出错了</code></pre><ol start="3"><li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象</li></ol><pre><code class="javascript">let p1 = Promise.resolve(&#39;hello world&#39;);p1.then(res =&gt; console.log(res)); // hello world</code></pre><p>以上代码等价于</p><pre><code class="javascript">let p1 = new Promise(resolve =&gt; resolve(&#39;hello world&#39;));p1.then(res =&gt; console.log(res));</code></pre><ol start="4"><li>不带有任何参数</li></ol><pre><code class="javascript">let p = Promise.resolve();p.then(res =&gt; console.log(res)); // undefined</code></pre><p><code>Promise.reject(reason)</code>方法也会返回一个新的<code>Promise</code>实例，该实例的状态为<code>rejected</code>。</p><pre><code class="javascript">let p = Promise.reject(&#39;出错了&#39;);p.catch(err =&gt; console.log(err)); // 出错了</code></pre><p>以上代码等同于</p><pre><code class="javascript">let p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;));p.catch(err =&gt; console.log(err)); // 出错了</code></pre><p>最后提一下，在社区有很多库实现了<code>Promise</code>，都遵循<a href="https://promisesaplus.com/">Primise&#x2F;A+</a>规范，有人测试社区的多种实现中，<a href="http://bluebirdjs.com/docs/getting-started.html">bluebird.js</a>的性能比官方的ES6要高三倍，而且很多还在草案中的特性，<code>bluebird.js</code>都已经实现了，如果想要使用或者学习新的<code>Promise</code>特性，不妨试试<code>bluebird.js</code>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js async、await函数</title>
      <link href="/2023/04/06/JavaScript/js%20async%E3%80%81await%E5%87%BD%E6%95%B0/"/>
      <url>/2023/04/06/JavaScript/js%20async%E3%80%81await%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="js-async-await函数"><a href="#js-async-await函数" class="headerlink" title="js async&#x2F;await函数"></a>js async&#x2F;await函数</h1><p><code>async</code>函数就是<code>generator</code>函数的语法糖，一般结合<code>Promise</code>使用</p><p>我们可以把generator函数函数改写成async&#x2F;await函数，例如</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var co = require(&#39;co&#39;);var readFile = function (fileName) &#123;    return new Promise(function (resolve, reject) &#123;        fs.readFile(fileName, function (error, data) &#123;            if (error) reject(error);            resolve(data.toString());        &#125;);    &#125;);&#125;;function* read() &#123;    // resolve multiple promises in parallel    var a = yield readFile(&#39;./data/a.text&#39;)    var b = yield readFile(&#39;./data/b.text&#39;)    console.log(a.toString());    console.log(b.toString());&#125;co(read)</code></pre><p>改写成</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var readFile = function (fileName) &#123;    return new Promise(function (resolve, reject) &#123;        fs.readFile(fileName, function (error, data) &#123;            if (error) reject(error);            resolve(data.toString());        &#125;);    &#125;);&#125;;async function read() &#123;    // resolve multiple promises in parallel    var a = await readFile(&#39;./data/a.text&#39;)    var b = await readFile(&#39;./data/b.text&#39;)    console.log(a.toString());    console.log(b.toString());&#125;read()</code></pre><p>输出和上面的<code>generator</code>函数是一样的，但是我们对比可以发现，<code>async</code>函数只是将<code>generator</code>函数的<code>*</code>去掉了，然后在前面加了一个<code>async</code>，函数内部的<code>yield</code>替换成了<code>await</code>，其他的都没有变化</p><p><code>async</code>函数的改进，体现在以下几点：</p><ul><li>内置执行器：我们发现是用<code>async</code>函数，我们不需要引入<code>co</code>模块，就能使用，因为<code>async</code>函数内置了执行器</li><li>更好的语义：<code>async/await</code>相比<code>generator</code>的<code>yield</code>有更好的语义，<code>async</code>表示函数内部有异步操作，而<code>await</code>表示紧跟在后面的表达式需要等待结果，才能继续执行下面的代码</li><li>更广的适用性：<code>co</code>模块约定，<code>yield</code>命令后面只能是<code>thunk</code>函数或 <code>Promise</code>对象，而<code>async</code>函数的<code>await</code>命令后面，可以是<code>Promise</code>对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即<code>resolved</code>的 <code>Promise</code>对象）。</li><li>返回值是<code>Promise</code>：<code>async</code>函数的返回值是<code>Promise</code>对象，这比 <code>generator</code>函数的返回值是<code>iterator</code>对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</li></ul><p><code>async</code>函数的返回值是一个<code>Promise</code>对象，函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><pre><code class="javascript">async function fn() &#123;    return 123&#125;fn().then(d =&gt; console.log(d))  // 123</code></pre><p><strong>错误处理</strong><br>async函数的错误处理方式可以放在函数内部也可以放在函数外部</p><p>放在函数内部</p><pre><code class="javascript">async function f() &#123;  try &#123;    await new Promise(function (resolve, reject) &#123;      throw new Error(&#39;出错了&#39;);    &#125;);  &#125; catch(e) &#123;  &#125;  return await(&#39;hello world&#39;);&#125;</code></pre><p>放在函数外部</p><pre><code class="javascript">async function f() &#123;  await new Promise(function (resolve, reject) &#123;    throw new Error(&#39;出错了&#39;);  &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))</code></pre><p>如果有多个await命令，可以统一放在try…catch结构中。</p><pre><code class="javascript">async function f() &#123;  try &#123;    const val1 = await firstStep();    const val2 = await secondStep(val1);    const val3 = await thirdStep(val1, val2);    console.log(&#39;Final: &#39;, val3);  &#125;  catch (err) &#123;    console.error(err);  &#125;&#125;</code></pre><p>思考一下下面的代码为什么会按照<code>1、3、2</code>的顺序输出，那是因为执行<code>fn</code>函数，执行<code>console.log(1)</code>，然后返回一个<code>Promise</code>对象，又由于<code>Promise</code>对象的<code>then</code>属于微任务，放到微任务执行队列里面，执行下面的<code>console.log(3)</code>，后面执行栈没有代码了，然后执行微任务队列里的任务，执行<code>console.log(2)</code></p><pre><code class="javascript">async function fn() &#123;    console.log(1)    return 2&#125;fn().then(d =&gt; console.log(d))console.log(3)</code></pre><p>输出结果</p><pre><code class="javascript">132</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js for...in循环和for...of循环</title>
      <link href="/2023/04/06/JavaScript/js%20for...in%E5%BE%AA%E7%8E%AF%E5%92%8Cfor...of%E5%BE%AA%E7%8E%AF/"/>
      <url>/2023/04/06/JavaScript/js%20for...in%E5%BE%AA%E7%8E%AF%E5%92%8Cfor...of%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="js-for…in循环和for…of循环"><a href="#js-for…in循环和for…of循环" class="headerlink" title="js for…in循环和for…of循环"></a>js for…in循环和for…of循环</h1><p><code>for...in</code>循环和<code>for...of</code>循环结合ES6新增的方法<code>Object.keys()</code>&#x2F;<code>Object.values()</code>&#x2F;<code>Object.entries()</code>，可以以自己想要的方式遍历对象，两者结合使用非常nice</p><h1 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h1><p><code>for...in</code>是ES5的标准，该方法遍历的是对象的属性名称(<code>key</code>：键名)。一个<code>Array</code>对象也是一个对象，数组中的每个元素的索引被视为属性名称，所以在使用<code>for...in</code>遍历<code>Array</code>时，拿到的是每个元素索引</p><blockquote><p>注意：<code>Object.keys()</code>返回的是一个数组，对这个数组进行<code>for...in</code>循环，也会拿到数组的原型链上的属性，这点需要注意</p></blockquote><ul><li>一般用于遍历对象自身的和继承的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。</li><li>不建议使用<code>for...in</code>遍历数组，因为输出的顺序是不固定的。</li><li>如果迭代的对象的变量值是<code>null</code>或者<code>undefined</code>, <code>for...in</code>不执行循环体，建议在使用<code>for...in</code>循环之前，先检查该对象的值是不是<code>null</code>或者<code>undefined</code></li><li><code>for…in</code> 语句以原始插入顺序迭代对象的<strong>可枚举属性</strong>(只能迭代出可枚举的属性，可枚举属性【js自定义属性】&#x2F;不可枚举属性【对象的内置属性】，如数组的<code>length</code>就是一个内置属性，所以<code>for…in</code>遍历不出来】)。</li><li><code>for…in</code>的原理是: <code>Object.keys()</code>：返回给定对象所有可枚举属性的字符串数组<span id="more"></span></li></ul><h2 id="for-in循环数组"><a href="#for-in循环数组" class="headerlink" title="for...in循环数组"></a><code>for...in</code>循环数组</h2><pre><code class="javascript">let arr = [1, 2, 3]arr.__proto__.name = &#39;jerry&#39;for (let i in arr) &#123;  console.log(i)    // 0, 1, 2, name&#125;for (let i in Object.keys(arr)) &#123;  console.log(i)    // 0, 1, 2, name&#125;for (let i = 0; i &lt; arr.length; i++) &#123;  console.log(i)    // 0, 1, 2&#125;;</code></pre><h1 id="for-in循环对象"><a href="#for-in循环对象" class="headerlink" title="for...in循环对象"></a><code>for...in</code>循环对象</h1><pre><code class="javascript">let obj = &#123;a: &#39;aaa&#39;, b: &#39;bbb&#39;, c: &#39;ccc&#39;&#125;obj.__proto__.name = &#39;jerry&#39;for (let i in obj) &#123;  console.log(i)    // a, b, c, name&#125;for (let i in Object.keys(obj)) &#123;  console.log(i)    // 0, 1, 2, name&#125;</code></pre><h1 id="for-in循环字符串"><a href="#for-in循环字符串" class="headerlink" title="for...in循环字符串"></a><code>for...in</code>循环字符串</h1><blockquote><p>如果<code>Object.keys()</code>传入的是一个字符串，对<code>Object.keys()</code>的结果进行<code>for...in</code>循环，不会获取原型链上的属性</p></blockquote><pre><code class="javascript">let str = &#39;abcde&#39;str.__proto__.age = 18for (let i in str) &#123;  console.log(i)    // 0, 1, 2, 3, 4, age&#125;for (let i in Object.keys(str)) &#123;  console.log(i)    // 0, 1, 2, 3, 4  // 这里没有age属性&#125;for (let i = 0; i &lt; str.length; i++) &#123;  console.log(i)    // 0, 1, 2, 3, 4&#125;;</code></pre><h1 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for...of循环"></a><code>for...of</code>循环</h1><p><code>for...of</code>是<code>ES6</code>的标准，该方法遍历的是对象的属性所对应的值(<code>value</code>：键值)。所以它用来遍历数组时得到每个元素的值</p><ul><li><code>for…of</code>语句在可迭代对象（包括 <code>Array</code>，<code>String</code>，<code>Set</code>，<code>Map</code>，<code>TypedArray</code>，<code>arguments</code>，<code>Generators</code>，<code>DOM collection</code>对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</li><li><code>for…of</code>语句遍历可迭代对象定义要迭代的数据（非自定义属性）</li><li><code>for…of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象、Generator 对象，以及字符串。</li></ul><h2 id="for-of循环数组"><a href="#for-of循环数组" class="headerlink" title="for...of循环数组"></a><code>for...of</code>循环数组</h2><pre><code class="javascript">let arr1 = [10, 20, 30];for (let value of arr1) &#123;    console.log(value);&#125;// 10// 20// 30// 我们可以使用const来替代let，这样它就变成了在循环里的不可修改的静态变量。let arr2 = [100, 200, 300];for (const value of arr2) &#123;    console.log(value);&#125;// 100// 200// 300</code></pre><h2 id="for-of循环字符串"><a href="#for-of循环字符串" class="headerlink" title="for...of循环字符串"></a><code>for...of</code>循环字符串</h2><pre><code class="javascript">let str1 = &quot;abcde&quot;;for (let value of str1) &#123;    console.log(value);&#125;// a// b// c// d// e</code></pre><h2 id="for-of循环Set"><a href="#for-of循环Set" class="headerlink" title="for...of循环Set"></a><code>for...of</code>循环<code>Set</code></h2><pre><code class="javascript"> let set1 = new Set([1, 1, 2, 2, 3, 3]);for (let value of set1) &#123;    console.log(value);&#125;// 1// 2// 3</code></pre><h2 id="for-of循环Map"><a href="#for-of循环Map" class="headerlink" title="for...of循环Map"></a><code>for...of</code>循环<code>Map</code></h2><pre><code class="javascript">let map1 = new Map([[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]);for (let [key, value] of map1) &#123;    console.log(key, value);&#125;// &#39;a&#39; 1// &#39;b&#39; 2// &#39;c&#39; 3for (let entry of map1) &#123;    console.log(entry);&#125;// [a, 1]// [b, 2]// [c, 3]</code></pre><h2 id="for-of循环类型化数组（TypedArray）"><a href="#for-of循环类型化数组（TypedArray）" class="headerlink" title="for...of循环类型化数组（TypedArray）"></a><code>for...of</code>循环类型化数组（<code>TypedArray</code>）</h2><pre><code class="javascript">let tArr = new Uint8Array([0x00, 0xff]);for (let value of tArr) &#123;    console.log(value);&#125;// 0// 255</code></pre><h2 id="for-of循环arguments"><a href="#for-of循环arguments" class="headerlink" title="for...of循环arguments"></a><code>for...of</code>循环<code>arguments</code></h2><pre><code class="javascript">function func() &#123;    for (let arg of arguments) &#123;        console.log(arg);    &#125;&#125;func(1, 2, 3)// 1// 2// 3</code></pre><h2 id="for-of循环generator"><a href="#for-of循环generator" class="headerlink" title="for...of循环generator"></a><code>for...of</code>循环<code>generator</code></h2><pre><code class="javascript">function* gen() &#123; // a generator function    yield 1;    yield 2;    yield 3;&#125;for (let n of gen()) &#123;    console.log(n);&#125;// 1// 2// 3function* fibonacci() &#123; // a generator function    let [prev, curr] = [0, 1];    while (true) &#123;        [prev, curr] = [curr, prev + curr];        yield curr;    &#125;&#125;for (let n of fibonacci()) &#123;    console.log(n);    // truncate the sequence at 100    if (n &gt;= 100) &#123;        break;    &#125;&#125;// 1// 2// 3// 5// 8// 13// 21// 34// 55// 89// 144</code></pre><h2 id="for-of循环DOM-collection"><a href="#for-of循环DOM-collection" class="headerlink" title="for...of循环DOM collection"></a><code>for...of</code>循环<code>DOM collection</code></h2><pre><code class="javascript">let articleParagraphs = document.querySelectorAll(&quot;article &gt; p&quot;);for (let paragraph of articleParagraphs) &#123;    paragraph.classList.add(&quot;read&quot;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js generator函数特性</title>
      <link href="/2023/04/06/JavaScript/js%20generator%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/04/06/JavaScript/js%20generator%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="js-generator函数特性"><a href="#js-generator函数特性" class="headerlink" title="js generator函数特性"></a>js generator函数特性</h1><ul><li>函数声明<code>function</code>和<code>函数名</code>之间加<code>*</code>号，<code>*</code>只要在中间，中间有空格也无所谓</li><li><code>yield</code> 关键字后面跟上返回值，使用<code>.next()</code>调用，输出<code>&#123;value: VALUE, done: [falise|true]&#125;</code></li><li>当<code>done</code>状态为<code>true</code>之后，<code>value</code>值就全都是<code>undefined</code>了，<code>value</code> 为 <code>undefined</code>不能被<code>for of</code>循环获取到</li><li>同一个作用域中函数不能被重复调用，执行完一遍之后 内部的<code>done</code>变为 <code>true</code>之后就不能再调用了</li><li>如果一个对象实现了<code>iterator</code>属性，且这个属性是一个<code>generator</code>函数，则<code>generator</code>函数的<code>yield</code>的值可以作为遍历的值<span id="more"></span></li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><code>generator</code>函数的调用方式和普通函数不一样，<code>generator</code>函数直接调用会返回一个迭代器对象，该迭代器对象可以使用<code>for</code>进行循环，也可以使用<code>next()</code>进行调用，区别是使用<code>for</code>循环调用的输出是<code>yield</code>关键字后面的返回值，而使用<code>next()</code>的输出是<code>&#123;value: VALUE, done: [falise|true]&#125;</code>对象</p><p>注意，使用for循环调用的时候，不会遍历return后面的值；</p><pre><code class="javascript">function* generator () &#123;  yield 1  yield 2  return &#39;ending&#39;   // return 标记结束，但还可以调用，return的值不会在for of循环中被获取到&#125;let g = generator()console.log(g.next());  // &#123; value: 1, done: false &#125;console.log(g.next());  // &#123; value: 2, done: false &#125;console.log(g.next());  // &#123; value: &#39;ending&#39;, done: true &#125;let g2 =generator()for (let a of g2) &#123;  console.log(a);&#125;// 1// 2console.log(g.next());  // &#123; value: undefined, done: true &#125;// 在同一个作用域中，多次调用generator函数，一旦done的状态为true了之后，函数就不能再调用了，而使用next()强行调用，会返回`&#123; value: undefined, done: true &#125;`</code></pre><h2 id="递归输出"><a href="#递归输出" class="headerlink" title="递归输出"></a>递归输出</h2><p>我们可以写一个递归函数，自己自动调用<code>next</code>，进行输出</p><pre><code class="javascript">function* generator () &#123;  yield 1  yield 2  return &#39;ending&#39;&#125;let g = generator()// 递归执行，自己写的递归会打印ending，for of 不会function next () &#123;  let &#123; value, done &#125; = g.next();  console.log(value);  if (!done) &#123;    next()  &#125;&#125;next();</code></pre><h2 id="next传参"><a href="#next传参" class="headerlink" title="next传参"></a>next传参</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作<strong>上一个</strong><code>yield</code>表达式的返回值。</p><p>先看第一个例子，不传参的情况</p><pre><code class="javascript">function* say (num) &#123;  let x = 2 * (yield (num + 1));  console.log(x);  let y = x * (yield (num + 2));  console.log(y);  return &#39;ending&#39;&#125;const g1 = say(1);0console.log(g1.next())  // &#123; value: 2, done: false &#125;console.log(g1.next())  // NaN                        // &#123; value: 3, done: false &#125;console.log(g1.next())  // NaN                        // &#123; value: &#39;ending&#39;, done: true &#125;</code></pre><ul><li>第一个<code>next</code>，<code>num</code>是<code>1</code>，碰到<code>yield</code>就退出，输出<code>&#123; value: 2, done: false &#125;</code></li><li>第二个<code>next</code>，<code>num</code>是<code>1</code>，由于没有传入参数，则<code>yield</code>返回值是<code>undefined</code>，<code>x</code>等于 <code>2 * undefined</code>，<code>x</code>结果是<code>NaN</code>，执行<code>console.log(x)</code>,输出<code>NaN</code>，然后碰到<code>yield</code>退出，输出<code>&#123; value: 3, done: false &#125;</code></li><li>第三个<code>next</code>，<code>num</code>是<code>1</code>，由于没有传入参数，<code>y</code>等于<code> NaN * NaN</code>，<code>y</code>结果是<code>NaN</code>，然后<code>return</code>出<code>&#123; value: &#39;ending&#39;, done: true &#125;</code></li></ul><p>再来看看传参的情况</p><pre><code class="javascript">const g2 = say(1);console.log(g2.next(1))   // &#123; value: 2, done: false &#125;console.log(g2.next(5))   // 10                          // &#123; value: 3, done: false &#125;console.log(g2.next(10))   // 100                          // &#123; value: &#39;ending&#39;, done: true &#125;</code></pre><ul><li>第一个<code>next</code>，<code>num</code>是<code>1</code>，传入了参数<code>1</code>，但是没用，在此次<code>yield</code>之前没有<code>yield</code>，所以没用，然后碰到<code>yield</code>退出，输出<code>&#123; value: 2, done: false &#125;</code></li><li>第二个<code>next</code>，<code>num</code>是<code>1</code>，传入了参数<code>5</code>，，<code>x</code>结果是<code>2 * 5</code>（这里的第二个<code>5</code>是<code>next</code>传入的<code>5</code>），<code>x</code>的结果是<code>10</code>，执行<code>console.log(x)</code>,输出<code>10</code>，然后碰到<code>yield</code>退出，输出<code>&#123; value: 3, done: false &#125;</code></li><li>第三个<code>next</code>，<code>num</code>是<code>1</code>，传入了参数<code>10</code>，<code>y</code>等于<code>10 * 10</code>，<code>y</code>结果是<code>100</code>，然后<code>return</code>出<code>&#123; value: &#39;ending&#39;, done: true &#125;</code></li></ul><h1 id="和iterator接口的关系"><a href="#和iterator接口的关系" class="headerlink" title="和iterator接口的关系"></a>和iterator接口的关系</h1><p>实际上可以通过<code>for</code>循环遍历的对象都有一个<code>Symbol.iterator</code>属性，该属性就是一个<code>generator</code>函数，可以直接进行遍历，就有<code>Symbol.iterator</code><br><img src="/images/generator.png"></p><p>如果我们把数组对象的<code>Symbol.iterator</code>属性修改了，则数组就无法进行遍历了<br><img src="/images/generator1.png"></p><p>我们还可以改写<code>Symbol.iterator</code>属性，使其按照我们想要的形式输出，由于<code>Symbol.iterator</code>属性就是一个<code>generator</code>函数，我们则可以给它赋值一个自定义<code>generator</code>函数<br><img src="/images/generator2.png"></p><p>我们都知道，普通的<code>key-value</code>对象是不具备迭代能力的，因此不能直接进行<code>for</code>循环，需要使用<code>Object.keys</code>或者<code>Object.values</code>函数辅助进行遍历，我们可以把<code>generator</code>赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有<code>iterator</code>接口。</p><pre><code class="javascript">function* objectEntries() &#123;  let propKeys = Object.keys(this);  for (let propKey of propKeys) &#123;    yield [propKey, this[propKey]];  &#125;&#125;let jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123;  console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe</code></pre><h1 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h1><p>ES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><pre><code class="javascript">function* foo() &#123;  yield &#39;a&#39;;  yield &#39;b&#39;;&#125;function* bar() &#123;  yield &#39;x&#39;;  yield* foo();  yield &#39;y&#39;;&#125;// 等同于function* bar() &#123;  yield &#39;x&#39;;  yield &#39;a&#39;;  yield &#39;b&#39;;  yield &#39;y&#39;;&#125;// 等同于function* bar() &#123;  yield &#39;x&#39;;  for (let v of foo()) &#123;    yield v;  &#125;  yield &#39;y&#39;;&#125;for (let v of bar())&#123;  console.log(v);&#125;// &quot;x&quot;// &quot;a&quot;// &quot;b&quot;// &quot;y&quot;</code></pre><blockquote><p>以上示例来自<a href="https://es6.ruanyifeng.com/#docs/generator#yield--%E8%A1%A8%E8%BE%BE%E5%BC%8F">阮一峰的ES6教程</a></p></blockquote><p>使用generator实现二叉树遍历</p><pre><code class="javascript">// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123;  this.left = left;  this.label = label;  this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123;  if (t) &#123;    yield* inorder(t.left);    yield t.label;    yield* inorder(t.right);  &#125;&#125;// 下面生成二叉树function make(array) &#123;  // 判断是否为叶节点  if (array.length == 1) return new Tree(null, array[0], null);  return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123;  result.push(node);&#125;console.log(result)// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</code></pre><blockquote><p>以上示例来自<a href="https://es6.ruanyifeng.com/#docs/generator#yield--%E8%A1%A8%E8%BE%BE%E5%BC%8F">阮一峰的ES6教程</a></p></blockquote><h1 id="generator函数异步应用"><a href="#generator函数异步应用" class="headerlink" title="generator函数异步应用"></a>generator函数异步应用</h1><p><code>javascript</code>的异步操作都是使用回调函数的方式进行的，但是会造成回调地狱的问题，后来<code>generator</code>函数出现了，配合<code>thunk</code>函数和执行器可以实现同步操作，而不使用回调函数，再结合后面的<code>async/await</code>，可以使我们用同步的形式写异步代码</p><h2 id="thunkify"><a href="#thunkify" class="headerlink" title="thunkify"></a>thunkify</h2><p><code>Thunk</code> 函数是自动执行<code>Generator</code>函数的一种方法。<code>Thunk</code>函数不是函数类型，而是一种编程方式，把多个入参的函数转换为一个入参的方式</p><p>例如</p><pre><code class="javascript">// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）var Thunk = function (fileName) &#123;  return function (callback) &#123;    return fs.readFile(fileName, callback);  &#125;;&#125;;var readFileThunk = Thunk(fileName);readFileThunk(callback);</code></pre><p><code>thunk</code>函数在<code>generator</code>函数中的使用，一般使用<code>thunkify</code>模块</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var thunkify = require(&#39;thunkify&#39;);var readFileThunk = thunkify(fs.readFile);var gen = function* () &#123;    var r1 = yield readFileThunk(&#39;./data/a.text&#39;);    var r2 = yield readFileThunk(&#39;./data/b.text&#39;);    console.log(r1.toString());    console.log(r2.toString());&#125;;// 手动的执行var g = gen();var r1 = g.next();console.log(r1);        // &#123; value: [Function], done: false &#125;   vale值就是yield出来的thunk函数r1.value(function (err, data) &#123;   // 执行thunk函数的回调函数, data就是readFileThunk的结果，然后把结果传入给generator    if (err) throw err;    // console.log(data.toString()); // aaaaa, 但是一般不在执行器里面处理结果，执行器仅进行流程控制，一般是把得到的结果传给generator，在generator里面进行处理    var r2 = g.next(data); // 把结果data传入generator函数中    r2.value(function (err, data) &#123;        if (err) throw err;        g.next(data);    &#125;);&#125;);</code></pre><p><code>generator</code>自动执行器，自动管理需要自己写一个方法，递归的进行自动处理，或者使用下文介绍的<code>co</code>模块</p><pre><code class="javascript">function run(fn) &#123;    var gen = fn();    function next(err, data) &#123;        var result = gen.next(data);        if (result.done) return;        result.value(next);    &#125;    next();&#125;run(gen)</code></pre><blockquote><p>上面这种方式是同步输出的</p></blockquote><h2 id="co"><a href="#co" class="headerlink" title="co"></a>co</h2><p><code>co</code>模块是著名程序员<code>TJ Holowaychuk</code> 于 2013 年 6 月发布的一个小工具，用于<code>Generator</code> 函数的自动执行。效果和自己写的<code>run</code>方法作用一样，但是<code>co</code>内部进行了很多处理，逻辑更加严谨，在<code>co</code>的<code>4.0</code>版本中,<code>yield</code>不仅可以是一个<code>thunk</code>函数,也可以是一个<code>Promise</code>对象</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var thunkify = require(&#39;thunkify&#39;);var readFileThunk = thunkify(fs.readFile);var co = require(&#39;co&#39;)var gen = function* () &#123;    var r1 = yield readFileThunk(&#39;./data/a.text&#39;);    var r2 = yield readFileThunk(&#39;./data/b.text&#39;);    console.log(r1.toString());    console.log(r2.toString());&#125;;co(gen)</code></pre><p><code>co</code>还支持并发的异步操作，就是把各个一步操作放在一个数组里面，当所有的操作执行成功后，再进行下一步</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var co = require(&#39;co&#39;)var readFile = function (fileName) &#123;    return new Promise(function (resolve, reject) &#123;        fs.readFile(fileName, function (error, data) &#123;            if (error) reject(error);            resolve(data.toString());        &#125;);    &#125;);&#125;;// 数组的写法co(function* () &#123;    var res = yield [        readFile(&#39;./data/a.text&#39;),        readFile(&#39;./data/b.text&#39;)    ];    console.log(&#39;res&#39;, res);&#125;).catch();// 对象的写法co(function* () &#123;    var res = yield &#123;        1: Promise.resolve(1),        2: Promise.resolve(2),    &#125;;    console.log(res);&#125;).catch();</code></pre><p>输出结果</p><pre><code class="javascript">&#123; &#39;1&#39;: 1, &#39;2&#39;: 2 &#125;res [ &#39;aaaaa&#39;, &#39;bbbbb&#39; ]</code></pre><p>由于都是异步操作，虽然读取文件是在<code>Promise.resolve</code>前面，但是读取文件是需要时间的，所以对象写法的输出会在前面</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js this指向问题以及改变this指向的三种方法（call、apply、bind）</title>
      <link href="/2023/04/06/JavaScript/js%20this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88call%E3%80%81apply%E3%80%81bind%EF%BC%89/"/>
      <url>/2023/04/06/JavaScript/js%20this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88call%E3%80%81apply%E3%80%81bind%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="js-this指向问题以及改变this指向的三种方法（call-apply-bind）"><a href="#js-this指向问题以及改变this指向的三种方法（call-apply-bind）" class="headerlink" title="js this指向问题以及改变this指向的三种方法（call&#x2F;apply&#x2F;bind）"></a>js this指向问题以及改变this指向的三种方法（call&#x2F;apply&#x2F;bind）</h1><p>在<code>JavaScript</code>中，<code>this</code>指向是一个很令人头疼的一个东西，由于<code>JavaScript</code>可以运行在浏览器环境中，也可以运行在<code>node</code>环境中，两者的<code>this</code>指向有着不同的特性，<code>this</code>指向问题往往会令你的代码朝着意想不到的方向运行，因此<code>JavaScript</code>也提供了几种修改<code>this</code>指向的方法，我们一一说明。</p><h1 id="浏览器环境中this的指向"><a href="#浏览器环境中this的指向" class="headerlink" title="浏览器环境中this的指向"></a>浏览器环境中<code>this</code>的指向</h1><p>下面先介绍在浏览器环境中<code>this</code>的指向问题；</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        // 全局模式下，this指向window        console.log(this);        // 全局变量是设置在window上的，因此下面的写法是一样的        a = 10;                     // window.a = 10        this.b = 10;        console.log(a === b);       // true        function fn1() &#123;            console.log(this);        &#125;        fn1();              // this指向window        window.fn1();       // this还是指向window        var obj = &#123;            c: 10,            fn2: function () &#123;                console.log(this);            &#125;        &#125;        obj.fn2()           // this指向obj        window.obj.fn2()    // this指向obj        var obj2 = &#123;            d: 10,            e: &#123;                f: 10,                fn3: function () &#123;                    console.log(this);                &#125;            &#125;        &#125;        window.obj2.e.fn3()     // this指向e        let fn4 = window.obj2.e.fn3;        fn4()                   // this指向window    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>总结：</p><ul><li><code>this</code>在定义的时候不会指定，只有在函数调用的时候才会指定</li><li><code>this</code>指向的是在调用函数时最近的调用者<span id="more"></span></li></ul><h1 id="node环境中this的指向"><a href="#node环境中this的指向" class="headerlink" title="node环境中this的指向"></a><code>node</code>环境中<code>this</code>的指向</h1><p>而在<code>node</code>环境中，<code>this</code>的指向和浏览器中有着较大出入；<br>在全局打印<code>this</code>，这里的<code>this</code>是一个空对象<code>&#123;&#125;</code></p><pre><code class="javascript">console.log(this); // &#123;&#125;</code></pre><p>在浏览器环境中，这里的结果是<code>true</code>，但是在<code>node</code>环境中，会报错，因为变量<code>b</code>是定义在this上的，而<code>this</code>指向的是一个空对象，而<code>a === b</code>中的变量<code>b</code>是根本没有定义的</p><pre><code class="javascript">a = 10;this.b = 10;console.log(a === b); // ReferenceError: b is not defined</code></pre><p>有趣的是，在函数中，this指向的又不是空对象，而是<code>global</code>对象，指向函数<code>fn1</code>的调用者<code>global</code></p><pre><code class="javascript"> function fn1() &#123;    console.log(this);&#125;fn1(); // Object [global] &#123;...&#125;</code></pre><pre><code class="javascript">var obj = &#123;    c: 10,    fn2: function () &#123;        console.log(this);    &#125;&#125;obj.fn2() // &#123; c: 10, fn2: [Function: fn2] &#125; =&gt; 指向obj</code></pre><pre><code class="javascript">var obj2 = &#123;    d: 10,    e: &#123;        f: 10,        fn3: function () &#123;            console.log(this);        &#125;    &#125;&#125;obj2.e.fn3() // &#123; f: 10, fn3: [Function: fn3] &#125; =&gt; 指向e</code></pre><p>总结：</p><ul><li><code>node</code>环境中直接打印的<code>this</code>指向空对象，浏览器环境直接打印<code>this</code>指向<code>window</code></li><li><code>this</code>指向和浏览器环境中是一样的，只是区别在于，浏览器环境全局是<code>window</code>，而<code>node</code>环境全局是<code>global</code></li></ul><h1 id="改变this指向的三种方法；"><a href="#改变this指向的三种方法；" class="headerlink" title="改变this指向的三种方法；"></a>改变<code>this</code>指向的三种方法；</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><pre><code class="javascript">function fun1(a, b, c) &#123;    console.log(this);    console.log(a + b + c);&#125;obj = &#123; name: &#39;jerry&#39;, age: 18 &#125;;fun1() // 这里函数里的this指向window对象fun1.call(obj, 1, 2, 3); // 这里函数中的this指向obj，而不是fun1</code></pre><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p><code>apply</code>和<code>call</code>的区别是<code>apply</code>传递的参数需要使用数组，而<code>call</code>直接传就行了</p><pre><code class="javascript"> function fun2(a, b, c) &#123;    console.log(this);    console.log(a + b + c);&#125;fun2.apply(obj, [1, 2, 3])</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code>区别是<code>bind</code>只会改变<code>this</code>指向，并不会执行函数，而<code>call</code>和<code>apply</code>不仅改变<code>this</code>指向，并且会执行函数</p><pre><code class="javascript"> function fun3(a, b, c) &#123;    console.log(this);    console.log(a + b + c);&#125;fun3.bind(obj, 1, 2, 3); // 并不会执行fun3</code></pre><p>需要特别注意的是，bind方法并不会直接去更改函数的this指向，而是返回一个新的修改了this指向的函数，如果要调用，则需要使用其他变量接收或者直接调用</p><pre><code class="javascript"> function fun3(a, b, c) &#123;    console.log(this);    console.log(a + b + c);&#125;fun3.bind(obj, 1, 2, 3); // 并不会执行fun3fun3() // 这里的this指向并没有发生改变// 如果想要调用，用变量接收let newFun3 = fun3.bind(obj, 1, 2, 3);newFun3()// 或者直接调用fun3.bind(obj, 1, 2, 3)()</code></pre><h1 id="一个bind方法的小例子"><a href="#一个bind方法的小例子" class="headerlink" title="一个bind方法的小例子"></a>一个bind方法的小例子</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button&gt;获取验证码&lt;/button&gt;    &lt;script&gt;        // 注意这里，如果不加bind(this)，那么定时器里面的this指向的是window        // 这里加了bind(this)，那么定时器里面的this就指向了btn事件源，从而可以使用this来操作btn        let btn = document.querySelector(&#39;button&#39;);        btn.onclick = function () &#123;            let time = 10;            this.disabled = true;            this.innerText = `重新获取($&#123;time&#125;)`            this.timer = setInterval(function () &#123;                time -= 1;                this.innerText = `重新获取($&#123;time&#125;)`                if (time == 0) &#123;                    this.disabled = false;                    this.innerText = `获取验证码`                    clearInterval(this.timer)                &#125;            &#125;.bind(this), 1000)        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/bind.gif"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 事件循环（event loop）、宏任务、微任务</title>
      <link href="/2023/04/06/JavaScript/js%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88event%20loop%EF%BC%89%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
      <url>/2023/04/06/JavaScript/js%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88event%20loop%EF%BC%89%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="js-事件循环（event-loop）、宏任务、微任务"><a href="#js-事件循环（event-loop）、宏任务、微任务" class="headerlink" title="js 事件循环（event loop）、宏任务、微任务"></a>js 事件循环（event loop）、宏任务、微任务</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Google工程师<code>Jake Archibald</code>写了一篇关于事件循环以及宏任务微任务的文章，非常经典，本文的例子都来源于改文章，有兴趣的可以去浏览原文<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly">Tasks, microtasks, queues and schedules</a></p><p>在该文中也提供了<code>Philip Roberts</code>在youtube上的一个关于事件循环的视频<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway?</a>（需要梯子），视频里讲的非常好，有兴趣可以看下。</p><h1 id="事件循环的基本概念"><a href="#事件循环的基本概念" class="headerlink" title="事件循环的基本概念"></a>事件循环的基本概念</h1><ul><li><code>JavaScript</code>是单线程的，同时只能执行一个代码片段。如果存在耗时的异步操作，则会被阻塞（<code>blocking</code>）.</li><li><code>JavaScript</code>代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(<code>task queue</code>)来搞定另外一些代码的执行，例如<code>setTimeout</code>，<code>AJAX(XHR)</code>等，这些都是<code>Web API</code>，由浏览器提供，不存在于<code>V8引擎</code>内。</li><li>任务队列又分为<code>macro-task</code>（宏任务）与<code>micro-task</code>（微任务），在最新标准中，它们被分别称为<code>task</code>与<code>jobs</code>。<strong>微任务在一次事件循环中，总是先于宏任务执行</strong></li><li>一个线程中，事件循环是唯一的，但是任务队列里的任务可以拥有多个。</li><li><code>macro-task</code>大概包括：<code>script</code>(整体代码), <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, <code>I/O</code>, <code>UI rendering</code>。</li><li><code>micro-task</code>大概包括: <code>process.nextTick</code>, <code>Promise</code>的<code>then catch finally</code>, <code>Object.observe</code>(已废弃), <code>MutationObserver</code>(<code>html5</code>新特性)</li><li><code>setTimeout/Promise</code>等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</li><li><code>Promise</code>的实例化会在主执行栈中执行<span id="more"></span></li></ul><h1 id="通过一个简单的例子来理解"><a href="#通过一个简单的例子来理解" class="headerlink" title="通过一个简单的例子来理解"></a>通过一个简单的例子来理解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="javascript">console.log(&#39;script start&#39;);setTimeout(function () &#123;  console.log(&#39;setTimeout&#39;);&#125;, 0);Promise.resolve()  .then(function () &#123;    console.log(&#39;promise1&#39;);  &#125;)  .then(function () &#123;    console.log(&#39;promise2&#39;);  &#125;);console.log(&#39;script end&#39;);</code></pre><p>打印结果：</p><pre><code>script startscript endpromise1promise2setTimeout</code></pre><h2 id="为什么会有这样的结果？"><a href="#为什么会有这样的结果？" class="headerlink" title="为什么会有这样的结果？"></a>为什么会有这样的结果？</h2><p>逐步分析：</p><ol><li>主执行栈开始，执行<code>console.log(&#39;script start&#39;);</code>，打印<code>script start</code></li><li>执行栈往下执行<code>setTimeout</code>，由于<code>setTimeout</code>是属于宏任务，浏览器等待<code>0ms</code>，将<code>setTimeout</code>的<code>callback</code>函数放入宏任务队列中</li><li>执行栈继续执行<code>Promise</code>，由于<code>Promise</code>的<code>then</code>属于微任务，则将<strong>第一个</strong><code>then</code>中的回调函数放入到微任务队列中，第二个<code>then</code>需要等待第一个<code>then</code>执行完毕才会执行，因此这里不会讲第二个<code>then</code>的回调函数放入微任务队列中</li><li>执行栈执行<code>console.log(&#39;script end&#39;);</code>，打印<code>script end</code></li><li>由于微任务总是先于宏任务执行，则先取出微任务队列中的第一个then的回调函数执行，打印<code>promise1</code></li><li>第一个<code>then</code>执行完，紧接着又有一个<code>then</code>，再将其放入微任务队列中</li><li>只要微任务队列中还有任务没有执行完，则优先执行，因此执行第二个<code>then</code>的回调函数，打印<code>promise2</code></li><li>微任务队列都执行完毕，此时执行宏任务队列里的任务，打印<code>setTimeout</code></li></ol><p>动画演示：<br><img src="/images/eventloop.gif"></p><h1 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background: #D4D4D4;            padding: 25px;            width: 92px;            margin: 0 auto;        &#125;        .inner &#123;            background: #ADADAD;            padding: 46px;            width: 0;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;outer&quot;&gt;        &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // Let&#39;s get hold of those elements        var outer = document.querySelector(&#39;.outer&#39;);        var inner = document.querySelector(&#39;.inner&#39;);        // Let&#39;s listen for attribute changes on the        // outer element        new MutationObserver(function () &#123;        console.log(&#39;mutate&#39;);        &#125;).observe(outer, &#123;        attributes: true,        &#125;);        // Here&#39;s a click listener…        function onClick() &#123;        console.log(&#39;click&#39;);        setTimeout(function () &#123;            console.log(&#39;timeout&#39;);        &#125;, 0);        Promise.resolve().then(function () &#123;            console.log(&#39;promise&#39;);        &#125;);        outer.setAttribute(&#39;data-random&#39;, Math.random());        &#125;        // …which we&#39;ll attach to both elements        inner.addEventListener(&#39;click&#39;, onClick);        outer.addEventListener(&#39;click&#39;, onClick);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>打印结果：</p><pre><code>clickpromisemutateclickpromisemutatetimeouttimeout</code></pre><p>我们这里就不逐步分析了，由于事件的冒泡机制，当第一个事件循环结束后，事件冒泡，会开启第二个事件循环，重复来一遍，看下动画演示：<br><img src="/images/eventloop2.gif"></p><h1 id="使用代码派发事件会发生什么事？"><a href="#使用代码派发事件会发生什么事？" class="headerlink" title="使用代码派发事件会发生什么事？"></a>使用代码派发事件会发生什么事？</h1><p>上面的代码，我们是通过点击鼠标来触发事件，但是如果我们直接在代码中触发事件，会发生什么事呢？</p><pre><code class="javascript">// 其他代码不变inner.click(); // 在代码中派发事件</code></pre><p>打印结果：</p><pre><code>clickclickpromisemutatepromisetimeouttimeout</code></pre><p>为什么差距这么大，哪里影响了代码的执行顺序？实际上是我们触发事件的方式引起的区别（废话），当直接在代码中触发事件的时候，此时js主执行栈并不是空的，因此不会先去执行微任务宏任务队列中的任务，再去触发<code>outer element</code>的点击事件，而是直接触发<code>outer element</code>的点击事件，当主执行栈没有任务的时候，再去执行微任务宏任务队列中的任务。</p><p>为什么<code>mutate</code>只打印了一次，那是因为<code>MutationObserver</code>的监听是异步触发，在所有的DOM操作完成后才触发使回调函数进入微任务队列。</p><p>比如，程序中有10个修改DOM的操作，只有在第十个处理完之后，回调函数才进入微任务队列。</p><p>通过动画就一目了然了：<br><img src="/images/eventloop3.gif"></p><h1 id="async-await的事件循环"><a href="#async-await的事件循环" class="headerlink" title="async&#x2F;await的事件循环"></a>async&#x2F;await的事件循环</h1><pre><code class="javascript">async function async1() &#123;    console.log( &#39;async1 start&#39; )     await async2()    console.log( &#39;async1 end&#39; )&#125;async function async2() &#123;    console.log( &#39;async2&#39; )&#125;console.log( &#39;script start&#39; )setTimeout( function () &#123;    console.log( &#39;setTimeout&#39; )&#125;, 0 )async1();new Promise(function ( resolve ) &#123;    console.log( &#39;promise1&#39; )    resolve();&#125;).then(function () &#123;    console.log( &#39;promise2&#39; ) &#125;)console.log( &#39;script end&#39; )</code></pre><p>执行结果：</p><pre><code>script startasync1 startasync2promise1script endasync1 endpromise2setTimeout</code></pre><p><code>await</code>之后的代码必须等<code>await</code>语句执行完成后（包括微任务完成），才能执行后面的，也就是说，只有运行完<code>await</code>语句，才把<code>await</code>语句后面的全部代码加入到微任务行列</p><p><code>await</code>语句是同步的，<code>await</code>语句后面全部代码才是异步的微任务<br><img src="/images/eventloop4.png"><br><img src="/images/eventloop5.png"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 作用域链</title>
      <link href="/2023/04/06/JavaScript/js%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2023/04/06/JavaScript/js%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="js-作用域链"><a href="#js-作用域链" class="headerlink" title="js 作用域链"></a>js 作用域链</h1><p>局部变量：在函数中通过var声明的变量。</p><p>全局变量：在函数外通过var声明的变量。</p><p>没有声明就使用的变量，默认为全局变量，不论这个变量在哪被使用。</p><h1 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h1><p>在函数内部定义的变量，为局部变量，局部变量只能在该局部作用域中访问</p><pre><code class="javascript">function fn1() &#123;    var username = &#39;jerry&#39;;    console.log(username);&#125;fn1()   // jerry</code></pre><span id="more"></span><p>此时在全局访问username，则会报错</p><pre><code class="javascript"> console.log(username);  // 报错，username未定义</code></pre><h1 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h1><p>函数内部和外部都可以访问该变量</p><pre><code class="javascript">var age = 12;function fn2() &#123;    console.log(age);&#125;fn2()     // 12console.log(age);  // 12</code></pre><p>如果在函数内部没有使用var定义变量，那么 gender &#x3D; ‘male’;就是个赋值语句，会找到最近的定义的变量进行赋值（注意变量提升），如果都没找到，则为全局变量</p><pre><code class="javascript">function fn3() &#123;    gender = &#39;male&#39;;    console.log(gender);&#125;fn3();</code></pre><p>如果上面的函数没有调用，那么在外面使用gender会报错，因为在 <code>fn3()</code> 被第一次调用之前， <code>gender</code>变量是不存在的。<code>fn3()</code> 被调用过之后，gender成为全局变量</p><h1 id="多层函数嵌套"><a href="#多层函数嵌套" class="headerlink" title="多层函数嵌套"></a>多层函数嵌套</h1><p>如果内层函数没有使用var定义变量，则可以看做是赋值语句，会向上层依次找到该变量的定义语句，并赋值给它,如果向上找都没有没找到，则为全局变量</p><p>这里在<code>fn5</code>函数这个作用域中没有找到<code>num</code>，则向上查找，找到<code>fn4</code>作用域中的<code>num</code>，赋值为<code>100</code>，则下面的<code>fn4里在fn5调用后的num</code>是<code>100</code></p><pre><code class="javascript">var num = 1;function fn4() &#123;    var num = 10    console.log(&#39;fn4里在fn5调用前的num &#39; + num);    function fn5() &#123;        num = 100        console.log(&#39;fn5里的num &#39; + num);    &#125;    fn5()    console.log(&#39;fn4里在fn5调用后的num &#39; + num);&#125;fn4()console.log(&#39;全局的num &#39; + num);</code></pre><p>输出结果:</p><pre><code>fn4里在fn5调用前的num 10fn5里的num 100fn4里在fn5调用后的num 100全局的num 1</code></pre><hr><p>这里在<code>fn5</code>函数内部的<code>num = 100</code>后面加了一个<code>var num = 200</code>，此时由于存在变量提升，<code>num</code>定义提升到函数顶部，并初始化为<code>undefined</code>，然后赋值<code>num = 100</code>（这里赋值的是<code>fn5</code>函数内部提升的<code>num</code>），再赋值<code>num = 200</code>，因此<code>fn5里的num</code>输出200，而<code>fn4里在fn5调用后的num</code>输出10</p><pre><code class="javascript">var num = 1;function fn4() &#123;    var num = 10    console.log(&#39;fn4里在fn5调用前的num &#39; + num);    function fn5() &#123;        num = 100        var num = 200        console.log(&#39;fn5里的num &#39; + num);    &#125;    fn5()    console.log(&#39;fn4里在fn5调用后的num &#39; + num);&#125;fn4()console.log(&#39;全局的num &#39; + num);</code></pre><p>输出结果:</p><pre><code>fn4里在fn5调用前的num 10fn5里的num 200fn4里在fn5调用后的num 10全局的num 1</code></pre><hr><p>这里在<code>fn5</code>函数内部的<code>num = 100</code>后面加了一个<code>let num = 200</code>，此时由于存在变量提升，<code>num</code>定义提升到函数顶部，但并不会初始化为<code>undefined</code><strong>（这是由于let的变量提升和var的变量提升有差异导致的）</strong>，此时<code>num</code>提升之后，执行<code>num = 100</code>，但是由于仅仅提升了变声声明，这个时候并没有初始化为<code>undefined</code>，因此会报错<code>Uncaught ReferenceError: Cannot access &#39;num&#39; before initialization</code></p><pre><code class="javascript">var num = 1;function fn4() &#123;    var num = 10    console.log(&#39;fn4里在fn5调用前的num &#39; + num);    function fn5() &#123;        num = 100        let num = 200        console.log(&#39;fn5里的num &#39; + num);    &#125;    fn5()    console.log(&#39;fn4里在fn5调用后的num &#39; + num);&#125;fn4()console.log(&#39;全局的num &#39; + num);</code></pre><p>输出结果:</p><pre><code>fn4里在fn5调用前的num 10报错: `Uncaught ReferenceError: Cannot access &#39;num&#39; before initialization`</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 伪数组</title>
      <link href="/2023/04/06/JavaScript/js%20%E4%BC%AA%E6%95%B0%E7%BB%84/"/>
      <url>/2023/04/06/JavaScript/js%20%E4%BC%AA%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="js-伪数组"><a href="#js-伪数组" class="headerlink" title="js 伪数组"></a>js 伪数组</h1><p>在js中，通过document的查询元素api查出来NodeList对象或者<code>arguments</code>等都会以伪数组的方式输出，例如下面的html中，通过<code>document.getElementsByTagName(&#39;li&#39;);</code>查出来的就是伪数组，伪数组和数组都具有length属性，但是伪数组不预备数组的<code>pop</code>、<code>push</code>、<code>slice</code>等方法</p><pre><code class="html">&lt;ul&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;</code></pre><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%84.png"></p><span id="more"></span><p>我们使用查出来的结果进行数组的操作，会报错，例如：</p><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%841.png"></p><p>如果我们想要正常操作该数组，则需要将伪数组转为数组，再进行操作。</p><p>伪数组转数组的方式有很多种，下面介绍几种常用的</p><ul><li><code>Array.prototype.slice.call()</code>或者<code>[].slice.call()</code></li></ul><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%842.png"></p><blockquote><p><code>Array.prototype.slice.call()</code>和<code>[].slice.call()</code>其实是一个东西，都是调用数组原型上的slice方法</p></blockquote><ul><li><code>Array.from()</code></li></ul><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%843.png"></p><ul><li>es6 解构赋值</li></ul><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%844.png"></p><ul><li>其他方法<br>例如使用循环，将伪数组一个个push到一个空数组里，也可以进行转化，这种比较繁琐，一般不常用</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 函数参数以及内置参数arguments</title>
      <link href="/2023/04/06/JavaScript/js%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%86%85%E7%BD%AE%E5%8F%82%E6%95%B0arguments/"/>
      <url>/2023/04/06/JavaScript/js%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%86%85%E7%BD%AE%E5%8F%82%E6%95%B0arguments/</url>
      
        <content type="html"><![CDATA[<h1 id="js-函数参数以及内置参数arguments"><a href="#js-函数参数以及内置参数arguments" class="headerlink" title="js 函数参数以及内置参数arguments"></a>js 函数参数以及内置参数arguments</h1><h1 id="普通传参"><a href="#普通传参" class="headerlink" title="普通传参"></a>普通传参</h1><ul><li><code>ES5</code>中如果函数在调用时如果未提供隐式参数（实参），参数会默认设置为<code>undefined</code></li><li>实参比形参多的时候，多出来的直接被忽略</li></ul><pre><code class="javascript">function getSum(a, b, c) &#123;    console.log(a + b + c);&#125;let res1 = getSum(1, 2)         // NaN，形参c没有赋值，为undefined，结果是 1 + 2 + undefined ,NaNlet res2 = getSum(1, 2, 3, 4)   // 实参比形参多的时候，多出来的直接被忽略</code></pre><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>默认参数，<code>ES5</code>中不值吃形参直接定义默认参数，需要自己再函数体中自己判断</p><pre><code class="javascript">function fn1(x, y) &#123;    if (y === undefined) &#123;        y = 0;    &#125;&#125;// 或者function fn2(x, y) &#123;    y = y || 0;&#125;</code></pre><p>在<code>ES6</code>中，可以在形参中直接设置默认参数；</p><pre><code class="javascript">function sumAll(a, b = 10) &#123;    console.log(a + b);&#125;sumAll(2, 2);       // 输出4，此时a = 2，b = 10sumAll(2);          // 输出12，此时a = 2，b = 10（取默认值）；</code></pre><span id="more"></span><h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><p><code>JavaScript</code> 函数有个内置的对象<code>arguments</code>对象。<code>argument</code> 对象包含了函数调用的参数数组。<code>arguments</code>是一个伪数组，具有数组特性的<code>arguments</code>对象</p><pre><code class="javascript">function fn3() &#123;    console.log(arguments);   // Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]    for (let i = 0; i &lt; arguments.length; i++) &#123;        console.log(arguments[i]);   // 1, 2, 3    &#125;&#125;fn3(1, 2, 3)</code></pre><p>通过这种方式你可以很方便的找到最大的一个参数的值。</p><pre><code class="javascript">function findMax() &#123;    var i, max = arguments[0];    if (arguments.length &lt; 2) return max;    for (i = 0; i &lt; arguments.length; i++) &#123;        if (arguments[i] &gt; max) &#123;            max = arguments[i];        &#125;    &#125;    return max;&#125;let res = findMax(1, 123, 500, 115, 44, 88);console.log(res); // 500</code></pre><p><code>arguments</code>是一个伪数组，只有一个<code>length</code>属性，不能使用数组的一些方法，使用<code>Array.prototype.slice.call()</code>方法可以把伪数组对象变成一个真正的数组(注意此方法转换的对象必须要有<code>length</code>属性)</p><pre><code class="javascript">function fn() &#123;    console.log([].slice.call(arguments));&#125;fn(1, 2, 3)</code></pre><p>如果在参数中传递<code>...args</code>，表示剩余参数，保存在一个数组里面，如果有像下面的形式，那么将会把第一个参数给到<code>x</code>，其他的再保存在<code>args</code>数组里面</p><pre><code class="javascript">function fn1(x, ...args) &#123;    console.log(x);     // 1    console.log(args);  // [2, 3]&#125;fn1(1, 2, 3)</code></pre><p>解构参数</p><pre><code class="javascript">function fn2(...args) &#123;    console.log(args);  // [1, 2, 3, 4, 5, 6]&#125;let args1 = [1, 2, 3]let args2 = [4, 5, 6]fn2(...args1, ...args2)    // 参数解构// console.log(...[1, 2, 3]);  // 1, 2, 3</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 函数柯里化</title>
      <link href="/2023/04/06/JavaScript/js%20%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2023/04/06/JavaScript/js%20%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="js-函数柯里化"><a href="#js-函数柯里化" class="headerlink" title="js 函数柯里化"></a>js 函数柯里化</h1><h1 id="什么是函数柯里化"><a href="#什么是函数柯里化" class="headerlink" title="什么是函数柯里化"></a>什么是函数柯里化</h1><p>维基百科上说道：柯里化，英语：<code>Currying</code>(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><p>通过一个简单的例子解释下，比如有一个函数：</p><pre><code class="javascript">function addFn (x, y, z) &#123;  return x + y + z&#125;</code></pre><p>正常函数的调用是：</p><pre><code class="javascript">addFn(1, 2, 3)</code></pre><p>而柯里化后的函数调用应该像这样：</p><pre><code class="javascript">addFn(1)(2)(3)// 或者addFn(1, 2)(3)// 又或者addFn(1)(2, 3)</code></pre><span id="more"></span><p>这样怎么实现呢，通过简单的2个参数的加法函数演示一下，当然这是最简单的，调用的方式也只能传单个参数；</p><pre><code class="javascript">function curryAdd (x) &#123;  return function (y) &#123;    return x + y  &#125;&#125;curryAdd(1)(2)    // 3    </code></pre><p>那么我们怎么怎么把一个普通的函数转换成形如上述<code>curryAdd</code>函数的样子呢，这就需要我们进行函数的柯里化，将一个多参数的函数转变称为能够像链式调用那样的函数；</p><p>抽象上面的<code>curryAdd</code>高阶函数，先假设只调用两层（<code>fn(1)(2)</code>），也可以理解为被柯里化的函数只有两个参数，我们最多只能返回两层，<code>args1</code>是<code>currying</code>函数本身的参数，<code>args2</code>是第一层的参数<code>1</code>，<code>args3</code>是第二层的参数<code>2</code></p><pre><code class="javascript">function addFn (x, y) &#123;  return x + y&#125;function currying (fn, ...args1) &#123;  console.log(args1, &#39;args1&#39;)   // 由于没有传参这里是[]  return function (...args2) &#123;    console.log(args2, &#39;args2&#39;) // 这里是[1]    return function(...args3) &#123;      console.log(args3, &#39;args3&#39;) // 这里是 [2]      // 然后把接收到的所有参数，交由fn函数处理，然后返回      return  fn(...args1, ...args2, ...args3)    &#125;  &#125;&#125;let fn = curry(addFn)console.log(fn(1)(2))  // 3</code></pre><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>问题来了，我们不可能有多少个参数就写多少层吧，我们需要定义一个柯里化函数，来进行函数的柯里化，具备通用性，无论多少参数都能进行转化；</p><p>我们可以利用函数上的特殊属性<code>length</code>来进行处理，这个是函数参数的个数，比如我们定义一个函数<code>foo(a, b, c)</code>，<code>foo.length</code> 就是函数入参的个数<code>3</code></p><p>由于我们不知道具体有多少个参数，因此需要递归来进行处理，如果传入的参数没有超过函数入参的个数，就再次调用自己，进行下一轮的柯里化，直到传入的参数等于函数入参的个数</p><p>代码如下：</p><pre><code class="javascript">function simpleCurrying(fn, ...args) &#123;  // 如果传入的参数已经大于函数可以处理的长度，则直接抛出错误  if (args.length &gt; fn.length) &#123;    throw new Error(&#39;参数超出可处理范围&#39;)  &#125;  // 一旦传入的参数等于了函数可以处理的长度，则调用fn进行处理  if (args.length === fn.length) &#123;    return fn(...args)  &#125;  // 否则继续调用自己，注意需要在外层接收下一次调用的入参，并合并到上一次的参数中，否则参数会丢失  return function(...args2) &#123;    return simpleCurrying(fn, ...args, ...args2)  &#125;&#125;</code></pre><p>让我们来测试一下：</p><pre><code class="javascript">function add (a, b, c, d) &#123;  return a + b + c + d&#125;let sc = simpleCurry(add);sc(1, 2, 3, 4)  // 10sc(1, 2)(3)(4)  // 10sc(1, 2, 3)(4)  // 10sc(1, 2)(3, 4)  // 10sc(1, 2, 3, 4, 5) // ERROR 参数超出可处理范围</code></pre><p>当然我们的例子还有许多需要优化的地方，而<a href="https://www.lodashjs.com/docs/lodash.curry">lodash.curry</a>也提供了柯里化函数的方法，可以直接使用；</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 原型、原型链、继承</title>
      <link href="/2023/04/06/JavaScript/js%20%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/04/06/JavaScript/js%20%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="js-原型、原型链、继承"><a href="#js-原型、原型链、继承" class="headerlink" title="js 原型、原型链、继承"></a>js 原型、原型链、继承</h1><p>在<code>JavaScript</code>中，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript的对象中都包含了一个<code>[[Prototype]]</code>内部属性，这个属性所对应的就是该对象的原型。<br><code>[[Prototype]]</code>作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了<code>__proto__</code>这个非标准（不是所有浏览器都支持）的访问器（ECMA引入了标准对象原型访问器<code>Object.getPrototype(object)</code>）。在<code>JavaScript</code>的原型对象中，还包含一个<code>constructor</code>属性，这个属性对应创建所有指向该原型的实例的构造函数</p><span id="more"></span><h1 id="原型对象，对象原型"><a href="#原型对象，对象原型" class="headerlink" title="原型对象，对象原型"></a>原型对象，对象原型</h1><p>构造函数，实例，原型对象三者的关系可以使用一张图来理解<br><img src="/images/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png"></p><h2 id="原型对象prototype"><a href="#原型对象prototype" class="headerlink" title="原型对象prototype"></a>原型对象<code>prototype</code></h2><p>每一个构造函数都有一个属性<code>prototype</code>，我们也称之为原型对象，原型对象另外开辟一个内存空间，用来存放方法，作用是为了共享方法，从而达到节省内存</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;Person.prototype.eat = function () &#123;    console.log(&#39;吃饭&#39;);&#125;;let jerry = new Person(&#39;jerry&#39;, 18);jerry.eat();// 实例对象有一个__proto__属性，可以指向该实例对象的构造函数的原型对象console.log(jerry.__proto__);console.log(Person.prototype);console.log(jerry.__proto__ === Person.prototype);      // true</code></pre><h2 id="原型对象属性constructor"><a href="#原型对象属性constructor" class="headerlink" title="原型对象属性constructor"></a>原型对象属性<code>constructor</code></h2><p>原型对象上有个属性<code>constructor</code>，用来指向该原型对象的构造函数</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;// 这里指向的就是Person构造函数console.log(Person.prototype.constructor === Person);   // true</code></pre><p>可以通过<code>Person.prototype.run = function()&#123;&#125;</code>的方式添加方法<br>以这种方式创建方法的话，原型对象上其中有个自带的属性<code>constructor</code>，用来指向原型对象的构造函数</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;Person.prototype.sing = function () &#123;    console.log(&#39;sing&#39;);&#125;Person.prototype.jump = function () &#123;    console.log(&#39;jump&#39;);&#125;console.log(Person.prototype);</code></pre><p>另外一种创建方法的方式，这种方式创建会覆盖原有的原型对象，且原型对象上的<code>constructor</code>属性也会没有，所以必须重新将<code>constructor</code>指向构造函数</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;Person.prototype = &#123;    rap: function () &#123;        console.log(&#39;rap&#39;);    &#125;,    basketball: function () &#123;        console.log(&#39;basketball&#39;);    &#125;,    // 重新指向构造函数    constructor: Person,&#125;console.log(Person.prototype);</code></pre><h2 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型__proto__"></a>对象原型<code>__proto__</code></h2><p>实例对象有一个属性，可以指向该实例对象的构造函数的原型对象</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;let jerry = new Person(&#39;jerry&#39;, 18);// 实例对象有一个属性，可以指向该实例对象的构造函数的原型对象console.log(jerry.__proto__);console.log(Person.prototype);console.log(jerry.__proto__ === Person.prototype);      // true</code></pre><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。<br>如果没有就查找它的原型（也就是<code>__proto__</code>指向的<code>prototype</code>原型对象）。<br>如果还没有就查找原型对象的原型（<code>Object</code>的原型对象）。<br>依此类推一直找到<code>Object</code> 为止（<code>null</code>）。<br><code>__proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</p><pre><code class="javascript">function Person(name, age) &#123;    this.name = name;    this.age = age;&#125;let jerry = new Person(&#39;jerry&#39;, 18);// Person.prototype指向Person构造函数的原型对象// jerry.__proto__也指向Person构造函数的原型对象// 原型对象也是对象，也有__proto__方法，原型对象的原型对象是Objectconsole.log(Person.prototype.__proto__);// Object原型对象的构造函数是Object()构造函数console.log(Person.prototype.__proto__.constructor);// 在往上找Object原型对象的原型对象，是null，这个就是原型链的顶端，并不是无限下去的console.log(Person.prototype.__proto__.__proto__);</code></pre><h2 id="对象的原型链"><a href="#对象的原型链" class="headerlink" title="对象的原型链"></a>对象的原型链</h2><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.png"></p><h2 id="构造函数的原型链"><a href="#构造函数的原型链" class="headerlink" title="构造函数的原型链"></a>构造函数的原型链</h2><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg"></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><pre><code class="javascript">// 原型链继承，定义一个父类function Father(name) &#123;  this.fatherName = [name]&#125;// 父类定义一个方法Father.prototype.printFatherName = function () &#123;  console.log(this.fatherName);&#125;// 定义一个子类function Son(name) &#123;  this.sonName = name&#125;// 把子类的原型对象指向父类的实例Son.prototype = new Father(&#39;Father&#39;)// 由于覆盖了原有的prototype，需要将它上面的constructor指向子类，否则原型链就会混乱Son.prototype.constructor = SonSon.prototype.printSonName = function () &#123;  console.log(this.sonName);&#125;// 实例化子类，此时子类就继承了父类的printFatherName方法（原型链方法会向上查找）let s = new Son(&#39;Son&#39;)s.printFatherName()             // [&quot;Father&quot;]s.printSonName()                // Sonconsole.log(s.fatherName);      // [&quot;Father&quot;]console.log(s.sonName);         // Son// 原型链继承的缺陷，对于引用数据类型，如果Son有多个实例，其中一个实例对继承的父类属性做了修改，那么所有实例都会随之修改let s1 = new Son(&#39;Son1&#39;)s1.printFatherName()            // [&quot;Father&quot;]s1.printSonName()               // Son1console.log(s1.fatherName);     // [&quot;Father&quot;]console.log(s1.sonName);        // Son1s.fatherName.push(&#39;newName&#39;)    // s 对继承的属性做了修改，此时 s1 也会随之修改console.log(s.fatherName);      // [&quot;Father&quot;, &quot;newName&quot;]console.log(s1.fatherName);     // [&quot;Father&quot;, &quot;newName&quot;]</code></pre><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF.jpg"></p><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>使用<code>call</code>改变了<code>this</code>指向的继承方式，称为构造函数继承</p><pre><code class="javascript">function Father(name) &#123;  this.fatherName = [name]&#125;Father.prototype.printFatherName = function () &#123;  console.log(this.fatherName);&#125;function Son(name) &#123;  // 使用call改变了this指向，  // 调用Father函数就相当于是把函数执行了一遍，在子类里面创建了一个和父类相同的属性，但是this是指向的子类实例  Father.call(this, name)&#125;let s = new Son(&#39;Son&#39;)console.log(s.fatherName);let s1 = new Son(&#39;Son1&#39;)console.log(s1.fatherName);// 解决了多个子类修改父类属性造成同步更改的问题s.fatherName.push(&#39;newName&#39;)console.log(s.fatherName);      // [&quot;Son&quot;, &quot;newName&quot;]console.log(s1.fatherName);     // [&quot;Son1&quot;]// 但是又有个问题就是子类无法继承父类的方法s.printFatherName()             // 报错  Uncaught TypeError: s.printFatherName is not a function</code></pre><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>把原型链继承和构造函数继承结合使用，就是组合继承</p><pre><code class="javascript">function Father(name) &#123;  this.name = name  this.arr = [1, 2, 3]&#125;Father.prototype.printName = function () &#123;  console.log(this.name);&#125;// 构造函数继承父类的方法和属性function Son(name, age) &#123;  Father.call(this, name)  this.age = age&#125;// 原型链继承父类原型上的方式和属性Son.prototype = new Father()Son.prototype.constructor = SonSon.prototype.printSonAge = function () &#123;  console.log(this.age);&#125;let s = new Son(&#39;son&#39;, 18)s.printSonAge()s.printName()console.log(s.arr);s.arr.push(4)// 可以调用父类原型上面的方法，实例的属性修改也不会影响其他实例的属性let s1 = new Son(&#39;son1&#39;, 20)s1.printSonAge()s1.printName()console.log(s.arr);       // [1, 2, 3, 4]console.log(s1.arr);      // [1, 2, 3 ]// 缺点：会调用两次父类的构造函数，第一次是在 new Faher() 的时候， 第二次是在new Son()的时候（new Son() 里面会执行 Father.call）// 因此实例的原型对象上会有两份相同的属性，解决这个问题可以用寄生组合继承</code></pre><p><img src="/images/%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF.png"></p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><pre><code class="javascript">let Father = &#123;  name: &#39;Father&#39;,  friends: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],  printName: function () &#123; console.log(this.name); &#125;&#125;// 原型式继承原理是，创建一个中间实例，中间实例的原型指向父类（这个父类此时是一个对象的实例）// 这个函数是Object.create函数的模拟实现function createObj(obj) &#123;  function F() &#123; &#125;  F.prototype = obj  return new F()&#125;let Son1 = createObj(Father)let Son2 = createObj(Father)// 使用下面Object.create()函数是一样的// let Son1 = Object.create(Father)// let Son2 = Object.create(Father)// 这里修改name值，并不是修改了原型上的name，而是给自己身上加了一个name属性Son1.name = &#39;Son1&#39;Son2.name = &#39;Son2&#39;Son1.printName()Son2.printName()// 缺点：原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。Son1.friends.push(&#39;D&#39;)console.log(Son1.friends);  // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(Son2.friends);  // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</code></pre><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><pre><code class="javascript">let Father = &#123;  name: &#39;Father&#39;,  friends: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],  printName: function () &#123; console.log(this.name); &#125;&#125;// 寄生式继承主要用来增强对象function createObj(obj) &#123;  var clone = Object.create(obj)  clone.printAge = function () &#123; console.log(this.age); &#125;  return clone&#125;let son1 = createObj(Father)son1.name = &#39;jerry&#39;son1.age = 18son1.printName()son1.printAge()let son2 = createObj(Father)son2.age = 20son2.printName()son2.printAge()</code></pre><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>寄生组合继承应该算是es5中最完美的继承方式</p><pre><code class="javascript">function Father(name) &#123;  this.name = name  this.friends = [&#39;A&#39;, &#39;B&#39;]&#125;Father.prototype.printName = function () &#123;  console.log(this.name);&#125;function Son(name, age) &#123;  Father.call(this, name)  this.age = age&#125;// 创建一个中间函数let tempFunc = function () &#123; &#125;// 中间函数的prototype指向Father的原型对象tempFunc.prototype = Father.prototype// 子类的prototype指向中间函数的实例Son.prototype = new tempFunc()// 修正constructor指针Son.prototype.constructor = Son// 子类增加一个方法，对其他继承Father的子类没有影响Son.prototype.printAge = function () &#123; console.log(this.age); &#125;let son1 = new Son(&#39;jerry&#39;, 18)son1.printName()  // jerryson1.printAge()   // 18let son2 = new Son(&#39;tom&#39;, 20)son2.printName()  // tomson2.printAge()   // 20son1.friends.push(&#39;D&#39;)console.log(son1.friends);  // [&quot;A&quot;, &quot;B&quot;, &quot;D&quot;]console.log(son2.friends);  // [&quot;A&quot;, &quot;B&quot;]// 有人要问，为什么不能直接Son.prototype = Father.prototype，// 这是因为如果多个子类，都指向同一个父类的prototype，子类的独立性就没有了，// 如果其中一个子类对原型上面的东西做了修改，其他所有子类都会发生变化// 其他子类function Child(name, age) &#123;  Father.call(this, name)  this.age = age&#125;let F = function () &#123; &#125;F.prototype = Father.prototypeChild.prototype = new F()Child.prototype.constructor = Child// 子类的原型上添加属性或方法，不会影响其他子类Child.prototype.printAge = function () &#123; console.log(&#39;child age&#39;, this.age); &#125;let c1 = new Child(&#39;child1&#39;, 22)c1.printName()  // child1c1.printAge()   // child age 22</code></pre><p><img src="/images/%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF.jpg"></p><h1 id="ES6-class-继承"><a href="#ES6-class-继承" class="headerlink" title="ES6 class 继承"></a>ES6 class 继承</h1><p>先看一个简单的例子</p><pre><code class="javascript">class Father &#123;    constructor(name, age) &#123;        this.name = name;        this.age = age;    &#125;    run() &#123;        console.log(&#39;I\&#39;m running, by father&#39;);    &#125;&#125;class Son extends Father &#123;    constructor(name, age, birth) &#123;        super(name, age);        this.birth = birth;    &#125;;    run() &#123;        super.run();    &#125;    fly() &#123;        console.log(&#39;I\&#39;m flying&#39;);    &#125;&#125;let son = new Son(&#39;jerry&#39;, 18, &#39;2000&#39;);console.log(son.name);  // jerryconsole.log(son.age);   // 18son.run();              // I&#39;m running, by fatherson.fly();              // I&#39;m flying</code></pre><p>一个稍微复杂的例子</p><pre><code class="javascript">class fatherCalculator &#123;    constructor(num1, num2) &#123;        this.num1 = num1;        this.num2 = num2;    &#125;;    sum() &#123;        return this.num1 + this.num2;    &#125;    multiply() &#123;        return this.num1 * this.num2;    &#125;    log() &#123;        return [this.num1, this.num2];    &#125;&#125;let cal = new fatherCalculator(1, 2);console.log(cal.sum());;    // 3// super关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数// super关键字指向当前对象的原型对象， sonCalculator.prototype 指向的是 fatherCalculatorclass sonCalculator extends fatherCalculator &#123;    constructor(num1, num2) &#123;        super(num1, num2);    &#125;;    sum() &#123;        return super.sum()    &#125;;    reduce() &#123;        return this.num1 - this.num2;    &#125;&#125;let cal2 = new sonCalculator(3, 4);console.log(cal2);console.log(cal2.sum());    // 7console.log(cal2.reduce()); // -1// 如果子类中没有方法，会向父类中去找，就近原则console.log(cal2.multiply());  // 12// 当子类没有constructor的时候可以随意用父类的，但是如果子类也含有的话，constructor会返回实例，this的指向不同，不可以再直接使用父类的东西class son extends fatherCalculator &#123; &#125;;let cal3 = new son(10, 10);console.log(cal3.sum());    // 20class son1 extends fatherCalculator &#123;    constructor(a, b, c) &#123;  // 前两个参数是父类构造函数中的参数，无法在子类中拿到，但是可以调用父类的方法来获取到        super(a, b)         // 子类constructor中必须先使用super，否则报错继承 Uncaught ReferenceError: Must call super constructor in derived class before accessing &#39;this&#39; or returning from derived constructor        this.c = c    &#125;    log() &#123;        // 在子类中无法直接拿到父类中的属性，但是可以在父类中暴露api，子类中进行获取        console.log(super.log());               // [1, 2]          // 这里无法拿到a, b参数，只能拿到自己的属性c        console.log(this.a, this.b, this.c);    // undefined undefined 33        return [super.sum(), this.c]      &#125;&#125;let cal4 = new son1(1, 2, 33)console.log(cal4.log());    // [3, 33]</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 引用数据类型和值数据类型</title>
      <link href="/2023/04/06/JavaScript/js%20%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/04/06/JavaScript/js%20%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="js-引用数据类型和值数据类型"><a href="#js-引用数据类型和值数据类型" class="headerlink" title="js 引用数据类型和值数据类型"></a>js 引用数据类型和值数据类型</h1><p>引用数据类型：对象(Object)、数组(Array)、函数(Function)、正则(RegExp)、日期(Date)等</p><p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p><p>栈内存中保存了变量标识符和指向堆内存中该对象的指针，堆内存中保存了对象的内容</p><p>值数据类型存放在栈中，而引用数据类型存放在堆中，栈中存放的是对象的引用内存地址</p><p>如果变量引用了同一块内存地址，修改其中一个变量的值，其他变量也会跟着修改</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><pre><code class="javascript">let obj1 = obj2 = &#123; name: &#39;jerry&#39;, age: 2 &#125;;obj2[&#39;age&#39;] = 10;console.log(obj1, obj2); // &#123;name: &quot;jerry&quot;, age: 10&#125; &#123;name: &quot;jerry&quot;, age: 10&#125;</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><pre><code class="javascript">let arr1 = [1, 2, 3];let arr2 = arr1;arr2[0] = 999;console.log(arr1, arr2);  // [999, 2, 3]  [999, 2, 3]</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数在js中是一个对象，函数体是保存在函数对象的属性上的，可以使用valueOf修改函数体</p><pre><code class="javascript">let f1 = function () &#123; console.log(&#39;function&#39;); &#125;let f2 = f1f2.valueOf = function () &#123; return &#39;new funciton&#39; &#125;console.log(f1.valueOf()); // new funcitonconsole.log(f2.valueOf()); // new funciton</code></pre><p>栈内存中包括了变量的标识符和变量的值。</p><p>如下所示，其实是分配了两块地址，修改其中一个变量，另一个变量不会随之修改</p><pre><code class="javascript">let str1 = str2 = &#39;hello&#39;;str2 = &#39;world&#39;;console.log(str1, str2);  // hello world</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 箭头函数特性</title>
      <link href="/2023/04/06/JavaScript/js%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/04/06/JavaScript/js%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="js-箭头函数特性"><a href="#js-箭头函数特性" class="headerlink" title="js 箭头函数特性"></a>js 箭头函数特性</h1><ul><li>不能使用<code>new</code>关键字，不能用作构造函数</li><li>箭头函数不能用作<code>generator</code>函数</li><li>箭头函数内部没有内置的<code>arguments</code>参数，通过剩余参数获取</li><li><code>this</code>指向的不是调用者，而是指向箭头函数所在作用域的环境上下文，箭头函数一旦声明，则<code>this</code>的指向就固定了，不会变</li></ul><p>我们先来看看面试中常问到的箭头函数中的<code>this</code>指向问题</p><p>下面的代码中，箭头函数<code>say</code>作为属性，放在<code>obj</code>对象中</p><pre><code class="javascript">let obj = &#123;    username: &#39;jerry&#39;,    say: () =&gt; &#123;        console.log(&#39;this指向：&#39;, this);        console.log(&#39;username&#39;, this.username);    &#125;&#125;</code></pre><p>调用<code>say</code>方法，看看函数输出，并看看<code>this</code>指向哪里</p><pre><code class="javascript">obj.say(); // this指向： window// username undefined</code></pre><p>结果<code>this</code>指向的是<code>window</code>，而不是指向<code>obj</code>，这是因为箭头函数的特殊性，箭头函数所处在的作用域是<code>obj</code>，而<code>obj</code>所存在的环境上下文是<code>window</code>，因此<code>obj</code>内部的<code>this</code>指向<code>window</code>，而此时打印<code>this.username</code>，输出的是<code>window</code>上的<code>username</code>，如果<code>window</code>上有<code>username</code>，则打印相应的值，否则打印<code>undefined</code>;</p><p>再来看另外一个例子</p><pre><code class="javascript">let obj2 = &#123;  username: &#39;tom&#39;,  say: function () &#123;      return () =&gt; &#123;        console.log(&#39;this指向：&#39;, this);        console.log(&#39;username：&#39;, this.username);      &#125;  &#125;&#125;</code></pre><p>调用结果</p><pre><code class="javascript">this指向： &#123;username: &quot;tom&quot;, say: ƒ&#125;username： tom</code></pre><p>结果<code>this</code>指向的<code>obj2</code>对象，此时箭头函数所在的作用是函数<code>say</code>的作用域，而<code>say</code>函数的上下文是在<code>obj2</code>里，因此<code>this</code>指向的是<code>obj2</code>，打印的<code>username</code>是<code>obj2</code>对象的<code>username</code>，即<code>tom</code></p><p>总结：</p><ul><li>箭头函数的<code>this</code>不是由调用者决定，而是在生成的时候就绑定了，在任何地方调用都不会改变箭头函数里的<code>this</code>指向</li><li>箭头函数的this指向的是该箭头函数创建时的作用域的父级上下文环境</li></ul><p>箭头函数其他的一些特性：</p><ul><li>箭头函数不能用作构造函数，不能使用 <code>new</code> 关键字</li><li>箭头函数不能用作<code>generator</code>函数</li><li>箭头函数中没有<code>arguments</code>对象，可以使用<code>...args</code>获取参数</li></ul><pre><code class="javascript">const fun1 = (...args) =&gt; &#123;  console.log(args);      // [1, 2, [3, 4], &#123;num: 5&#125;]  console.log(arguments); // 报错：arguments is not defined&#125;fun1(1, 2, [3, 4], &#123;num: 5&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 防抖和节流</title>
      <link href="/2023/04/06/JavaScript/js%20%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2023/04/06/JavaScript/js%20%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="js-防抖和节流"><a href="#js-防抖和节流" class="headerlink" title="js 防抖和节流"></a>js 防抖和节流</h1><p><code>lodash</code>里面有封装好的现成的方法，可以直接拿来用，下面是自己的实现</p><h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><pre><code class="javascript">/*** @desc   函数防抖      “立即执行版本” 和 “非立即执行版本” 的组合版本* @param  func         需要执行的函数* @param  wait         延迟执行时间（毫秒）* @param  immediate    true表示立即执行 false表示非立即执行 默认false**/function debounce(func, wait, immediate = false) &#123;    let timer;    // 这里用到了闭包，timer本来在debounde函数执行完毕的时候就会被销毁    // 但是下面return的代码中使用了timer，因此不会被销毁，被保留了下来    return function (...args) &#123;        if (timer) clearTimeout(timer);        if (immediate) &#123;            var callNow = !timer;            timer = setTimeout(() =&gt; &#123;                timer = null;            &#125;, wait)            if (callNow) func.apply(this, args)        &#125; else &#123;            timer = setTimeout(() =&gt; &#123;                func.apply(this, args)  // 这里要修改this指向，否则this指向的不是时间出发对象，而是window            &#125;, wait);        &#125;    &#125;&#125;</code></pre><h2 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h2><pre><code class="javascript">/*** @desc  函数节流   “立即执行版本” 和 “非立即执行版本” 的组合版本* @param func      需要执行的函数* @param wait      延迟执行毫秒数* @param immediate true表示立即执行 false表示非立即执行 默认false*/function throttle(func, wait, immediate = false) &#123;    if (immediate) &#123;        var previous = 0;    &#125; else &#123;        var timeout;    &#125;    return function () &#123;        let args = arguments;        if (immediate) &#123;            let now = Date.now();            if (now - previous &gt; wait) &#123;                func.apply(this, args);                previous = now;            &#125;        &#125; else &#123;            if (!timeout) &#123;                timeout = setTimeout(() =&gt; &#123;                    timeout = null;                    func.apply(this, args)                &#125;, wait)            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa + axios + jwt  实现token自动续期</title>
      <link href="/2023/04/06/JavaScript/koa%20+%20axios%20+%20jwt%20%20%E5%AE%9E%E7%8E%B0token%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F/"/>
      <url>/2023/04/06/JavaScript/koa%20+%20axios%20+%20jwt%20%20%E5%AE%9E%E7%8E%B0token%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="koa-axios-jwt-实现token自动续期"><a href="#koa-axios-jwt-实现token自动续期" class="headerlink" title="koa + axios + jwt  实现token自动续期"></a>koa + axios + jwt  实现token自动续期</h1><p><a href="http://baihuzi.com/article/92d64f68-21cc-491c-9340-52d33dbe6392">深入理解token</a>这篇文章详细讲解了token的作用及优势，这篇文章我们通过jwt和koa来简单实现一个自动续期token。</p><p>首先来看看JWT</p><h1 id="Json-web-token-JWT"><a href="#Json-web-token-JWT" class="headerlink" title="Json web token (JWT)"></a>Json web token (JWT)</h1><p><code>Json web token (JWT)</code>, 是为了在网络应用环境间传递声明而执行的一种基于<code>JSON</code>的开放标准<code>(RFC 7519)</code>，该<code>token</code>被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。<code>JWT</code>的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><p>一个完整的<code>JWT</code>长这样</p><pre><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImJhaWh1emkiLCJhZG1pbiI6dHJ1ZSwiYWdlIjoxOCwiaWF0IjoxNjI3NTU4MjU3LCJleHAiOjE2Mjc1NTg4NTd9.FmiN7MoQm8uzGAFXXNve6z3r94JRVFGmCcKWVQyz2T9o-0ovhFRC1eQ6xgFX8AKFMSqMIBs8Yd_rDSXNFqBgQkxkBQEHqQlv4-BjhvxA3W1FpclUtqQfSQx9mWeWDN79RPOV7ayTZ-8e9hDJVqB3hoFZsWddHxens1IKbSEQylZrgEGNJVGbeN2sTNyHvXQoxUzft5E3k2odp5lnS-Fl0dwkrwsBEvQ81cNQio24d4VINBDCcF6nOBii6mEMA9VLBj4j1PDT2BEBgZlCbrvHbsuYCQUljvsHInkRrnySzc4DwiIxzrKEapr8raD--MHH0Iz78__hJrqCZTAxve-iaA</code></pre><span id="more"></span><p>包括三段信息，通过<code>.</code>分隔，第一部分我们称它为头部（<code>header</code>),第二部分我们称其为载荷（<code>payload</code>, 类似于飞机上承载的物品)，第三部分是签名（<code>signature</code>）.</p><h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><p>jwt的头部承载两部分信息：</p><ul><li>声明类型，这里是<code>JWT</code></li><li>声明加密的算法 通常直接使用 <code>HMAC</code>或<code>SHA256</code><br>完整的头部就像下面这样的JSON：</li></ul><pre><code class="javascript">&#123;  &quot;alg&quot;:&quot;RS256&quot;,      // 算法  &quot;typ&quot;:&quot;JWT&quot;         // 类型&#125;</code></pre><p>然后将头部进行<code>base64</code>加密（该加密是可以对称解密的),构成了第一部分.</p><pre><code class="javascript">new Buffer.from(&#39;&#123;&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#39;).toString(&#39;base64&#39;);// eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9</code></pre><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ul><p>标准中注册的声明 (建议但不强制使用)：</p><ul><li>iss: jwt签发者</li><li>sub: jwt所面向的用户</li><li>aud: 接收jwt的一方</li><li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li><li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li><li>iat: jwt的签发时间</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li></ul><p>公共的声明：<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><p>私有的声明 ：<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为<code>base64</code>是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>定义一个payload:</p><pre><code class="javascript">&#123;  &quot;username&quot;:&quot;daryl&quot;,  &quot;age&quot;:18,  &quot;admin&quot;:true&#125;</code></pre><pre><code class="javascript">new Buffer.from(&#39;eyJ1c2VybmFtZSI6ImJhaWh1emkiLCJhZG1pbiI6dHJ1ZSwiYWdlIjoxOCwiaWF0IjoxNjI3NTU4MjU3LCJleHAiOjE2Mjc1NTg4NTd9&#39; , &#39;base64&#39;).toString();// &#123;&quot;username&quot;:&quot;baihuzi&quot;,&quot;admin&quot;:true,&quot;age&quot;:18,&quot;iat&quot;:1627558257,&quot;exp&quot;:1627558857&#125;</code></pre><h2 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h2><p>签名是把<code>header</code>和<code>payload</code>对应的<code>json</code>结构进行<code>base64</code>url编码之后得到的两个串用英文句点号拼接起来，然后根据<code>header</code>里面<code>alg</code>指定的签名算法生成出来的。</p><p>算法不同，签名结果不同。<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以自我签发<code>jwt</code>了。</p><h2 id="JWT的签发与验签"><a href="#JWT的签发与验签" class="headerlink" title="JWT的签发与验签"></a>JWT的签发与验签</h2><p><code>RS256</code>是非对称算法，有一对公私秘钥，需要自己生成，通过私钥进行签名，只有自己签发的才是合法的，防止恶意伪造token，通过公钥进行验签，如果token被修改挥着过期了，验签就会失败</p><pre><code class="javascript">let jwt = require(&#39;jsonwebtoken&#39;);let fs = require(&#39;fs&#39;)let data = &#123;    username: &#39;daryl&#39;,    age: 18,    admin: true&#125;// 用私钥进行签名，用公钥进行验签，防止客户端伪造tokenlet privateKey = fs.readFileSync(&#39;./private.pem&#39;)let token = jwt.sign(data, privateKey, &#123; algorithm: &#39;RS256&#39;, expiresIn: 60 * 10 &#125;);console.log(token)// 用公钥进行验签let publicKey = fs.readFileSync(&#39;./public.pem&#39;)let res = jwt.verify(token, publicKey, &#123; algorithm: &#39;RS256&#39; &#125;)console.log(res);</code></pre><pre><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImRhcnlsIiwiYWdlIjoxOCwiYWRtaW4iOnRydWUsImlhdCI6MTYyNzU3Mzc1MiwiZXhwIjoxNjI3NTc0MzUyfQ.snfD-YTXbCGb7et_BYtmw2FGZQ7wev_DAcdnn-StN13_PSpOw5zEUN7ldsL7_8RFH5m5Mu5Ot6WzdTKgP8JiuZuO-G01QsdECvSeEU3D7r2Yoj2x_H13lZpYpuZ6dgVsKE4CeWDME1MAN1YRwIygkse9Ds614nnfIx6ewRs1FNZXnusEXx4D6T1fMmhLBEcJs5gdFMdSrNQyuJvZtmIyqzY5wYYGfHen1CRmM_cFSq8EcnGgLsR_91S4sDzw3JVfw47rV8vp3OwlvI2Nldz_Zk7C6wLdkPw9VHxCigC4mJZ10tH4ICKU8XpZEzxhHgu7_o_luOOvXGfa6dm4-CrR6A&#123;  username: &#39;daryl&#39;,  age: 18,  admin: true,  iat: 1627573752,  // 签发时间  exp: 1627574352   // 过期时间&#125;</code></pre><h1 id="koa-jwt实现token续期"><a href="#koa-jwt实现token续期" class="headerlink" title="koa-jwt实现token续期"></a>koa-jwt实现token续期</h1><pre><code class="javascript">const Koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;)const betterBody = require(&#39;koa-better-body&#39;);const jwt = require(&#39;jsonwebtoken&#39;)const koaJwt = require(&#39;koa-jwt&#39;)// 假用户数据const user = &#123; username: &#39;jerry&#39;, password: &#39;123456&#39; &#125;// jwt 秘钥，默认使用的是HS256算法，签名和验签使用同一个秘钥const jwtSecret = &#39;sdD(Sdsdfsd^%8ds^^&amp;5s&#39;let app = new Koa()app.listen(8080);// 跨域设置，需要注意的是，要将Authorization头设置到Access-Control-Allow-Headers里面去，否则无法跨域发送Authorization头app.use(async (ctx, next) =&gt; &#123;    ctx.set(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);    ctx.set(&#39;Access-Control-Allow-Headers&#39;, &#39;x-requested-with,content-type,Authorization&#39;)    ctx.set(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT, POST, GET, DELETE, OPTIONS&#39;);    if (ctx.method == &#39;OPTIONS&#39;) &#123;        ctx.set(&quot;Access-Control-Max-Age&quot;, &quot;1728000000&quot;);        ctx.body = &#39;ok&#39;;    &#125; else &#123;        await next();    &#125;&#125;)app.use(betterBody());let router = new Router();// 模拟登录接口，成功就发送token// 发送accessToken 和 refreshToken两个tokenrouter.post(&#39;/login&#39;, async ctx =&gt; &#123;    let &#123; username, password &#125; = ctx.request.fields;    if (!username) &#123;        ctx.body = &#123; code: 201, msg: &#39;用户名不存在&#39; &#125;;    &#125; else &#123;        let &#123; username: name, password: pass &#125; = user        if (username == name &amp;&amp; password == pass) &#123;            let token = createToken(&#123; username &#125;)            ctx.body = &#123; code: 200, msg: &#39;登录成功&#39;, token &#125;        &#125; else &#123;            ctx.body = &#123; code: 202, msg: &#39;用户名或密码错误&#39; &#125;        &#125;    &#125;&#125;)// token自动续期接口router.post(&#39;/refreshToken&#39;, async ctx =&gt; &#123;    let refreshToken = ctx.headers.authorization;    await verifyToken(refreshToken)        .then(async (token) =&gt; &#123;            // 校验成功就重新发送accessToken和refreshToken            let newToken = createToken(&#123; username: token.username &#125;);            // 等待5秒再返回，方便查看效果            await sleep(5000).then(() =&gt; &#123;                ctx.body = &#123; code: 200, msg: &#39;续期成功&#39;, token: newToken &#125;            &#125;)        &#125;)        .catch((e) =&gt; &#123;            ctx.status = 402;            ctx.body = &#123; code: 402, msg: &#39;续期失败，请重新登录&#39; &#125;        &#125;)&#125;)// ---------------------------------koa-jwt----------------------------------// 验证失败时捕获401，返回自定义信息app.use(function (ctx, next) &#123;    return next().catch((err) =&gt; &#123;        if (401 == err.status) &#123;            ctx.status = 401;            ctx.body = &#123; code: 401, msg: &#39;token expired&#39; &#125;;        &#125; else &#123;            throw err;        &#125;    &#125;);&#125;);// 默认校验在请求头中的[ Authorization: Bearer TOKEN ] 头,&#39;Bearer &#39; (后面有一个空格)// token不合法或者过期都会返回401错误// 另外定义在unless中路由不会被校验app.use(koaJwt(&#123; secret: jwtSecret &#125;).unless(&#123; path: [/^\/login/, /^\/refreshToken/] &#125;))// ---------------------------------koa-jwt----------------------------------// 测试接口router.get(&#39;/a&#39;, async ctx =&gt; &#123;    ctx.body = &#123; code: 200, msg: &#39;a&#39; &#125;&#125;)router.get(&#39;/b&#39;, async ctx =&gt; &#123;    ctx.body = &#123; code: 200, msg: &#39;b&#39; &#125;&#125;)router.get(&#39;/c&#39;, async ctx =&gt; &#123;    ctx.body = &#123; code: 200, msg: &#39;c&#39; &#125;&#125;)app.use(router.routes())// 生成token函数function createToken(obj) &#123;    // 为了模拟续期，把token的时效设置短一点，单位是秒    // 生成两个token，accessToken用于接口访问，refreshToken用于请求token续期接口    let accessToken = jwt.sign(obj, jwtSecret, &#123; expiresIn: 15 &#125;)    let refreshToken = jwt.sign(obj, jwtSecret, &#123; expiresIn: 30 &#125;)    return &#123; accessToken, refreshToken &#125;&#125;// 校验refreshToken函数function verifyToken(refreshToken) &#123;    return new Promise((resolve, reject) =&gt; &#123;        jwt.verify(refreshToken.split(&#39; &#39;)[1], jwtSecret, (err, token) =&gt; &#123;            if (err) &#123;                reject(err)            &#125; else &#123;                resolve(token)            &#125;        &#125;)    &#125;)&#125;// 异步延时函数function sleep(time = 0) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve();        &#125;, time);    &#125;)&#125;</code></pre><h1 id="axios实现自动续期"><a href="#axios实现自动续期" class="headerlink" title="axios实现自动续期"></a>axios实现自动续期</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;script src=&quot;./axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;button id=&quot;login&quot;&gt;登录&lt;/button&gt;    &lt;button id=&quot;abc&quot;&gt;同时获取abc&lt;/button&gt;    &lt;script&gt;        let loginBtn = document.querySelector(&#39;#login&#39;);        let requestBtn = document.querySelector(&#39;#abc&#39;);        axios.defaults.baseURL = &#39;http://localhost:8080&#39;        loginBtn.onclick = function () &#123;            axios.post(&#39;/login&#39;, &#123;                username: &#39;jerry&#39;,                password: &#39;123456&#39;            &#125;).then(res =&gt; &#123;                if (res.data.code == 200) &#123;                    localStorage.setItem(&#39;accessToken&#39;, res.data.token.accessToken)                    localStorage.setItem(&#39;refreshToken&#39;, res.data.token.refreshToken)                &#125; else &#123;                    alert(&#39;用户名或密码错误&#39;)                &#125;            &#125;)        &#125;        requestBtn.onclick = function () &#123;            axios.all([axios.get(&#39;/a&#39;), axios.get(&#39;b&#39;), axios.get(&#39;/c&#39;)]).then(axios.spread(function (a, b, c) &#123;                console.log(a.data, b.data, c.data);            &#125;))        &#125;        // 请求拦截器，根据url设置不同的请求token        axios.interceptors.request.use(function (config) &#123;            if (config.url == &#39;/refreshToken&#39;) &#123;                config.headers.Authorization = &#39;Bearer &#39; + localStorage.getItem(&#39;refreshToken&#39;)            &#125; else if (config.url !== &#39;/login&#39;) &#123;                config.headers.Authorization = &#39;Bearer &#39; + localStorage.getItem(&#39;accessToken&#39;)            &#125;            return config;        &#125;, function (error) &#123;            return Promise.reject(error);        &#125;);        // 如果正在请求续期接口，则不再请求了，避免重复请求续期接口        let isRefreshing = false;        // 请求401后，把失败的请求放在这里面，等到token续期后拿出来重新请求        let retryRequests = [];        axios.interceptors.response.use(response =&gt; &#123;            const &#123;code&#125; = response.data;            if (code !== 200) &#123;                return Promise.reject(response)            &#125; else &#123;                return response            &#125;        &#125;, error =&gt; &#123;            if (!error.response) return Promise.reject(error)            // 401 accessToken过期，402 refreshToken过期            if (error.response.data.code === 401) &#123;                const config = error.config                if (!isRefreshing) &#123;                    isRefreshing = true;                    axios.post(&#39;/refreshToken&#39;).then(res =&gt; &#123;                        if (res.data.code == 200) &#123;                            localStorage.setItem(&#39;accessToken&#39;, res.data.token.accessToken)                            localStorage.setItem(&#39;refreshToken&#39;, res.data.token.refreshToken)                            retryRequests.forEach(req =&gt; req())                            retryRequests = []                            return axios(config)                        &#125;                    &#125;).catch(err =&gt; &#123;                        alert(&#39;请重新登录&#39;);                    &#125;).finally(()=&gt;&#123;                        isRefreshing = false;                    &#125;)                &#125; else &#123;                    return new Promise((resolve) =&gt; &#123;                        // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行                        retryRequests.push((newToken) =&gt; &#123;                            resolve(axios(config))                        &#125;)                    &#125;)                &#125;            &#125;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>查看效果：</p><p>可以看到，多个请求<code>401</code>，只会去调用一次<code>refreshToken</code>接口，并且当续期接口成功返回后，之前失败的<code>401</code>请求也会重新请求，当续期接口的<code>token</code>也过期后，会返回<code>402</code>，让用户重新登录；<br><img src="/images/refreshToken.gif"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】深入理解token</title>
      <link href="/2023/04/06/JavaScript/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/"/>
      <url>/2023/04/06/JavaScript/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/</url>
      
        <content type="html"><![CDATA[<h1 id="【转载】深入理解token"><a href="#【转载】深入理解token" class="headerlink" title="【转载】深入理解token"></a>【转载】深入理解token</h1><hr><p>转载自<a href="https://my.oschina.net/jamesfancy/blog/1613994">深入理解token</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p><code>Token</code> 是在服务端产生的。如果前端使用<code>用户名/密码</code>向服务端请求认证，服务端认证成功，那么在服务端会返回 <code>Token</code> 给前端。前端可以在每次请求的时候带上 <code>Token</code> 证明自己的合法地位</p><p>不久前，我在在前后端分离实践中提到了基于 <code>Token</code> 的认证，现在我们稍稍深入一些。</p><p>通常情况下，我们在讨论某个技术的时候，都是从问题开始。那么第一个问题：</p><h1 id="为什么要用-Token？"><a href="#为什么要用-Token？" class="headerlink" title="为什么要用 Token？"></a>为什么要用 Token？</h1><p>而要回答这个问题很简单——因为它能解决问题！</p><p>可以解决哪些问题呢？</p><ol><li><code>Token</code> 完全由应用管理，所以它可以避开同源策略</li><li><code>Token</code> 可以避免 <code>CSRF</code> 攻击(<a href="http://dwz.cn/7joLzx">http://dwz.cn/7joLzx</a>)</li><li><code>Token</code> 可以是无状态的，可以在多个服务间共享</li></ol><p><code>Token</code> 是在服务端产生的。如果前端使用<code>用户名/密码</code>向服务端请求认证，服务端认证成功，那么在服务端会返回 <code>Token</code> 给前端。前端可以在每次请求的时候带上 <code>Token</code> 证明自己的合法地位。如果这个 <code>Token</code> 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。</p><p>于是，又一个问题产生了：需要为 <code>Token</code> 设置有效期吗？</p><span id="more"></span><h1 id="需要设置有效期吗？"><a href="#需要设置有效期吗？" class="headerlink" title="需要设置有效期吗？"></a>需要设置有效期吗？</h1><p>对于这个问题，我们不妨先看两个例子。一个例子是登录密码，一般要求定期改变密码，以防止泄漏，所以密码是有有效期的；另一个例子是安全证书。<code>SSL</code> 安全证书都有有效期，目的是为了解决吊销的问题，对于这个问题的详细情况，来看看<a href="https://www.zhihu.com/question/20803288">知乎的回答</a>。所以无论是从安全的角度考虑，还是从吊销的角度考虑，<code>Token</code> 都需要设有效期。</p><p>那么有效期多长合适呢？</p><p>只能说，根据系统的安全需要，尽可能的短，但也不能短得离谱——想像一下手机的自动熄屏时间，如果设置为 10 秒钟无操作自动熄屏，再次点亮需要输入密码，会不会疯？如果你觉得不会，那就亲自试一试，设置成可以设置的最短时间，坚持一周就好（不排除有人适应这个时间，毕竟手机厂商也是有用户体验研究的）。</p><p>然后新问题产生了，如果用户在正常操作的过程中，<code>Token</code> 过期失效了，要求用户重新登录……用户体验岂不是很糟糕？</p><p>为了解决在操作过程不能让用户感到 <code>Token</code> 失效这个问题，有一种方案是在服务器端保存 <code>Token</code> 状态，用户每次操作都会自动刷新（推迟） <code>Token</code> 的过期时间（<code>Session</code> 就是采用这种策略来保持用户登录状态的）。然而仍然存在这样一个问题，在前后端分离、单页 App 这些情况下，每秒种可能发起很多次请求，每次都去刷新过期时间会产生非常大的代价。如果 <code>Token</code> 的过期时间被持久化到数据库或文件，代价就更大了。所以通常为了提升效率，减少消耗，会把 <code>Token</code> 的过期时保存在缓存或者内存中。</p><p>还有另一种方案，使用 <code>Refresh Token</code>，它可以避免频繁的读写操作。这种方案中，服务端不需要刷新 <code>Token</code> 的过期时间，一旦 <code>Token</code> 过期，就反馈给前端，前端使用 <code>Refresh Token</code> 申请一个全新 <code>Token</code> 继续使用。这种方案中，服务端只需要在客户端请求更新 <code>Token</code> 的时候对 <code>Refresh Token</code> 的有效性进行一次检查，大大减少了更新有效期的操作，也就避免了频繁读写。当然 <code>Refresh Token</code> 也是有有效期的，但是这个有效期就可以长一点了，比如，以天为单位的时间。</p><h1 id="时序图表示"><a href="#时序图表示" class="headerlink" title="时序图表示"></a>时序图表示</h1><p>使用 <code>Token</code> 和 <code>Refresh Token</code> 的时序图如下：</p><p>1）登录<br><img src="/images/token.jpg"></p><p>2）业务请求<br><img src="/images/token2.jpg"></p><p>3）Token 过期，刷新 Token<br><img src="/images/token3.jpg"></p><p>上面的时序图中并未提到 <code>Refresh Token</code> 过期怎么办。不过很显然，<code>Refresh Token</code> 既然已经过期，就该要求用户重新登录了。</p><p>当然还可以把这个机制设计得更复杂一些，比如，<code>Refresh Token</code> 每次使用的时候，都更新它的过期时间，直到与它的创建时间相比，已经超过了非常长的一段时间（比如三个月），这等于是在相当长一段时间内允许 <code>Refresh Token</code> 自动续期。</p><p>到目前为止，<code>Token</code> 都是有状态的，即在服务端需要保存并记录相关属性。那说好的无状态呢，怎么实现？</p><h1 id="无状态-Token"><a href="#无状态-Token" class="headerlink" title="无状态 Token"></a>无状态 Token</h1><p>如果我们把所有状态信息都附加在 <code>Token</code> 上，服务器就可以不保存。但是服务端仍然需要认证 <code>Token</code> 有效。不过只要服务端能确认是自己签发的 <code>Token</code>，而且其信息未被改动过，那就可以认为 <code>Token</code> 有效——“签名”可以作此保证。平时常说的签名都存在一方签发，另一方验证的情况，所以要使用非对称加密算法。但是在这里，签发和验证都是同一方，所以对称加密算法就能达到要求，而对称算法比非对称算法要快得多（可达数十倍差距）。</p><p>更进一步思考，对称加密算法除了加密，还带有还原加密内容的功能，而这一功能在对 <code>Token</code> 签名时并无必要——既然不需要解密，摘要（散列）算法就会更快。可以指定密码的散列算法，自然是 <code>HMAC</code>。</p><p>上面说了这么多，还需要自己去实现吗？不用！<code>JWT</code> 已经定义了详细的规范，而且有各种语言的若干实现。</p><p>不过在使用无状态 <code>Token</code> 的时候在服务端会有一些变化，服务端虽然不保存有效的 <code>Token</code> 了，却需要保存未到期却已注销的 <code>Token</code>。如果一个 <code>Token</code> 未到期就被用户主动注销，那么服务器需要保存这个被注销的 <code>Token</code>，以便下次收到使用这个仍在有效期内的 <code>Token</code> 时判其无效。有没有感到一点沮丧？</p><p>在前端可控的情况下（比如前端和服务端在同一个项目组内），可以协商：前端一但注销成功，就丢掉本地保存（比如保存在内存、<code>LocalStorage</code> 等）的 <code>Token</code> 和 <code>Refresh Token</code>。基于这样的约定，服务器就可以假设收到的 <code>Token</code> 一定是没注销的（因为注销之后前端就不会再使用了）。</p><p>如果前端不可控的情况，仍然可以进行上面的假设，但是这种情况下，需要尽量缩短 <code>Token</code> 的有效期，而且必须在用户主动注销的情况下让 <code>Refresh Token</code> 无效。这个操作存在一定的安全漏洞，因为用户会认为已经注销了，实际上在较短的一段时间内并没有注销。如果应用设计中，这点漏洞并不会造成什么损失，那采用这种策略就是可行的。</p><p>在使用无状态 <code>Token</code> 的时候，有两点需要注意：</p><ol><li><code>Refresh Token</code> 有效时间较长，所以它应该在服务器端有状态，以增强安全性，确保用户注销时可控</li><li>应该考虑使用二次认证来增强敏感操作的安全性</li></ol><p>到此，关于 <code>Token</code> 的话题似乎差不多了——然而并没有，上面说的只是认证服务和业务服务集成在一起的情况，如果是分离的情况呢？</p><h1 id="分离认证服务"><a href="#分离认证服务" class="headerlink" title="分离认证服务"></a>分离认证服务</h1><p>当 <code>Token</code> 无状态之后，单点登录就变得容易了。前端拿到一个有效的 <code>Token</code>，它就可以在任何同一体系的服务上认证通过——只要它们使用同样的密钥和算法来认证 <code>Token</code> 的有效性。就样这样：<br><img src="/images/token4.jpg"></p><p>当然，如果 <code>Token</code> 过期了，前端仍然需要去认证服务更新 <code>Token</code>：<br><img src="/images/token5.jpg"></p><h1 id="不受信的业务服务器"><a href="#不受信的业务服务器" class="headerlink" title="不受信的业务服务器"></a>不受信的业务服务器</h1><p>遇到不受信的业务服务器时，很容易想到的办法是使用不同的密钥。认证服务器使用密钥1签发，业务服务器使用密钥2验证——这是典型非对称加密签名的应用场景。认证服务器自己使用私钥对 <code>Token</code> 签名，公开公钥。信任这个认证服务器的业务服务器保存公钥，用于验证签名。幸好，<code>JWT</code> 不仅可以使用 <code>HMAC</code> 签名，也可以使用 <code>RSA</code>（一种非对称加密算法）签名。</p><p>不过，当业务服务器已经不受信任的时候，多个业务服务器之间使用相同的 <code>Token</code> 对用户来说是不安全的。因为任何一个服务器拿到 <code>Token</code> 都可以仿冒用户去另一个服务器处理业务……悲剧随时可能发生。</p><p>为了防止这种情况发生，就需要在认证服务器产生 <code>Token</code> 的时候，把使用该 <code>Token</code> 的业务服务器的信息记录在 <code>Token</code> 中，这样当另一个业务服务器拿到这个 <code>Token</code> 的时候，发现它并不是自己应该验证的 <code>Token</code>，就可以直接拒绝。</p><p>现在，认证服务器不信任业务服务器，业务服务器相互也不信任，但前端是信任这些服务器的——如果前端不信任，就不会拿 <code>Token</code> 去请求验证。那么为什么会信任？可能是因为这些是同一家公司或者同一个项目中提供的若干服务构成的服务体系。</p><p>但是，前端信任不代表用户信任。如果 <code>Token</code> 不没有携带用户隐私（比如姓名），那么用户不会关心信任问题。但如果 <code>Token</code> 含有用户隐私的时候，用户得关心信任问题了。这时候认证服务就不得不再啰嗦一些，当用户请求 <code>Token</code> 的时候，问上一句，你真的要授权给某某某业务服务吗？而这个“某某某”，用户怎么知道它是不是真的“某某某”呢？用户当然不知道，甚至认证服务也不知道，因为公钥已经公开了，任何一个业务都可以声明自己是“某某某”。</p><p>为了得到用户的信任，认证服务就不得不帮助用户来甄别业务服务。所以，认证服器决定不公开公钥，而是要求业务服务先申请注册并通过审核。只有通过审核的业务服务器才能得到认证服务为它创建的，仅供它使用的公钥。如果该业务服务泄漏公钥带来风险，由该业务服务自行承担。现在认证服务可以清楚的告诉用户，“某某某”服务是什么了。如果用户还是不够信任，认证服务甚至可以问，某某某业务服务需要请求  A、B、C 三项个人数据，其中 A 是必须的，不然它不工作，是否允许授权？如果你授权，我就把你授权的几项数据加密放在 <code>Token</code> 中……</p><p>废话了这么多，有没有似曾相识……对了，这类似开放式 <code>API</code> 的认证过程。开发式 <code>API</code> 多采用 <code>OAuth</code> 认证，而关于 <code>OAuth</code> 的探讨资源非常丰富，这里就不深究了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理一些`Promise`库`bluebird`的常用api</title>
      <link href="/2023/04/06/JavaScript/%E6%95%B4%E7%90%86%E4%B8%80%E4%BA%9B%60Promise%60%E5%BA%93%60bluebird%60%E7%9A%84%E5%B8%B8%E7%94%A8api/"/>
      <url>/2023/04/06/JavaScript/%E6%95%B4%E7%90%86%E4%B8%80%E4%BA%9B%60Promise%60%E5%BA%93%60bluebird%60%E7%9A%84%E5%B8%B8%E7%94%A8api/</url>
      
        <content type="html"><![CDATA[<h1 id="整理一些Promise库bluebird的常用api"><a href="#整理一些Promise库bluebird的常用api" class="headerlink" title="整理一些Promise库bluebird的常用api"></a>整理一些<code>Promise</code>库<code>bluebird</code>的常用api</h1><h1 id="Promis-promisify"><a href="#Promis-promisify" class="headerlink" title="Promis.promisify"></a>Promis.promisify</h1><p><code>promisify</code>可以帮我们吧一些常用异步方法或者库转化成<code>Promise</code>对象，这样我们就不用自己封装了；</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);readFile(&#39;./data/a.txt&#39;).then(data =&gt; console.log(data.toString()));</code></pre><blockquote><p>这里仅做个最简单的介绍，更多详细用法查看官网<a href="http://bluebirdjs.com/docs/features.html">Promis.promisify</a></p></blockquote><span id="more"></span><h1 id="Promise-promisifyAll"><a href="#Promise-promisifyAll" class="headerlink" title="Promise.promisifyAll"></a>Promise.promisifyAll</h1><pre><code class="javascript">const Promise = require(&#39;bluebird&#39;);const fs = Promise.promisifyAll(require(&#39;fs&#39;));fs.readFileAsync(&quot;./data/a.txt&quot;).then(contents =&gt; &#123; // 实际是readFile方法，Async只是Promise.promisifyAll为我们自动添加的后缀，下面会介绍    console.log(contents);&#125;).catch(err =&gt; &#123;    console.error(err);&#125;);</code></pre><p>可以为包装后的函数添加后缀，以区分原始方法，默认的后缀是<code>Async</code></p><pre><code class="javascript">const Promise = require(&#39;bluebird&#39;);const fs = Promise.promisifyAll(require(&#39;fs&#39;), &#123;suffix: &#39;Promise&#39;&#125;);fs.readFilePromise(&quot;./data/a.txt&quot;, &quot;utf8&quot;).then(contents =&gt; &#123;    console.log(contents);&#125;).catch(err =&gt; &#123;    console.error(err);&#125;);</code></pre><blockquote><p>更多用法查看官网<a href="http://bluebirdjs.com/docs/api/promise.promisifyall.html">Promis.promisify</a></p></blockquote><p><code>Promise.promisifyAll</code>可以接受数组，一次性<code>promisify</code>多个类；</p><pre><code class="javascript">var Pool = require(&quot;mysql/lib/Pool&quot;);var Connection = require(&quot;mysql/lib/Connection&quot;);Promise.promisifyAll([Pool, Connection]);</code></pre><h1 id="Cancellation"><a href="#Cancellation" class="headerlink" title="Cancellation"></a>Cancellation</h1><p>javascript中的Promise是不支持取消异步操作的，但是bluebird支持取消异步操作，这个是一个很好的特性，能够帮我们解决很多问题，比如在React中，组件挂载时请求接口，如果在接口返回之前这个组件被卸载了，React会抛出一个异常，我们就可以利用bluebird的这一特性，来帮我们处理这个问题；</p><p>想要使用<code>Cancellation</code>必须配置开启，如下第二行代码，此时Promise就可以取消了，还可以定义取消的回调函数，当取消的时候，执行一些操作。</p><p>注意：<code>.cancel</code>操作是同步的</p><pre><code class="javascript">const Promise = require(&#39;bluebird&#39;);Promise.config(&#123;cancellation: true&#125;);let p1 = new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;p1&#39;), 3000);&#125;)// 第三个参数只有当cancellation配置为true时才有let p2 = new Promise((resolve, reject, onCancel) =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;p2&#39;), 5000);    onCancel(() =&gt; console.log(&#39;p2 canceled&#39;))&#125;)let p3 = new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;p3&#39;), 7000);&#125;)p1.then(res =&gt; console.log(res));p2.then(res =&gt; console.log(res));p3.then(res =&gt; console.log(res));console.log(&#39;-----------------&#39;);p2.cancel();</code></pre><p>输出</p><pre><code>----------------- // 执行栈直接输出p2 canceled       // 调用p2的cancel方法时输出，.cancel方法是同步的，因此会在-----后直接输出p1                // 等待3秒后输出p3                // 等待7秒后输出，注意这里不是p1三秒结束后再等待7秒，而是从一开始等待7秒，因为Promise一旦创建就立即执行了</code></pre><p>使用已经取消了的<code>Promise</code>是会报错的<code>SubError [CancellationError]: late cancellation observer</code></p><pre><code class="javascript">const Promise = require(&#39;bluebird&#39;);Promise.config(&#123;cancellation: true&#125;);let p2 = new Promise((resolve, reject, onCancel) =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;p2&#39;), 5000);    onCancel(() =&gt; console.log(&#39;p2 canceled&#39;));&#125;)p2.cancel(); // 已取消p2.then(res =&gt; &#123;    console.log(res);&#125;).catch(err =&gt; console.log(err));</code></pre><p>结果</p><pre><code>p2 canceledSubError [CancellationError]: late cancellation observer    at Promise._then (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\promise.js:285:21)    at Promise.then (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\promise.js:154:17)    at Object.&lt;anonymous&gt; (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo    ...</code></pre><h1 id="Promise-spread"><a href="#Promise-spread" class="headerlink" title="Promise.spread"></a>Promise.spread</h1><p><code>Promise.spread</code>可以把一个<code>Promise</code>数组进行解构，例如我们使用<code>Promise.all</code>进行多个异步操作，正常的<code>.then</code>拿到的入参就是一个数组，如果我们使用<code>Promise.spread</code>，那么我们获取到的就是数组里对应的值，而不是一个数组，结果和<code>Promise</code>对象的数组顺序一一对应，如果只传一个入参，则只获取第一个结果。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.all([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/b.txt&#39;)]).then(res =&gt; console.log(res.map(str =&gt; str.toString())))// [ &#39;aaaaaaaaaaaaaaaaaaaaaa&#39;, &#39;bbbbbbbbbbbbbbbbbbbbbb&#39; ]</code></pre><p>使用<code>Promise.spread</code>，我们可以看到入参是数组每一项的值，而不是一整个数组</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.all([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/b.txt&#39;)]).spread((res1, res2) =&gt; console.log(res1.toString(), res2.toString()))// &#39;aaaaaaaaaaaaaaaaaaaaaa&#39; &#39;bbbbbbbbbbbbbbbbbbbbbb&#39;</code></pre><h1 id="Promise-bind"><a href="#Promise-bind" class="headerlink" title="Promise.bind"></a>Promise.bind</h1><p><code>Promise.bind</code>可以修改当前的<code>this</code>指向</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);class MyClass &#123;    constructor()&#123;        this.fileName = &#39;./data/a.txt&#39;;    &#125;    error(error) &#123;        console.log(error)    &#125;&#125;MyClass.prototype.method = function() &#123;    console.log(this); // 这里this指向MyClass    return readFile(this.fileName).bind(this) // 绑定this指向    .then((contents) =&gt; &#123;        console.log(contents)        console.log(this)   // 这里this指向MyClass，如果没有上面的bind(this)，那么这里将指向全局对象    &#125;).catch((e) =&gt; &#123;        this.error(e.stack); // 这里this指向MyClass，，如果没有上面的bind(this)，那么这里将指向全局对象    &#125;);&#125;;let me = new MyClass()me.method()</code></pre><h1 id="Promise-props"><a href="#Promise-props" class="headerlink" title="Promise.props"></a>Promise.props</h1><p><code>Promise.props</code>和<code>Promise.all</code>的作用类似，都是组合<code>Promise</code>对象，最大的区别是，<code>Promise.all</code>是需要一个具有<code>iterator</code>接口的对象，例如数组，而<code>Promise.props</code>的入参是一个<code>key: [Promise]</code>对象，而结果也会是一个<code>key: [result]</code>对象，</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.props(&#123;    txtA: readFile(&#39;./data/a.txt&#39;),    txtB: readFile(&#39;./data/b.txt&#39;),&#125;).then(result =&gt; &#123;    console.log(result.txtA.toString());    console.log(result.txtB.toString());&#125;)// aaaaaaaaaaaaaaaaaaaaaa// bbbbbbbbbbbbbbbbbbbbbb</code></pre><h1 id="Promise-some"><a href="#Promise-some" class="headerlink" title="Promise.some"></a>Promise.some</h1><p><code>Promise.some</code>接收两个参数，第一个是<code>Promise</code>对象数组（不一定是数组，具有<code>iterator</code>接口就行），第二个参数是返回的个数，这个个数是在所有的<code>Promise</code>对象中，状态最快变为<code>fulfilled</code>的前几个，例如下面的代码，读取4个文件，返回最快读到的前2个；</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.some([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/b.txt&#39;),    readFile(&#39;./data/c.txt&#39;),    readFile(&#39;./data/d.txt&#39;),], 2).then(res =&gt; &#123;console.log(res)&#125;)</code></pre><p>如果成功的个数小于第二个参数指定的个数，会抛出一个异常</p><pre><code class="javascript">Unhandled rejection AggregateError: aggregate error    at SomePromiseArray._checkOutcome (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\some.js:82:17)    at SomePromiseArray._promiseRejected (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\some.js:69:17)    at Promise._settlePromise (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\promise.js:611:26)</code></pre><p>我们可以直接<code>.catch</code>捕获，但是此时捕获的错误是一个<code>rejected Promise</code>的数组，具有<code>length</code>属性和一些数组的操作方法</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.some([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/bd.txt&#39;),    readFile(&#39;./data/cd.txt&#39;),], 2).then(res =&gt; &#123;console.log(res)&#125;).catch(err =&gt; console.log(err))</code></pre><p>此时<code>bd.txt</code>和<code>cd.txt</code>文件是不存在的，只有<code>a.txt</code>能读取成功，而我们定义了成功的数量是前两个，此时就会进入异常</p><pre><code class="javascript">SubError [AggregateError]: aggregate error    at SomePromiseArray._checkOutcome (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\some.js:82:17)    ...    at processImmediate (internal/timers.js:439:21) &#123;  &#39;0&#39;: [OperationalError: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\bd.txt&#39;] &#123;    cause: [Error: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\bd.txt&#39;] &#123;      errno: -4058,      code: &#39;ENOENT&#39;,      syscall: &#39;open&#39;,      path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\bd.txt&#39;    &#125;,    isOperational: true,    errno: -4058,    code: &#39;ENOENT&#39;,    syscall: &#39;open&#39;,    path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\bd.txt&#39;  &#125;,  &#39;1&#39;: [OperationalError: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\cd.txt&#39;] &#123;    cause: [Error: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\cd.txt&#39;] &#123;      errno: -4058,      code: &#39;ENOENT&#39;,      syscall: &#39;open&#39;,      path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\cd.txt&#39;    &#125;,    isOperational: true,    errno: -4058,    code: &#39;ENOENT&#39;,    syscall: &#39;open&#39;,    path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\cd.txt&#39;  &#125;,  length: 2&#125;</code></pre><p>返回的整个错误是可以调用数组方法的，例如</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.some([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/bd.txt&#39;),    readFile(&#39;./data/cd.txt&#39;),], 2).then(res =&gt; &#123;console.log(res)&#125;).catch(err =&gt; console.log(err.map(errItem =&gt; errItem)))</code></pre><p>结果</p><pre><code class="javascript">[  [OperationalError: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\bd.txt&#39;] &#123;    cause: [Error: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\bd.txt&#39;] &#123;      errno: -4058,      code: &#39;ENOENT&#39;,      syscall: &#39;open&#39;,      path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\bd.txt&#39;    &#125;,    isOperational: true,    errno: -4058,    code: &#39;ENOENT&#39;,    syscall: &#39;open&#39;,    path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\bd.txt&#39;  &#125;,  [OperationalError: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\cd.txt&#39;] &#123;    cause: [Error: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\cd.txt&#39;] &#123;      errno: -4058,      code: &#39;ENOENT&#39;,      syscall: &#39;open&#39;,      path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\cd.txt&#39;    &#125;,    isOperational: true,    errno: -4058,    code: &#39;ENOENT&#39;,    syscall: &#39;open&#39;,    path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\cd.txt&#39;  &#125;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Protals</title>
      <link href="/2023/04/06/React/React%20Protals/"/>
      <url>/2023/04/06/React/React%20Protals/</url>
      
        <content type="html"><![CDATA[<h1 id="React-Protals"><a href="#React-Protals" class="headerlink" title="React Protals"></a>React Protals</h1><p><code>Portal</code> 提供了一种将子节点渲染到存在于父组件以外的 <code>DOM</code> 节点的优秀的方案。</p><pre><code class="javascript">ReactDOM.createPortal(child, container)</code></pre><p>注意<code>createPortal</code>是<code>ReactDOM</code>的api，需要引入<code>react-dom</code>包</p><p>第一个参数（<code>child</code>）是任何可渲染的 <code>React</code> 子元素，例如一个元素，字符串或 <code>fragment</code>。第二个参数（<code>container</code>）是一个 <code>DOM</code> 元素。</p><p>通常来讲，当你从组件的 <code>render</code> 方法返回一个元素时，该元素将被挂载到 <code>DOM</code> 节点中离其最近的父节点：</p><p>然而，有时候将子元素插入到 <code>DOM</code> 节点中的不同位置也是有好处的，一个 <code>portal</code> 的典型用例是当父组件有 <code>overflow: hidden</code> 或<code> z-index</code> 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：</p><p>下面是一个demo：</p><pre><code class="javascript">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;// Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。// antd中的Dialog就是用的这个方案class Modal extends React.Component &#123;  constructor(props) &#123;    super(props)    this.$el = document.createElement(&#39;div&#39;)  &#125;  componentDidMount() &#123;    document.body.appendChild(this.$el)  &#125;  componentWillUnmount() &#123;    console.log(this.$el)    document.body.removeChild(this.$el)  &#125;  render () &#123;    return &lt;div&gt;      &#123;ReactDOM.createPortal(this.props.children, this.$el)&#125;    &lt;/div&gt;  &#125;&#125;class Comp extends React.Component &#123;  constructor(props)&#123;    super(props)    this.state = &#123;      showModal: false    &#125;  &#125;  handleClick = () =&gt; &#123;    this.setState(&#123;      showModal: !this.state.showModal    &#125;)  &#125;  render() &#123;    return &lt;div&gt;      &lt;button onClick=&#123;this.handleClick&#125;&gt;show&lt;/button&gt;      &#123;this.state.showModal ? &lt;Modal&gt;        &lt;div style=&#123;&#123;width: '100px', height: '100px', backgroundColor: 'gray'&#125;&#125;&gt;          &lt;button onClick=&#123;this.handleClick&#125;&gt;hide&lt;/button&gt;        &lt;/div&gt;      &lt;/Modal&gt; : null&#125;    &lt;/div&gt;  &#125;&#125;export default Comp</code></pre><p><img src="/images/portals.gif"></p><p>尽管 <code>portal</code> 可以被放置在 <code>DOM</code> 树中的任何地方，但在任何其他方面，其行为和普通的 <code>React</code> 子节点行为一致。由于 <code>portal</code> 仍存在于 <code>React</code> 树， 且与 <code>DOM</code> 树中的位置无关，那么无论其子节点是否是 <code>portal</code>，像 <code>context</code> 这样的功能特性都是不变的。</p><p>这包含事件冒泡。一个从 <code>portal</code> 内部触发的事件会一直冒泡至包含 <code>React</code> 树的祖先，即便这些元素并不是 <code>DOM</code> 树中的祖先。</p><p>假设我们在<code>Modal</code>父元素上绑定一个点击事件，则<code>Modal</code>内部的点击会一直冒泡到其<code>React</code> 树的父元素上</p><pre><code class="javascript">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;class Modal extends React.Component &#123;  constructor(props) &#123;    super(props)    this.$el = document.createElement(&#39;div&#39;)  &#125;  componentDidMount() &#123;    document.body.appendChild(this.$el)  &#125;  componentWillUnmount() &#123;    console.log(this.$el)    document.body.removeChild(this.$el)  &#125;  render () &#123;    return ReactDOM.createPortal(this.props.children, this.$el)  &#125;&#125;class Comp extends React.Component &#123;  constructor(props)&#123;    super(props)    this.state = &#123;      showModal: false,      count: 0    &#125;  &#125;  handleClick = (e) =&gt; &#123;    this.setState(&#123;      showModal: !this.state.showModal    &#125;)    e.stopPropagation()  &#125;  handlePopClick = () =&gt; &#123;    this.setState(&#123;      count: this.state.count + 1    &#125;)  &#125;  render() &#123;    // 在这里绑定事件，每次都会使count +1,    return &lt;div onClick=&#123;this.handlePopClick&#125;&gt;      &lt;button onClick=&#123;this.handleClick&#125;&gt;show&lt;/button&gt;      count: &#123;this.state.count&#125;      &#123;this.state.showModal ? &lt;Modal&gt;        &lt;div style=&#123;&#123;width: '100px', height: '100px', backgroundColor: 'gray'&#125;&#125;&gt;          &lt;button onClick=&#123;this.handleClick&#125;&gt;hide&lt;/button&gt;        &lt;/div&gt;      &lt;/Modal&gt; : null&#125;    &lt;/div&gt;  &#125;&#125;export default Comp</code></pre><p><img src="/images/portals1.gif"></p><p>可以看到虽然<code>Modal</code>被渲染到了<code>body</code>上，但是父元素上还是能捕获到冒泡上来的事件。</p><p>可以理解为<code>Portals</code>只是把<code>dom</code>渲染到了其他地方，但是从代码结构上来看，还是处在当前父子组件的上下文中</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React hooks知识点整理</title>
      <link href="/2023/04/06/React/%20React%20hooks%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2023/04/06/React/%20React%20hooks%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="React-hooks知识点整理"><a href="#React-hooks知识点整理" class="headerlink" title="React hooks知识点整理"></a>React hooks知识点整理</h1><h1 id="Hook-使用规则"><a href="#Hook-使用规则" class="headerlink" title="Hook 使用规则"></a>Hook 使用规则</h1><p><code>Hook</code> 就是 <code>JavaScript</code> 函数，但是使用它们会有两个额外的规则：</p><ul><li>只能在函数最外层调用 <code>Hook</code>。不要在循环、条件判断或者子函数中调用。</li><li>只能在 <code>React</code> 的函数组件中调用 <code>Hook</code>。不要在其他 <code>JavaScript</code> 函数中调用，还可以在自定义<code>Hook</code>中调用其他<code>Hook</code></li></ul><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><pre><code class="javascript">const [state, setState] = useState(initialState);</code></pre><p>返回一个 <code>state</code>，以及更新 <code>state</code> 的函数。</p><p>在初始渲染期间，返回的状态 (<code>state</code>) 与传入的第一个参数 (<code>initialState</code>) 值相同。</p><p><code>setState</code> 函数用于更新 <code>state</code>。它接收一个新的 <code>state</code> 值并将组件的一次重新渲染加入队列。</p><p>在后续的重新渲染中，<code>useState</code> 返回的第一个值将始终是更新后最新的 <code>state</code>。</p><p>在<code>class</code>中<code>state</code>只能作为对象，但在<code>useState</code> hook中不仅仅可以使用对象，还可以使用数组，数字，字符串等;</p><pre><code class="javascript">export default function CountHooks () &#123;  const [count, setCount] = useState(0)  // setState会合并，取最后一次更新的值，因此调用这个函数，每次只会加1，而不是4  function changeCount () &#123;    setCount(count + 3)    setCount(count + 1)  &#125;  return (    &lt;div&gt;      &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;+1&lt;/button&gt;      &lt;button onClick=&#123;changeCount&#125;&gt;changeCount&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>注意！和<code>class</code>组件的<code>setState</code>一样，会合并调用，谁在最后执行谁，因此上面代码中每次调用<code>changeCount</code>函数，每次<code>count</code>还是加1，不是加4也不是加3</p><h2 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h2><p>如果新的 <code>state</code> 需要通过使用先前的 <code>state</code> 计算得出，那么可以将函数传递给 <code>setState</code>。该函数将接收先前的 <code>state</code>，并返回一个更新后的值。</p><pre><code class="javascript">export default function CountHooks () &#123;  const [count, setCount] = useState(0)  function changeCount () &#123;    setCount(count =&gt; &#123;      return count + 1    &#125;)    setCount(count =&gt; &#123;      return count + 1    &#125;)  &#125;  return (    &lt;div&gt;      &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count =&gt; count + 1) &#125;&#125;&gt;+1&lt;/button&gt;      &lt;button onClick=&#123;changeCount&#125;&gt;+2&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; setCount(0)&#125;&gt;reset&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h2 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h2><p>惰性初始化，<code>useState</code>中传入一个函数即可，这个函数只会在初始化的时候调用一次，后面组件重新渲染的时候并不会再次调用，提高性能</p><p>如果下面不使用函数，而是直接<code>fib(40)</code>，这是函数的调用，这会在每次渲染的时候都执行一遍该函数，每当点击按钮一次，就会重新计算一次，此时页面会夯住。即使后续的重新渲染不会用到，但也会执行。</p><pre><code class="javascript">import React, &#123; useState &#125; from &#39;react&#39;function fib (n) &#123;  if (n == 1 || n == 2) return 1  return fib(n - 1) + fib(n - 2)&#125;export default function Comp () &#123;  const [result] = useState(() =&gt; fib(40))  const [count, setCount] = useState(0)  function handleClick () &#123;    setCount(c =&gt; c + 1)  &#125;  return (    &lt;div&gt;      &lt;p&gt;&#123;result&#125;&lt;/p&gt;      &lt;p&gt;&#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;handleClick&#125;&gt;+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>如果<code>useState</code>初始值是一个对象或数组，<code>setState</code>并不会进行对象的合并，需要自己使用扩展语法进行扩展，如果下面的代码不对<code>count</code>进行扩展，则<code>label</code>属性会丢失</p><pre><code class="javascript">export default function CountHooks () &#123;  const [count, setCount] = useState(&#123;sum: 0, label: &#39;个数&#39;&#125;)  function changeCount () &#123;    setCount(count =&gt; &#123;      return &#123;...count, sum: count.sum + 1&#125;    &#125;)  &#125;  return (    &lt;div&gt;      &lt;p&gt;&#123;count.label&#125;: &#123;count.sum&#125;&lt;/p&gt;      &lt;button onClick=&#123;changeCount&#125;&gt;+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><p><code>useEffect</code>的用法查看官网<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect">React 官网-useEffect</a></p><p>下面通过一个例子解释下其运行机制</p><pre><code class="javascript">import React, &#123; useState, useEffect &#125; from &#39;react&#39;export default function TimerHooks () &#123;  console.log(&#39;function start run &#39; + Date.now())  const [date, setDate] = useState(new Date())  useEffect(() =&gt; &#123;    console.log(&#39;timer hooks 的effect执行了&#39;, date);    let timerId = setInterval(() =&gt; &#123;      setDate(new Date())    &#125;, 1000)  &#125;);  console.log(&#39;function end run &#39; + Date.now())  return (    &lt;div&gt;      &lt;p&gt;时间: &#123;date.toLocaleTimeString()&#125;&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><ul><li>组件初次挂载，会开启一个定时器，每隔1s更新一下当前时间</li><li>我们什么也不做，此时副作用内部又更新了state，会导致组件更新，又开启定时器，无限循环，性能极差<br><img src="/images/hooks1.gif"></li></ul><p>此时我们给定一个清除副作用的函数</p><pre><code class="javascript">useEffect(() =&gt; &#123;  console.log(&#39;timer hooks 的effect执行了&#39;, date);  let timerId = setInterval(() =&gt; &#123;    setDate(new Date())  &#125;, 1000)  return () =&gt; &#123;    console.log(&#39;取消副作用&#39;);    clearInterval(timerId)  &#125;&#125;);</code></pre><ul><li>组件初次挂载，会开启一个定时器，每隔1s更新一下当前时间</li><li>组件更新前，先取消副作用，清除了定时器，然后再重新设置一个定时器</li></ul><p>这样做看似没什么问题，但是如果我们有其他状态也变化了呢，此时也会取消定时器，导致异常</p><p>我们加一个按钮，修改一下count</p><pre><code class="javascript">import React, &#123; useState, useEffect &#125; from &#39;react&#39;export default function TimerHooks () &#123;  console.log(&#39;function start run &#39; + Date.now())  const [date, setDate] = useState(new Date())  const [count, setCount] = useState(0)  useEffect(() =&gt; &#123;    console.log(&#39;timer hooks 的effect执行了&#39;, date);    let timerId = setInterval(() =&gt; &#123;      setDate(new Date())    &#125;, 1000)    return () =&gt; &#123;      console.log(&#39;取消副作用&#39;);      clearInterval(timerId)    &#125;  &#125;);  console.log(&#39;function end run &#39; + Date.now())  return (    &lt;div&gt;      &lt;p&gt;时间: &#123;date.toLocaleTimeString()&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>疯狂点击按钮，此时页面上的事件会停住，因为我们点击按钮，也会导致组件更新，此时先清除定时器，再设置，由于我们点得非常快，定时器一直在被清除，因此页面时间显示会卡住，观察下图时间显示<br><img src="/images/hooks2.gif"></p><p>那此时要怎么做，这时我们可以给useEffect传入第二个参数，是一个依赖数组，我们直接传入一个空数组，此时这个effect只在挂载的时候执行一次，卸载的时候清除副作用，组件再怎么更新就与这个effect无关了</p><pre><code class="javascript">  // ...  useEffect(() =&gt; &#123;    console.log(&#39;timer hooks 的effect执行了&#39;, date);    let timerId = setInterval(() =&gt; &#123;      setDate(new Date())    &#125;, 1000)    return () =&gt; &#123;      console.log(&#39;取消副作用&#39;);      clearInterval(timerId)    &#125;  &#125;, []); // 这里传入一个空数组</code></pre><p>此时所有问题就都被解决了<br><img src="/images/hooks3.gif"></p><h1 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h1><p><code>useContext</code>接收一个 <code>context</code> 对象（<code>React.createContext</code> 的返回值）并返回该 <code>context</code> 的当前值。当前的 <code>context</code> 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> <code>prop</code> 决定。</p><p>使用<code>useContext</code>只是让我们允许在函数组件中能接收到<code>context</code>的值，但仍然需要在上层组件中使用<code>Provider</code>来提供<code>value</code></p><pre><code class="javascript">import React, &#123; useContext &#125; from &#39;react&#39;const myContext = React.createContext()const Provider = myContext.Providerexport default function ContextHooks () &#123;  const store = &#123;    user: &#123;      name: &#39;jerry&#39;,      age: 18    &#125;  &#125;  return (    &lt;Provider value=&#123;store&#125;&gt;      &lt;Child&gt;&lt;/Child&gt;    &lt;/Provider&gt;  )&#125;const Child = props =&gt; &#123;  console.log(useContext(myContext));  const &#123; user &#125; = useContext(myContext)  return &lt;div&gt;    &lt;h1&gt;user: &#123;user.name&#125;&lt;/h1&gt;  &lt;/div&gt;&#125;</code></pre><h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><p><code>useReducer</code>就像一个小型的<code>redux</code>，对于比较复杂的<code>state</code>，我们建议通过使用<code>useReducer</code>来声明状态，而不是<code>useState</code></p><p>我们还可以把<code>dispatch</code>函数向子组件传递，用来修改父组件的状态，不用父组件内部再定义一个回调函数了。</p><p><code>useReducer</code>和<code>useState</code>一样，不仅可以使用对象作为初始值，还可以使用数组，数字，字符串等，和<code>redux</code>的区别是，<code>redux</code>可以将初始状态通过默认参数直接传递给<code>state</code>，但是在<code>useReducer</code>中，初始状态只能通过<code>userReducer</code>的第二个参数传入</p><p><code>useReducer</code>接收两个参数，第一个参数是<code>reducer</code>，第二个是初始值，返回最新的<code>state</code>，和<code>dispatch</code>派发<code>reducer</code>的函数</p><pre><code class="javascript">import React, &#123; useReducer &#125; from &#39;react&#39;const initCount = &#123; count: 0 &#125;function reducer (state, action) &#123;  switch (action.type) &#123;    case &#39;decrement&#39;:      return &#123; count: state.count - 1 &#125;    case &#39;increment&#39;:      return &#123; count: state.count + 1 &#125;    default:      throw new Error(&#39;unknow action type&#39;);  &#125;&#125;function ReducerCounter (props) &#123;  const [state, dispatch] = useReducer(reducer, initCount)  return (    &lt;div&gt;      &lt;h1&gt;&#123;state.count&#125;&lt;/h1&gt;      &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: &#39;decrement&#39; &#125;) &#125;&#125;&gt;-1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: &#39;increment&#39; &#125;) &#125;&#125;&gt;+1&lt;/button&gt;    &lt;/div&gt;  )&#125;export default ReducerCounter</code></pre><p><code>useReducer</code>还可以接受第三个参数，就是初始化函数，这个初始化函数将<code>userReducer</code>的第二个初始值入参作为参数，返回一个新的<code>state</code></p><pre><code class="javascript">import React, &#123; useReducer &#125; from &#39;react&#39;function init (initialCount) &#123;  return &#123; count: initialCount &#125;;&#125;function reducer (state, action) &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      return &#123; count: state.count + 1 &#125;;    case &#39;decrement&#39;:      return &#123; count: state.count - 1 &#125;;    case &#39;reset&#39;:      return init(action.payload);    default:      throw new Error();  &#125;&#125;function Counter (&#123; initialCount &#125;) &#123;  // 这里的初始值是通过props传过来的  // 这里使用init初始化函数，作用是如果需要根据传过来的数据做处理，然后再设置状态，这样就可以把数据处理方法组件外面来执行  // reducer第三个参数就是初始化数据的函数，会自动把第二个参数的值传递给该函数，再由该函数返回初始的状态值，  // 这对于复杂的处理很方便，比如需要对传入的参数进行筛选或者改造，但对于简单的，直接使用第二个参数就行了  // 而对于有重置功能的组件来说，使用第三个参数也是非常方便的  const [state, dispatch] = useReducer(reducer, initialCount, init);  return (    &lt;&gt;      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;      &lt;button        onClick=&#123;() =&gt; dispatch(&#123; type: &#39;reset&#39;, payload: initialCount &#125;)&#125;&gt;        Reset      &lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;decrement&#39; &#125;)&#125;&gt;-&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;+&lt;/button&gt;    &lt;/&gt;  );&#125;export default Counter</code></pre><pre><code class="javascript">&lt;Counter initialCount=&#123;0&#125;&gt;&lt;/Counter&gt;</code></pre><h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><p><code>useCallback</code> 第一个参数是函数，第二个参数是依赖状态的数组，返回值是函数，因此下面使用的时候要带上<code>()</code></p><p>它将返回该回调函数的 <code>memoized</code> 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p>当组件更新的时候，返回的缓存函数依然会执行，只不过执行的函数是缓存起来的函数，因此值不会发生改变</p><blockquote><p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)。但useMemo的实际用法不是这样，只是说useCallback可以使用useMemo的这种方式代替<br>useMemo缓存的是返回值，useCallback缓存的是回调函数 </p></blockquote><pre><code class="javascript">import React, &#123; useCallback, useState &#125; from &#39;react&#39;export default function HooksCallBack (props) &#123;  const [count, setCount] = useState(0)  const [price, setPrice] = useState(10)  const [any, setAny] = useState(1)  const getTotalCallback = useCallback(() =&gt; &#123;    console.log(&#39;函数执行了&#39;);    console.log(any);    return price * count    // 如果这里为空数组，那么count和price无论怎么改变，getTotalCallback函数都是缓存下来的函数，下面的总计调用永远都是那个函数，就不会更新    // 若只有一个，则只有该状态变化的时候，才会执行回调函数  &#125;, [count, price])  return (    &lt;div&gt;      &lt;p&gt;单价：&#123;price&#125;，数量：&#123;count&#125;，总计：&#123;getTotalCallback()&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setPrice(price + 1) &#125;&#125;&gt;单价+1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;数量+1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; setAny(any + 1) &#125;&#125;&gt;测试+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p><img src="/images/hooks4.gif"><br>可以看到，每次点击函数都会执行，并且只有当【单价】和【数量】有变化的时候，函数才变了，因为我们多次点击测试按钮，每次返回的都是上一次的值，而当点击单价或数量后，这个值才是最新的值。</p><h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><p><code>useMemo</code>和<code>useCallback</code>的用法类似，只不过<code>useMemo</code>缓存的是值，而<code>useCallback</code>缓存的是函数，<code>useMemo</code>返回的是缓存的具体值；</p><p>我们依然可以使用上面相同的例子，转换成<code>useMemo</code></p><pre><code class="javascript">import React, &#123; useState, useMemo &#125; from &#39;react&#39;export default function HooksCallBack (props) &#123;  const [count, setCount] = useState(0)  const [price, setPrice] = useState(10)  const [any, setAny] = useState(1)  // useMemo返回值即函数的返回值，下面使用的时候直接使用  const total = useMemo(() =&gt; &#123;    console.log(&#39;函数执行了&#39;);    console.log(any);    return price * count    // 当不在依赖状态数组里面的状态发生了变化，不会执行fn函数，返回的是上一次执行后的缓存的值  &#125;, [count, price])  return (    &lt;div&gt;      &lt;p&gt;单价：&#123;price&#125;，数量：&#123;count&#125;，总计：&#123;total&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setPrice(price + 1) &#125;&#125;&gt;单价+1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;数量+1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; setAny(any + 1) &#125;&#125;&gt;测试+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p><img src="/images/hooks5.gif"></p><h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><pre><code class="javascript">const refContainer = useRef(initialValue);</code></pre><p><code>useRef</code> 返回一个<strong>可变的</strong> <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 <code>ref</code> 对象在组件的整个生命周期内持续存在。</p><p>普通用法和createRef一样，都是通过绑定ref属性来获取DOM元素或者组件实例，区别在于，在class组件中，我们在constructor中创建ref，而constructor仅在组件挂载的时候执行一次，更新阶段是不会执行的，因此在class组件中更新不会重新创建ref，在函数组件中，函数更新每次都会重新执行，因此createRef在函数组件中每次都会重新创建，导致每次都是得到的结果都是初始值，而useRef在函数组件中具有“缓存”的特点，多次执行函数并不会“重置”ref的值。</p><p>我们通过下面的例子来看看两者的区别：</p><pre><code class="javascript">export default const UseRefCreateRef = () =&gt; &#123;  const [count, setCount] = useState(0)  const varUseRef = useRef()  const varCreateRef = createRef()  console.log(varUseRef, varCreateRef);  // 从这里的打印值就可以看出来，每次打印，varUseRef返回的是同一个引用，而createRef每次都会创建一个新的引用  varUseRef.current = count  varCreateRef.current = count  return (    &lt;&gt;      &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;      &lt;p&gt;varUseRef: &#123;varUseRef.current&#125;&lt;/p&gt;      &lt;p&gt;varCreateRef: &#123;varCreateRef.current&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;    &lt;/&gt;  )&#125;</code></pre><p><img src="/images/hooks6.png"><br>解释下，每次更新<code>count</code>，都会使组件重新渲染，我们在函数组件里面重新设置<code>varUseRef</code>和<code>varCreateRef</code>的值，但是从结果可以看出来，<code>varCreateRef</code>每次都被重新创建了，而<code>varUseRef</code>每次都保持了相同的引用。</p><p>有了这一特性，我们就可以把一些在组件全生命周期中需要保留的东西放在<code>useRef</code>上面，比如一个可修改的“全局变量”，又或是<code>debounce</code>时候定义的定时器也可以使用<code>useRef</code>保存。</p><h1 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h1><p>我们在使用<code>forwardRef</code>进行转发时，接收到父组件的<code>ref</code>，然后直接将其绑定到子组件的<code>DOM</code>上，这样做并没有什么问题，但是这会带来一些问题，将子组件的<code>DOM</code>直接暴露给父组件，父组件的行为子组件并不可控，可能做一些破坏性的动作。此时我们可以仅暴露操作子组件DOM的方法，而不将整个DOM暴露给父组件，例如我只希望父组件可以操作子组件内部input元素的focus，就可以将其封装成一个函数，暴露给父组件。借助<code>useImperativeHandle</code>，我们就可以进行这种操作。</p><pre><code class="javascript">useImperativeHandle(ref, createHandle, [deps])</code></pre><ul><li><code>ref</code>：父组件绑定的<code>ref</code></li><li><code>createHandle</code>：一个函数，返回值是一个对象，这个对象将绑定到传过来的<code>ref</code>的<code>.current</code>属性上</li><li><code>[deps]</code>：依赖列表，当监听的依赖发生变化，<code>useImperativeHandle</code> 才会重新将子组件的实例属性输出到父组件</li></ul><p><code>useImperativeHandle</code>应该总是配合<code>React.forwardRef</code>一起使用，</p><p>例如以下代码：</p><pre><code class="javascript">import React, &#123; useRef, useImperativeHandle &#125; from &#39;react&#39;function FancyInput (props, ref) &#123;  const inputRef = useRef();  const btnRef = useRef();  useImperativeHandle(ref, () =&gt; (&#123;    inputFocus: () =&gt; &#123;      inputRef.current.focus();    &#125;,    getBtnWidth: () =&gt; &#123;      return btnRef.current.offsetWidth;    &#125;  &#125;));  return (    &lt;&gt;      &lt;input ref=&#123;inputRef&#125;&gt;&lt;/input&gt;      &lt;button ref=&#123;btnRef&#125;&gt;按钮按钮按钮按钮按钮&lt;/button&gt;    &lt;/&gt;  )&#125;FancyInput = React.forwardRef(FancyInput);export default function HooksRef () &#123;  const fancyInputRef = useRef()  return (    &lt;div&gt;      &lt;p&gt;useRef&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; fancyInputRef.current.inputFocus()&#125;&gt;聚焦&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; alert(fancyInputRef.current.getBtnWidth())&#125;&gt;获取子组件按钮宽度&lt;/button&gt;      &lt;div&gt;        &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt;      &lt;/div&gt;    &lt;/div&gt;  )&#125;</code></pre><p><img src="/images/hooks6.gif"></p><h1 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h1><p>其函数签名与 <code>useEffect</code> 相同，但它会在所有的 <code>DOM</code> 变更之后同步调用 <code>effect</code>。可以使用它来读取 <code>DOM</code> 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。</p><p><code>useEffect</code>在浏览器渲染完成后执行，算是异步执行，这样就不会阻塞浏览器渲染，影响用户体验。应该尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p><pre><code class="javascript">import React, &#123; useLayoutEffect, useEffect &#125; from &#39;react&#39;const LayoutEffectComp = () =&gt; &#123;  const ref = React.createRef()  // 使用useLayoutEffect的时候，在副作用里面操作dom会在浏览器渲染前变化，不会看到页面有闪屏  useEffect(() =&gt; &#123;    ref.current.style.transform = &#39;translateX(100px)&#39;  &#125;)  return (    &lt;div style=&#123;&#123; width: 100, height: 100, backgroundColor: 'red' &#125;&#125; ref=&#123;ref&#125;&gt;&lt;/div&gt;  )&#125;export default LayoutEffectComp</code></pre><p><img src="/images/hooks7.gif"></p><p>将<code>useEffect</code>换成<code>useLayoutEffect</code>就不会有这种闪动了</p><h1 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h1><pre><code class="javascript">useDebugValue(value)</code></pre><p><code>useDebugValue</code> 可用于在 <code>React</code> 开发者工具中显示自定义 <code>hook</code> 的标签。</p><p>例如一个简易的useDebounce</p><pre><code class="javascript">import &#123; useRef, useDebugValue &#125; from &#39;react&#39;const useDebounce = (func, time) =&gt; &#123;  useDebugValue(&#39;someDebounceName&#39;)  let timer = useRef()  return function (...args) &#123;    if (timer.current) clearTimeout(timer.current)    timer.current = setTimeout(() =&gt; &#123;      func(...args)    &#125;, time)  &#125;&#125;export default useDebounce</code></pre><p><img src="/images/hooks7.png"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React react-redux的使用</title>
      <link href="/2023/04/06/React/React%20react-redux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/06/React/React%20react-redux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="React-react-redux的使用"><a href="#React-react-redux的使用" class="headerlink" title="React react-redux的使用"></a>React react-redux的使用</h1><p>由于redux是一个独立的库，我们如果需要想在react中更方便的使用redux，推荐使用<code>react-redux</code>这个库，当然不使用这个库也是可以的，那么你需要自己维护全局<code>state</code>，并且订阅state的更新，去修改视图，而react-redux已经帮我们做好了这些东西，并且提供了一些api可以使用。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先我们需要安装<code>redux</code>和<code>react-redux</code></p><pre><code>yarn add redux react-redux</code></pre><span id="more"></span><h1 id="定义store"><a href="#定义store" class="headerlink" title="定义store"></a>定义store</h1><p>然后我们需要定义<code>store</code>，我们在这里创建一个姓名和年龄的<code>store</code>，并<code>combineReducers</code>，一般存放在单独的文件中，我们放在<code>store.js</code>中</p><pre><code class="javascript">import &#123; createStore, combineReducers &#125; from &#39;redux&#39;const ageReducer = (state = &#123;age: 18&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      return &#123;...state, age: state.age + 1&#125;    case &#39;decrement&#39;:      return &#123;...state, age: state.age - 1&#125;    default:      return state  &#125;&#125;const nameReducer = (state = &#123;name: &#39;jerry&#39;&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;changeName&#39;:      return &#123;...state, name: action.payload.name&#125;        default:      return state  &#125;&#125;const reducers = combineReducers(&#123;ageReducer, nameReducer&#125;);const store = createStore(reducers)export default store</code></pre><h1 id="在react中使用"><a href="#在react中使用" class="headerlink" title="在react中使用"></a>在react中使用</h1><p>如何将<code>store</code>和<code>react app</code>之间关联起来呢？这就是<code>react-redux</code>的作用，<code>react-redux</code>提供一个<code>Provider</code>组件，将<code>store</code>绑定到组件，一般我们直接绑定到根组件<code>app</code>上，那么子组件中也可以使用<code>store</code>了</p><pre><code class="javascript">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import App from &#39;./App&#39;;import &#123; Provider &#125; from &#39;react-redux&#39;import store from &#39;./store&#39;ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#39;root&#39;));</code></pre><h1 id="在组件中使用"><a href="#在组件中使用" class="headerlink" title="在组件中使用"></a>在组件中使用</h1><p><code>store</code>已经可用，但是在组件中要怎么使用，怎么拿到<code>state</code>，又怎么派发<code>action</code>呢？此时需要使用到<code>react-redux</code>提供的<code>connect</code>高阶组件了，这个是可选的，如果你的组件不需要访问<code>store</code>，就可以不使用<code>connect</code>。</p><p>来看看具体用法，假设我们有一个组件<code>User.js</code>，渲染姓名和年龄，注意我们使用的时候不提供<code>name</code>和<code>age`` props</code></p><pre><code class="javascript">import React from &#39;react&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        return &lt;div&gt;            姓名： &#123;this.props.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.age&#125;        &lt;/div&gt;    &#125;&#125;export default User</code></pre><p>此时肯定是渲染不出来的，因为我们还没有使用<code>connect</code>连接<code>store</code>，<code>&lt;User /&gt;</code>上也没有提供相应的<code>props</code>。</p><p>现在我们来连接<code>store</code>，就使用到了<code>connect</code>高阶组件，<code>connect</code>接收两个函数作为参数，我们习惯性的称之为<code>mapStateToProps</code>和<code>mapDispatchToProps</code>，顾名思义，就是把<code>state</code>和<code>dispatc</code>h映射到<code>props</code>上，使我们的组件可以通过<code>props</code>属性访问<code>state</code>和<code>dispatch</code>，通过<code>dispatch</code>，就可以派发<code>action</code>了。<strong>第二个函数是可选的，如果不传，会直接把<code>dispatch</code>映射到组件的<code>props</code>上</strong></p><h2 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h2><p>我们先来看看<code>mapStateToProps</code>怎么用，我们打印一下<code>state</code>，看看是什么东西</p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        return &lt;div&gt;            姓名： &#123;this.props.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.age&#125;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state) =&gt; &#123;    console.log(state)&#125;const ConnectedUser = connect(mapStateToProps)(User)export default ConnectedUser</code></pre><p><img src="/images/redux11.png"></p><p>可以看到，就是<code>state</code>对象，注意我们是使用<code>combineReducers</code>过的，是有<code>key</code>的，具体可以查看<a href="https://www.baihuzi.com/2021/08/13/Redux%E7%9A%84%E4%BD%BF%E7%94%A8/#Redux-combineReducers">Redux combineReducers</a></p><p>从上图报错也可以看出来，<code>mapStateToProps</code>需要返回一个纯对象，因此我们可以拿到所有的<code>state</code>后，只挑选出对自己有用的，如果都需要或者图方便，直接返回<code>&#123;...state&#125;</code>即可</p><pre><code class="javascript">// ...const mapStateToProps = (state) =&gt; &#123;    return &#123;...state&#125;&#125;// ...</code></pre><p>此时我们就可以在组件的<code>props</code>属性上获取到<code>state</code>了，渲染的时候要根据<code>state</code>的结构进行渲染，因此上面的<code>this.props.name</code>和<code>this.props.age</code>需要修改一下</p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state) =&gt; &#123;    console.log(state)    return &#123;...state&#125;&#125;const ConnectedUser = connect(mapStateToProps)(User)export default ConnectedUser</code></pre><p><img src="/images/redux12.png"></p><p>实际上，如果我们的组件有自己的<code>props</code>，例如有一个性别属性<code>&lt;User gender=&quot;male&quot; /&gt;</code>，<code>mapStateToProp</code>函数还接受第二个参数，可以获取到组件自己的属性，如果只传了<code>state</code>参数，会自动进行合并，<strong>不幸的是，如果组件自身的props和state的属性有重名的，组件自身的属性将会丢失</strong>，因此对于这种情况，<code>mapStateToProp</code>函数让你接受第二个参数，就是组件自身的<code>props</code>，具体保留哪个，我们可以自行指定。</p><p>例如我们是组件以自身的属性优先，就可以直接<code>return &#123; ...state, ...props &#125;</code>，此时组件自身的值总是会覆盖<code>state</code>的值<br>例如这样使用组件<code>&lt;User ageReducer=&quot;male&quot; /&gt;</code></p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state, props) =&gt; &#123;    console.log(state)    return &#123;...state, ...props&#125;&#125;const ConnectedUser = connect(mapStateToProps)(User)export default ConnectedUser</code></pre><p><img src="/images/redux13.png"></p><blockquote><p>看完记得记得把<code>&lt;User ageReducer=&quot;male&quot; /&gt;</code>还原</p></blockquote><h2 id="仅在需要时返回新的对象引用"><a href="#仅在需要时返回新的对象引用" class="headerlink" title="仅在需要时返回新的对象引用"></a>仅在需要时返回新的对象引用</h2><p>我们从<code>store</code>中取出的<code>state</code>还可以结合组件自身<code>props</code>进行一些计算操作，例如排序，复杂计算等，但是如果非常耗时，可能会影响性能.</p><p><code>react-redux</code> 内部实现了<code>shouldComponentUpdate</code>方法以便在组件用到的数据发生变化后能够精确地重新渲染。默认地，<code>react-redux</code>使用<code>===</code>对<code>mapStateToProps</code>返回的对象的每一个字段逐一对比，以判断内容是否发生了改变。</p><p><code>react-redux</code>进行浅比较来检查<code>mapStateToProps</code>的结果是否改变了。返回一个新对象或数组引用十分容易操作，但会造成你的组件在数据没变的情况下也重新渲染。</p><p>我们建议将所有复杂的查找和计算数据的方法封装到<code>selector</code>中。此外，你今后可以通过使用<a href="https://github.com/reduxjs/reselect">Reselect</a>编写“<code>memoized</code>” <code>selectors</code>来跳过不必要的工作从而优化性能。还可以将复杂计算放到组件内部去做计算，使用<code>useMeme</code>或<code>useCallback</code>进行优化</p><h1 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h1><p>在来看看如何<code>dispatch</code>一个<code>action</code>，上面看到，<code>dispatch</code>函数已经是默认被传递到组件的<code>props</code>属性上了，如果不做操作，可以直接使用<code>this.props.dispatch</code>派发一个<code>action</code></p><p>例如:</p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    handleIncrementClick = () =&gt; &#123;        this.props.dispatch(&#123;type: &#39;increment&#39;&#125;)    &#125;    handleDecrementClick = () =&gt; &#123;        this.props.dispatch(&#123;type: &#39;decrement&#39;&#125;)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;            &lt;br /&gt;            &lt;button onClick=&#123;this.handleIncrementClick&#125;&gt;+&lt;/button&gt;            &lt;button onClick=&#123;this.handleDecrementClick&#125;&gt;-&lt;/button&gt;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state, props) =&gt; &#123;    console.log(state)    return &#123;...state, ...props&#125;&#125;const ConnectedUser = connect(mapStateToProps)(User)export default ConnectedUser</code></pre><p><img src="/images/redux14.gif"></p><p>这样做没问题，但是直接在组件内部派发<code>action</code>，组件里面可能很多地方都需要<code>dispatch</code>，分散在组件的各个地方，代码维护起来就会十分困难，如果在组件内部还要继续向子组件里面传递<code>dispatch</code>，再在子组件内部派发<code>action</code>，就非常混乱了，并且暴露了父层的<code>dispatch</code>给子组件了，子组件如果内部还有自己的<code>connect</code>，就会非常混乱。</p><p>此时借助<code>connect</code>的第二个参数，我们可以在<code>mapDispatchToProps</code>里面集中定义组件的需要的<code>dispatch</code>方法，再传给组件，这样集中管理起来代码维护起来成本就降低很多了。</p><p>怎么用呢？<code>mapDispatchToProps</code>接收<code>dispatch</code>作为参数，返回一个派发<code>action</code>的函数对象，一旦定义了这个函数，<code>dispatch</code>就不会默认传给组件了，需要自己定义。</p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    handleIncrementClick = () =&gt; &#123;        this.props.ageIncrement()    &#125;    handleDecrementClick = () =&gt; &#123;        this.props.ageDecrement()    &#125;    handleNameChange = () =&gt; &#123;        this.props.changeName(&#123;name: &#39;tom&#39;&#125;)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;            &lt;br /&gt;            &lt;button onClick=&#123;this.handleIncrementClick&#125;&gt;+&lt;/button&gt;            &lt;button onClick=&#123;this.handleDecrementClick&#125;&gt;-&lt;/button&gt;            &lt;button onClick=&#123;this.handleNameChange&#125;&gt;改变名字&lt;/button&gt;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state, props) =&gt; &#123;    console.log(state)    return &#123;...state, ...props&#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123;    return &#123;        ageIncrement: payload =&gt; dispatch(&#123;type: &#39;increment&#39;, payload&#125;),        ageDecrement: payload =&gt; dispatch(&#123;type: &#39;decrement&#39;, payload&#125;),        changeName: payload =&gt; dispatch(&#123;type: &#39;changeName&#39;, payload&#125;),    &#125;&#125;const ConnectedUser = connect(mapStateToProps, mapDispatchToProps)(User)export default ConnectedUser</code></pre><p>这样的话，我们自己定义的派发<code>action</code>函数<code>ageIncrement</code>、<code>ageDecrement</code>、<code>changeName</code>就会放到组件的<code>props</code>属性上了<br><img src="/images/redux15.gif"></p><h2 id="mapDispatchToProps简写形式"><a href="#mapDispatchToProps简写形式" class="headerlink" title="mapDispatchToProps简写形式"></a>mapDispatchToProps简写形式</h2><p>使用上述方式定义<code>mapDispatchToProps</code>看起来有点累赘，<code>react-redux</code>也帮我们想到了，在<code>connect</code>函数的第二个参数上，可以直接传递一个<code>action creator</code>函数的数组，然后使用<code>bindActionCreators</code> API来帮我们进行处理，<code>bindActionCreators</code>的使用具体请看<a href="https://www.baihuzi.com/2021/08/13/Redux%E7%9A%84%E4%BD%BF%E7%94%A8/#Redux-bindActionCreators">Redux bindActionCreators</a></p><p>我们对<code>mapDispatchToProps</code>进行改写，这样看起来好多了，功能也没有受到影响。</p><pre><code class="javascript">// ...// const mapDispatchToProps = (dispatch) =&gt; &#123;//     return &#123;//         ageIncrement: payload =&gt; dispatch(&#123;type: &#39;increment&#39;, payload&#125;),//         ageDecrement: payload =&gt; dispatch(&#123;type: &#39;decrement&#39;, payload&#125;),//         changeName: payload =&gt; dispatch(&#123;type: &#39;changeName&#39;, payload&#125;),//     &#125;// &#125;const ConnectedUser = connect(mapStateToProps, &#123;    ageIncrement(payload) &#123;        return &#123;type: &#39;increment&#39;, payload&#125;    &#125;,    ageDecrement(payload) &#123;        return &#123;type: &#39;decrement&#39;, payload&#125;    &#125;,    changeName(payload) &#123;        return &#123;type: &#39;changeName&#39;, payload&#125;    &#125;&#125;)(User)export default ConnectedUser</code></pre><p><code>react-redux</code>的基本使用就这些了，如果想要继续深入学习，可以看一下它的<a href="https://github.com/reduxjs/react-redux">源码</a>，和<a href="https://www.yuque.com/marckon/react-redux.cn/usage#osumaf">中文文档</a></p><p>现在都流行<code>hooks</code>，<code>react-redux</code>也实现了<code>hooks</code>，留坑，有时间再更新吧。</p><h1 id="用例源码"><a href="#用例源码" class="headerlink" title="用例源码"></a>用例源码</h1><p>store.js</p><pre><code class="javascript">import &#123; createStore, combineReducers &#125; from &#39;redux&#39;const ageReducer = (state = &#123;age: 18&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      return &#123;...state, age: state.age + 1&#125;    case &#39;decrement&#39;:      return &#123;...state, age: state.age - 1&#125;    default:      return state  &#125;&#125;const nameReducer = (state = &#123;name: &#39;jerry&#39;&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;changeName&#39;:      return &#123;...state, name: action.payload.name&#125;        default:      return state  &#125;&#125;const reducers = combineReducers(&#123;ageReducer, nameReducer&#125;);const store = createStore(reducers)export default store</code></pre><p>index.js</p><pre><code class="javascript">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import App from &#39;./App&#39;;import &#123; Provider &#125; from &#39;react-redux&#39;import store from &#39;./store&#39;ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#39;root&#39;));</code></pre><p>app.js</p><pre><code class="javascript">import React, &#123; Profiler &#125; from &#39;react&#39;;import SagaTest from &#39;./components/redux/storeTest&#39;function App () &#123;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;SagaTest gender=&quot;male&quot;&gt;&lt;/SagaTest&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>src&#x2F;components&#x2F;redux&#x2F;storeTest.js</p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    handleIncrementClick = () =&gt; &#123;        this.props.ageIncrement()    &#125;    handleDecrementClick = () =&gt; &#123;        this.props.ageDecrement()    &#125;    handleNameChange = () =&gt; &#123;        this.props.changeName(&#123;name: &#39;tom&#39;&#125;)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;            &lt;br /&gt;            &lt;button onClick=&#123;this.handleIncrementClick&#125;&gt;+&lt;/button&gt;            &lt;button onClick=&#123;this.handleDecrementClick&#125;&gt;-&lt;/button&gt;            &lt;button onClick=&#123;this.handleNameChange&#125;&gt;改变名字&lt;/button&gt;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state, props) =&gt; &#123;    console.log(state)    return &#123;...state, ...props&#125;&#125;// const mapDispatchToProps = (dispatch) =&gt; &#123;//     return &#123;//         ageIncrement: payload =&gt; dispatch(&#123;type: &#39;increment&#39;, payload&#125;),//         ageDecrement: payload =&gt; dispatch(&#123;type: &#39;decrement&#39;, payload&#125;),//         changeName: payload =&gt; dispatch(&#123;type: &#39;changeName&#39;, payload&#125;),//     &#125;// &#125;const ConnectedUser = connect(mapStateToProps, &#123;    ageIncrement(payload) &#123;        return &#123;type: &#39;increment&#39;, payload&#125;    &#125;,    ageDecrement(payload) &#123;        return &#123;type: &#39;decrement&#39;, payload&#125;    &#125;,    changeName(payload) &#123;        return &#123;type: &#39;changeName&#39;, payload&#125;    &#125;&#125;)(User)export default ConnectedUser</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React ref的使用</title>
      <link href="/2023/04/06/React/React%20ref%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/06/React/React%20ref%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="React-ref的使用"><a href="#React-ref的使用" class="headerlink" title="React ref的使用"></a>React ref的使用</h1><p><code>ref</code>可以作用于普通元素，也可以作用于<code>class</code>组件上，<strong>不能作用于函数式组件</strong>，因为函数式组件没有<code>this</code>实例对象，在函数式组件中可以使用<code>useRef</code>和<code>useImperativeHandle</code></p><p>如果作用于组件上，可以直接访问组件的<code>state</code>，还可以调用组件的方法（自定义方法以及<code>setState</code>等内置方法）</p><p>父组件设置的<code>ref</code>还可以转发给子组件，以获取子组件内部的元素或者组件</p><h1 id="设置ref的3种方法"><a href="#设置ref的3种方法" class="headerlink" title="设置ref的3种方法"></a>设置ref的3种方法</h1><h2 id="设置为字符串（已废弃）"><a href="#设置为字符串（已废弃）" class="headerlink" title="设置为字符串（已废弃）"></a>设置为字符串（已废弃）</h2><pre><code class="jsx">  &lt;Child ref=&quot;child&quot;&gt;&lt;/Child&gt;</code></pre><span id="more"></span><h2 id="使用React-createRef"><a href="#使用React-createRef" class="headerlink" title="使用React.createRef()"></a>使用<code>React.createRef()</code></h2><pre><code class="jsx">class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = React.createRef()    &#125;    handleClick = () =&gt; &#123;        console.log(this.childRef.current) // Child组件实例，可以访问Child上的state和方法    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child ref=&#123;this.childRef&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;</code></pre><h2 id="使用回调函数"><a href="#使用回调函数" class="headerlink" title="使用回调函数"></a>使用回调函数</h2><p><code>React</code> 也支持另一种设置 <code>refs</code> 的方式，称为“回调 <code>refs</code>”。它能助你更精细地控制何时 <code>refs</code> 被设置和解除。</p><p>不同于传递 <code>createRef()</code> 创建的 <code>ref</code> 属性，你会传递一个函数。这个函数中接受 <code>React</code> 组件实例或 <code>HTML DOM</code> 元素作为参数，以使它们能在其他地方被存储和访问。</p><pre><code class="jsx">class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childInput = null;    &#125;    handleClick = () =&gt; &#123;        console.log(this.childInput)    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child ref=&#123;el =&gt; this.childInput = el&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;</code></pre><p>如果 <code>ref</code> 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数绑定的<code>DOM</code>元素或者组件。这是因为在每次渲染时会创建一个新的函数实例，所以 <code>React</code> 清空旧的 <code>ref</code> 并且设置新的。通过将 <code>ref</code> 的回调函数定义成 <code>class</code> 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p><pre><code class="javascript">import React from &#39;react&#39;import Child from &#39;./Child&#39;class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = null;        this.state = &#123;            count: 0        &#125;    &#125;    handleClick = () =&gt; &#123;        this.setState(&#123;            count: this.state.count + 1        &#125;)    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child ref=&#123;el =&gt; &#123;console.log(el); this.childRef = el&#125;&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><h1 id="ref转发"><a href="#ref转发" class="headerlink" title="ref转发"></a>ref转发</h1><p>为什么需要转发？如果我们给一个组件设置<code>ref</code>，那么这个<code>ref</code>是该组件实例，那如果我们需要封装一个组件，在外部调用它的时候，给他设置<code>ref</code>，则直接抛出组件内部的<code>DOM</code>元素，这就需要用到转发了；</p><p>转发的方式有两种，一个是使用<code>React.forwardRef</code> api，另一个是作为<strong>额外属性</strong>传递；</p><p>注意，不管是以何种方式定义的<code>ref</code>，转发都会转发到对应的<code>DOM</code>元素或者组件；</p><h2 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef"></a>React.forwardRef</h2><p><code>forwardRef</code>接收一个函数作为参数，该函数有两个入参，一个是<code>props</code>，另一个就是需要传递的<code>ref</code>，由于<code>React</code>内部把<code>ref</code>属性<strong>从props中过滤掉了</strong>，因此我们需要单独的接受<code>ref</code>，我们可以指定这个从父组件传过来的<code>ref</code>具体绑定到哪个元素上；</p><pre><code class="jsx">import React from &#39;react&#39;import Child from &#39;./Child&#39;class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = React.createRef()    &#125;    handleClick = () =&gt; &#123;        console.log(this.childRef.current) // Child组件的input元素    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child ref=&#123;this.childRef&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><pre><code class="jsx">import React from &#39;react&#39;const Child = React.forwardRef((props, ref) =&gt; &#123;    return         &lt;div&gt;            &lt;p&gt;Child&lt;/p&gt;            &lt;input ref=&#123;ref&#125;&gt;&lt;/input&gt;        &lt;/div&gt;&#125;)export default Child</code></pre><p>可以看到，像上面的写法我们只能返回一个函数式组件，那么要返回一个<code>class</code>组件，要怎么写呢，此时我们需要额外的包装一层，有点类似高阶组件，实际上高阶组件中传递<code>ref</code>也是通过下面这种方式的，由于<code>ref</code>不会通过<code>props</code>传递给子组件，因此需要一个额外的属性来传递<code>ref</code></p><pre><code class="jsx">import React from &#39;react&#39;class Child extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        return &lt;&gt;            &lt;div&gt;                &lt;p&gt;Child&lt;/p&gt;                &lt;input ref=&#123;this.props.forwardRef&#125;&gt;&lt;/input&gt;            &lt;/div&gt;        &lt;/&gt;    &#125;&#125;const wrappedChild = React.forwardRef((props, ref) =&gt; &#123;    // 注意透传props    return &lt;Child &#123;...props&#125; forwardRef=&#123;ref&#125; /&gt;&#125;)export default wrappedChild</code></pre><h2 id="作为属性传递"><a href="#作为属性传递" class="headerlink" title="作为属性传递"></a>作为属性传递</h2><p>其实上述的例子中已经用到了作为属性传递<code>ref</code>的特性，由于<code>ref</code>不会存在于<code>props</code>中，因此需要额外的通过一个属性进行传递，这里就不举例子了。</p><p>额外的属性除了可以传递<code>createRef</code>的值之外，还可以传递一个回调<code>refs</code>，作用和<code>createRef</code>一样，两者并没有什么明显区别</p><pre><code class="javascript">class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = null;        this.state = &#123;            count: 0        &#125;    &#125;    handleClick = () =&gt; &#123;        this.setState(&#123;            count: this.state.count + 1        &#125;)    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child forwardRef=&#123;el =&gt; &#123;console.log(el); this.childRef = el&#125;&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><pre><code class="javascript">class Child extends React.Component &#123;    constructor(props)&#123;        super(props)        this.state = &#123;            count: 0        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;div&gt;                &lt;p&gt;Child&lt;/p&gt;                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;                &lt;input ref=&#123;this.props.forwardRef&#125;&gt;&lt;/input&gt;            &lt;/div&gt;        &lt;/&gt;    &#125;&#125;   export default Child</code></pre><h1 id="displayName"><a href="#displayName" class="headerlink" title="displayName"></a>displayName</h1><p>在 <code>DevTools</code> 中显示自定义名称，例如下面的子组件，在<code>DevTools</code>中会显示为<code>Child ForwardRef</code>，否则会显示<code>Anonymous ForwardRef</code></p><pre><code class="javascript">const Child = React.forwardRef((props, ref) =&gt; &#123;    return &lt;div&gt;                &lt;p&gt;Child&lt;/p&gt;                &lt;input ref=&#123;ref&#125;&gt;&lt;/input&gt;            &lt;/div&gt;&#125;)Child.displayName = &#39;Child&#39;export default Child</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React render props模式</title>
      <link href="/2023/04/06/React/React%20render%20props%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/06/React/React%20render%20props%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="React-render-props模式"><a href="#React-render-props模式" class="headerlink" title="React render props模式"></a>React render props模式</h1><p><code>render props</code>模式是封装组件的其中一种方式，由外部指定需要渲染的元素，组件内部把状态传递给它，外部声明一个函数式的<code>props</code>，函数参数接收内部状态，返回需要渲染的元素</p><pre><code class="jsx">import React from &#39;react&#39;class Mouse extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      x: 0,      y: 0    &#125;  &#125;  moveHandle = e =&gt; &#123;    this.setState(&#123;      x: e.clientX,      y: e.clientY    &#125;)  &#125;  componentDidMount () &#123;    window.addEventListener(&#39;mousemove&#39;, this.moveHandle)  &#125;  componentWillUnmount() &#123;    window.removeEventListener(&#39;mousemove&#39;, this.moveHandle)  &#125;  render () &#123;    // render props模式，这里渲染的是外面调用的时候传过来的函数的返回值，同时把组件内部的状态传递给外面的函数    // 外面的传递过来的函数不一定要叫render，任何名字都行，同时还可以把函数放在props.children里面    // 这种使用方式被称之为render props模式，实现组件的复用    return this.props.render(this.state)  &#125;&#125;export default Mouse</code></pre><p>使用</p><pre><code class="jsx">&lt;Mouse render=&#123;mouse =&gt; &lt;h1&gt;rendre props-鼠标位置：&#123;mouse.x&#125;,&#123;mouse.y&#125;&lt;/h1&gt;&#125;&gt;&lt;/Mouse&gt;</code></pre><p>上面是一个简单的<code>render props</code>例子，注意，我们并不是只能使用<code>render</code>作为属性，随便叫什么属性都行，组件内部用法协商好就行</p><p>除了在属性上给定函数，还可以直接在<code>children</code>中使用，例如</p><pre><code class="javascript">&lt;Mouse&gt;  &#123;mouse =&gt; &lt;h1&gt;rendre props-鼠标位置：&#123;mouse.x&#125;,&#123;mouse.y&#125;&lt;/h1&gt;&#125;&lt;/Mouse&gt;</code></pre><p>此时组件内部就需要使用<code>children</code>获取渲染函数</p><pre><code class="javascript">render () &#123;    return this.props.children(this.state)  &#125;</code></pre><p>由于这一技术的特殊性，当你在设计一个类似的 <code>API</code> 时，你或许会要直接地在你的 <code>propTypes</code> 里声明 <code>children</code> 的类型应为一个函数。</p><pre><code class="javascript">Mouse.propTypes = &#123;  children: PropTypes.func.isRequired&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React setState需要注意的地方</title>
      <link href="/2023/04/06/React/React%20setState%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/2023/04/06/React/React%20setState%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="React-setState需要注意的地方"><a href="#React-setState需要注意的地方" class="headerlink" title="React setState需要注意的地方"></a>React setState需要注意的地方</h1><p>函数内部多次调用<code>setState</code>，会将所有的<code>setState</code>操作进行合并，如果有修改到相同的属性，谁在最后执行谁，例如下面调用3次<code>setState</code>，<code>count</code>初始值是<code>0</code>，依次修改<code>count</code>的值，分别加1，加2，加3，最终<code>count</code>的值会被修改为3，而不是6</p><pre><code class="jsx">import React from &#39;react&#39;class Counter extends React.Component &#123;    constructor(props) &#123;        super(props)        this.state = &#123;            count: 0,        &#125;    &#125;    clickHandle = () =&gt; &#123;        this.setState(&#123;            count: this.state.count + 1        &#125;)        this.setState(&#123;            count: this.state.count + 2        &#125;)        this.setState(&#123;            count: this.state.count + 3        &#125;)    &#125;    render () &#123;        console.log(&#39;render&#39;);        return (            &lt;div&gt;                &lt;h1 id=&quot;title&quot;&gt;计数器：&#123;this.state.count&#125;&lt;/h1&gt;                &lt;button onClick=&#123;this.clickHandle&#125;&gt;+1&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default Counter</code></pre><span id="more"></span><p>如果我们想要结果为6，就是都执行的话，需要给<code>setState</code>传入一个函数，函数的入参分别是最新的<code>state</code>和最新的<code>props</code>，可以进行解构，得到自己想要的值，下面的<code>setState</code>执行了3次，每次都拿到了最新的<code>state</code>，因此<code>count</code>最终会被修改为6</p><pre><code class="javascript">// ...clickHandle = () =&gt; &#123;    this.setState((state, props) =&gt; &#123;        console.log(state);          // &#123;count: 0&#125;        return &#123;            count: state.count + 1        &#125;    &#125;)    this.setState((state, props) =&gt; &#123;        console.log(state);          // &#123;count: 1&#125;        return &#123;            count: state.count + 2        &#125;    &#125;)    this.setState((&#123;count&#125;, props) =&gt; &#123;        console.log(count);          // 3        return &#123;            count: state.count + 2        &#125;    &#125;)&#125;</code></pre><p>我们设置了<code>setState</code>，怎么拿到最新的值呢？直接在<code>setState</code>后面获取行不行？答案是不行，因为<code>setState</code>是<strong>异步</strong>的，因此每次拿到的都是初始值，也就是<code>0</code></p><pre><code class="javascript">// ...clickHandle = () =&gt; &#123;    this.setState((state, props) =&gt; &#123;        console.log(state);          // &#123;count: 0&#125;        return &#123;            count: state.count + 1        &#125;    &#125;)    // 这里获取到的值是0，因为setState是异步的    console.log(this.state.count) // 0&#125;</code></pre><p>那有什么方法可以拿到修改后的值呢？我们可以给<code>setState</code>传入第二个参数，是一个函数，可以拿到<code>setState</code>修改后的值，但是请注意，是<strong>所有setState合并执行后的值</strong>！</p><pre><code class="javascript">// ...clickHandle = () =&gt; &#123;    this.setState((state, props) =&gt; &#123;        return &#123;            count: state.count + 1        &#125;    &#125;, () =&gt; &#123;        console.log(&#39;更新后的状态：&#39;, this.state.count);  // 2    &#125;)    this.setState((state, props) =&gt; &#123;        return &#123;            count: state.count + 1        &#125;    &#125;, () =&gt; &#123;        console.log(&#39;更新后的状态：&#39;, this.state.count);  // 2    &#125;)&#125;</code></pre><p>除了上面的方式使得我们可以同步设置<code>state</code>，还有其他一些方法，但是我们只推荐使用上面的方法，下面的方法都<strong>不建议</strong>使用</p><ul><li><p>定时器</p><pre><code class="javascript">// ...  clickHandle = () =&gt; &#123;  setTimeout(() =&gt; &#123;    this.setState(&#123; count: this.state.count + 1 &#125;)    console.log(this.state.count);  // 这里获取到的就是修改后的count 1  &#125;, 0)  setTimeout(() =&gt; &#123;    this.setState(&#123; count: this.state.count + 1 &#125;)    console.log(this.state.count);  // 这里获取到的就是修改后的count 2  &#125;, 0)&#125;</code></pre></li><li><p>原生事件中修改状态</p><pre><code class="javascript">// ...clickHandle = () =&gt; &#123;  this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count);    // 这里获取到的就是修改后的count 1  this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count);    // 这里获取到的就是修改后的count 2&#125;  componentDidMount() &#123;  this.btnRef.addEventListener(&#39;click&#39;, this.clickHandle, false)&#125;</code></pre></li><li><p>使用<code>async</code>&#x2F;<code>await</code> (不规范，不建议使用)</p><pre><code class="javascript">clickHandle = async () =&gt; &#123;  await this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count);  // 这里获取到的就是修改后的count 1  await this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count);  // 这里获取到的就是修改后的count 2&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 受控组件和非受控组件</title>
      <link href="/2023/04/06/React/React%20%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
      <url>/2023/04/06/React/React%20%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="React-受控组件和非受控组件"><a href="#React-受控组件和非受控组件" class="headerlink" title="React 受控组件和非受控组件"></a>React 受控组件和非受控组件</h1><p>什么是受控组件和非受控组件，这两个东西都是基于表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）来讨论的，其他类型的标签不存在受控和非受控的说法，那么，受控和非受控，控制的是什么呢，实际上就是控制表单元素的<code>value</code>，原生的表单元素<code>value</code>是元素自身维护的，我们不需要关心<code>value</code>的改变具体要怎么做，最后提交的时候拿到<code>value</code>就行了，而受控组件就是把表单元素的<code>value</code>拿来自己维护，不使用其自身的特性，非受控组件就需要依赖元素自身的<code>value</code>管理来实现</p><p>以<code>&lt;input&gt;</code>元素为例，我们原生的使用方式是这样的</p><pre><code class="html">&lt;form action=&quot;&quot; id=&quot;form&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;script&gt;    document.querySelector(&#39;#form&#39;).addEventListener(&#39;submit&#39;, (e) =&gt; &#123;        let textInput = document.querySelector(&#39;#text&#39;)        console.log(textInput.value)        e.preventDefault()    &#125;)&lt;/script&gt;</code></pre><p>我们只是在提交的时候拿到表单的<code>value</code>，其中是如何修改<code>value</code>的我们并不关心</p><p>那我们在<code>React</code>中使用表单元素的时候，受控组件怎么做，非受控组件怎么做，下面来看看。</p><h1 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h1><p>我们上面说了，受控组件控制的是表单元素的<code>value</code>值，因此我们需要在组件内部自己维护<code>value</code>，然后赋值给表单，自己也需要定义方法来更新<code>value</code></p><p>通过下面代码，我们就定义了一个受控组件，我们自己组件内部维护了一个<code>value</code>值，绑定给了<code>&lt;input&gt;</code>元素，并且<code>value</code>的更新都是我们自己控制。</p><span id="more"></span><pre><code class="jsx">import React from &#39;react&#39;class ControlledComp extends React.Component &#123;    constructor(props) &#123;        super(props)        this.state = &#123;            value: &#39;&#39;        &#125;    &#125;    handleChange = (e) =&gt; &#123;        this.setState(&#123;            value: e.target.value        &#125;)    &#125;    submit = () =&gt; &#123;      console.log(this.state.value)    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;input name=&quot;text&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.value&#125; /&gt;                &lt;button onClick=&#123;this.submit&#125;&gt;提交&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default ControlledComp</code></pre><h1 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h1><p>非受控组件我们组件内部不需要维护一个<code>value</code>值，也不用我们自己定义函数去更新<code>value</code>，而是交由表单元素自己去做，我们只需要拿到表单元素获取<code>value</code>就可以了</p><pre><code class="jsx">import React, &#123;createRef&#125; from &#39;react&#39;class UnControlledComp extends React.Component &#123;    constructor(props) &#123;        super(props)        this.inputRef = createRef()    &#125;    submit = () =&gt; &#123;      console.log(this.inputRef.current.value)    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;input name=&quot;text&quot; ref=&#123;this.inputRef&#125; /&gt;                &lt;button onClick=&#123;this.submit&#125;&gt;提交&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default UnControlledComp</code></pre><p>我们表单元素不止有<code>&lt;input&gt;</code>，还有<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等，在<code>&lt;select&gt;</code>上我们绑定的值并不是<code>value</code>，而是<code>checked</code>，这就需要我们做进一步处理，下面是一个更复杂的例子</p><pre><code class="jsx">class Reservation extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      isGoing: true,      numberOfGuests: 2    &#125;;    this.handleInputChange = this.handleInputChange.bind(this);  &#125;  handleInputChange(event) &#123;    const target = event.target;    const value = target.type === &#39;checkbox&#39; ? target.checked : target.value;    const name = target.name;    this.setState(&#123;      [name]: value    &#125;);  &#125;  render() &#123;    return (      &lt;form&gt;        &lt;label&gt;          参与:          &lt;input            name=&quot;isGoing&quot;            type=&quot;checkbox&quot;            checked=&#123;this.state.isGoing&#125;            onChange=&#123;this.handleInputChange&#125; /&gt;        &lt;/label&gt;        &lt;br /&gt;        &lt;label&gt;          来宾人数:          &lt;input            name=&quot;numberOfGuests&quot;            type=&quot;number&quot;            value=&#123;this.state.numberOfGuests&#125;            onChange=&#123;this.handleInputChange&#125; /&gt;        &lt;/label&gt;      &lt;/form&gt;    );  &#125;&#125;</code></pre><blockquote><p>上述例子来自<a href="https://zh-hans.reactjs.org/docs/forms.html#handling-multiple-inputs">React官网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 事件处理函数以及传参</title>
      <link href="/2023/04/06/React/React%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%BC%A0%E5%8F%82/"/>
      <url>/2023/04/06/React/React%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%BC%A0%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<h1 id="React-事件处理函数以及传参"><a href="#React-事件处理函数以及传参" class="headerlink" title="React 事件处理函数以及传参"></a>React 事件处理函数以及传参</h1><p>在React class组件中，给事件绑定处理函数需要注意一下this的指向，还有获取事件对象以及函数的传参，我们将分几种情况看看到底该怎么做</p><h1 id="普通函数形式"><a href="#普通函数形式" class="headerlink" title="普通函数形式"></a>普通函数形式</h1><p>如果使用function函数声明一个事件处理函数，我们需要特别注意this的指向，在constructor中修改this的指向或者直接在绑定的时候修改，并且事件对象会默认追加到入参<strong>尾部</strong>。</p><p>如果给处理函数传参了，事件对象是追加到所有入参的尾部的</p><span id="more"></span><pre><code class="javascript">import React from &#39;react&#39;;class Com1 extends React.Component &#123;  constructor(...props) &#123;    super(...props)    this.handler1 = this.handler.bind(this)  &#125;  handler1(e) &#123;    console.log(e)  // Event  &#125;  handler2(e) &#123;    console.log(e)  // Event  &#125;  handler3(arg1, arg2, e) &#123;    console.log(arg1)   // 123    console.log(arg2)   // 456    console.log(e)      // Event  &#125;  render () &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handler1&#125;&gt;点击&lt;/button&gt;        &lt;button onClick=&#123;this.handler2.bind(this)&#125;&gt;点击&lt;/button&gt;        &lt;button onClick=&#123;this.handler3.bind(this, 123, 456)&#125;&gt;点击&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;export default Com1</code></pre><h1 id="箭头函数形式"><a href="#箭头函数形式" class="headerlink" title="箭头函数形式"></a>箭头函数形式</h1><p>箭头函数和普通函数不一样，不用特别处理this的指向问题，</p><ul><li>如果不需要传参，则事件对象默认传入</li><li>如果需要传参，则必须重新声明一个函数</li><li>如果需要同时传参和事件对象，则新声明函数需要手动传入事件对象</li></ul><pre><code class="javascript">import React from &#39;react&#39;;class Com1 extends React.Component &#123;  constructor(...props) &#123;    super(...props)  &#125;  handler1 = (e) =&gt; &#123;    console.log(e)  // Event  &#125;  handler2 = (arg1, arg2, e) =&gt; &#123;    console.log(arg1)  // 123    console.log(arg2)  // 456    console.log(e)  // undefined  &#125;  handler3(e, arg1, arg2) &#123;    console.log(e)      // Event    console.log(arg1)   // 123    console.log(arg2)   // 456  &#125;  render () &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handler1&#125;&gt;点击&lt;/button&gt;        &lt;button onClick=&#123;() =&gt; this.handler2(123, 456)&#125;&gt;点击&lt;/button&gt;        &lt;button onClick=&#123;(e) =&gt; this.handler3(e, 123, 456)&#125;&gt;点击&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;export default Com1</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 组件生命周期</title>
      <link href="/2023/04/06/React/React%20%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2023/04/06/React/React%20%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="React-组件生命周期"><a href="#React-组件生命周期" class="headerlink" title="React 组件生命周期"></a>React 组件生命周期</h1><p>分三个阶段来看<code>React</code>组件的<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期</a></p><ul><li><p>挂载阶段</p><p>当组件初次挂载，会有以下几个动作</p><ol><li>执行<code>constructor</code>构造函数，如果组件内部没有使用到<code>state</code>或者不需要对事件处理函数绑定<code>this</code>，则这个构造函数可以不写</li><li>执行 <code>static getDerivedStateFromProps</code>，这个方法接收两个参数，<code>nextprops</code>和<code>nextState</code>，可以获取到最新的属性和状态，在挂载阶段这两个值都是初始绑定的值，该方法有个返回值，它可以返回一个对象来更新 <code>state</code>，如果返回 <code>null</code>，则不对<code>state</code>进行修改，否则会修改<code>state</code>（浅合并）</li><li>执行<code>render</code>，更新属性和状态</li><li>渲染组件，更新<code>DOM</code></li><li>执行<code>componentDidMount</code>，组件已经挂在，通常在这个方法里做数据请求操作，或者订阅事件等</li></ol></li></ul><span id="more"></span><ul><li><p>更新阶段</p><p>当组件的<code>props</code>或者<code>state</code>有更新的时候，就会触发组件的更新</p><ol><li>执行 <code>static getDerivedStateFromProps</code>，和挂载阶段一样。</li><li>执行<code>shouldComponentUpdate</code>，同样这个方法接收两个参数，<code>nextprops</code>和<code>nextState</code>，可以获取到最新的属性和状态，有一个返回值为<code>true</code>或者<code>false</code>，如果为<code>false</code>，组件将不进行更新，后面的几个个动作都不会执行，这个函数通常用作性能优化。</li><li>执行<code>render</code>，更新属性和状态</li><li>执行<code>getSnapshotBeforeUpdate</code>，这个方法在最近一次渲染输出（提交到 <code>DOM</code> 节点）之前调用，此生命周期方法的任何返回值将作为参数传递给<code>componentDidUpdate</code>作为第三个参数（如果不返回值，<code>componentDidUpdate</code>第三个参数将会接收到undefined，开发工具里面此时会报错，但不影响代码运行）。需要特别注意这个方法的入参，由于属性和状态已经更改了，因此这个方法的接收两个入参<code>prevProps</code>和<code>prevState</code>，分别是修改前的<code>props</code>和<code>state</code>。</li><li>渲染组件，更新<code>DOM</code></li><li>执行<code>componentDidUpdate</code>，这个方法在更新完成后调用，接收两个入参<code>prevProps</code>和<code>prevState</code>，也分别是修改前的<code>props</code>和<code>state</code>。如果<code>getSnapshotBeforeUpdate</code>方法有返回值，将作为第三个参数传入给<code>componentDidUpdate</code>。</li></ol><p>我们可以总结出，可以以<code>rener</code>函数分界，<code>render</code>函数执行之前，属性和状态还没有发生变更， 在它之前的两个方法<code>getDerivedStateFromProps</code>和<code>shouldComponentUpdate</code>的参数获取的是将要发生变更的属性和方法，而在<code>render</code>函数执行之后，属性和状态已经变更了，在它之后的两个方法<code>getSnapshotBeforeUpdate</code>和<code>componentDidUpdate</code>的参数获取的是修改之前的属性和方法。</p><p>这样的好处是我们可以在这个数据更改前后做一些自定义的操作，比如在<code>shouldComponentUpdate</code>方法中对当前状态和修改的状态做深度比较，完全相等才不去更新组件，否则更新。又比如在<code>componentDidUpdate</code>中，可以对比修改前的状态和修改后的状态，例如<code>this.props.userID !== prevProps.userID</code>，如果两者不相等，就去调用数据更新接口，可以在<code>componentDidUpdate</code>中直接调用<code>setState</code>更新组件，但请注意它<strong>必须被包裹在一个条件语句里</strong>，例如上面这种，否则会导致死循环。</p></li><li><p>卸载阶段</p><ol><li>执行<code>componentWillUnmount</code>，会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除定时器，取消网络请求或清除在 <code>componentDidMount</code>中创建的订阅等。<code>componentWillUnmount</code>中不应调用 <code>setState</code>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</li></ol></li></ul><h1 id="父子组件生命周期执行顺序"><a href="#父子组件生命周期执行顺序" class="headerlink" title="父子组件生命周期执行顺序"></a>父子组件生命周期执行顺序</h1><p>通过以下代码来进行观察</p><pre><code class="javascript">import React from &#39;react&#39;class LifeCycleChild extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;&#125;    console.log(&#39;child constructor&#39;);  &#125;  static getDerivedStateFromProps (nextProps, nextState) &#123;    console.log(&#39;child getDerivedStateFromProps&#39;);    return null  &#125;  componentDidMount () &#123;    console.log(&#39;child componentDidMount&#39;);  &#125;  shouldComponentUpdate (nextProps, nextState) &#123;    console.log(&#39;child shouldComponentUpdate&#39;);    return true  &#125;  getSnapshotBeforeUpdate (prevProps, prevState) &#123;    console.log(&#39;child getSnapshotBeforeUpdate&#39;);  &#125;  componentDidUpdate (prevProps, prevState, snapshot) &#123;    console.log(&#39;child componentDidUpdate&#39;);  &#125;  componentWillUnmount() &#123;    console.log(&#39;child componentWillUnmount&#39;)  &#125;  render () &#123;    console.log(&#39;child render&#39;);    return (      &lt;div&gt;        &lt;p&gt;&#123;this.props.text&#125;&lt;/p&gt;      &lt;/div&gt;    )  &#125;&#125;class LifeCycleFather extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      text: &#39;hello&#39;    &#125;    console.log(&#39;father constructor&#39;)  &#125;  componentDidMount () &#123;     console.log(&#39;father componentDidMount&#39;);  &#125;    static getDerivedStateFromProps () &#123;     console.log(&#39;father getDerivedStateFromProps&#39;);    return null  &#125;  shouldComponentUpdate () &#123;     console.log(&#39;father shouldComponentUpdate&#39;);    return true  &#125;  getSnapshotBeforeUpdate () &#123;     console.log(&#39;father getSnapshotBeforeUpdate&#39;);    return &#39;father&#39;  &#125;  componentDidUpdate () &#123;     console.log(&#39;father componentDidUpdate&#39;);  &#125;  componentWillUnmount() &#123;    console.log(&#39;father componentWillUnmount&#39;)  &#125;  render () &#123;    console.log(&#39;father render&#39;);    return &lt;&gt;      &lt;p&gt;father&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; this.setState(&#123;text: &#39;new text&#39;&#125;)&#125;&gt;修改text&lt;/button&gt;      &lt;LifeCycleChild text=&#123;this.state.text&#125; /&gt;    &lt;/&gt;  &#125;&#125;class WrappedComp extends React.Component &#123;  constructor(props)&#123;    super(props)    this.state = &#123;      isShow: true    &#125;  &#125;  render() &#123;    return &lt;&gt;      &lt;button onClick=&#123;()=&gt;&#123;this.setState(&#123;isShow: !this.state.isShow&#125;)&#125;&#125;&gt;卸载组件&lt;/button&gt;      &#123; this.state.isShow ? &lt;LifeCycleFather /&gt; : null &#125;    &lt;/&gt;  &#125;&#125;export default WrappedComp</code></pre><ul><li><p>挂载阶段</p><pre><code>father constructorfather getDerivedStateFromPropsfather renderchild constructorchild getDerivedStateFromPropschild renderchild componentDidMountfather componentDidMount</code></pre></li><li><p>更新阶段</p><pre><code>father getDerivedStateFromPropsfather shouldComponentUpdatefather renderchild getDerivedStateFromPropschild shouldComponentUpdatechild renderchild getSnapshotBeforeUpdatefather getSnapshotBeforeUpdatechild componentDidUpdatefather componentDidUpdate</code></pre></li><li><p>卸载阶段</p><pre><code>father componentWillUnmountchild componentWillUnmount</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 合成事件</title>
      <link href="/2023/04/06/React/React%20%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/04/06/React/React%20%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="React-合成事件"><a href="#React-合成事件" class="headerlink" title="React 合成事件"></a>React 合成事件</h1><p>如果<code>DOM</code>上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。<code>React</code>为了避免这类<code>DOM</code>事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——<code>SyntheticEvent</code>。</p><p>当用户在为<code>onClick</code>添加函数时，<code>React</code>并没有将<code>Click</code>事件绑定在对应的元素上面，而是在<code>document</code>处监听所有支持的事件，当事件发生并冒泡至<code>document</code>处时，<code>React</code>将事件内容封装交给中间层<code>SyntheticEvent</code>（负责所有事件合成）</p><p>所有的react合成事件都存放在一个事件池里面，当调用的时候给合成事件的事件对象赋值，执行完之后把事件对象设置为null，放回事件池，而不用每次都创建一个新的合成事件</p><p>当事件触发的时候，对使用统一的分发函数<code>ReactEventListener.dispatchEvent</code>将指定函数执行。</p><h1 id="合成事件和原生事件的执行顺序是什么？可以混用吗？"><a href="#合成事件和原生事件的执行顺序是什么？可以混用吗？" class="headerlink" title="合成事件和原生事件的执行顺序是什么？可以混用吗？"></a>合成事件和原生事件的执行顺序是什么？可以混用吗？</h1><ol><li><code>React</code>的所有事件都通过 <code>document</code>进行统一分发。当真实 <code>Dom</code>触发事件后冒泡到 <code>document</code>后才会对 <code>React</code>事件进行处理。</li><li>原生的事件会先执行，然后执行 <code>React</code>合成事件，最后执行真正在 <code>document</code>上挂载的事件</li><li><code>React</code>事件和原生事件最好不要混用。原生事件中如果执行了 <code>stopPropagation</code>方法，则会导致其他 <code>React</code>事件失效。因为所有元素的事件将无法冒泡到 <code>document</code>上，导致所有的 <code>React</code>事件都将无法被触发。<span id="more"></span>在 <code>React</code> 中 <code>event</code> 是一个 <code>SyntheticEvent</code>，如果和它的交互被延迟了（例如：通过 <code>setTimeout</code>），事件会被清除并且 <code>e.target</code> 引用不会再有效，事件对象上的所有属性都为<code>null</code></li></ol><pre><code class="javascript">import React from &#39;react&#39;class SyntheticEvent extends React.Component &#123;  constructor(...props) &#123;    super(...props)  &#125;  clickHandler = (e) =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&#39;React 事件触发了&#39;, e);    &#125;, 2000)  &#125;  render () &#123;    return (      &lt;&gt;        &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击&lt;/button&gt;      &lt;/&gt;    )  &#125;&#125;export default SyntheticEvent</code></pre><p><img src="/images/SyntheticEvent.gif"></p><p>如果你需要在事件处理函数运行之后获取事件对象的属性，你需要调用 <code>e.persist()</code>：</p><pre><code class="javascript">// ...clickHandler = (e) =&gt; &#123;    e.persist()    setTimeout(() =&gt; &#123;      console.log(&#39;React 事件触发了&#39;, e);    &#125;, 2000)  &#125;</code></pre><p><img src="/images/SyntheticEvent1.gif"></p><p>如果原生事件和React事件混用，则优先调用原生事件，再调用React事件，如果document上也绑定了原生事件，则最后执行；</p><pre><code class="javascript">import React from &#39;react&#39;class SyntheticEvent extends React.Component &#123;  constructor(...props) &#123;    super(...props)    this.btnRef = React.createRef()  &#125;  clickHandler = (e) =&gt; &#123;      console.log(&#39;React 事件触发了&#39;, e);  &#125;  componentDidMount() &#123;    this.btnRef.current.addEventListener(&#39;click&#39;, (e) =&gt; &#123;      console.log(&#39;原生事件&#39;, e)    &#125;)    document.addEventListener(&#39;click&#39;, (e) =&gt; &#123;      console.log(&#39;原生事件 document&#39;, e)    &#125;)  &#125;  render () &#123;    return (      &lt;&gt;        &lt;button ref=&#123;this.btnRef&#125; onClick=&#123;this.clickHandler&#125;&gt;点击&lt;/button&gt;      &lt;/&gt;    )  &#125;&#125;export default SyntheticEvent</code></pre><p><img src="/images/SyntheticEvent2.gif"></p><p>如果原生事件中阻止冒泡了，则React事件不会触发</p><pre><code class="javascript">// ...componentDidMount() &#123;    this.btnRef.current.addEventListener(&#39;click&#39;, (e) =&gt; &#123;      console.log(&#39;原生事件&#39;, e)      e.stopPropagation()    &#125;)    document.addEventListener(&#39;click&#39;, (e) =&gt; &#123;      console.log(&#39;原生事件 document&#39;, e)    &#125;)  &#125;</code></pre><p><img src="/images/SyntheticEvent3.gif"></p><p><code>React v17</code> 中，<code>React</code> 不会再将事件处理添加到 <code>document</code> 上，而是将事件处理添加到渲染 <code>React</code> 树的根 <code>DOM</code> 容器中：移除了 “<code>event pooling</code>（事件池）”</p><pre><code class="javascript">const rootNode = document.getElementById(&#39;root&#39;);ReactDOM.render(&lt;App /&gt;, rootNode);</code></pre><p>在 <code>React 16</code> 及之前版本中，<code>React</code> 会对大多数事件进行 <code>document.addEventListener()</code> 操作。React v17 开始会通过调用 <code>rootNode.addEventListener()</code> 来代替。<br><img src="/images/react_17_delegation.png"></p><p><img src="/images/SyntheticEvent3.png"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 跨层组件树传值-context上下文</title>
      <link href="/2023/04/06/React/React%20%E8%B7%A8%E5%B1%82%E7%BB%84%E4%BB%B6%E6%A0%91%E4%BC%A0%E5%80%BC-context%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2023/04/06/React/React%20%E8%B7%A8%E5%B1%82%E7%BB%84%E4%BB%B6%E6%A0%91%E4%BC%A0%E5%80%BC-context%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="React-跨层组件树传值-context上下文"><a href="#React-跨层组件树传值-context上下文" class="headerlink" title="React 跨层组件树传值-context上下文"></a>React 跨层组件树传值-context上下文</h1><p>跨层组件树传值，可以使用<code>context</code>上下文来处理，先要定义一个上下文，然后在子孙组件中进行消费</p><p>详细文档查看<a href="https://zh-hans.reactjs.org/docs/context.html">React官网</a></p><h1 id="创建context"><a href="#创建context" class="headerlink" title="创建context"></a>创建context</h1><p>首先需要创建一个<code>context</code>，可以给定一个默认值，当消费组件上没有<code>Provider</code>的时候，使用默认值。</p><p>然后通过上面的Provider指定想要传递的数据</p><span id="more"></span><p><code>colorCtx.js</code></p><pre><code class="javascript">import &#123; createContext &#125; from &#39;react&#39;export const ColorCtx = createContext(&quot;red&quot;)    </code></pre><p>然后通过<code>CTX.Provider</code> 组件，绑定一个<code>value</code>，用来传递给子孙组件，这里我我们绑定一个<code>&#123;color: &#39;green&#39;&#125;</code>状态</p><pre><code class="jsx">import React from &#39;react&#39;import Child from &#39;./Child&#39;import &#123; ColorCtx &#125; from &#39;./context&#39;class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.state = &#123;            color: &#39;green&#39;        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Provider value=&#123;this.state.color&#125;&gt;                &lt;p&gt;Parent&lt;/p&gt;                &lt;Child&gt;&lt;/Child&gt;            &lt;/ColorCtx.Provider&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><h1 id="消费context"><a href="#消费context" class="headerlink" title="消费context"></a>消费<code>context</code></h1><p>下面我们就可以在子孙组件里面消费绑定的value了，有以下几种方式可以消费</p><ul><li><p>使用<code>consumer</code>消费</p><p>在使用<code>consumer</code>的时候，不能在生命周期中获取到上下文的信息，只能在<code>consumer</code>里面获取到，同时如果需要同时消费多个<code>Provider</code>，也只能使用<code>consumer</code>消费</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; ColorCtx &#125; from &#39;./context&#39;class Child extends React.Component &#123;    constructor(...props) &#123;        super(...props)    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Consumer&gt;                &#123;value =&gt; &lt;div&gt;                    &lt;p style=&#123;&#123;color: value&#125;&#125;&gt;Child&lt;/p&gt;                &lt;/div&gt;&#125;            &lt;/ColorCtx.Consumer&gt;        &lt;/&gt;    &#125;&#125;export default Child</code></pre></li><li><p>使用静态方法<code>contentType</code>消费</p><p>通过指定<code>contentType</code>，来消费<code>Provider</code>，取值的时候就可以使用<code>this.context</code>取值</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; ColorCtx &#125; from &#39;./context&#39;class Child extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.state = &#123;            color: &#39;green&#39;        &#125;    &#125;    // 定义了这个，会把this.context 映射到 vlue    static contextType = ColorCtx    render() &#123;        return &lt;&gt;            &lt;div&gt;                &lt;p style=&#123;&#123;color: this.context&#125;&#125;&gt;Child&lt;/p&gt;            &lt;/div&gt;        &lt;/&gt;    &#125;&#125;//上面的 static contextType = ColorCtx 也可以使用这种方法指定// Child.contextType = ColorCtxexport default Child</code></pre></li><li><p>消费多个<code>Provider</code></p><ol><li>创建多个context</li></ol><pre><code class="javascript">import &#123;createContext&#125; from &#39;react&#39;export const ColorCtx = createContext(&#39;red&#39;)export const BackColorCtx = createContext(&#39;white&#39;)</code></pre><ol start="2"><li>在父组件中提供多个<code>Provider</code></li></ol><pre><code class="jsx">import React from &#39;react&#39;import Child from &#39;./Child&#39;import &#123; ColorCtx, BackColorCtx &#125; from &#39;./context&#39;class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.state = &#123;            color: &#39;green&#39;,            backColor: &#39;black&#39;        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Provider value=&#123;this.state.color&#125;&gt;                &lt;BackColorCtx.Provider value=&#123;this.state.backColor&#125;&gt;                    &lt;p&gt;Parent&lt;/p&gt;                    &lt;Child&gt;&lt;/Child&gt;                &lt;/BackColorCtx.Provider&gt;            &lt;/ColorCtx.Provider&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><ol start="3"><li>在子孙组件中进行消费</li></ol><pre><code class="jsx">import React from &#39;react&#39;import &#123; ColorCtx, BackColorCtx &#125; from &#39;./context&#39;class Child extends React.Component &#123;    constructor(...props) &#123;        super(...props)    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Consumer&gt;                &#123; color =&gt;                     &lt;BackColorCtx.Consumer&gt;                        &#123; backColor =&gt;                             &lt;div&gt;                                &lt;p style=&#123;&#123;color: color, backgroundColor: backColor&#125;&#125;&gt;Child&lt;/p&gt;                            &lt;/div&gt;                        &#125;                    &lt;/BackColorCtx.Consumer&gt;                &#125;            &lt;/ColorCtx.Consumer&gt;        &lt;/&gt;    &#125;&#125;export default Child</code></pre></li></ul><h1 id="default默认值"><a href="#default默认值" class="headerlink" title="default默认值"></a><code>default</code>默认值</h1><p>如果说子孙组件没有提供<code>Provider</code>，则子组件的消费者的value会被赋予默认值。</p><p>例如第二个子组件<code>Child</code>没有提供<code>Provider</code>，则<code>Child</code>会被渲染成红色，就是上面<code>export const ColorCtx = createContext(&#39;red&#39;)</code>指定的</p><pre><code class="jsx">class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.state = &#123;            color: &#39;green&#39;,            backColor: &#39;black&#39;        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Provider value=&#123;this.state.color&#125;&gt;                &lt;p&gt;Parent&lt;/p&gt;                &lt;Child&gt;&lt;/Child&gt;            &lt;/ColorCtx.Provider&gt;            &lt;Child&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;</code></pre><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>当<code>context</code>的<code>value</code>发生变化的时候，会引发子组件的更新，在<code>React</code>内部，很暴力，直接使用<code>===</code>进行对比新旧值，那如果我们使用类似<code>&lt;ColorCtx.Provider value=&#123;&#123;someValue: 'value'&#125;&#125;&gt;</code>的方式传递<code>value</code>，内部比较直接<code>&#123;someValue: &#39;value&#39;&#125; === &#123;someValue: &#39;value&#39;&#125;</code>，此时永远都是<code>false</code>，子组件就会更新，造成性能问题，我们的解决方法是把<code>value</code>放到<code>state</code>中，传递的是<code>state</code>里的值，就像上述例子里那样，这样的话，值没变子组件就不会更新了。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React.memo</title>
      <link href="/2023/04/06/React/React.memo/"/>
      <url>/2023/04/06/React/React.memo/</url>
      
        <content type="html"><![CDATA[<h1 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h1><p>如果你的组件在相同 <code>props</code> 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，<code>React</code> 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p><code>React.memo</code> 仅检查 <code>props</code> 变更</p><p>例如我们渲染一个斐波那契数列的第40位的值，这是一个很耗时的递归操作，在父组件中修改<code>state</code>，我们知道<code>state</code>变了，会导致组件重新渲染，此时<code>Fib</code>组件也会重新渲染，会去重新计算斐波那契数列的值，由于计算非常耗时，此时页面会夯住；</p><span id="more"></span><pre><code class="javascript">import React from &#39;react&#39;class Fib extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    fib = (n) =&gt; &#123;        if (n == 1 || n == 2) return 1        return this.fib(n - 1) + this.fib(n - 2)    &#125;    componentDidUpdate() &#123;        console.log(&#39;重新渲染了&#39;)    &#125;    render() &#123;        return &lt;div&gt;            &lt;div&gt;&#123;this.fib(this.props.n)&#125;&lt;/div&gt;        &lt;/div&gt;    &#125;&#125;class Comp extends React.Component &#123;    constructor(props)&#123;        super(props)        this.state = &#123;            count: 0        &#125;    &#125;    render()&#123;        return &lt;div&gt;            &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;            &lt;button onClick=&#123;()=&gt;&#123;this.setState(&#123;count: this.state.count + 1&#125;)&#125;&#125;&gt;+1&lt;/button&gt;            &lt;Fib n=&#123;40&#125;&gt;&lt;/Fib&gt;        &lt;/div&gt;    &#125;&#125;export default Comp</code></pre><p><img src="/images/react_memo2.gif"></p><p>查看结果发现，每当我们点击按钮，<code>Fib</code>组件都会重新渲染并计算值，性能很差;</p><p>而如果我们使用<code>React.memo</code>高阶组件包装一下<code>Fib</code>，此时页面检测到实际上<code>Fib</code>组件的<code>props</code>属性<code>n</code> 并没有发生改变，则跳过渲染组件的操作并直接复用最近一次渲染的结果</p><p>只需要这么包一下</p><pre><code class="javascript">// ...const FibMemo = React.memo(Fib)class Comp extends React.Component &#123;    constructor(props)&#123;        super(props)        this.state = &#123;            count: 0        &#125;    &#125;    render()&#123;        return &lt;div&gt;            &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;            &lt;button onClick=&#123;()=&gt;&#123;this.setState(&#123;count: this.state.count + 1&#125;)&#125;&#125;&gt;+1&lt;/button&gt;            &lt;FibMemo n=&#123;40&#125;&gt;&lt;/FibMemo&gt;        &lt;/div&gt;    &#125;&#125;</code></pre><p><img src="/images/react_memo.gif"></p><p>通过结果可以看到，使用<code>React.memo</code>包装了之后，组件没有重复渲染，父组件的行为也正常</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactDOM顶层API</title>
      <link href="/2023/04/06/React/ReactDOM%E9%A1%B6%E5%B1%82API/"/>
      <url>/2023/04/06/React/ReactDOM%E9%A1%B6%E5%B1%82API/</url>
      
        <content type="html"><![CDATA[<h1 id="ReactDOM顶层API"><a href="#ReactDOM顶层API" class="headerlink" title="ReactDOM顶层API"></a>ReactDOM顶层API</h1><h1 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h1><p>在提供的 <code>container</code> 里渲染一个 <code>React</code> 元素，并返回对该组件的引用（或者针对无状态组件返回 <code>null</code>）。</p><p>如果 <code>React</code> 元素之前已经在 <code>container</code> 里渲染过，这将会对其执行更新操作，并仅会在必要时改变 <code>DOM</code> 以映射最新的 <code>React</code> 元素。</p><p>如果提供了可选的回调函数，该回调将在组件被渲染或更新之后被执行。</p><h1 id="hydrate"><a href="#hydrate" class="headerlink" title="hydrate()"></a>hydrate()</h1><p>与 <code>render()</code> 相同，但它用于在<code> ReactDOMServer</code> 渲染的容器中对 <code>HTML</code> 的内容进行 <code>hydrate</code> 操作。</p><h1 id="unmountComponentAtNode"><a href="#unmountComponentAtNode" class="headerlink" title="unmountComponentAtNode()"></a>unmountComponentAtNode()</h1><pre><code class="javascript">ReactDOM.unmountComponentAtNode(container)</code></pre><p>从 <code>DOM</code> 中卸载组件，会将其事件处理器（<code>event handlers</code>）和 <code>state</code> 一并清除。如果指定容器上没有对应已挂载的组件，这个函数什么也不会做。如果组件被移除将会返回 <code>true</code>，如果没有组件可被移除将会返回 <code>false</code>。</p><p>只能销毁<code>ReactDOM.render(element, container)</code>调用生成的的容器节点，通过<code>react</code>产生的节点使用此方法回报错：</p><pre><code>Warning: unmountComponentAtNode(): The node you&#39;re attempting to unmount was rendered by React and is not a top-level container. Instead, have the parent component update its state and rerender in order to remove this component.</code></pre><h1 id="findDOMNode"><a href="#findDOMNode" class="headerlink" title="findDOMNode()"></a>findDOMNode()</h1><p>当<code>ref</code>作用于组件时，只能拿到组件的实例，但是如何拿到组件的<code>DOM</code>呢？一种方法是通过<code>ref</code>转发，将<code>ref</code>转发到组件内部，绑定到具体<code>DOM</code>上<br>另一种方法就是通过<code>ReactDOM.findDOMNode()</code>API，通过组件实例去查找<code>DOM</code>，</p><p>使用这个API是有条件的</p><ul><li><code>findDOMNode</code> 只在已挂载的组件上可用（即，已经放置在 <code>DOM</code> 中的组件）。如果你尝试调用未挂载的组件（例如在一个还未创建的组件上调用 <code>render()</code> 中的 <code>findDOMNode()</code>）将会引发异常。</li><li><code>findDOMNode</code> 不能用于函数组件。</li></ul><p>大多数情况下，你可以绑定一个 <code>ref</code> 到 <code>DOM</code> 节点上，可以完全避免使用 <code>findDOMNode</code>。</p><p><strong>严格模式下该方法已弃用。</strong></p><p>示例代码</p><pre><code class="javascript">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;class Child extends React.Component &#123;    constructor(props)&#123;        super(props)        this.state = &#123;            count: 0        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;div&gt;                &lt;p&gt;Child&lt;/p&gt;                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;                &lt;input&gt;&lt;/input&gt;            &lt;/div&gt;        &lt;/&gt;    &#125;&#125; class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = React.createRef()    &#125;    componentDidMount() &#123;        console.log(this.childRef.current)        console.log(ReactDOM.findDOMNode(this.childRef.current))    &#125;    render() &#123;        return &lt;&gt;            &lt;p &gt;Parent&lt;/p&gt;            &lt;Child ref=&#123;this.childRef&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><p><img src="/images/findNodeDom.png"></p><h1 id="createPortal"><a href="#createPortal" class="headerlink" title="createPortal()"></a>createPortal()</h1><p><a href="https://www.baihuzi.com/2021/08/11/React-Protals/">React Protals</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React顶层API</title>
      <link href="/2023/04/06/React/React%E9%A1%B6%E5%B1%82API/"/>
      <url>/2023/04/06/React/React%E9%A1%B6%E5%B1%82API/</url>
      
        <content type="html"><![CDATA[<h1 id="React顶层API"><a href="#React顶层API" class="headerlink" title="React顶层API"></a>React顶层API</h1><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React.Component"></a>React.Component</h2><p><code>React.Component</code> 是使用 <code>ES6 classes</code> 方式定义 <code>React</code> 组件的基类：</p><pre><code class="javascript">class Greeting extends React.Component &#123;  render() &#123;    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;  &#125;&#125;</code></pre><h2 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h2><p><code>React.PureComponent</code> 与 <code>React.Component</code> 很相似。两者的区别在于 <code>React.Component</code> 并未实现 <code>shouldComponentUpdate()</code>，而 <code>React.PureComponent</code> 中以浅层对比 <code>prop</code> 和 <code>state</code> 的方式来实现了该函数。</p><p>如果赋予<code> React</code> 组件相同的 <code>props</code> 和 <code>state</code>，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。</p><p><code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 <code>props</code> 和 <code>state</code> 较为简单时，才使用 <code>React.PureComponent</code>，或者在深层数据结构发生变化时调用 <code>forceUpdate()</code> 来确保组件被正确地更新。你也可以考虑使用 <code>immutable</code> 对象加速嵌套数据的比较。</p><p>此外，<code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 将跳过所有子组件树的 <code>prop</code> 更新。因此，请确保所有子组件也都是“纯”的组件。</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><p><a href="http://baihuzi.com/article/4ea65d80-a267-4653-8c9b-2b4242225477">React.memo</a></p><h1 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h1><h2 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h2><p><code>JSX</code>实际上是<code>React.createElement</code>的语法糖，最终都会转换为<code>React.createElement</code>函数<br>参考<a href="https://zhuanlan.zhihu.com/p/140962830">通过源码学习React.createElement</a></p><h1 id="转换元素"><a href="#转换元素" class="headerlink" title="转换元素"></a>转换元素</h1><h2 id="React-Children"><a href="#React-Children" class="headerlink" title="React.Children"></a>React.Children</h2><p><code>React.Children</code> 提供了用于处理 <code>this.props.children</code> 不透明数据结构的实用方法。</p><p>我们先来看看<code>children</code>上有哪些东西</p><pre><code class="javascript">import React from &#39;react&#39;class ReactChildren extends React.Component &#123;  render () &#123;    // children还可以是一个函数，如果内部不调用，则会报错，所以内部需要使用this.props.children()来调用    console.log(this.props.children, &#39;ReactChildren&#39;);    return (      &lt;div&gt;        &#123; this.props.children &#125;      &lt;/div&gt;    )  &#125;&#125;export default class Wrapper extends React.Component &#123;  constructor(props) &#123;    super(props)    this.titleRef = React.createRef();  &#125;  handleClick = () =&gt; &#123;    console.log(&#39;clicked!&#39;)  &#125;  render () &#123;    return (      &lt;ReactChildren&gt;        &#123;/* 在children里传入一个函数，内部需要进行调用，否则报错，同样可以进行传参，和render props一样，只不过是写在了children里面 */&#125;        &#123;/* &#123;(msg) =&gt; &#123; return &lt;h1&gt;&#123;msg&#125;&lt;/h1&gt; &#125;&#125; */&#125;        &lt;h1 name=&quot;name&quot; ref=&#123;this.titleRef&#125;&gt;Title&lt;/h1&gt;        &lt;ul&gt;          &lt;li key=&quot;a&quot;&gt;aaa&lt;/li&gt;          &lt;li key=&quot;b&quot;&gt;bbb&lt;/li&gt;          &lt;li key=&quot;c&quot;&gt;ccc&lt;/li&gt;        &lt;/ul&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/button&gt;      &lt;/ReactChildren&gt;    )  &#125;&#125;</code></pre><span id="more"></span><p><img src="/images/react_children.png"></p><h3 id="React-Children-map"><a href="#React-Children-map" class="headerlink" title="React.Children.map"></a>React.Children.map</h3><p><code>React.Children.map</code>的实现比数组的<code>map</code>实现要多，因为<code>children</code>的值可能是<code>null</code>，或者其他，直接使用<code>this.props.children.map</code>可能会报错</p><pre><code class="javascript">React.Children.map(this.props.children, (child, index) =&gt; &#123;console.log(child, index)&#125;)</code></pre><h3 id="React-Children-forEach"><a href="#React-Children-forEach" class="headerlink" title="React.Children.forEach"></a>React.Children.forEach</h3><p>与 <code>React.Children.map()</code> 类似，但它不会返回一个数组。</p><pre><code class="javascript">React.Children.forEach(this.props.children, (child, index) =&gt; &#123;console.log(child, index)&#125;)</code></pre><h3 id="React-Children-count"><a href="#React-Children-count" class="headerlink" title="React.Children.count"></a>React.Children.count</h3><p>输出<code>children</code>的长度</p><pre><code class="javascript">React.Children.count(this.props.children)</code></pre><h3 id="React-Children-only"><a href="#React-Children-only" class="headerlink" title="React.Children.only"></a>React.Children.only</h3><p>验证 <code>children</code> 是否只有一个子节点（一个 <code>React</code> 元素），如果有则返回它，否则此方法会抛出错误</p><blockquote><p>注意：<code>React.Children.only()</code> 不接受 <code>React.Children.map()</code> 的返回值，因为它是一个数组而并不是 <code>React</code> 元素。</p></blockquote><pre><code class="javascript">try &#123;  console.log(React.Children.only(this.props.children))&#125; catch (error) &#123;  console.log(error)&#125;</code></pre><h3 id="React-Children-toArray"><a href="#React-Children-toArray" class="headerlink" title="React.Children.toArray"></a>React.Children.toArray</h3><p>将 <code>children</code> 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 <code>key</code>。当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 <code>this.props.children</code> 之前对内容重新排序或获取子集时。</p><pre><code class="javascript">React.Children.toArray(this.props.children)</code></pre><p><img src="/images/react_children2.png"></p><p><strong>以上所有的方法都不涉及子元素的情况，只能操作当前层级的元素</strong>，如果需要操作整个树，需要自己递归。</p><h2 id="cloneElement"><a href="#cloneElement" class="headerlink" title="cloneElement()"></a>cloneElement()</h2><p><code>cloneElement()</code>是<code>createFactory()</code>的替代品，<code>createFactory()</code>已被废弃</p><p><code>cloneElement()</code>以 <code>element</code> 元素为样板克隆并返回新的 <code>React</code> 元素。返回元素的 <code>props</code> 是将新的 <code>props</code> 与原始元素的 <code>props</code> 浅层合并后的结果。新的子元素将取代现有的子元素（如果子元素里有children，要记得同时传入），而<strong>来自原始元素的 key 和 ref 将被保留</strong>。</p><p><code>children</code>是<strong>只读</strong>的，我们不能直接对<code>children</code>进行修改，就可以借助此<code>api</code>进行修改；</p><pre><code class="javascript">&#123; React.Children.map(this.props.children, (child, index) =&gt; &#123;  console.log(child);  return React.cloneElement(child, &#123; style: &#123; color: &#39;red&#39; &#125;, aaa: &#39;title&#39; &#125;, [...child.props.children, &lt;span key=&#123;null&#125;&gt;新添加的内容&lt;/span&gt;])&#125;) &#125;</code></pre><p>类似<code>createElement</code>，第一个参数是具体<code>React</code>元素，第二个参数是扩展的属性，第三个参数是子元素</p><p>扩展的属性会进行一个浅合并，相同的属性名将直接覆盖，不相同的则逐个添加到props</p><p>子元素是个数组，</p><ul><li>如果不传，则里面的元素不会发生变化，有多少克隆多少</li><li>如果传了，则里面的元素会整体替换为传入的元素，因此如果当前元素里面仍存在<code>children</code>不想丢失，也需要进行扩展</li></ul><h2 id="isValidElement"><a href="#isValidElement" class="headerlink" title="isValidElement()"></a>isValidElement()</h2><p>验证对象是否为 <code>React</code> 元素，返回值为 <code>true</code> 或 <code>false</code></p><pre><code class="javascript">React.isValidElement(this.props.children)</code></pre><p>有一点需要注意的是，判断的元素<strong>必须有单一根元素（Fragment也算）</strong>，像上面例子那种没有单一根元素的，其实是一个数组，都会被判定为<code>false</code></p><h1 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h1><p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p><p>例如在特定标签中（例如<code>table</code> <code>th</code> <code>td</code>），限定标签类型，此时如果有多个标签，给定额外的根标签会使HTML无效，Fragments就解决了此问题</p><p>可以使用<code>&lt;React.Fragment&gt;</code>组件，或者短语发<code>&lt;&gt;&lt;/&gt;</code></p><p>使用显式 <code>&lt;React.Fragment&gt;</code> 语法声明的片段可能具有 <code>key</code>，<code>key</code> 是唯一可以传递给 <code>Fragment</code> 的属性。未来可能会添加对其他属性的支持，例如事件。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p>refs相关操作，查阅<a href="http://baihuzi.com/article/87a30bf5-6788-481a-bade-97fa0c4420dd">React ref的使用</a>，或官方文档<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">Refs &amp; DOM</a>&#x2F;<a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html">Refs 转发</a></p><h1 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h1><p><code>Suspense</code>用于懒加载组件时进行，<code>React.Suspense</code> 可以指定加载指示器（<code>loading indicator</code>），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 <code>&lt;React.Suspense&gt;</code> 支持的唯一用例</p><pre><code class="javascript">import React, &#123; Suspense &#125; from &#39;react&#39;const List = React.lazy(() =&gt; import(&#39;./列表渲染&#39;))class LazyLoadTest extends React.Component &#123;    render () &#123;        return (            &lt;Suspense fallback=&#123;&lt;div&gt;Loading&lt;/div&gt;&#125;&gt;                &lt;List&gt;&lt;/List&gt;            &lt;/Suspense&gt;        )    &#125;&#125;export default LazyLoadTest</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux 异步操作redux-thunk和redux-saga</title>
      <link href="/2023/04/06/React/Redux%20%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9Credux-thunk%E5%92%8Credux-saga/"/>
      <url>/2023/04/06/React/Redux%20%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9Credux-thunk%E5%92%8Credux-saga/</url>
      
        <content type="html"><![CDATA[<h1 id="Redux-异步操作redux-thunk和redux-saga"><a href="#Redux-异步操作redux-thunk和redux-saga" class="headerlink" title="Redux 异步操作redux-thunk和redux-saga"></a>Redux 异步操作redux-thunk和redux-saga</h1><p>在<code>Redux</code>中的<code>action</code>仅支持原始对象（<code>plain object</code>），处理有副作用的<code>action</code>，需要使用中间件。中间件可以在发出<code>action</code>，到<code>reducer</code>函数接受<code>action</code>之间，执行具有副作用的操作，例如网络请求，读取浏览器缓存等。</p><p>下面的示例基于<a href="https://www.baihuzi.com/2021/08/13/React-react-redux%E7%9A%84%E4%BD%BF%E7%94%A8/#%E7%94%A8%E4%BE%8B%E6%BA%90%E7%A0%81">【react-redux的使用】学习源码</a></p><h1 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h1><p><code>redux-thunk</code>是<code>redux</code>的作者提供的一个处理副作用的方案，我们都知道，<code>dispatch</code>必须接收一个原始对象，在里面无法实现副作用逻辑，但是我们可以使用<code>action creator</code>函数，在内部处理副作用，然后返回一个<code>action</code>原始对象。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>yarn add redux-thunk</code></pre><h2 id="应用redux-thunk中间件"><a href="#应用redux-thunk中间件" class="headerlink" title="应用redux-thunk中间件"></a>应用redux-thunk中间件</h2><pre><code class="javascript">import thunk from &#39;redux-thunk&#39;// ...let store = createStore(reducers, applyMiddleware(thunk))</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>此时我们不能直接派发<code>action</code>，而是先要创建一个函数，例如下面的<code>changeName</code>，函数签名<code>dispatch</code>和<code>getState</code>，都是<code>store</code>上的两个方法，然后可以在里面进行异步请求操作</p><pre><code class="javascript">const ConnectedUser = connect(mapStateToProps, &#123;    ageIncrement(payload) &#123;        return &#123;type: &#39;increment&#39;, payload&#125;    &#125;,    ageDecrement(payload) &#123;        return &#123;type: &#39;decrement&#39;, payload&#125;    &#125;,    changeName(payload) &#123;        return (dispatch, getState) =&gt; &#123;           fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;)            .then(res =&gt; res.json())            .then(data =&gt; dispatch(&#123;type: &#39;changeName&#39;, payload&#125; ))        &#125;    &#125;&#125;)(User)</code></pre><h1 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h1><p><code>redux-saga</code>是<code>redux</code>处理副作用的另一种方式，相较于<code>redux-thunk</code>，能更好的的组织代码，功能也更加丰富</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><pre><code>yarn add redux-saga</code></pre><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h2 id="应用中间件"><a href="#应用中间件" class="headerlink" title="应用中间件"></a>应用中间件</h2><pre><code class="javascript">import createSagaMidware from &#39;redux-saga&#39;const saga = createSagaMidware()const store = createStore(reducers, applyMiddleware(saga))</code></pre><p><code>redux-saga</code>采用的方案更接近于<code>redux</code>的全局思想，使用方式和<code>thunk</code>有很大不同，<br><code>saga</code>需要一个全局监听器（<code>watcher saga</code>），用于监听组件发出的<code>action</code>，将监听到的<code>action</code>转发给对应的接收器（<code>worker saga</code>），再由接收器执行具体任务，副作用执行完后，再发出另一个<code>action</code>交由<code>reducer</code>修改<code>state</code>，所以这里必须注意：**<code>watcher saga</code>监听的<code>action</code>和对应<code>worker saga</code>中发出的<code>action</code>不能同名**，否则造成死循环</p><h2 id="watcher-saga"><a href="#watcher-saga" class="headerlink" title="watcher saga"></a>watcher saga</h2><p>我们先定义一个<code>watcher saga</code></p><pre><code class="javascript">import &#123; takeEvery &#125; from &#39;redux-saga/effects&#39;// watcher sagafunction* watchIncrementSaga() &#123;  yield takeEvery(&#39;increment&#39;, workIncrementSaga)&#125;</code></pre><p><code>watcher saga</code> 很简单，就是监听用户派发的<code>action</code>（只用于监听，具体操作交由<code>worker saga</code>），这里使用<code>takeEvery</code>辅助方法，表示每次派发都会被监听到，第一个参数就是用户派发<code>action</code>的类型，第二个参数就是指定交由哪个<code>worker saga</code>进行处理</p><h2 id="worker-saga"><a href="#worker-saga" class="headerlink" title="worker saga"></a>worker saga</h2><p>因此我们需要再定义一个名为<code>workIncrementSaga</code>的<code>worker saga</code>，我们在里面执行副作用操作，然后使用<code>yield put(...)</code>派发<code>action</code>，让<code>reducer</code>去更新<code>state</code></p><pre><code class="javascript">import &#123; call, put, takeEvery &#125; from &#39;redux-saga/effects&#39;// watcher sagafunction* watchIncrementSaga() &#123;  yield takeEvery(&#39;increment&#39;, workIncrementSaga)&#125;// worker sagafunction* workIncrementSaga() &#123;  function f () &#123;    return fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;).then(res =&gt; res.json()).then(data =&gt; data)  &#125;  const res = yield call(f)  console.log(res)  yield put(&#123;type: &#39;INCREMENT&#39;&#125;)&#125;</code></pre><p>基本使用就是这样。</p><p>上面的代码可能有些难以理解，为什么要用<code>generator</code>函数，<code>call</code>，<code>put</code>又是什么方法，下面我们来看看<code>redux-saga</code>里面一些非常重要的概念和API</p><p>在 <code>redux-saga</code> 的世界里，<code>Sagas</code> 都用 <code>Generator</code> 函数实现。我们从 <code>Generator</code> 里 <code>yield</code> 纯 <code>JavaScript</code> 对象以表达 <code>Saga</code> 逻辑。 我们称呼那些对象为 <code>Effect</code>。<code>Effect</code> 是一个简单的对象，这个对象包含了一些给 <code>middleware</code> 解释执行的信息。 你可以把 <code>Effect</code> 看作是发送给 <code>middleware</code> 的指令以执行某些操作（调用某些异步函数，发起一个 <code>action</code> 到 <code>store</code>，等等）。你可以使用 <code>redux-saga/effects</code> 包里提供的函数来创建 <code>Effect</code>。</p><h2 id="辅助方法（监听类型）"><a href="#辅助方法（监听类型）" class="headerlink" title="辅助方法（监听类型）"></a>辅助方法（监听类型）</h2><ul><li><code>takeEvery</code>：     监听类型，同一时间允许多个处理函数同时进行，并发处理</li><li><code>takeLatest</code>：    监听类型，同一时间只能有一个处理函数在执行，后面开启的任务会执行，前面的会取消执行</li><li><code>takeLeading</code>：   如果当前有一个处理函数正在执行，那么后面开启的任务都不会被执行，直到该任务执行完毕</li></ul><h2 id="effect创建器"><a href="#effect创建器" class="headerlink" title="effect创建器"></a>effect创建器</h2><ul><li><p><code>take(pattern)</code></p><p>在<code>watcher saga</code>中使用，用来拦截<code>action</code>，当<code>action</code>匹配到这个<code>take</code>的时候，在发起与 <code>pattern</code> 匹配的 <code>action</code> <code>之前，Generator</code> 将暂停。实际上就是上面辅助方法的底层实现，例如：</p><pre><code class="javascript">function* watchDecrementSaga() &#123;  while(true) &#123;    yield take(&#39;decrement&#39;)    const state = yield select()    console.log(state, &#39;state&#39;)    yield put(&#123;type: &#39;DECREMENT&#39;&#125;)  &#125;&#125;</code></pre><p>此时用户派发一个<code>&#123;type: &#39;decrement&#39;, payload&#125;</code>的<code>action</code>，就会被上面的<code>take</code>拦截到，执行相应的代码，然后再去派发一个<code>action</code>，通知<code>reducer</code>修改<code>state</code>，如果没有<code>put</code>，则不会通知<code>reducer</code>修改<code>state</code>，注意需要使用<code>while true</code>一直监听，否则只有第一次派发<code>decrement</code>的action会被拦截，后面的都不会被拦截到。</p></li></ul><p> <code> pattern</code>就是匹配规则，基本有以下几种形式</p><ol><li>如果以空参数或 <code>*</code> 调用 <code>take</code>，那么将匹配所有发起的 <code>action</code>。（例如，<code>take()</code> 将匹配所有 <code>action</code>）</li><li>如果它是一个函数，那么将匹配 <code>pattern(action)</code> 为 <code>true</code> 的 <code>action</code>。（例如，<code>take(action =&gt; action.entities)</code> 将匹配哪些 <code>entities</code> 字段为真的 <code>action</code>）</li><li>如果它是一个字符串，那么将匹配 <code>action.type === pattern</code> 的 <code>action</code>。（例如，<code>take(INCREMENT_ASYNC)</code>）</li><li>如果它是一个数组，那么数组中的每一项都适用于上述规则 —— 因此它是支持字符串与函数混用的。不过，最常见的用例还属纯字符串数组，其结果是用 <code>action.type</code> 与数组中的每一项相对比。（例如，<code>take([INCREMENT, DECREMENT]</code>) 将匹配 <code>INCREMENT</code> 或 <code>DECREMENT</code> 类型的 <code>action</code>）</li></ol><p>  有了这个规则，我们就可以进行更细粒度的控制拦截到的<code>action</code>，再去做相应的修改。</p><ul><li><p><code>call(fn, ...args)</code></p><p>创建一个 <code>Effect</code> 描述信息，用来命令 <code>middleware</code> 以参数 <code>args</code> 调用函数 <code>fn</code> 。</p><ol><li><code>fn</code>: <code>Function</code> - 一个 <code>Generator</code> 函数, 也可以是一个返回 <code>Promise</code> 或任意其它值的普通函数。</li><li><code>args</code>: <code>Array&lt;any&gt;</code> - 传递给 fn 的参数数组。</li></ol></li><li><p><code>put(action)</code></p><p>创建一个 <code>Effect</code> 描述信息，用来命令 <code>middleware</code> 向 <code>Store</code> 发起一个 <code>action</code>。 这个 <code>effect</code> 是非阻塞型的，并且所有向下游抛出的错误（例如在 <code>reducer</code> 中），都不会冒泡回到 <code>saga</code> 当中。</p></li><li><p><code>fork(fn, ...args)</code></p><p><code>fork</code>和<code>call</code>用法一样，唯一的区别就是<code>fork</code>是非阻塞的，而<code>call</code>是阻塞的</p><p>创建一个 <code>Effect</code> 描述信息，用来命令 <code>middleware</code> 以 非阻塞调用 的形式执行 <code>fn</code>，返回一个 <code>Task</code> 对象。<code>Task</code>对象上有一些实用的方法及属性，比如取消某个网络请求什么的。</p><ol><li><code>fn</code>: <code>Function</code> - 一个 Generator 函数，或返回 Promise 的普通函数</li><li><code>args</code>: <code>Array&lt;any&gt;</code> - 传递给 fn 的参数数组。</li></ol></li><li><p><code>select(selector, ...args)</code></p><p>创建一个 <code>Effect</code>，用来命令 <code>middleware</code> 在当前 <code>Store</code> 的 <code>state</code> 上调用指定的选择器（即返回 <code>selector(getState(), ...args)</code> 的结果）。</p><p>获取当前<code>state</code>中的部分数据，第一个参数是一个函数，函数的参数是<code>state</code>，即当前状态，后面的参数依次传递给第一个函数，作为该函数的参数</p><pre><code class="javascript">function selector (state, index) &#123;  return state[index]&#125;let state2 = yield select(selector, 0)console.log(state2, &#39;select2&#39;);</code></pre><p><code>select</code> 也可以不传任何参数，返回值就直接是当前的所有状态</p></li><li><p><code>cancel(task)</code></p><p>创建一个 <code>Effect</code> 描述信息，用来命令 <code>middleware</code> 取消之前的一个分叉任务。</p><ol><li><code>task</code>: <code>Task</code> - 由之前 <code>fork</code> 指令返回的 <code>Task</code> 对象</li></ol><p><code>cancel</code> 是一个非阻塞的 <code>Effect</code>。也就是说，执行 <code>cancel</code> 的 <code>Saga</code> 会在发起取消动作后立即恢复执行。</p><p>对于返回 Promise 结果的函数，你可以通过给 promise 附加一个 [CANCEL] 来插入自己的取消逻辑。</p><p>举个使用cancel取消请求的例子，</p><ol><li>首先需要从<code>redux-saga</code>库里引入<code>CANCEL</code>（注意不是<code>redux-saga/effects</code>中的）</li><li>然后在异步操作上面自定义一个取消异步操作的函数，需要根据不同的异步操作形式自定义不同的取消函数，下面的例子我们是用<code>fetch</code>进行网络请求的，因此要使用<code>fetch</code>对应的取消请求的方法，如果你用的<code>axios</code>，则需要使用<code>axios</code>取消请求的方法</li><li>把这个取消函数绑定到异步请求上，如下<code>promise[CANCEL] = () =&gt; &#123; controller.abort() &#125;</code></li><li>使用<code>fork</code>去执行异步操作（不会阻塞下面代码执行），返回这个异步操作的<code>task</code></li><li>如果想要取消这个异步操作，则直接使用<code>redux-saga/effects</code>中的<code>cancel</code>方法取消这个<code>task</code></li></ol><pre><code class="javascript">import &#123; call, cancel, put, select, take, takeEvery, fork &#125; from &#39;redux-saga/effects&#39;import &#123;CANCEL&#125; from &#39;redux-saga&#39;function* watchChangeName() &#123;  yield takeEvery(&#39;changeName&#39;, workerChangeName)&#125;function* workerChangeName(&#123; payload &#125;) &#123;  function f () &#123;    const controller = new AbortController();    const &#123; signal &#125; = controller;    const promise = fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;, &#123; signal &#125;).then(res =&gt; res.json()).then(data =&gt; console.log(data))    promise[CANCEL] = () =&gt; &#123; controller.abort() &#125;    console.log(promise)    return promise  &#125;  const fetchTask = yield fork(f)  yield cancel(fetchTask) // 这里直接调用cancel取消请求  yield put(&#123;type: &#39;CHANGE_NAME&#39;, payload&#125;)&#125;</code></pre><p><img src="/images/redux16"></p></li></ul><p>上面就是我们常用到的一些方法，具体的其他一些用法，参考<a href="https://redux-saga-in-chinese.js.org/">redux-saga官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 相关【持续更新...】</title>
      <link href="/2021/08/08/%E5%89%8D%E7%AB%AF/Webpack-%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/08/08/%E5%89%8D%E7%AB%AF/Webpack-%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="三种hash策略"><a href="#三种hash策略" class="headerlink" title="三种hash策略"></a>三种hash策略</h1><ul><li><p>hash</p><p><code>hash</code> 和每次 build有关，没有任何改变的情况下，每次编译出来的 <code>hash</code>都是一样的，但当你改变了任何一点东西，它的<code>hash</code>就会发生改变。</p><p>简单理解，你改了任何东西，hash 就会和上次不一样了。</p></li><li><p>chunkhash</p><p><code>chunkhash</code>根据不同的入口文件(<code>Entry</code>)进行依赖文件解析、构建对应的代码块（<code>chunk</code>），生成对应的哈希值，某文件变化时只有该文件对应代码块（<code>chunk</code>）的<code>hash</code>会变化</p></li><li><p>contenthash</p><p>它的出现主要是为了解决，让<code>css</code>文件不受<code>js</code>文件的影响。比如<code>foo.css</code>被<code>foo.js</code>引用了，所以它们共用相同的<code>chunkhash</code>值。但这样子是有问题的，如果<code>foo.js</code>修改了代码，<code>css</code>文件就算内容没有任何改变，由于是该模块的 <code>hash</code> 发生了改变，其<code>css</code>文件的<code>hash</code>也会随之改变。</p><p>这个时候我们就可以使用<code>contenthash</code>了，保证即使<code>css</code>文件所处的模块里有任何内容的改变，只要 <code>css</code> 文件内容不变，那么它的<code>hash</code>就不会发生变化。</p><p><code>contenthash</code> 你可以简单理解为是 <code>moduleId + content</code> 所生成的 <code>hash</code>。</p></li></ul><h1 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h1><h2 id="优化loader查找范围"><a href="#优化loader查找范围" class="headerlink" title="优化loader查找范围"></a>优化loader查找范围</h2><p>在<code>loader</code>中结合<code>test</code> <code>include</code> <code>exclude</code>三个配置项来缩⼩loader的处理范围，推荐<code>include</code></p><pre><code class="javascript">// ...rules: [    &#123; test: /\.js$/, use: &#39;babel-loader&#39;, exclude: &#39;/node_modules/&#39; &#125;,]// ...</code></pre><blockquote><p><code>exclude</code> 优先级要优于 <code>include</code> 和 <code>test</code> ，所以当三者配置有冲突时， <code>exclude</code> 会优先于其他两个配置。</p></blockquote><h2 id="优化resolve-modules配置"><a href="#优化resolve-modules配置" class="headerlink" title="优化resolve.modules配置"></a>优化resolve.modules配置</h2><p><code>resolve.modules</code>⽤于配置<code>webpack</code>去哪些⽬录下寻找第三⽅模块，默认是[‘node_modules’]</p><p>寻找第三⽅模块，默认是在当前项⽬⽬录下的<code>node_modules</code>⾥⾯去找，如果没有找到，就会去上⼀级⽬录<code>../node_modules</code>找，再没有会去<code>../../node_modules</code>中找，以此类推，和<code>Node.js</code>的模块寻找机制很类似。</p><p>如果我们的第三⽅模块都安装在了项⽬根⽬录下，就可以直接指明这个路径。</p><pre><code class="javascript">module.exports=&#123; resolve:&#123; modules: [path.resolve(__dirname, &quot;./node_modules&quot;)] &#125;&#125;</code></pre><h2 id="优化resolve-alias配置"><a href="#优化resolve-alias配置" class="headerlink" title="优化resolve.alias配置"></a>优化resolve.alias配置</h2><p><code>resolve.alias</code>配置通过别名来将原导⼊路径映射成⼀个新的导⼊路径，拿<code>react</code>为例，我们引⼊的<code>react</code>库，⼀般存在两套代码</p><ul><li><p>cjs</p><p>采⽤commonJS规范的模块化代码</p></li><li><p>umd</p><p>已经打包好的完整代码，没有采⽤模块化，可以直接执⾏</p></li></ul><p>默认情况下，<code>webpack</code>会从⼊⼝⽂件<code>./node_modules/bin/react/index</code>开始递归解析和处理依赖的⽂件。我们可以直接指定⽂件，避免这处的耗时。</p><pre><code class="javascript">resolve: &#123;  alias: &#123;    &quot;@assets&quot;: path.resolve(__dirname, &quot;../src/assets&quot;),    &quot;@src&quot;: path.join(__dirname, &quot;./src&quot;),    &quot;react&quot;: path.resolve(__dirname, &quot;./node_modules/react/umd/react.production.min.js&quot;),    &quot;react-dom&quot;: path.resolve(__dirname, &quot;./node_modules/react-dom/umd/react-dom.production.min.js&quot;)  &#125;,&#125;,</code></pre><h2 id="优化resolve-extensions配置"><a href="#优化resolve-extensions配置" class="headerlink" title="优化resolve.extensions配置"></a>优化resolve.extensions配置</h2><p><code>resolve.extensions</code>在导⼊语句没带⽂件后缀时，<code>webpack</code>会⾃动带上后缀后，去尝试查找⽂件是否存在</p><p>默认值：</p><pre><code class="javascript">extensions:[&#39;.js&#39;,&#39;.json&#39;,&#39;.jsx&#39;,&#39;.ts&#39;]</code></pre><ul><li>后缀尝试列表尽量的⼩</li><li>导⼊语句尽量的带上后缀</li></ul><h2 id="利⽤多线程提升构建速度"><a href="#利⽤多线程提升构建速度" class="headerlink" title="利⽤多线程提升构建速度"></a>利⽤多线程提升构建速度</h2><p>由于运⾏在 <code>Node.js</code> 之上的 <code>Webpack</code> 是单线程模型的，所以 <code>Webpack</code> 需要处理的事情需要⼀件⼀件的做，不能多件事⼀起做。我们需要 <code>Webpack</code> 能同⼀时间处理多个任务，发挥多核 <code>CPU</code> 电脑的威⼒。</p><p><strong>thread-loader</strong>是针对 <code>loader</code> 进⾏优化的，它会将 <code>loader</code> 放置在⼀个 <code>worker</code> 池⾥⾯运⾏，以达到多线程构建。<code>thread-loader</code> 在使⽤的时候，需要将其放置在其他 <code>loader</code> 之前，如下⾯实例:</p><pre><code class="javascript">module.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\.js$/,        use: [          &#39;thread-loader&#39;          // 你的⾼开销的loader放置在这后面 (e.g babel-loader)        ]      &#125;    ]  &#125;&#125;;</code></pre><h2 id="缓存cache相关"><a href="#缓存cache相关" class="headerlink" title="缓存cache相关"></a>缓存cache相关</h2><p><code>Webpack</code> 中打包的核⼼是 <code>JavaScript</code> <code>⽂件的打包，JavaScript</code> 使⽤的是 <code>babel-loader</code>，其实打包时间⻓很多时候是<code>babel-loader</code> 执⾏慢导致的。这时候我们不仅要使⽤ <code>exclude</code> 和 <code>include</code> 来尽可能准确的指定要转换内容的范畴，还需要关注 <code>babel-loader</code> 在执⾏的时候，可能会产⽣⼀些运⾏期间重复的公共⽂件，造成代码体积⼤冗余，同时也会减慢编译的速度。</p><p><code>babel-loader</code>提供了 <code>cacheDirectory</code> 配置给 <code>Babel</code> 编译时给定的⽬录，并且将⽤于缓存加载器的结果，但是这个设置默认是 <code>false</code> 关闭的状态，我们需要设置为 <code>true</code> ，这样 <code>babel-loader</code> 将使⽤默认的缓存⽬录 。<code>node_modules/.cache/babel-loader</code> ，如果在任何根⽬录下都没有找到 <code>node_modules</code> ⽬录，将会降级回退到操作系统默认的临时⽂件⽬录。</p><pre><code class="javascript">rules: [  &#123;    test: /\.js$/,    loader: &#39;babel-loader&#39;,    options: &#123;      cacheDirectory: true    &#125;,  &#125;];</code></pre><h2 id="压缩速度优化"><a href="#压缩速度优化" class="headerlink" title="压缩速度优化"></a>压缩速度优化</h2><p>相对于构建过程⽽⾔，压缩相对我们来说只有⽣产环境打包才会做，⽽且压缩我们除了添加 <code>cache</code> 和多线程⽀持之外，可以优化的空间较⼩。我们在使⽤ <code>terser-webpack-plugin</code> 的时候可以通过下⾯的配置开启多线程和缓存：</p><pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);module.exports = &#123;  optimization: &#123;    minimizer: [      new TerserPlugin(&#123;        cache: true, // 开启缓存        parallel: true // 多线程      &#125;)    ]  &#125;&#125;;</code></pre><h2 id="使⽤externals优化cdn静态资源"><a href="#使⽤externals优化cdn静态资源" class="headerlink" title="使⽤externals优化cdn静态资源"></a>使⽤externals优化cdn静态资源</h2><p>公司有<code>cdn</code>，静态资源有部署到<code>cdn</code>有链接了，我们使⽤<code>cdn</code>，我们的<code>bundle</code>⽂件⾥，就不⽤打包进去这个依赖了，体积会⼩很多，我们可以将⼀些<code>JS</code>⽂件存储在 <code>CDN</code> 上(减少 <code>Webpack</code> 打包出来的 <code>js</code> 体积)，在<code>index.html</code>中通过标签引⼊，如:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;root&lt;/div&gt;    &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>我们希望在使⽤时，仍然可以通过 <code>import</code> 的⽅式去引⽤(如 <code>import $ from &#39;jquery&#39;</code> )，并且希望<code>webpack</code> 不会对其进⾏打包，此时就可以配置 <code>externals</code> 。</p><pre><code class="javascript">module.exports = &#123; //...  externals: &#123;    //jquery通过script引⼊之后，全局中即有了 jQuery 变量    &#39;jquery&#39;: &#39;jQuery&#39;  &#125;&#125;</code></pre><h2 id="使⽤静态资源路径publicPath-CDN"><a href="#使⽤静态资源路径publicPath-CDN" class="headerlink" title="使⽤静态资源路径publicPath(CDN)"></a>使⽤静态资源路径publicPath(CDN)</h2><p><code>CDN</code>通过将资源部署到世界各地，使得⽤户可以就近访问资源，加快访问速度。要接⼊<code>CDN</code>，需要把⽹⻚的静态资源上传到<code>CDN</code>服务上，在访问这些资源时，使⽤<code>CDN</code>服务提供的<code>URL</code>。</p><pre><code class="javascript">// webpack.config.jsoutput:&#123;  publicPath: &#39;//cdnURL.com&#39;, //指定存放JS⽂件的CDN地址&#125;</code></pre><h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h2><p>借助<code>postcss</code>和<code>cssnano</code>，实现<code>css</code>代码的压缩，借助<code>terser-webpack-plugin</code>，实现<code>js</code>的压缩，借助<code>html-webpack-plugin</code>，实现<code>html</code>的压缩</p><ul><li><p>压缩html</p><pre><code class="javascript">plugin: [  new htmlWebpackPlugin(&#123;    title: &quot;京东商城&quot;,    template: &quot;./index.html&quot;,    filename: &quot;index.html&quot;,    minify: &#123;      // 压缩HTML⽂件      removeComments: true, // 移除HTML中的注释      collapseWhitespace: true, // 删除空⽩符与换⾏符      minifyCSS: true // 压缩内联css    &#125;  &#125;),]</code></pre></li><li><p>压缩css</p><p><code>webpack.config.js</code></p><pre><code class="javascript">&#123;  test: /\.css$/,  use: [    &#39;style-loader&#39;,    &#39;css-loader&#39;,    &#39;postcss-loader&#39;  ]&#125;,</code></pre><p><code>postcss.config.js</code></p><pre><code class="javascript">module.exports = &#123;  plugins: [    require(&#39;autoprefixer&#39;),    require(&#39;cssnano&#39;)  ]&#125;;</code></pre></li><li><p>压缩js</p><p>在 <code>mode=production</code> 下，<code>Webpack</code> 会⾃动压缩代码，我们可以⾃定义⾃⼰的压缩⼯具，这⾥推荐<code>terser-webpack-plugin</code>，它是 <code>Webpack</code> 官⽅维护的插件，使⽤<code>terser</code>来压缩 <code>JavaScript</code> 代码。<code>UglifyJS</code>在压缩 <code>ES5</code> ⽅⾯做的很优秀，但是随着 <code>ES6</code> 语法的普及，<code>UglifyJS</code> 在 <code>ES6</code> 代码压缩上做的不够好，所以有了 <code>uglify-es</code> 项⽬，但是之后 <code>uglify-es</code> 项⽬不在维护了，<code>terser</code> 是从 <code>uglify-es</code> 项⽬拉的⼀个分⽀，来继续维护。</p><pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);module.exports = &#123;  optimization: &#123;    minimizer: [      new TerserPlugin()    ]  &#125;&#125;;</code></pre><p>在实际开发中，我们可以通过移除⼀些不⽤的代码从⽽达到优化代码体积的作⽤，<code>Tree-Shaking</code> 也是依赖这个插件的</p><pre><code class="javascript">new TerserPlugin(&#123;  // 使⽤ cache，加快⼆次构建速度  cache: true,  terserOptions: &#123;    comments: false,    compress: &#123;      // 删除⽆⽤的代码      unused: true,      // 删掉 debugger      drop_debugger: true, // eslint-disable-line      // 移除 console      drop_console: true, // eslint-disable-line      // 移除⽆⽤的代码      dead_code: true // eslint-disable-line    &#125;  &#125;&#125;);</code></pre><p>压缩是发布前处理最耗时间的⼀个步骤，在 <code>Webpack</code> 配置中可以通过开启 <code>terser-webpack-plugin</code> 的多线程压缩来加速我们的构建压缩速度：</p><pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);module.exports = &#123;  optimization: &#123;    minimizer: [new TerserPlugin(      parallel: true // 多线程    )],  &#125;,&#125;;</code></pre></li></ul><h2 id="tree-Shaking：擦除⽆⽤的JS-CSS"><a href="#tree-Shaking：擦除⽆⽤的JS-CSS" class="headerlink" title="tree Shaking：擦除⽆⽤的JS,CSS"></a>tree Shaking：擦除⽆⽤的JS,CSS</h2><p><code>webpack4.x</code>开始⽀持 <code>tree shaking</code>概念，顾名思义，”摇树”，清除⽆⽤ <code>css</code>,<code>js</code>(<code>Dead Code</code>)<br><code>Dead Code</code> ⼀般具有以下⼏个特征</p><ul><li><p>代码不会被执⾏，不可到达</p></li><li><p>代码执⾏的结果不会被⽤到</p></li><li><p>代码只会影响死变量（只写不读）</p></li><li><p>Js tree shaking只⽀持ES module的引⼊⽅式！！！！</p></li><li><p>Css tree shaking</p><pre><code>npm install glob-all purify-css purifycss-webpack -D</code></pre><pre><code class="javascript">const PurifyCSS = require(&#39;purifycss-webpack&#39;)const glob = require(&#39;glob-all&#39;)// ...plugins: [// 清除⽆⽤ css  new PurifyCSS(&#123;    paths: glob.sync([      // 要做 CSS Tree Shaking 的路径⽂件      path.resolve(__dirname, &#39;./src/*.html&#39;), // 请注意，我们同样需要对 html ⽂件进⾏ tree shaking      path.resolve(__dirname, &#39;./src/*.js&#39;)    ])  &#125;)]// ...</code></pre></li><li><p>JS tree shaking</p><p>只⽀持<code>import</code>⽅式引⼊，不⽀持<code>commonjs</code>的⽅式引⼊</p><p>⽣产模式不需要配置，默认开启</p><pre><code class="javascript">// ...optimization: &#123;  usedExports: true // 哪些导出的模块被使⽤了，再做打包&#125;// ...</code></pre><p>只要<code>mode</code>是<code>production</code>就会⽣效，<code>develpoment</code>的<code>tree shaking</code>是不⽣效的，因为<code>webpack</code>为了⽅便你的调试</p><p><code>sideEffects</code> 处理副作⽤<br>&#x2F;&#x2F;package.json</p><pre><code class="json">&quot;sideEffects&quot;:false</code></pre><p>正常对所有模块进⾏<code>tree shaking</code> , 仅⽣产模式有效，需要配合<code>usedExports</code>使用</p><p>或者 在数组⾥⾯排除不需要<code>tree shaking</code>的模块</p><pre><code class="json">&quot;sideEffects&quot;: [&#39;*.css&#39;,&#39;@babel/polyfill&#39;]</code></pre></li></ul><h2 id="代码分割-code-Splitting"><a href="#代码分割-code-Splitting" class="headerlink" title="代码分割 code Splitting"></a>代码分割 code Splitting</h2><p>单⻚⾯应⽤<code>spa</code>：</p><p>打包完后，所有⻚⾯只⽣成了⼀个<code>bundle.js</code></p><ul><li>代码体积变⼤，不利于下载</li><li>没有合理利⽤浏览器资源</li></ul><p>多⻚⾯应⽤mpa:</p><p>如果多个⻚⾯引⼊了⼀些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要<br>下载⼀次就缓存起来了，避免了重复下载。</p><p>其实<code>code Splitting</code>概念 与 <code>webpack</code>并没有直接的关系，只不过<code>webpack</code>中提供了⼀种更加⽅便的⽅法供我们实现代码分割</p><p><code>webpack</code>的配置基于<a href="https://webpack.js.org/plugins/split-chunks-plugin/">split-chunks-plugin</a></p><pre><code class="javascript">optimization: &#123;  splitChunks: &#123;    chunks: &quot;all&quot;, // 所有的 chunks 代码公共的部分分离出来成为⼀个单独的⽂件  &#125;,&#125;,</code></pre><pre><code class="javascript">optimization: &#123;  splitChunks: &#123;    chunks: &#39;async&#39;,  //对同步 initial，异步 async，所有的模块有效 all    minSize: 30000, //最⼩尺⼨，当模块⼤于30kb    maxSize: 0, //对模块进⾏⼆次分割时使⽤，不推荐使⽤    minChunks: 1, //打包⽣成的chunk⽂件最少有⼏个chunk引⽤了这个模块    maxAsyncRequests: 5,  //最⼤异步请求数，默认5    maxInitialRequests: 3,  //最⼤初始化请求书，⼊⼝⽂件同步请求，默认3    automaticNameDelimiter: &#39;-&#39;,  //打包分割符号    name: true, //打包后的名称，除了布尔值，还可以接收⼀个函数function    cacheGroups: &#123;  //缓存组      vendors: &#123;        test: /[\\/]node_modules[\\/]/, // 判断引入库是否是node_modules里的        name: &quot;vendor&quot;,  // 要缓存的 分隔出来的 chunk 名称        priority: -10, //缓存组优先级 数字越⼤，优先级越⾼        // filename: &#39;vendor.min.js&#39;  // 设置代码分割后的文件名，仅在chunks为initial时能用，否则报错      &#125;,      other:&#123;        chunks: &quot;initial&quot;,  // 必须三选⼀： &quot;initial&quot; | &quot;all&quot; | &quot;async&quot; (默认就是async)        test: /react|lodash/,   // 正则规则验证，如果符合就提取 chunk,        name:&quot;other&quot;,        minSize: 30000,        minChunks: 1,      &#125;,      default: &#123;        minChunks: 2, // 在拆分之前共享模块的最小块数, 默认为1，表示只要有一个地方引入，就抽离到公共模块，设置为2表示 有两个chunk 引入同一个人文件才进行抽离，设置2更为合理一点        priority: -20,        reuseExistingChunk: true  // 允许在模块完全匹配时重用现有的块，而不是创建新的块      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="webpack-bundle-analyzer-分析webpack打包后的模块依赖关系："><a href="#webpack-bundle-analyzer-分析webpack打包后的模块依赖关系：" class="headerlink" title="webpack-bundle-analyzer: 分析webpack打包后的模块依赖关系："></a>webpack-bundle-analyzer: 分析webpack打包后的模块依赖关系：</h2><pre><code class="javascript">// npm install webpack-bundle-analyzer -Dconst BundleAnalyzerPlugin = require(&#39;webpack-bundleanalyzer&#39;).BundleAnalyzerPlugin;module.exports = merge(baseWebpackConfig, &#123; //.... plugins: [ //...  new BundleAnalyzerPlugin(), ]&#125;)</code></pre><h1 id="development-vs-Production模式区分打包"><a href="#development-vs-Production模式区分打包" class="headerlink" title="development vs Production模式区分打包"></a>development vs Production模式区分打包</h1><p>区分环境打包可以创建多个不同环境的<code>config</code>文件，执行打包命令的时候指定对应的config文件，我们可以定义一个基础文件<code>webpack.common.config.js</code>存放公用的配置，然后再创建其他环境的配置文件，例如<code>webpack.prod.config.js</code>、<code>webpack.dev.config.js</code>、<code>webpack.test.config.js</code>等，在里面进行公共配置的合并</p><p>例如：</p><pre><code class="javascript">const merge = require(&quot;webpack-merge&quot;)const commonConfig = require(&quot;./webpack.common.js&quot;)const devConfig = &#123; ...&#125;module.exports = merge(commonConfig,devConfig)</code></pre><p><code>package.js</code></p><pre><code class="json">&quot;scripts&quot;:&#123; &quot;dev&quot;: &quot;webpack --config ./webpack.dev.config.js&quot;, &quot;build&quot;: &quot;webpack --config ./webpack.prod.config.js&quot;&#125;</code></pre><p>还可以借助<code>cross-env</code>基于环境变量区分，由于不同平台之间环境变量稍有不同，因此需要借助这个工具进行统一，这个工具可以在我们执行打包命令的时候，自动修改<code>node</code>的<code>process.env</code>环境变量的配置，比如</p><pre><code class="json">&quot;scripts&quot;:&#123; &quot;dev&quot;: &quot;cross-env NODE_ENV=&#39;development&#39; webpack --config ./webpack.dev.config.js&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=&#39;production&#39; webpack --config ./webpack.prod.config.js&quot;&#125;</code></pre><p>我们执行<code>npm run dev</code>的时候，<code>process.env.NODE_ENV</code> 被设置为<code>development</code>，而执行<code>npm run build</code>的时候<code>process.env.NODE_ENV</code> 被设置为<code>production</code>，然后我们可以根据这个环境变量，只写一份<code>webpack.config.js</code>配置，实现不同环境环境的打包；</p><p>例如：</p><pre><code class="javascript">const webpackEnv = process.env.NODE_ENV;const isEnvDevelopment = webpackEnv === &#39;development&#39;;const isEnvProduction = webpackEnv === &#39;production&#39;;module.exports = &#123;  mode: isEnvProduction ? &#39;production&#39; : isEnvDevelopment &amp;&amp; &#39;development&#39;,  devtool: isEnvProduction    ? shouldUseSourceMap      ? &#39;source-map&#39;      : false    : isEnvDevelopment &amp;&amp; &#39;cheap-module-source-map&#39;,  // ...&#125;</code></pre><p><code>webpack.config.js</code>还可以导出一个函数，函数接收两个入参：</p><ul><li>env：当前运行 <code>webpack</code> 的环境变量, 设置它时需要在启动 <code>webpack</code> 时候带上参数, 例如: <code>webpack --env.production</code>;</li><li>args：代表在 <code>webpack</code> 启动时候通过命令行传入的所有参数; 例如: <code>--config</code> <code>--env</code> <code>--devtool</code> 等;</li></ul><p>例如：</p><pre><code class="json">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;webpack --env development --config ./webpack.dev.config.js&quot;,  &#125;,</code></pre><pre><code class="javascript">module.exports = function(env, args) &#123;  console.log(env, args)  const isEnvDevelopment = env === &#39;development&#39;;  const isEnvProduction = env === &#39;production&#39;;  return &#123;    mode: isEnvProduction ? &#39;production&#39; : isEnvDevelopment &amp;&amp; &#39;development&#39;,    devtool: isEnvProduction      ? shouldUseSourceMap        ? &#39;source-map&#39;        : false      : isEnvDevelopment &amp;&amp; &#39;cheap-module-source-map&#39;,    // ...  &#125;&#125;</code></pre><p><code>env</code>、<code>args</code>打印结果</p><pre><code class="javascript">development // env&#123; // args  _: [],  cache: null,  bail: null,  profile: null,  color: &#123; level: 3, hasBasic: true, has256: true, has16m: true &#125;,  colors: &#123; level: 3, hasBasic: true, has256: true, has16m: true &#125;,  env: &#39;development&#39;,  config: &#39;./webpack.dev.config.js&#39;,  &#39;info-verbosity&#39;: &#39;info&#39;,  infoVerbosity: &#39;info&#39;,  &#39;$0&#39;: &#39;node_modules\\webpack\\bin\\webpack.js&#39;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browserslist的作用</title>
      <link href="/2021/08/07/%E5%89%8D%E7%AB%AF/browserslist%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2021/08/07/%E5%89%8D%E7%AB%AF/browserslist%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>browserslist</code> 实际上就是声明了⼀段浏览器的集合，我们的⼯具可以根据这段集合描述，针对性的输出兼容性代码。</p><p><code>browserslist</code>就是帮助我们来设置⽬标浏览器的⼯具。<code>browserslist</code> 被⼴泛的应⽤到 <code>Babel</code>、<code>postcsspreset-env``、autoprefixer</code> 等开发⼯具上。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>browserslist</code> 的配置可以放在<code> package.json</code> 中，也可以单独放在配置⽂件 <code>.browserslistrc</code> 中。所有的⼯具都会主动查找 <code>browserslist</code> 的配置⽂件，根据 <code>browserslist</code> 配置找出对应的⽬标浏览器集合。</p><p><code>browserslist</code> 的数据都是来⾃<a href="https://browserl.ist/">Can I Use</a>，可惜⽹站关闭了，现在需要⼿动检测：</p><pre><code>npx browserslist &quot;last 1 version, &gt;1%&quot;</code></pre><p>在 <code>package.json</code> 中的配置是增加⼀个 <code>browserslist</code> 数组属性：</p><pre><code class="json">&#123; &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;maintained node versions&quot;, &quot;notie &lt; 11&quot;]&#125;</code></pre><p>或者在项⽬的根⽬录下创建⼀个 <code>.browserslistrc</code> ⽂件：</p><pre><code># 注释是这样写的，以#号开头# 每⾏⼀个浏览器集合描述last 2 version&gt; 1%maintained node versionsnot ie &lt; 11</code></pre><h1 id="常⻅集合范围说明"><a href="#常⻅集合范围说明" class="headerlink" title="常⻅集合范围说明"></a>常⻅集合范围说明</h1><table><thead><tr><th>范围</th><th>说明</th></tr></thead><tbody><tr><td><code>last 2 versions</code></td><td><a href="https://caniuse.com/">caniuse.com</a>⽹站跟踪的最新两个版本，假如 iOS 12 是最新版本，那么向后兼容两个版本就是 iOS 11 和 iOS 12</td></tr><tr><td><code>&gt; 1%</code></td><td>全球超过 1%⼈使⽤的浏览器，类似 <code>&gt; 5% in US</code> 则指代美国 5%以上⽤户</td></tr><tr><td><code>cover 99.5%</code></td><td>覆盖 99.5%主流浏览器</td></tr><tr><td><code>chrome &gt; 50</code> 或 <code>ie 6-8</code></td><td>指定某个浏览器版本范围</td></tr><tr><td><code>unreleased versions</code></td><td>所有浏览器的 beta 版本</td></tr><tr><td><code>not ie &lt; 11</code></td><td>排除 ie11 以下版本不兼容</td></tr><tr><td><code>since 2013</code> 或 <code>last 2 years</code></td><td>某时间范围发布的所有浏览器版本</td></tr><tr><td><code>maintained node versions</code></td><td>所有被 node 基⾦会维护的 node 版本</td></tr><tr><td><code>current node</code></td><td>当前环境的 node 版本</td></tr><tr><td><code>dead</code></td><td>通过 last 2 versions 筛选的浏览器中，全球使⽤率低于 0.5% 且官⽅声明不在维护或者事实上已经两年没有再更新的版本</td></tr><tr><td><code>defaults</code></td><td>默认配置， <code>&gt; 0.5%</code> <code>last 2 versions</code> <code>Firefox ESR</code> <code>not dead</code></td></tr></tbody></table><h1 id="浏览器名称列表（⼤⼩写不敏感）"><a href="#浏览器名称列表（⼤⼩写不敏感）" class="headerlink" title="浏览器名称列表（⼤⼩写不敏感）"></a>浏览器名称列表（⼤⼩写不敏感）</h1><ul><li>Android ：安卓 webview 浏览器；</li><li>Baidu ： 百度浏览器；</li><li>BlackBerry &#x2F; bb ：⿊莓浏览器；</li><li>Chrome ：chrome 浏览器；</li><li>ChromeAndroid &#x2F; and_chr ：chrome 安卓移动浏览器；</li><li>Edge ：微软 Edge 浏览器；</li><li>Electron ：Electron；</li><li>Explorer &#x2F; ie ：ie 浏览器；</li><li>ExplorerMobile &#x2F; ie_mob ：ie 移动浏览器；</li><li>Firefox &#x2F; ff ：⽕狐浏览器； * FirefoxAndroid &#x2F; and_ff ：⽕狐安卓浏览器；</li><li>iOS &#x2F; ios_saf ：iOS Safari 浏览器；</li><li>Node ：nodejs；</li><li>Opera ：opera 浏览器；</li><li>OperaMini &#x2F; op_mini ：operaMini 浏览器；</li><li>OperaMobile &#x2F; op_mob ：opera 移动浏览器；</li><li>QQAndroid &#x2F; and_qq ：QQ 安卓浏览器；</li><li>Samsung ：三星浏览器；</li><li>Safari ：桌⾯版本 Safari；</li><li>UCAndroid &#x2F; and_uc ：UC 安卓浏览器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browserslist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex 详解</title>
      <link href="/2021/08/06/Vue/Vuex-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/08/06/Vue/Vuex-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在大型的项目中，状态往往不只是父子之间传递，而是分布于各个组件中，我们通过属性传值的方式就会显得十分臃肿，并且在<code>Vue</code>中，兄弟组件之间传值并没有什么好的办法，往往通过事件总线订阅发布的方式，这种方式可行，但是我们把一些共享的状态抽离出来，统一的放在一个仓库中，哪个组件需要使用，就去仓库里拿，这种方式不是更好吗，这就是状态机的作用，在<code>React</code>中有<code>Redux</code>，<code>Mobx</code>等一些库，而在<code>Vue</code>中，官方推出的<code>Vuex</code>是最适合Vue的，<code>Vuex</code>中的状态是响应式的，完美的结合了<code>Vue</code>的优势；</p><h1 id="Vuex核心内容"><a href="#Vuex核心内容" class="headerlink" title="Vuex核心内容"></a>Vuex核心内容</h1><p>在<code>Vuex</code>对象中，其实不止有<code>state</code>,还有用来操作<code>state</code>中数据的方法集，以及当我们需要对<code>state</code>中的数据需要加工的方法集等等成员。</p><p>成员列表：</p><ul><li><code>state</code>     存放状态</li><li><code>getters</code>   加工<code>state</code>成员给外界</li><li><code>mutations</code> 同步<code>state</code>成员操作</li><li><code>actions</code>   异步操作</li><li><code>modules</code>   模块化状态管理</li></ul><h1 id="Vuex工作流程"><a href="#Vuex工作流程" class="headerlink" title="Vuex工作流程"></a>Vuex工作流程</h1><p>官网给出的流程图<br><img src="/images/vuex.png"></p><p>首先，<code>Vue</code>组件如果调用某个<code>Vuex</code>的方法过程中需要向后端请求时或者说出现异步操作时，需要<code>dispatch</code> <code>Actions</code>的方法，以保证数据的同步。可以说，<code>action</code>的存在就是为了让<code>mutations</code>中的方法能在异步操作中起作用。</p><p>如果没有异步操作，那么我们就可以直接在组件内提交状态中的Mutations中自己编写的方法来达成对<code>state</code>成员的操作。<strong>但是不建议这样做</strong>，我们希望总是由<code>action</code>去调用<code>mutations</code>修改<code>state</code></p><p>不建议在组件中直接对<code>state</code>中的成员进行操作，这是因为直接修改(例如：<code>this.$store.state.name = &#39;hello&#39;</code>)的话不能被<code>VueDevtools</code>所监控到。同样，总是应该有<code>mustaions</code>去修改<code>state</code></p><p>最后被修改后的<code>state</code>成员会被渲染到组件的当中去。</p><p>这样就形成了一个单向闭环，这样的好处是可以明确的知道数据的流向，避免数据混乱；</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm install vuex --save或者yarn add vuex</code></pre><h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p>一般我们把全局状态单独放在一个文件夹中，然后把<code>store</code>导出，在<code>main.js</code>中使用这个<code>store</code>，<code>store</code>文件夹组织类似于<br><img src="/images/vuex2.png"></p><p><code>store</code>的<code>index.js</code>文件类似于下面代码，由于<code>Vuex</code>实例化之前需要<code>Vue.use()</code>一下，因此需要先导入<code>vue</code></p><p><code>store/index.js</code></p><pre><code class="javascript">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)import state from &#39;./state&#39;import mutations from &#39;./mutations&#39;import getters from &#39;./getters&#39;import actions from &#39;./actions&#39;// 单独模块import users from &#39;./modules/users&#39;export default new Vuex.Store(&#123;  state,  mutations,  actions,  getters,  modules: &#123;    users  &#125;&#125;)</code></pre><p><code>main.js</code></p><pre><code class="javascript">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import store from &#39;./store&#39;new Vue(&#123;  store,  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><h2 id="state-mapState"><a href="#state-mapState" class="headerlink" title="state &amp; mapState"></a>state &amp; mapState</h2><p><code>state</code>的声明很简单，就是一个对象，里面存放的是响应式数据</p><p><code>state.js</code></p><pre><code class="javascript">export default &#123;    name: &#39;jerry&#39;,    age: 18&#125;</code></pre><p>由于我们把<code>state</code>抽离出来了，因此直接导出对象就行了</p><p>数据声明了，怎么使用呢？ 在组件中我们直接可以拿到<code>store</code>里的<code>state</code>，有以下几种方式</p><ul><li><p>直接在模板中使用</p><pre><code class="html">    &lt;template&gt;      &lt;div&gt;        &#123;&#123; $store.state.name &#125;&#125;        &#123;&#123; $store.state.age &#125;&#125;      &lt;/div&gt;    &lt;/template&gt;</code></pre></li><li><p><code>computed</code>中指定</p><p>当不使用<code>mapState</code>辅助函数的时候，直接定义计算属性，使用<code>this.$store.state</code>获取状态，如果很多状态，这样写代码十分冗余</p><p>但是如果需要拿到状态和本地数据进行结合，这样写是很方便的，（无法使用过滤器，过滤器中无法访问实例this）</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; name &#125;&#125;    &#123;&#123; age &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    name() &#123;      return this.$store.state.name    &#125;,    age() &#123;      return this.$store.state.age + this.localData    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li><li><p><code>mapState</code>辅助函数</p><p><code>mapState</code>的第一个参数是命名空间，字符串，结合<code>modules</code>使用，可省略，第二个参数可以是一个数组或者对象</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; name &#125;&#125;    &#123;&#123; age &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    ...mapState([&#39;name&#39;, &#39;age&#39;])  &#125;&#125;&lt;/script&gt;</code></pre><p>如果传入对象，必须定义一个计算属性名称，不能使用ES6的<code>&#123;name, age&#125;</code>的省略写法，否则报错</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; stateName &#125;&#125;    &#123;&#123; stateAge &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    ...mapState(&#123;      stateName: &#39;name&#39;,      stateAge: &#39;age&#39;    &#125;)  &#125;&#125;&lt;/script&gt;</code></pre></li></ul><h2 id="getters-mapGetters"><a href="#getters-mapGetters" class="headerlink" title="getters &amp; mapGetters"></a>getters &amp; mapGetters</h2><p><code>getter</code>可认为是<code>state</code>的计算属性，将<code>state</code>作为第一个参数，可以拿到<code>state</code>里的数据，并且还可以接受第二个参数，就是<code>getters</code>，用来调用其他<code>getter</code></p><p><code>getters.js</code></p><pre><code class="javascript">export default &#123;    // getter将state作为第一个参数    ageWithSuffix(state) &#123;        return state.age + &#39;岁&#39;    &#125;,    // getter也可将getters作为第二个参数，用来调用其他getter    ageWithPrefix(state, getters) &#123;        return &#39;今年&#39; + getters.ageWithSuffix    &#125;&#125;</code></pre><p>如何使用getters？</p><ul><li><p>模板里直接使用</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; $store.getters.ageWithSuffix &#125;&#125;    &#123;&#123; $store.getters.ageWithPrefix &#125;&#125;  &lt;/div&gt;&lt;/template&gt;</code></pre></li><li><p><code>computed</code>里使用</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; prefix &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  // ...  computed: &#123;    prefix()&#123;      return this.$store.getters.ageWithPrefix    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li><li><p><code>mapGetters</code>辅助函数<br>数组写法</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; ageWithSuffix &#125;&#125;    &#123;&#123; ageWithPrefix &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    ...mapGetters([&#39;ageWithSuffix&#39;, &#39;ageWithPrefix&#39;]),  &#125;&#125;&lt;/script&gt;</code></pre><p>对象写法</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; suffix &#125;&#125;    &#123;&#123; prefix &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    ...mapGetters(&#123;       suffix: &#39;ageWithSuffix&#39;,       prefix: &#39;ageWithPrefix&#39;    &#125;)  &#125;&#125;&lt;/script&gt;</code></pre></li></ul><p>上面是定义状态以及获取状态的方法，而修改状态需要<code>dispatch</code>一个<code>action</code>，然后再由<code>action</code>去<code>commit</code>一个<code>mutation</code>，实现状态修改</p><p>所以<code>action</code>和<code>mutation</code>之间是强耦合的，我们为了去耦合，会引入一个<code>mutation-type.js</code>，这个也可以帮助我们快速找到相关代码的位置。</p><p><code>mutation-type.js</code></p><pre><code class="javascript">export const CHANGE_AGE = &#39;change_age&#39;export const CHANGE_NAME = &#39;change_name&#39;</code></pre><p>然后我们定义<code>action</code>和<code>mutation</code>的时候，通过这个中间变量，进行关联；</p><h2 id="actions-mutations"><a href="#actions-mutations" class="headerlink" title="actions &amp; mutations"></a>actions &amp; mutations</h2><ul><li><p>actions<br><code>action</code>整体是一个对象，<code>key</code>是将来我们<code>dispatch``action</code>的<code>type</code>值，因此我们可以直接使用<code>mutation-types</code>导出的值，和<code>mutaion</code>保持一致。</p><p><code>action</code> 函数第一个参数是一个与 <code>store</code> 实例具有相同方法和属性的<code>context</code> 对象，因此你可以调用 <code>context.commit</code> 提交一个 <code>mutation</code>，或者通过<code>context.state</code> 和 <code>context.getters</code> 来获取 <code>state</code> 和 <code>getters</code>，甚至可以通过<code>context.dispatch</code>派发另外一个<code>action</code>，可以通过解构来简化代码</p><p><code>action</code>里是可以执行异步代码的，等异步执行完了再去<code>commit</code> <code>mutation</code>，此时才是同步修改<code>state</code></p><p><code>actions.js</code></p><pre><code class="javascript">import &#123; CHANGE_AGE, CHANGE_NAME &#125; from &#39;./mutation-types&#39;export default &#123;    // 第二个参数是payload，用于接收数据，通常为一个对象，用于接收多个数据，也可以直接接受单个参数    [CHANGE_NAME](&#123; commit &#125;, payload) &#123;        commit(CHANGE_NAME, payload)    &#125;,&#125;</code></pre><p>  如果我们利用 <code>async / await</code>，我们可以如下组合 <code>action</code>，在<code>action</code>中调用另外一个<code>action</code></p><pre><code class="javascript">// 假设 getData() 和 getOtherData() 返回的是 Promiseasync actionA(&#123; commit &#125;) &#123;  commit(&#39;gotData&#39;, await getData())&#125;,async actionB(&#123; dispatch, commit &#125;) &#123;  await dispatch(&#39;actionA&#39;) // 等待 actionA 完成  commit(&#39;gotOtherData&#39;, await getOtherData())&#125;</code></pre></li><li><p>mutations</p><p><code>mutation</code>接收两个参数，一个是<code>state</code>，用于修改状态，一个是<code>payload</code>，用于接收<code>action</code>传参，<code>payload</code>大多数为一个对象，用以传递多个数据</p><p><code>mutations.js</code></p><pre><code class="javascript">import &#123; CHANGE_AGE, CHANGE_NAME &#125; from &#39;./mutation-types&#39;export default &#123;    // [CHANGE_AGE] 为es6语法，可以将表达式作为属性名    [CHANGE_AGE](state, payload) &#123;        console.log(payload);        state.age = payload.age    &#125;,    [CHANGE_NAME](state, payload) &#123;        state.name = payload.name    &#125;,&#125;</code></pre></li></ul><h2 id="store-dispatch-mapActions"><a href="#store-dispatch-mapActions" class="headerlink" title="$store.dispatch &amp; mapActions"></a>$store.dispatch &amp; mapActions</h2><ul><li><p>$store.dispatch</p><p><code>$store.dispatch</code>可以直接派发一个<code>action</code>，<code>dispatch</code>接收一个对象作为参数，对象必须指定一个<code>type</code>属性，表示派发哪一个<code>action</code>，或者把<code>type</code>放在第一个参数上</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CHANGE_NAME &#125; from &#39;@/store/mutation-types&#39;export default &#123;  // ...  methods: &#123;    changeName() &#123;      this.$store.dispatch(&#123;        type: CHANGE_NAME,        name: &#39;tom&#39;      &#125;)      // 把type放在第一个参数上      this.$store.dispatch(CHANGE_NAME, &#123;        name: &#39;tom&#39;      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li><li><p>mapActions</p><p><code>mapActions</code> 辅助函数将组件的 <code>methods</code> 映射为 <code>store.dispatch</code> 调用</p><pre><code class="javascript">import &#123; mapActions &#125; from &#39;vuex&#39;export default &#123;  // ...  methods: &#123;    ...mapActions([      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`      // `mapActions` 也支持载荷：      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#39;incrementBy&#39;, amount)`    ]),    ...mapActions(&#123;      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`，相当于取了个别名    &#125;)  &#125;&#125;</code></pre><p>引入<code>mutation-types</code>的例子：</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CHANGE_NAME &#125; from &#39;@/store/mutation-types&#39;import &#123; mapActions &#125; from &#39;vuex&#39;export default &#123;  // ...  methods: &#123;    ...mapActions([CHANGE_NAME]),    changeName() &#123;      this[CHANGE_NAME](&#123;name: &#39;tom&#39;&#125;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li></ul><h2 id="store-commit-mapMutations"><a href="#store-commit-mapMutations" class="headerlink" title="$store.commit &amp; mapMutations"></a>$store.commit &amp; mapMutations</h2><ul><li><p>$store.commit</p><p>我们是可以直接跳过<code>action</code>直接提交一个<code>mutation</code>的，但是不建议这么做，即使你知道并没有异步操作</p><p><code>$store.commit</code>可以直接提交一个<code>mutation</code>，<code>commit</code>接收一个对象作为参数，对象必须指定一个<code>type</code>属性，表示提交哪一个<code>mutation</code>，或者把<code>type</code>放在第一个参数上</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CHANGE_NAME, CHANGE_AGE &#125; from &#39;@/store/mutation-types&#39;export default &#123;  // ...  methods: &#123;    changeAge() &#123;      this.$store.commit(&#123;        type: CHANGE_AGE,        age: 20      &#125;)      // 把type放在第一个参数上      this.$store.commit(CHANGE_AGE, &#123;        age: 20      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li><li><p>mapMutations</p><pre><code class="javascript">import &#123; mapMutations &#125; from &#39;vuex&#39;export default &#123;  // ...  methods: &#123;    ...mapMutations([      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.commit(&#39;increment&#39;)`      // `mapMutations` 也支持载荷：      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#39;incrementBy&#39;, amount)`    ]),    ...mapMutations(&#123;      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.commit(&#39;increment&#39;)`    &#125;)  &#125;&#125;</code></pre><p>引入<code>mutation-types</code>的例子：</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CHANGE_AGE &#125; from &#39;@/store/mutation-types&#39;import &#123; mapMutations &#125; from &#39;vuex&#39;export default &#123;  // ...  methods: &#123;    ...mapMutations([CHANGE_AGE]),    changeAge() &#123;      this[CHANGE_AGE](&#123;age: 20&#125;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li></ul><h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>在外面使用<code>state</code>时，通过 <code>&#123;&#123;$store.state.users.username&#125;&#125;</code> 获取，</p><p>这里的<code>users</code>是根据<code>new Vuex.Store(&#123; modules: &#123; users: users &#125; &#125;)</code> 的<code>key</code>来指定的</p><p>是否启用命名空间对模块内的<code>state</code>都没有影响，取值的方式都需要加上命名空间</p><p>因此取值方式变成了</p><pre><code class="html">&lt;template&gt;  &#123;&#123;$store.state.users.username&#125;&#125;  &lt;/template&gt;</code></pre><p>或者</p><pre><code class="javascript">...mapState(&#39;account&#39;, [&#39;user&#39;])</code></pre><p>或者</p><pre><code class="javascript">...mapState(&#123;  tomRole: state =&gt; state.users.role,  tomAge: state =&gt; state.users.age&#125;)</code></pre><p>如果仅仅是区分了模块，而没有设置命名空间，那么<code>getters</code>、<code>actions</code>、<code>mutations</code>将会和根状态合并，外部直接获取，不需要加上命名空间</p><p>如果设置命名空间为<code>true</code>，则在外面获取时需要加上命名空间，如下</p><p>如果使用命名空间，那么使用<code>getters</code>、<code>actions</code>、<code>mutaions</code>都需要使用命名空间的写法，</p><pre><code class="javascript">[this.]$store.getters[&#39;account/isAdmin&#39;]   或  ...mapGetters(&#39;account&#39;, [&#39;isAdmin&#39;])[this.]$store.dispatch(&#39;account/login&#39;)    或  ...mapActions(&#39;account&#39;, [&#39;login&#39;])[this.]$store.commit(&#39;account/login&#39;)      或  ...mapMutations(&#39;account&#39;, [&#39;login&#39;])</code></pre><pre><code class="javascript">export default &#123;    namespaced: true,    // 可以注意到state是一个函数返回了对象，避免自己和其他state数据互相污染，实际上和Vue组件内的data是同样的问题    state() &#123;        return &#123;            username: &#39;Tom&#39;,            role: &#39;admin&#39;,            age: 20        &#125;    &#125;,    // 在这个模块的 getter 中，`getters` 被局部化了， 你可以使用 getter 的第四个参数来调用 `rootGetters`    // 如果你希望使用全局 state 和 getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，    // 也会通过 context 对象的属性传入 action。    getters: &#123;        role(state, getters, rootState, rootGetters) &#123;            return state.role        &#125;,        allAge(state, getters, rootState, rootGetters) &#123;            return state.age + rootState.age        &#125;    &#125;,    // 对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：    actions: &#123;        change_role(&#123; commit, rootState &#125;) &#123;            commit(&#39;m_change_role&#39;)        &#125;,        // 在这个模块中， dispatch 和 commit 也被局部化了，他们可以接受 `root` 属性以访问根 dispatch 或 commit        // 若需要在全局命名空间内分发 action 或提交 mutation，将 &#123; root: true &#125; 作为第三参数传给 dispatch 或 commit 即可。        someAction(&#123; dispatch, commit, getters, rootGetters &#125;) &#123;            getters.someGetter                                  // -&gt; &#39;users/someGetter&#39;            rootGetters.someGetter                              // -&gt; &#39;someGetter&#39;            dispatch(&#39;someOtherAction&#39;)                         // -&gt; &#39;users/someOtherAction&#39;            dispatch(&#39;someOtherAction&#39;, null, &#123; root: true &#125;)   // -&gt; &#39;someOtherAction&#39;            commit(&#39;someMutation&#39;)                              // -&gt; &#39;users/someMutation&#39;            commit(&#39;someMutation&#39;, null, &#123; root: true &#125;)        // -&gt; &#39;someMutation&#39;        &#125;,        // 若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。例如：        globalAction: &#123;            root: true,            handler(namespacedContext, payload) &#123; &#125;        &#125;    &#125;,    mutations: &#123;        m_change_role(state, payload) &#123;            state.role = &#39;vip&#39;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 中一些常常令人忽视的重要知识点</title>
      <link href="/2021/08/03/Vue/Vue-%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E5%B8%B8%E4%BB%A4%E4%BA%BA%E5%BF%BD%E8%A7%86%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/08/03/Vue/Vue-%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E5%B8%B8%E4%BB%A4%E4%BA%BA%E5%BF%BD%E8%A7%86%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要是总结一下自己在使用和学习<code>Vue</code>的过程中容易忽视的重要知识点</p><h1 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h1><p><code>inheritAttrs</code>的作用是组件根元素上是否继承来自父组件定义给该组件的属性，这里的属性不包括已经在子组件中使用<code>props</code>接收到的属性和<code>class</code>、<code>style</code>属性；这些属性可以使用<code>$attrs</code>获取到；</p><p>默认值是<code>true</code></p><p>例如以下父子组件：<br>父组件 ParentComp.vue</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp aaa=&quot;123&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  // inheritAttrs: false,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>父组件中，在子组件定义了一个属性<code>aaa</code>为<code>123</code>，<code>inheritAttrs</code>默认值是<code>true</code>，因此，在子组件的根元素<code>div</code>上，会跟着有<code>aaa</code>为<code>123</code>的属性；</p><p>如图：<br><img src="/images/vue1.png"></p><p>如果此时把子组件的<code>inheritAttrs</code>设置为<code>false</code>，此时子组件的根元素上就不会有该属性了；</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  inheritAttrs: false,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><p><img src="/images/vue2.png"></p><p><strong>那我要怎么拿到这个属性呢？</strong></p><p>可以使用<code>Vue</code>提供的<code>$attrs</code> API来获取组件的属性；</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  inheritAttrs: false,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,  created() &#123;    console.log(&#39;$attrs&#39;, this.$attrs)  &#125;&#125;&lt;/script&gt;</code></pre><p><img src="/images/vue3.png"></p><p>有了这个api就好办了，我们可以把该属性放到自己想要放到的任意元素上，而不是默认的根元素上；</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p v-bind=&quot;$attrs&quot;&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  inheritAttrs: false,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,  created() &#123;    console.log(&#39;$attrs&#39;, this.$attrs)  &#125;&#125;&lt;/script&gt;</code></pre><p>使用<code>v-bind=&quot;$attrs&quot;</code>，可以直接把<code>$attrs</code>里面的属性绑定到元素上，有多少个就绑定多少个;</p><p><strong>最后再强调一下，这里的<code>$attrs</code>是排除了组件<code>props</code>已接收到的属性和<code>class</code>、<code>style</code>属性的；</strong><br>通过一个例子综合看下效果：</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp aaa=&quot;123&quot; bbb=&quot;456&quot; ccc=&quot;789&quot; class=&quot;class1&quot; style=&quot;color: red&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p v-bind=&quot;$attrs&quot;&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  inheritAttrs: false,  props: [&#39;ccc&#39;],  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,  created() &#123;    console.log(&#39;$attrs&#39;, this.$attrs)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>可以看到，<code>class</code>属性和<code>style</code>属性被设置到了根元素上，而此时<code>ccc</code>属性被子组件<code>props</code>接收了，因此只有<code>aaa</code>和<code>bbb</code>属性了;<br><img src="/images/vue4.png"></p><p><img src="/images/vue5.png"></p><h1 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h1><p><code>.sync</code>修饰符有什么作用呢，很简单，我们都知道，父组件向子组件传值可以使用<code>props</code>，子组件是不能直接修改传过来<code>props</code>的，此时常用的方法是子组件通过<code>$emit</code>一个自定义事件，父组件中监听这个时间，然后去修改<code>props</code>的值，从而在子组件中修改<code>props</code>。</p><p>这样并没有任何问题，但是如果每次修改都需要在父组件中定义一个自定义事件，这样十分冗余，那有没有什么方式能够实现<code>props</code>的“双向绑定”呢，这就是<code>.sync</code>的作用，<code>.sync</code>实际上就是上述实现方法的语法糖，通过下面的例子我们可以看到；</p><p>通过自定义方法修改<code>props</code> </p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp @change-msg=&quot;msg = $event&quot;  :msg=&quot;msg&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;$emit(&#39;change-msg&#39;, &#39;我不是传奇&#39;)&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  props: [&#39;msg&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>修改一下自定义事件名，修改为<code>update:msg</code>，也是可以正常工作的。为什么要修改成这样？后面再看。</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp @update:msg=&quot;msg = $event&quot; :msg=&quot;msg&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;$emit(&#39;update:msg&#39;, &#39;我不是传奇&#39;)&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  props: [&#39;msg&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>修改为<code>.sync</code>修饰符的方式，可以看到，我们把父组件的<code>@update:msg=&quot;msg = $event&quot; :msg=&quot;msg&quot;</code> 这直接替换成了<code>:msg.sync=&quot;msg&quot;</code>，仍然能正常工作，实际上<code>.sync</code>就是上述写法的语法糖，不用自己定义事件了，方便了许多；</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp :msg.sync=&quot;msg&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;$emit(&#39;update:msg&#39;, &#39;我不是传奇&#39;)&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  props: [&#39;msg&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><h1 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs&#x2F;$listeners"></a>$attrs&#x2F;$listeners</h1><p><code>$attrs</code>可以拿到绑定到该组件的属性，可以使用<code>v-bind=&quot;$attrs&quot;</code>进行透传，类似于<code>react</code>的<code>&#123;...restProps&#125;</code>，<strong>但是注意，这里的<code>$attrs</code>是排除组件<code>props</code>已接收到的属性和<code>class</code>、<code>style</code>属性</strong></p><p><code>$listeners</code>可以拿到绑定到该组件的绑定的事件，可以使用<code>v-on=&quot;$listeners&quot;</code>进行透传;</p><p>这两个api常用于多个属性，或多个事件的父子组件（或祖孙组件）通信，例如自己封装组件库的时候，一般一个组件层级不会太深，引入<code>vuex</code>进行通信又不合适，使用这两个属性就非常合适了</p><p>我们先看看两个东西具体长啥样，</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp props1=&quot;props1&quot; props2=&quot;props2&quot; @event1=&quot;handleEvent1&quot; @event2=&quot;handleEvent2&quot;&gt;&lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;&#125;  &#125;,  methods: &#123;      handleEvent1(val)&#123;        console.log(&#39;handleEvent1&#39;, val)      &#125;,      handleEvent2(val)&#123;        console.log(&#39;handleEvent2&#39;, val)      &#125;,    &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;    return &#123;&#125;  &#125;,  created() &#123;    console.log(this.$attrs);    console.log(this.$listeners);  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue6.png"></p><p>我们可以拿到父组件传递的属性和监听的事件了，如果这些属性和事件不是给子组件用的，而是给子组件的子组件用的，此时我们就可以进行透传，将其原封不动的传递给孙组件</p><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;!-- 这里进行透传 --&gt;    &lt;grand-son-comp v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/grand-son-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandSonComp from &#39;./GrandSonComp.vue&#39;export default &#123;  name: &#39;ChildComp&#39;,  components: &#123;    GrandSonComp  &#125;,  data() &#123;    return &#123;&#125;  &#125;,  created() &#123;    console.log(this.$attrs);    console.log(this.$listeners);  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 孙组件 GrandSonComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;GrandSonComp&lt;/p&gt;    &#123;&#123;props1&#125;&#125;    &#123;&#123;props2&#125;&#125;    &lt;button @click=&quot;$emit(&#39;event1&#39;, &#39;触发事件event1&#39;)&quot;&gt;触发事件event1&lt;/button&gt;    &lt;button @click=&quot;$emit(&#39;event2&#39;, &#39;触发事件event2&#39;)&quot;&gt;触发事件event2&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;GrandSonComp&#39;,  props: [&#39;props1&#39;, &#39;props2&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue7.gif"></p><p>这样我们就把属性和事件透传给孙组件了，在孙组件里面进行接收和使用；</p><h1 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide&#x2F;inject"></a>provide&#x2F;inject</h1><p><code>provide/inject</code>提供了一个方法，使你能够跨层级进行数据传递，但是注意，传递过去的属性并不是响应式的；</p><p><code>provide</code>可以是一个对象也可以是一个返回对象的函数；</p><p>后代元素可以直接<code>inject</code>注入数据，可以使用字符串数组接收，也可以使用对象，给定一个<code>default</code>，使其变成可选项（后文有例子）</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;button @click=&quot;changeMsg&quot;&gt;change msg&lt;/button&gt;    &lt;child-comp&gt;&lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  provide() &#123;    return &#123;      dataFromParent: &#39;data from parent&#39;,      msg: this.msg,    &#125;  &#125;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,  methods: &#123;    changeMsg() &#123;      this.msg = &#39;我不是传奇&#39;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;grand-son-comp&gt;&lt;/grand-son-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandSonComp from &#39;./GrandSonComp.vue&#39;export default &#123;  name: &#39;ChildComp&#39;,  components: &#123;    GrandSonComp  &#125;,  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 孙组件 GrandSonComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;GrandSonComp&lt;/p&gt;    &#123;&#123; dataFromParent &#125;&#125;    &#123;&#123; msg &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;GrandSonComp&#39;,  inject: [&#39;dataFromParent&#39;, &#39;msg&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue8.gif"></p><p>上述代码，我们在<code>ParentComp</code>中<code>provide</code>了两个数据，一个是<code>dataFromParent</code>，一个是<code>msg</code>，子组件中并没有对着两个属性进行接收传递，而在孙组件<code>GrandSonComp</code>中使用<code>inject</code>可以直接拿到那两个数据，这就是<code>provide/inject</code>的作用，同时，我们可以看到，虽然<code>msg</code>在父组件中是响应式的，但是孙组件<code>inject</code>进来的<code>msg</code><strong>并不具备响应式能力</strong>，这是为了避免<code>props</code>混乱而刻意为之的，但是如果provide提供的本身是一个响应式对象，则可以进行响应式；</p><p>如果我们在父组件中直接把父组件的实例传递<code>provide</code>，则后代可以拿到这个父实例，并且拿到父实例绑定的<code>data</code>，这些<code>data</code>都是响应式的，例如：</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &#123;&#123; msg &#125;&#125;    &lt;button @click=&quot;changeMsg&quot;&gt;change msg&lt;/button&gt;    &lt;child-comp&gt;&lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  provide() &#123;    return &#123;      dataFromParent: &#39;data from parent&#39;,      msg: this.msg,      // 直接把父组件实例给到provide      parentInstance: this    &#125;  &#125;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,  methods: &#123;    changeMsg() &#123;      this.msg = &#39;我不是传奇&#39;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;grand-son-comp&gt;&lt;/grand-son-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandSonComp from &#39;./GrandSonComp.vue&#39;export default &#123;  name: &#39;ChildComp&#39;,  components: &#123;    GrandSonComp  &#125;,  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 孙组件 GrandSonComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;GrandSonComp&lt;/p&gt;    &#123;&#123; dataFromParent &#125;&#125;    &#123;&#123; msg &#125;&#125;    &#123;&#123; parentInstance.msg &#125;&#125;    &lt;button @click=&quot;changeMsg&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;GrandSonComp&#39;,  inject: [&#39;dataFromParent&#39;, &#39;msg&#39;, &#39;parentInstance&#39;],  data() &#123;    return &#123;&#125;  &#125;,  methods: &#123;      changeMsg() &#123;          this.parentInstance.msg = &#39;我也不是传奇 - from GrandSonComp&#39;      &#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue9.gif"></p><p>可以看到，我们直接把父组件实例给到<code>provide</code>，后代组件可以直接拿到，然后我们队父组件实例的数据修改，后代组件都能响应式处理，并且，也可以在后代组件中对父组件实例进行操作，比如修改属性等，十分灵活，但是这种用法不建议在应用程序中使用，而是更多的应用于基础组件的封装；</p><p>拓展一下，<code>inject</code>不仅可以使用字符串数组的方式，还可以使用对象的方式，还可以修改属性名，就以上的例子，下面的写法是相同的；</p><blockquote><p>由于msg已经被重命名为parentMsg了，因此模板里的msg也需要随之修改</p></blockquote><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;GrandSonComp&lt;/p&gt;    &#123;&#123; dataFromParent &#125;&#125;    &#123;&#123; parentMsg &#125;&#125;    &#123;&#123; parentInstance.msg &#125;&#125;    &lt;button @click=&quot;changeMsg&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;GrandSonComp&#39;,  // inject: [&#39;dataFromParent&#39;, &#39;msg&#39;, &#39;parentInstance&#39;],  inject: &#123;      dataFromParent: &#123; default: &#39;default value&#39; &#125;, // 给定default，如果provide中没有就使用默认值      parentMsg: &#123;  // msg是父组件provide过来的，如果想要在后代中修改属性名，可以使用这种方式，from是provide里的key          from: &#39;msg&#39;,          default: &#39;default msg&#39;      &#125;,      parentInstance: &#39;parentInstance&#39; // 这种也可以，什么都不指定  &#125;,  data() &#123;    return &#123;&#125;  &#125;,  methods: &#123;      changeMsg() &#123;          this.parentInstance.msg = &#39;我也不是传奇 - from GrandSonComp&#39;      &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h1 id="slots-scopedSlots"><a href="#slots-scopedSlots" class="headerlink" title="$slots &amp; $scopedSlots"></a>$slots &amp; $scopedSlots</h1><p><code>$slots</code>只能拿到具名插槽分发的内容，不能拿到作用域插槽的内容，默认插槽实际上也是具名插槽，只不过可以简写；</p><p><code>$scopedSlots</code>用来获取作用域插槽的内容；</p><p>在如下组件中，子组件<code>ChildComp</code>定义了一个默认插槽，一个具名插槽，一个作用域插槽，而在我们获取<code>$slots</code>的时候，只能获取到<code>default</code>和<code>slot1</code>的插槽内容</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp&gt;      &lt;template #slot1&gt;        slot1 content      &lt;/template&gt;      &lt;template #slot2=&quot;&#123;compName&#125;&quot;&gt;        &#123;&#123;compName&#125;&#125;        123      &lt;/template&gt;      default slot content    &lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;slot&gt;&lt;/slot&gt;    &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;    &lt;slot name=&quot;slot2&quot; :comp-name=&quot;compName&quot;&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;    return &#123;      compName: &quot;ChildComp&quot;    &#125;  &#125;,  created() &#123;    console.log(this.$slots)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue9.png"></p><h1 id="Vue-delete删除数组"><a href="#Vue-delete删除数组" class="headerlink" title="Vue.delete删除数组"></a>Vue.delete删除数组</h1><p>使用js 的delete删除数组的时候，只是将该索引位的值变为了empty，实际长度是没变的，而使用Vue.delete删除数组的时候，会将该索引位的值直接删除，索引会前进一位<br><img src="/images/vue8.png"></p><h1 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="$forceUpdate"></a>$forceUpdate</h1><p>当视图层无法进行数据更新时，用<code>this.$forceUpdate()</code>进行视图层重新渲染。例如我们知道，对一个数组类型的数据，直接使用索引去修改数据，数据是不会响应式变化的，此时我们就可以使用<code>$forceUpdate</code>强制更新组件并重新渲染</p><p>例如下面的代码，我们点击了<code>change</code>按钮之后，<code>data</code>里面的值是发生了变化的，但是页面没有相应变化，就是没有重新渲染，当我们点击<code>forceUpdate</code>后，页面变化了;</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;button @click=&quot;change&quot;&gt;change&lt;/button&gt;    &lt;button @click=&quot;forceUpdate&quot;&gt;forceUpdate&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      list: [1, 2, 3, 5]    &#125;  &#125;,  methods: &#123;    change() &#123;      this.list[1] = 999    &#125;,    forceUpdate() &#123;      this.$forceUpdate()    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p><img src="/images/vue10.gif"></p><h1 id="hook-lifecycle"><a href="#hook-lifecycle" class="headerlink" title="@hook:[lifecycle]"></a>@hook:[lifecycle]</h1><p>试想一下，父子组件的挂载顺序是<code>beforeCreate-&gt; created -&gt; beforeMount -&gt; mounted</code>，那我们有没有什么方法能够在父组件中监听到子组件是否挂载了呢？通常我们的做法是在子组件的<code>mounted</code>钩子中<code>$emit</code>一个自定义事件，在父组件中监听，这样确实可以，但是如果说子组件是一个第三方的组件，我们无法直接修改子组件里的代码，此时该怎么办？</p><p>此时我们就可以使用下面介绍的方法，在<code>Vue</code>中，当每个生命周期执行的时候，都会<code>emit</code>一个自定义事件，例如在<code>created</code>生命周期中，会<code>$emit(&#39;hook:created&#39;)</code>，这是<code>Vue</code>内部自己做的事情，我们不需要手动做，有了这一个东西，我们就可以在引用这个组件的任意组件中进行这个自定义事件的监听，例如<code>@hook:created</code></p><p>通过代码能更直观的感受到这个方式的好处</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp @hook:mounted=&quot;handleChildCompMounted&quot; @hook:created=&quot;handleChildCompCreated&quot;&gt;&lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;&#125;  &#125;,  methods: &#123;    handleChildCompMounted() &#123;      console.log(&#39;child-comp mounted&#39;)    &#125;,    handleChildCompCreated() &#123;      console.log(&#39;child-comp created&#39;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;    return &#123;      compName: &quot;ChildComp&quot;    &#125;  &#125;,  created()&#123;    console.log(&#39;ChildComp created --- from ChildComp&#39;)  &#125;,  mounted() &#123;    console.log(&#39;ChildComp mounted --- from ChildComp&#39;)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>查看结果：<br><img src="/images/vue11.png"></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 生命周期及父子组件生命周期钩子执行顺序</title>
      <link href="/2021/08/03/Vue/Vue-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2021/08/03/Vue/Vue-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h1><p>我们先来看看Vue的生命周期，Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>updated</td><td>组件数据更新之后</td></tr><tr><td>activited</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestory</td><td>组件销毁前调用</td></tr><tr><td>destoryed</td><td>组件销毁后调用</td></tr></tbody></table><p>图示：<br><img src="/images/lifecycle.png"></p><h1 id="父子组件声明周期执行顺序"><a href="#父子组件声明周期执行顺序" class="headerlink" title="父子组件声明周期执行顺序"></a>父子组件声明周期执行顺序</h1><p>在单一组件中，挂载时钩子的执行顺序是<code>beforeCreate-&gt; created -&gt; beforeMount -&gt; mounted</code>，但当父子组件嵌套时，父组件和子组件各拥有各自独立的钩子函数，这些父子组件的这些钩子是如何交融执行，且执行顺序又是怎样的呢?</p><p>我们先给出父子组件的代码；</p><!-- tab 父组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;gray&#39;, padding: &#39;10px&#39;&#125;&quot;&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;ChildComp /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;    &#125;  &#125;,  methods: &#123;  &#125;,  beforeCreate() &#123;    console.log(`ParentComp - beforeCreate - $&#123;new Date().getTime()&#125;`)  &#125;,  created() &#123;    console.log(`ParentComp - created - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeMount() &#123;    console.log(`ParentComp - beforeMount - $&#123;new Date().getTime()&#125;`)  &#125;,  mounted() &#123;    console.log(`ParentComp - mounted - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeUpdate() &#123;    console.log(`ParentComp - beforeUpdate - $&#123;new Date().getTime()&#125;`)  &#125;,  updated() &#123;    console.log(`ParentComp - updated - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeDestroy() &#123;    console.log(`ParentComp - beforeDestroy - $&#123;new Date().getTime()&#125;`)  &#125;,  destroyed() &#123;    console.log(`ParentComp - destroyed - $&#123;new Date().getTime()&#125;`)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;green&#39;&#125;&quot;&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;      return &#123;      &#125;  &#125;,  methods: &#123;  &#125;,  beforeCreate() &#123;    console.log(`ChildComp - beforeCreate - $&#123;new Date().getTime()&#125;`)  &#125;,  created() &#123;    console.log(`ChildComp - created - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeMount() &#123;    console.log(`ChildComp - beforeMount - $&#123;new Date().getTime()&#125;`)  &#125;,  mounted() &#123;    console.log(`ChildComp - mounted - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeUpdate() &#123;    console.log(`ChildComp - beforeUpdate - $&#123;new Date().getTime()&#125;`)  &#125;,  updated() &#123;    console.log(`ChildComp - updated - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeDestroy() &#123;    console.log(`ChildComp - beforeDestroy - $&#123;new Date().getTime()&#125;`)  &#125;,  destroyed() &#123;    console.log(`ChildComp - destroyed - $&#123;new Date().getTime()&#125;`)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><h1 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h1><p><img src="/images/vue_lifecycle2.gif"></p><p>子组件挂载完成后，父组件还未挂载。所以组件数据回显的时候，在父组件<code>mounted</code>中获取<code>api</code>的数据，子组件的<code>mounted</code>是拿不到的。</p><pre><code>ParentComp - beforeCreate - 1627923686788ParentComp - created - 1627923686807ParentComp - beforeMount - 1627923686808ChildComp - beforeCreate - 1627923686810ChildComp - created - 1627923686810ChildComp - beforeMount - 1627923686811ChildComp - mounted - 1627923686814ParentComp - mounted - 1627923686815</code></pre><h1 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h1><p>当数据发生更新的时候，组件会触发<code>beforeUpdate</code>和<code>updated</code>这两个钩子函数，下面我们来看看在父子组件中，这两个钩子的触发顺序是怎样的；</p><h2 id="父子组件各自更新"><a href="#父子组件各自更新" class="headerlink" title="父子组件各自更新"></a>父子组件各自更新</h2><p>父子组件各自在自己组件内部更新自己的数据，此时都只会触发各自的钩子；</p><!-- tab 父组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;gray&#39;, padding: &#39;10px&#39;&#125;&quot;&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &#123;&#123; parentData &#125;&#125;    &lt;button @click=&quot;updateParentData&quot;&gt;update parent data&lt;/button&gt;    &lt;ChildComp /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      parentData: &#39;parentData&#39;    &#125;  &#125;,  methods: &#123;    updateParentData() &#123;      this.parentData = &#39;new parentData&#39;    &#125;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;green&#39;&#125;&quot;&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &#123;&#123;childData&#125;&#125;    &lt;button @click=&quot;updateChildData&quot;&gt;update child data&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;      return &#123;        childData: &#39;childData&#39;      &#125;  &#125;,  methods: &#123;    updateChildData() &#123;      this.childData = &#39;new childData&#39;    &#125;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue_lifecycle1.gif"></p><p>可以看到，父子组件各自更新，不会互相影响，只会触发自己的更新钩子</p><h2 id="props更新"><a href="#props更新" class="headerlink" title="props更新"></a>props更新</h2><p>当使用<code>props</code>将数据传递给子组件的时候，由于父组件自身的数据发生了变化，因此会触发钩子函数，子组件虽然没有显示的修改数据，但是父组件穿过类的<code>props</code>数据发生了变化，此时子组件也会触发钩子函数，可以理解为子组件将父组件传过来的<code>props</code>作为了<code>data</code>里的数据，此时<code>props</code>变了，也会触发钩子，也可以看到模板里使用<code>props</code>的数据直接实用就好了，和<code>data</code>里声明的数据是同样的使用方式</p><!-- tab 父组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;gray&#39;, padding: &#39;10px&#39;&#125;&quot;&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;button @click=&quot;updatePropsData&quot;&gt;update child props data&lt;/button&gt;    &lt;ChildComp :childPropsData=&quot;childPropsData&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      childPropsData: &#39;props data&#39;    &#125;  &#125;,  methods: &#123;    updatePropsData() &#123;      this.childPropsData = &#39;new props data&#39;    &#125;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;green&#39;&#125;&quot;&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &#123;&#123; childPropsData &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  props: [&#39;childPropsData&#39;],  data() &#123;      return &#123;      &#125;  &#125;,  methods: &#123;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue_lifecycle3.gif"></p><p>可以看到，通过修改<code>props</code>来更新数据，会先触发父组件的<code>beforeUpdate</code>钩子，让后等到子组件更新完毕，再触发父组件的<code>updated</code>钩子</p><h2 id="通过ref更新"><a href="#通过ref更新" class="headerlink" title="通过ref更新"></a>通过ref更新</h2><p>我们再来看看直接通过ref更新子组件的数据，此时父组件是没有数据修改的，因此不会触发钩子，但是子组件的数据被父组件修改了，因此会触发钩子函数</p><!-- tab 父组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;gray&#39;, padding: &#39;10px&#39;&#125;&quot;&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;button @click=&quot;updateChildData&quot;&gt;update child data&lt;/button&gt;    &lt;ChildComp ref=&quot;childComp&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;    &#125;  &#125;,  methods: &#123;    updateChildData() &#123;      this.$refs.childComp.childData = &#39;new child data&#39;    &#125;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;green&#39;&#125;&quot;&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &#123;&#123; childData &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,  methods: &#123;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue_lifecycle4.gif"></p><p>可以看到，通过ref去更新子组件的数据，也只会触发子组件的<code>beforeUpdate</code>和<code>updated</code>钩子；</p><h1 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h1><p><img src="/images/vue_lifecycle5.gif"></p><p>父组件开始销毁，然后当子组件都销毁了之后，父组件才会执行<code>destroyed</code>钩子</p><pre><code>ParentComp - beforeDestroy - 1627927903322ChildComp - beforeDestroy - 1627927903322ChildComp - destroyed - 1627927903323ParentComp - destroyed - 1627927903323</code></pre><h1 id="异步引入组件"><a href="#异步引入组件" class="headerlink" title="异步引入组件"></a>异步引入组件</h1><p>如果是异步引入组件，我们来看看有什么不同的地方；<br>我们只需要将引入子组件的方式修改成为异步的方式，例如：</p><pre><code class="html">&lt;script&gt;// import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp: () =&gt; import(&#39;./ChildComp.vue&#39;)  &#125;,&#125;&lt;/script&gt;</code></pre><p>很明显的区别在于，异步引入组件，父组件是直接挂载完成的，<code>mounted</code>之后才去开始挂载子组件，此时我们不刷新页面，卸载组件后重新挂载，钩子函数的触发顺序又和之前一样了，因此，只有当第一次挂载组件的时候，才会等到父组件挂载完成之后再去挂载子组件，之后无论卸载重新挂载多少次，钩子的触发顺序和同步引入的方式就一致了</p><p><img src="/images/vue_lifecycle6.gif"></p><p>对于其他场景的钩子触发顺序，则都是一样的，只有在第一次挂载的时候有所差异；</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa + axios + jwt  实现token自动续期</title>
      <link href="/2021/07/29/%E5%89%8D%E7%AB%AF/koa-axios-jwt-%E5%AE%9E%E7%8E%B0token%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F/"/>
      <url>/2021/07/29/%E5%89%8D%E7%AB%AF/koa-axios-jwt-%E5%AE%9E%E7%8E%B0token%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.baihuzi.com/2021/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/">深入理解token</a>这篇文章详细讲解了token的作用及优势，这篇文章我们通过jwt和koa来简单实现一个自动续期token。</p><p>首先来看看JWT</p><h1 id="Json-web-token-JWT"><a href="#Json-web-token-JWT" class="headerlink" title="Json web token (JWT)"></a>Json web token (JWT)</h1><p><code>Json web token (JWT)</code>, 是为了在网络应用环境间传递声明而执行的一种基于<code>JSON</code>的开放标准<code>(RFC 7519)</code>，该<code>token</code>被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。<code>JWT</code>的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><p>一个完整的<code>JWT</code>长这样</p><pre><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImJhaWh1emkiLCJhZG1pbiI6dHJ1ZSwiYWdlIjoxOCwiaWF0IjoxNjI3NTU4MjU3LCJleHAiOjE2Mjc1NTg4NTd9.FmiN7MoQm8uzGAFXXNve6z3r94JRVFGmCcKWVQyz2T9o-0ovhFRC1eQ6xgFX8AKFMSqMIBs8Yd_rDSXNFqBgQkxkBQEHqQlv4-BjhvxA3W1FpclUtqQfSQx9mWeWDN79RPOV7ayTZ-8e9hDJVqB3hoFZsWddHxens1IKbSEQylZrgEGNJVGbeN2sTNyHvXQoxUzft5E3k2odp5lnS-Fl0dwkrwsBEvQ81cNQio24d4VINBDCcF6nOBii6mEMA9VLBj4j1PDT2BEBgZlCbrvHbsuYCQUljvsHInkRrnySzc4DwiIxzrKEapr8raD--MHH0Iz78__hJrqCZTAxve-iaA</code></pre><p>包括三段信息，通过<code>.</code>分隔，第一部分我们称它为头部（<code>header</code>),第二部分我们称其为载荷（<code>payload</code>, 类似于飞机上承载的物品)，第三部分是签名（<code>signature</code>）.</p><h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><p>jwt的头部承载两部分信息：</p><ul><li>声明类型，这里是<code>JWT</code></li><li>声明加密的算法 通常直接使用 <code>HMAC</code>或<code>SHA256</code><br>完整的头部就像下面这样的JSON：</li></ul><pre><code class="javascript">&#123;  &quot;alg&quot;:&quot;RS256&quot;,      // 算法  &quot;typ&quot;:&quot;JWT&quot;         // 类型&#125;</code></pre><p>然后将头部进行<code>base64</code>加密（该加密是可以对称解密的),构成了第一部分.</p><pre><code class="javascript">new Buffer.from(&#39;&#123;&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#39;).toString(&#39;base64&#39;);// eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9</code></pre><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ul><p>标准中注册的声明 (建议但不强制使用)：</p><ul><li>iss: jwt签发者</li><li>sub: jwt所面向的用户</li><li>aud: 接收jwt的一方</li><li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li><li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li><li>iat: jwt的签发时间</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li></ul><p>公共的声明：<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><p>私有的声明 ：<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为<code>base64</code>是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>定义一个payload:</p><pre><code class="javascript">&#123;  &quot;username&quot;:&quot;daryl&quot;,  &quot;age&quot;:18,  &quot;admin&quot;:true&#125;</code></pre><pre><code class="javascript">new Buffer.from(&#39;eyJ1c2VybmFtZSI6ImJhaWh1emkiLCJhZG1pbiI6dHJ1ZSwiYWdlIjoxOCwiaWF0IjoxNjI3NTU4MjU3LCJleHAiOjE2Mjc1NTg4NTd9&#39; , &#39;base64&#39;).toString();// &#123;&quot;username&quot;:&quot;baihuzi&quot;,&quot;admin&quot;:true,&quot;age&quot;:18,&quot;iat&quot;:1627558257,&quot;exp&quot;:1627558857&#125;</code></pre><h2 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h2><p>签名是把<code>header</code>和<code>payload</code>对应的<code>json</code>结构进行<code>base64</code>url编码之后得到的两个串用英文句点号拼接起来，然后根据<code>header</code>里面<code>alg</code>指定的签名算法生成出来的。</p><p>算法不同，签名结果不同。<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以自我签发<code>jwt</code>了。</p><h2 id="JWT的签发与验签"><a href="#JWT的签发与验签" class="headerlink" title="JWT的签发与验签"></a>JWT的签发与验签</h2><p><code>RS256</code>是非对称算法，有一对公私秘钥，需要自己生成，通过私钥进行签名，只有自己签发的才是合法的，防止恶意伪造token，通过公钥进行验签，如果token被修改挥着过期了，验签就会失败</p><pre><code class="javascript">let jwt = require(&#39;jsonwebtoken&#39;);let fs = require(&#39;fs&#39;)let data = &#123;    username: &#39;daryl&#39;,    age: 18,    admin: true&#125;// 用私钥进行签名，用公钥进行验签，防止客户端伪造tokenlet privateKey = fs.readFileSync(&#39;./private.pem&#39;)let token = jwt.sign(data, privateKey, &#123; algorithm: &#39;RS256&#39;, expiresIn: 60 * 10 &#125;);console.log(token)// 用公钥进行验签let publicKey = fs.readFileSync(&#39;./public.pem&#39;)let res = jwt.verify(token, publicKey, &#123; algorithm: &#39;RS256&#39; &#125;)console.log(res);</code></pre><pre><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImRhcnlsIiwiYWdlIjoxOCwiYWRtaW4iOnRydWUsImlhdCI6MTYyNzU3Mzc1MiwiZXhwIjoxNjI3NTc0MzUyfQ.snfD-YTXbCGb7et_BYtmw2FGZQ7wev_DAcdnn-StN13_PSpOw5zEUN7ldsL7_8RFH5m5Mu5Ot6WzdTKgP8JiuZuO-G01QsdECvSeEU3D7r2Yoj2x_H13lZpYpuZ6dgVsKE4CeWDME1MAN1YRwIygkse9Ds614nnfIx6ewRs1FNZXnusEXx4D6T1fMmhLBEcJs5gdFMdSrNQyuJvZtmIyqzY5wYYGfHen1CRmM_cFSq8EcnGgLsR_91S4sDzw3JVfw47rV8vp3OwlvI2Nldz_Zk7C6wLdkPw9VHxCigC4mJZ10tH4ICKU8XpZEzxhHgu7_o_luOOvXGfa6dm4-CrR6A&#123;  username: &#39;daryl&#39;,  age: 18,  admin: true,  iat: 1627573752,  // 签发时间  exp: 1627574352   // 过期时间&#125;</code></pre><h1 id="koa-jwt实现token续期"><a href="#koa-jwt实现token续期" class="headerlink" title="koa-jwt实现token续期"></a>koa-jwt实现token续期</h1><pre><code class="javascript">const Koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;)const betterBody = require(&#39;koa-better-body&#39;);const jwt = require(&#39;jsonwebtoken&#39;)const koaJwt = require(&#39;koa-jwt&#39;)// 假用户数据const user = &#123; username: &#39;jerry&#39;, password: &#39;123456&#39; &#125;// jwt 秘钥，默认使用的是HS256算法，签名和验签使用同一个秘钥const jwtSecret = &#39;sdD(Sdsdfsd^%8ds^^&amp;5s&#39;let app = new Koa()app.listen(8080);// 跨域设置，需要注意的是，要将Authorization头设置到Access-Control-Allow-Headers里面去，否则无法跨域发送Authorization头app.use(async (ctx, next) =&gt; &#123;    ctx.set(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);    ctx.set(&#39;Access-Control-Allow-Headers&#39;, &#39;x-requested-with,content-type,Authorization&#39;)    ctx.set(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT, POST, GET, DELETE, OPTIONS&#39;);    if (ctx.method == &#39;OPTIONS&#39;) &#123;        ctx.set(&quot;Access-Control-Max-Age&quot;, &quot;1728000000&quot;);        ctx.body = &#39;ok&#39;;    &#125; else &#123;        await next();    &#125;&#125;)app.use(betterBody());let router = new Router();// 模拟登录接口，成功就发送token// 发送accessToken 和 refreshToken两个tokenrouter.post(&#39;/login&#39;, async ctx =&gt; &#123;    let &#123; username, password &#125; = ctx.request.fields;    if (!username) &#123;        ctx.body = &#123; code: 201, msg: &#39;用户名不存在&#39; &#125;;    &#125; else &#123;        let &#123; username: name, password: pass &#125; = user        if (username == name &amp;&amp; password == pass) &#123;            let token = createToken(&#123; username &#125;)            ctx.body = &#123; code: 200, msg: &#39;登录成功&#39;, token &#125;        &#125; else &#123;            ctx.body = &#123; code: 202, msg: &#39;用户名或密码错误&#39; &#125;        &#125;    &#125;&#125;)// token自动续期接口router.post(&#39;/refreshToken&#39;, async ctx =&gt; &#123;    let refreshToken = ctx.headers.authorization;    await verifyToken(refreshToken)        .then(async (token) =&gt; &#123;            // 校验成功就重新发送accessToken和refreshToken            let newToken = createToken(&#123; username: token.username &#125;);            // 等待5秒再返回，方便查看效果            await sleep(5000).then(() =&gt; &#123;                ctx.body = &#123; code: 200, msg: &#39;续期成功&#39;, token: newToken &#125;            &#125;)        &#125;)        .catch((e) =&gt; &#123;            ctx.status = 402;            ctx.body = &#123; code: 402, msg: &#39;续期失败，请重新登录&#39; &#125;        &#125;)&#125;)// ---------------------------------koa-jwt----------------------------------// 验证失败时捕获401，返回自定义信息app.use(function (ctx, next) &#123;    return next().catch((err) =&gt; &#123;        if (401 == err.status) &#123;            ctx.status = 401;            ctx.body = &#123; code: 401, msg: &#39;token expired&#39; &#125;;        &#125; else &#123;            throw err;        &#125;    &#125;);&#125;);// 默认校验在请求头中的[ Authorization: Bearer TOKEN ] 头,&#39;Bearer &#39; (后面有一个空格)// token不合法或者过期都会返回401错误// 另外定义在unless中路由不会被校验app.use(koaJwt(&#123; secret: jwtSecret &#125;).unless(&#123; path: [/^\/login/, /^\/refreshToken/] &#125;))// ---------------------------------koa-jwt----------------------------------// 测试接口router.get(&#39;/a&#39;, async ctx =&gt; &#123;    ctx.body = &#123; code: 200, msg: &#39;a&#39; &#125;&#125;)router.get(&#39;/b&#39;, async ctx =&gt; &#123;    ctx.body = &#123; code: 200, msg: &#39;b&#39; &#125;&#125;)router.get(&#39;/c&#39;, async ctx =&gt; &#123;    ctx.body = &#123; code: 200, msg: &#39;c&#39; &#125;&#125;)app.use(router.routes())// 生成token函数function createToken(obj) &#123;    // 为了模拟续期，把token的时效设置短一点，单位是秒    // 生成两个token，accessToken用于接口访问，refreshToken用于请求token续期接口    let accessToken = jwt.sign(obj, jwtSecret, &#123; expiresIn: 15 &#125;)    let refreshToken = jwt.sign(obj, jwtSecret, &#123; expiresIn: 30 &#125;)    return &#123; accessToken, refreshToken &#125;&#125;// 校验refreshToken函数function verifyToken(refreshToken) &#123;    return new Promise((resolve, reject) =&gt; &#123;        jwt.verify(refreshToken.split(&#39; &#39;)[1], jwtSecret, (err, token) =&gt; &#123;            if (err) &#123;                reject(err)            &#125; else &#123;                resolve(token)            &#125;        &#125;)    &#125;)&#125;// 异步延时函数function sleep(time = 0) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve();        &#125;, time);    &#125;)&#125;</code></pre><h1 id="axios实现自动续期"><a href="#axios实现自动续期" class="headerlink" title="axios实现自动续期"></a>axios实现自动续期</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;script src=&quot;./axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;button id=&quot;login&quot;&gt;登录&lt;/button&gt;    &lt;button id=&quot;abc&quot;&gt;同时获取abc&lt;/button&gt;    &lt;script&gt;        let loginBtn = document.querySelector(&#39;#login&#39;);        let requestBtn = document.querySelector(&#39;#abc&#39;);        axios.defaults.baseURL = &#39;http://localhost:8080&#39;        loginBtn.onclick = function () &#123;            axios.post(&#39;/login&#39;, &#123;                username: &#39;jerry&#39;,                password: &#39;123456&#39;            &#125;).then(res =&gt; &#123;                if (res.data.code == 200) &#123;                    localStorage.setItem(&#39;accessToken&#39;, res.data.token.accessToken)                    localStorage.setItem(&#39;refreshToken&#39;, res.data.token.refreshToken)                &#125; else &#123;                    alert(&#39;用户名或密码错误&#39;)                &#125;            &#125;)        &#125;        requestBtn.onclick = function () &#123;            axios.all([axios.get(&#39;/a&#39;), axios.get(&#39;b&#39;), axios.get(&#39;/c&#39;)]).then(axios.spread(function (a, b, c) &#123;                console.log(a.data, b.data, c.data);            &#125;))        &#125;        // 请求拦截器，根据url设置不同的请求token        axios.interceptors.request.use(function (config) &#123;            if (config.url == &#39;/refreshToken&#39;) &#123;                config.headers.Authorization = &#39;Bearer &#39; + localStorage.getItem(&#39;refreshToken&#39;)            &#125; else if (config.url !== &#39;/login&#39;) &#123;                config.headers.Authorization = &#39;Bearer &#39; + localStorage.getItem(&#39;accessToken&#39;)            &#125;            return config;        &#125;, function (error) &#123;            return Promise.reject(error);        &#125;);        // 如果正在请求续期接口，则不再请求了，避免重复请求续期接口        let isRefreshing = false;        // 请求401后，把失败的请求放在这里面，等到token续期后拿出来重新请求        let retryRequests = [];        axios.interceptors.response.use(response =&gt; &#123;            const &#123;code&#125; = response.data;            if (code !== 200) &#123;                return Promise.reject(response)            &#125; else &#123;                return response            &#125;        &#125;, error =&gt; &#123;            if (!error.response) return Promise.reject(error)            // 401 accessToken过期，402 refreshToken过期            if (error.response.data.code === 401) &#123;                const config = error.config                if (!isRefreshing) &#123;                    isRefreshing = true;                    axios.post(&#39;/refreshToken&#39;).then(res =&gt; &#123;                        if (res.data.code == 200) &#123;                            localStorage.setItem(&#39;accessToken&#39;, res.data.token.accessToken)                            localStorage.setItem(&#39;refreshToken&#39;, res.data.token.refreshToken)                            retryRequests.forEach(req =&gt; req())                            retryRequests = []                            return axios(config)                        &#125;                    &#125;).catch(err =&gt; &#123;                        alert(&#39;请重新登录&#39;);                    &#125;).finally(()=&gt;&#123;                        isRefreshing = false;                    &#125;)                &#125; else &#123;                    return new Promise((resolve) =&gt; &#123;                        // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行                        retryRequests.push((newToken) =&gt; &#123;                            resolve(axios(config))                        &#125;)                    &#125;)                &#125;            &#125;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>查看效果：</p><p>可以看到，多个请求<code>401</code>，只会去调用一次<code>refreshToken</code>接口，并且当续期接口成功返回后，之前失败的<code>401</code>请求也会重新请求，当续期接口的<code>token</code>也过期后，会返回<code>402</code>，让用户重新登录；<br><img src="/images/refreshToken.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> token </tag>
            
            <tag> jwt </tag>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】深入理解token</title>
      <link href="/2021/07/28/%E5%89%8D%E7%AB%AF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/"/>
      <url>/2021/07/28/%E5%89%8D%E7%AB%AF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://my.oschina.net/jamesfancy/blog/1613994">深入理解token</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p><code>Token</code> 是在服务端产生的。如果前端使用<code>用户名/密码</code>向服务端请求认证，服务端认证成功，那么在服务端会返回 <code>Token</code> 给前端。前端可以在每次请求的时候带上 <code>Token</code> 证明自己的合法地位</p><p>不久前，我在在前后端分离实践中提到了基于 <code>Token</code> 的认证，现在我们稍稍深入一些。</p><p>通常情况下，我们在讨论某个技术的时候，都是从问题开始。那么第一个问题：</p><h1 id="为什么要用-Token？"><a href="#为什么要用-Token？" class="headerlink" title="为什么要用 Token？"></a>为什么要用 Token？</h1><p>而要回答这个问题很简单——因为它能解决问题！</p><p>可以解决哪些问题呢？</p><ol><li><code>Token</code> 完全由应用管理，所以它可以避开同源策略</li><li><code>Token</code> 可以避免 <code>CSRF</code> 攻击(<a href="http://dwz.cn/7joLzx">http://dwz.cn/7joLzx</a>)</li><li><code>Token</code> 可以是无状态的，可以在多个服务间共享</li></ol><p><code>Token</code> 是在服务端产生的。如果前端使用<code>用户名/密码</code>向服务端请求认证，服务端认证成功，那么在服务端会返回 <code>Token</code> 给前端。前端可以在每次请求的时候带上 <code>Token</code> 证明自己的合法地位。如果这个 <code>Token</code> 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。</p><p>于是，又一个问题产生了：需要为 <code>Token</code> 设置有效期吗？</p><h1 id="需要设置有效期吗？"><a href="#需要设置有效期吗？" class="headerlink" title="需要设置有效期吗？"></a>需要设置有效期吗？</h1><p>对于这个问题，我们不妨先看两个例子。一个例子是登录密码，一般要求定期改变密码，以防止泄漏，所以密码是有有效期的；另一个例子是安全证书。<code>SSL</code> 安全证书都有有效期，目的是为了解决吊销的问题，对于这个问题的详细情况，来看看<a href="https://www.zhihu.com/question/20803288">知乎的回答</a>。所以无论是从安全的角度考虑，还是从吊销的角度考虑，<code>Token</code> 都需要设有效期。</p><p>那么有效期多长合适呢？</p><p>只能说，根据系统的安全需要，尽可能的短，但也不能短得离谱——想像一下手机的自动熄屏时间，如果设置为 10 秒钟无操作自动熄屏，再次点亮需要输入密码，会不会疯？如果你觉得不会，那就亲自试一试，设置成可以设置的最短时间，坚持一周就好（不排除有人适应这个时间，毕竟手机厂商也是有用户体验研究的）。</p><p>然后新问题产生了，如果用户在正常操作的过程中，<code>Token</code> 过期失效了，要求用户重新登录……用户体验岂不是很糟糕？</p><p>为了解决在操作过程不能让用户感到 <code>Token</code> 失效这个问题，有一种方案是在服务器端保存 <code>Token</code> 状态，用户每次操作都会自动刷新（推迟） <code>Token</code> 的过期时间（<code>Session</code> 就是采用这种策略来保持用户登录状态的）。然而仍然存在这样一个问题，在前后端分离、单页 App 这些情况下，每秒种可能发起很多次请求，每次都去刷新过期时间会产生非常大的代价。如果 <code>Token</code> 的过期时间被持久化到数据库或文件，代价就更大了。所以通常为了提升效率，减少消耗，会把 <code>Token</code> 的过期时保存在缓存或者内存中。</p><p>还有另一种方案，使用 <code>Refresh Token</code>，它可以避免频繁的读写操作。这种方案中，服务端不需要刷新 <code>Token</code> 的过期时间，一旦 <code>Token</code> 过期，就反馈给前端，前端使用 <code>Refresh Token</code> 申请一个全新 <code>Token</code> 继续使用。这种方案中，服务端只需要在客户端请求更新 <code>Token</code> 的时候对 <code>Refresh Token</code> 的有效性进行一次检查，大大减少了更新有效期的操作，也就避免了频繁读写。当然 <code>Refresh Token</code> 也是有有效期的，但是这个有效期就可以长一点了，比如，以天为单位的时间。</p><h1 id="时序图表示"><a href="#时序图表示" class="headerlink" title="时序图表示"></a>时序图表示</h1><p>使用 <code>Token</code> 和 <code>Refresh Token</code> 的时序图如下：</p><p>1）登录<br><img src="/images/token.jpg"></p><p>2）业务请求<br><img src="/images/token2.jpg"></p><p>3）Token 过期，刷新 Token<br><img src="/images/token3.jpg"></p><p>上面的时序图中并未提到 <code>Refresh Token</code> 过期怎么办。不过很显然，<code>Refresh Token</code> 既然已经过期，就该要求用户重新登录了。</p><p>当然还可以把这个机制设计得更复杂一些，比如，<code>Refresh Token</code> 每次使用的时候，都更新它的过期时间，直到与它的创建时间相比，已经超过了非常长的一段时间（比如三个月），这等于是在相当长一段时间内允许 <code>Refresh Token</code> 自动续期。</p><p>到目前为止，<code>Token</code> 都是有状态的，即在服务端需要保存并记录相关属性。那说好的无状态呢，怎么实现？</p><h1 id="无状态-Token"><a href="#无状态-Token" class="headerlink" title="无状态 Token"></a>无状态 Token</h1><p>如果我们把所有状态信息都附加在 <code>Token</code> 上，服务器就可以不保存。但是服务端仍然需要认证 <code>Token</code> 有效。不过只要服务端能确认是自己签发的 <code>Token</code>，而且其信息未被改动过，那就可以认为 <code>Token</code> 有效——“签名”可以作此保证。平时常说的签名都存在一方签发，另一方验证的情况，所以要使用非对称加密算法。但是在这里，签发和验证都是同一方，所以对称加密算法就能达到要求，而对称算法比非对称算法要快得多（可达数十倍差距）。</p><p>更进一步思考，对称加密算法除了加密，还带有还原加密内容的功能，而这一功能在对 <code>Token</code> 签名时并无必要——既然不需要解密，摘要（散列）算法就会更快。可以指定密码的散列算法，自然是 <code>HMAC</code>。</p><p>上面说了这么多，还需要自己去实现吗？不用！<code>JWT</code> 已经定义了详细的规范，而且有各种语言的若干实现。</p><p>不过在使用无状态 <code>Token</code> 的时候在服务端会有一些变化，服务端虽然不保存有效的 <code>Token</code> 了，却需要保存未到期却已注销的 <code>Token</code>。如果一个 <code>Token</code> 未到期就被用户主动注销，那么服务器需要保存这个被注销的 <code>Token</code>，以便下次收到使用这个仍在有效期内的 <code>Token</code> 时判其无效。有没有感到一点沮丧？</p><p>在前端可控的情况下（比如前端和服务端在同一个项目组内），可以协商：前端一但注销成功，就丢掉本地保存（比如保存在内存、<code>LocalStorage</code> 等）的 <code>Token</code> 和 <code>Refresh Token</code>。基于这样的约定，服务器就可以假设收到的 <code>Token</code> 一定是没注销的（因为注销之后前端就不会再使用了）。</p><p>如果前端不可控的情况，仍然可以进行上面的假设，但是这种情况下，需要尽量缩短 <code>Token</code> 的有效期，而且必须在用户主动注销的情况下让 <code>Refresh Token</code> 无效。这个操作存在一定的安全漏洞，因为用户会认为已经注销了，实际上在较短的一段时间内并没有注销。如果应用设计中，这点漏洞并不会造成什么损失，那采用这种策略就是可行的。</p><p>在使用无状态 <code>Token</code> 的时候，有两点需要注意：</p><ol><li><code>Refresh Token</code> 有效时间较长，所以它应该在服务器端有状态，以增强安全性，确保用户注销时可控</li><li>应该考虑使用二次认证来增强敏感操作的安全性</li></ol><p>到此，关于 <code>Token</code> 的话题似乎差不多了——然而并没有，上面说的只是认证服务和业务服务集成在一起的情况，如果是分离的情况呢？</p><h1 id="分离认证服务"><a href="#分离认证服务" class="headerlink" title="分离认证服务"></a>分离认证服务</h1><p>当 <code>Token</code> 无状态之后，单点登录就变得容易了。前端拿到一个有效的 <code>Token</code>，它就可以在任何同一体系的服务上认证通过——只要它们使用同样的密钥和算法来认证 <code>Token</code> 的有效性。就样这样：<br><img src="/images/token4.jpg"></p><p>当然，如果 <code>Token</code> 过期了，前端仍然需要去认证服务更新 <code>Token</code>：<br><img src="/images/token5.jpg"></p><h1 id="不受信的业务服务器"><a href="#不受信的业务服务器" class="headerlink" title="不受信的业务服务器"></a>不受信的业务服务器</h1><p>遇到不受信的业务服务器时，很容易想到的办法是使用不同的密钥。认证服务器使用密钥1签发，业务服务器使用密钥2验证——这是典型非对称加密签名的应用场景。认证服务器自己使用私钥对 <code>Token</code> 签名，公开公钥。信任这个认证服务器的业务服务器保存公钥，用于验证签名。幸好，<code>JWT</code> 不仅可以使用 <code>HMAC</code> 签名，也可以使用 <code>RSA</code>（一种非对称加密算法）签名。</p><p>不过，当业务服务器已经不受信任的时候，多个业务服务器之间使用相同的 <code>Token</code> 对用户来说是不安全的。因为任何一个服务器拿到 <code>Token</code> 都可以仿冒用户去另一个服务器处理业务……悲剧随时可能发生。</p><p>为了防止这种情况发生，就需要在认证服务器产生 <code>Token</code> 的时候，把使用该 <code>Token</code> 的业务服务器的信息记录在 <code>Token</code> 中，这样当另一个业务服务器拿到这个 <code>Token</code> 的时候，发现它并不是自己应该验证的 <code>Token</code>，就可以直接拒绝。</p><p>现在，认证服务器不信任业务服务器，业务服务器相互也不信任，但前端是信任这些服务器的——如果前端不信任，就不会拿 <code>Token</code> 去请求验证。那么为什么会信任？可能是因为这些是同一家公司或者同一个项目中提供的若干服务构成的服务体系。</p><p>但是，前端信任不代表用户信任。如果 <code>Token</code> 不没有携带用户隐私（比如姓名），那么用户不会关心信任问题。但如果 <code>Token</code> 含有用户隐私的时候，用户得关心信任问题了。这时候认证服务就不得不再啰嗦一些，当用户请求 <code>Token</code> 的时候，问上一句，你真的要授权给某某某业务服务吗？而这个“某某某”，用户怎么知道它是不是真的“某某某”呢？用户当然不知道，甚至认证服务也不知道，因为公钥已经公开了，任何一个业务都可以声明自己是“某某某”。</p><p>为了得到用户的信任，认证服务就不得不帮助用户来甄别业务服务。所以，认证服器决定不公开公钥，而是要求业务服务先申请注册并通过审核。只有通过审核的业务服务器才能得到认证服务为它创建的，仅供它使用的公钥。如果该业务服务泄漏公钥带来风险，由该业务服务自行承担。现在认证服务可以清楚的告诉用户，“某某某”服务是什么了。如果用户还是不够信任，认证服务甚至可以问，某某某业务服务需要请求  A、B、C 三项个人数据，其中 A 是必须的，不然它不工作，是否允许授权？如果你授权，我就把你授权的几项数据加密放在 <code>Token</code> 中……</p><p>废话了这么多，有没有似曾相识……对了，这类似开放式 <code>API</code> 的认证过程。开发式 <code>API</code> 多采用 <code>OAuth</code> 认证，而关于 <code>OAuth</code> 的探讨资源非常丰富，这里就不深究了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie session token详解</title>
      <link href="/2021/07/27/%E5%89%8D%E7%AB%AF/cookie-session-token%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/07/27/%E5%89%8D%E7%AB%AF/cookie-session-token%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>cookie</code>、<code>session</code> 和 <code>token</code>是前端开发中很重要的概念，很多朋友并不真正了解这三者有什么区别，或者这三者到底是个什么的东西，面试的时候也只能模模糊糊的说一点，不能很清晰的讲明白，这里我们就这三个东西讨论下，彻底搞懂。</p><h1 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h1><p>众所周知，<code>http</code>协议本身是一个无连接的协议，<code>web</code>早期只是用来浏览文档，不需要交互，每次<code>http</code>请求都是一个全新的请求，服务端并不关心到底是谁在访问，但是随着交互式<code>web</code>应用的发展，我们必须要识别客户端到底是谁，否则根本无法进行交互，比如商城应用，后端服务必须要知道是谁在买东西，每个客户端要区分开，这时候就需要客户端要和服务端能够进行数据的相互传递，有时还需要在不同的域名下实现数据共享，<code>cookie</code>就是用来解决这一问题的。</p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p><code>cookie</code>是一个真实存在的东西，保存在客户端浏览器中，当一个请求发起后，后端如果想要设置<code>cookie</code>，则在响应头中添加一个<code>Set-Cookie</code>字段，浏览器识别到此响应头，就把里面的数据存放到浏览器本地，当下次再次请求的时候，将该<code>cookie</code>放到请求头中，发送给后端，实现前后端的交互。<br><img src="/images/cookie.png"></p><p>cookie是有大小和数量限制的，根据浏览器的不同这个有所差异；</p><p>Set-Cookie响应头类似于<code>Set-Cookie: username=daryl; path=/; expires=Thu, 26 Aug 2021 16:37:43 GMT; domain=localhost; samesite=none; secure; httponly</code></p><p>这个值是后端设置的，可选的属性有以下几种</p><ul><li><p>maxAge</p><p>用来告诉浏览器此<code>cookie</code>多久过期（单位是毫秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。</p></li><li><p>expires</p><p>失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。</p></li><li><p>path</p><p>表示这个cookie影响到的路径，浏览器跟会根据这项配置，向指定域中匹配的路径发送cookie。</p></li><li><p>domain</p><p>cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：<code>yq.aliyun.com</code>)，也可以不包含它(如：<code>.aliyun.com</code>，则对于<code>aliyun.com</code>的所有子域都有效).</p></li><li><p>secure</p><p>安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置</p></li><li><p>secureProxy?: boolean | undefined;</p><p>“secureProxy” option is deprecated; use “secure” option, provide “secure” to constructor if needed</p></li><li><p>httpOnly?: boolean | undefined;</p><p>a boolean indicating whether the cookie is only to be sent over HTTP(S),<br>and not made available to client JavaScript (true by default).</p></li><li><p>sameSite?: ‘strict’ | ‘lax’ | ‘none’ | boolean | undefined;</p><p>a boolean or string indicating whether the cookie is a “same site” cookie (false by default).<br>This can be set to ‘strict’, ‘lax’, or true (which maps to ‘strict’).</p></li><li><p>signed</p><p>是否对cookie进行签名（默认为false），如果设置为true，还将发送附加的另一个同名的后缀是.sig的cookie ，值类似于<code>Set-Cookie: username.sig=yuJIW4DxsPvY4BoKAP2YMpH5p5k; path=/; expires=Thu, 26 Aug 2021 16:37:43 GMT; domain=localhost; samesite=none; secure; httponly</code>，此签名密钥用于在下次收到cookie时检测篡改。</p></li><li><p>overwrite</p><p>是否覆盖以前的设置同名cookies（默认为false）</p></li></ul><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p><code>session</code>实际上是一个概念，即会话；<code>session</code>的实现有很多方式，最常见的是基于<code>cookie</code>的方式，后端生成一个<code>session</code>，有一个唯一的<code>session id</code>，标识唯一性，然后把这个<code>session id</code>通过<code>cookie</code>发送给客户端，客户端保存起来，下次请求的时候再携带包含<code>session id</code>值的<code>cookie</code>发送给后端，后端拿到后再去通过<code>session id</code>值查找对应的<code>session</code>；所以<code>session</code>实际上是保存在后端的，而发送给客户端的只是一个<code>session id</code>。</p><p><code>session</code>这种方式的弊端在于服务器必须要保存<code>session</code>，无论是保存在文件里还是数据库里，都是一个很大的开销，并且一旦用户量过于庞大，<code>session</code>也会非常庞大，做负载均衡的话如果请求负载到了不同的机器，会造成<code>session</code>失效。</p><h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p><code>token</code>这种方案现在已经被广泛应用了，相比于<code>cookie + session</code>的实现方式，<code>token</code>不需要保存在服务器上，而是将数据签名，然后发送给客户端（可以通过<code>cookie</code>也可以通过其他方式），下次请求的时候再校验<code>token</code>的合法性，如果合法，则响应成功，如果不合法，则响应失败，这种方式就是用计算资源来节省空间资源，好处是我们不需要关心<code>token</code>的存储，而只需要扩展机器增加算力即可。</p><p>详细的token解决方案，可以阅读<a href="https://www.baihuzi.com/2021/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/">深入理解token</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域设置cookie</title>
      <link href="/2021/07/26/%E5%89%8D%E7%AB%AF/%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AEcookie/"/>
      <url>/2021/07/26/%E5%89%8D%E7%AB%AF/%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AEcookie/</url>
      
        <content type="html"><![CDATA[<p>我们先从一个问题来引入接下来的内容，先看下以下代码</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());// cookie循环秘钥server.keys = [    &#39;sdf7as9d8f7asd7f9sdfa9s&#39;,    &#39;sdfasd6fgjhgjgdgjsfgsf5&#39;,    &#39;nk54h3k2klj78kh89kh5kh3&#39;,];router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p>我们开启了一个服务器，当请求<code>/api/user</code>接口的时候，我们设置跨域，并且设置了一个<code>cookie</code>，<code>key</code>为<code>username</code>，<code>value</code>为<code>daryl</code></p><p>当我们直接在浏览器中请求这个接口，我们发现可以将<code>cookie</code>设置成功，响应头中有<code>set-cookie</code>响应头，并在<code>application</code>中可以看到已经设置成功<br><img src="/images/cors_cookie2.png"><br><img src="/images/cors_cookie.png"></p><p>但是当我们使用<code>ajax</code>请求去调用接口，此时<code>cookie</code>无论如何也设置不上</p><p>客户端代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;http://localhost:8080/api/user&#39;,        )            .then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>我们可以看到，在响应头中也有<code>set-cookie</code>字段，但是<code>application</code>中就是设置不成功<br><img src="/images/cors_cookie3.png"><br><img src="/images/cors_cookie4.png"></p><p>这是什么原因？实际上是因为当我们使用<code>ajax</code>去请求接口时，是发生了跨域的，而设置<code>cookie</code>是不允许跨域设置的，浏览器也不会跨域发送<code>cookie</code></p><p>如果想要能够跨域设置<code>cookie</code>或发送<code>cookie</code>，需要服务端和<code>ajax</code>同时配置，才能允许跨域设置<code>cookie</code></p><p>服务端需要添加一个<code>Access-Control-Allow-Credentials</code>响应头，客户端<code>ajax</code>请求时需要设置<code>withCredentials</code>属性为<code>true</code>（使用fetch的配置是<code>&#123; credentials: &#39;include&#39; &#125;</code>，不同的库有不同的设置方法）</p><p>我们加上这两个设置，看能不能设置成功。</p><pre><code class="javascript">router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><pre><code class="javascript">btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;    fetch(&#39;http://localhost:8080/api/user&#39;,    &#123;        credentials: &#39;include&#39;    &#125;    )      .then(response =&gt; &#123;          return response.json();      &#125;)      // 请求的数据      .then(data =&gt; &#123;          console.log(data);      &#125;).catch(err =&gt; console.log(err));&#125;);</code></pre><p>我们来看看效果<br><img src="/images/cors_cookie5.png"><br>直接报跨域错误了，咋回事，我们明明设置了<code>Access-Control-Allow-Origin</code>为<code>*</code>啊。</p><p>记住，这是因为一旦当我们设置了<code>Access-Control-Allow-Credentials</code>请求头，我们<code>Access-Control-Allow-Origin</code>就不能直接设置为<code>*</code>了，需要指定明确的源，因此这里我们需要设置为<code>http://127.0.0.1:5500</code>（客户端的<code>url</code>是这个）</p><pre><code class="javascript">router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p>我们再来看看效果<br><img src="/images/cors_cookie6.png"></p><p>跨域错误没有了，但是在<code>set-cookie</code>头的这里出现了一个黄色的感叹号，<code>application</code>里面<code>cookie</code>也没有设置成功</p><p>这个警告是什么？</p><p>这个警告是告诉我们<code>cookie</code>的<code>SameSite</code>属性当前默认是<code>Lax</code>，如果我们需要跨站点访问<code>cookie</code>，需要将其设置为<code>None</code></p><p>这个<code>SameSite</code>用来限制第三方 <code>Cookie</code>，可以设置三个值</p><ul><li><p>Strict</p><p><code>Strict</code>最为严格，完全禁止第三方 <code>Cookie</code>，跨站点时，任何情况下都不会发送 <code>Cookie</code>。换言之，只有当前网页的 <code>URL</code> 与请求目标一致，才会带上 <code>Cookie</code>。</p><p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 <code>GitHub</code>链接，用户点击跳转就不会带有<code> GitHub</code> 的 <code>Cookie</code>，跳转过去总是未登陆状态。</p></li><li><p>Lax</p><p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 <code>Cookie</code>，但是导航到目标网址的 <code>Get</code> 请求除外。</p><p>导航到目标网址的 <code>GET</code> 请求，只包括三种情况：链接，预加载请求，<code>GET</code> 表单。详见下表。</p><table><thead><tr><th>请求类型</th><th>示例</th><th>正常情况</th><th>设置Lax后</th></tr></thead><tbody><tr><td>链接</td><td><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>预加载</td><td><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>GET 表单</td><td><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>POST 表单</td><td><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>iframe</td><td><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>AJAX</td><td><code>$.get(&quot;...&quot;)</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>Image</td><td><code>&lt;img src=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr></tbody></table></li><li><p>None</p><p><code>Chrome</code> 计划将Lax变为默认设置。这时，网站可以选择显式关闭<code>SameSite</code>属性，将其设为<code>None</code>。不过，前提是必须同时设置<code>Secure</code>属性（<code>Cookie</code> 只能通过 <code>HTTPS</code> 协议发送），否则无效。</p><p>下面的设置无效。</p><pre><code>Set-Cookie: widget_session=abc123; SameSite=None</code></pre><p>下面的设置有效。</p><pre><code>Set-Cookie: widget_session=abc123; SameSite=None; Secure</code></pre></li></ul><p>因此，如果我们想要跨站点发送<code>cookie</code>，需要设置<code>SameSite=None</code>，并且同时设置<code>Secure</code>属性（即配置<code>https</code>）</p><p>我们就来配置下</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);const fs = require(&#39;fs&#39;);const https = require(&#39;https&#39;);const sslify = require(&#39;koa-sslify&#39;).default;var options = &#123;    key: fs.readFileSync(&#39;./private_key.pem&#39;),  //私钥文件路径    cert: fs.readFileSync(&#39;./ca-cert.pem&#39;)  //证书文件路径&#125;;let server = new koa();server.use(sslify());let router = new Router();server.use(router.routes());https.createServer(options, server.callback()).listen(8080, (err) =&gt; &#123;    if (err) &#123;      console.log(&#39;服务启动出错&#39;, err);    &#125; else &#123;      console.log(&#39;guessWord-server运行在&#39; + 8080 + &#39;端口&#39;);    &#125;&#125;);// cookie循环秘钥server.keys = [    &#39;sdf7as9d8f7asd7f9sdfa9s&#39;,    &#39;sdfasd6fgjhgjgdgjsfgsf5&#39;,    &#39;nk54h3k2klj78kh89kh5kh3&#39;,];router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,        sameSite: &#39;none&#39;,        secure: true    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p>此时请求路径则需要修改为<code>https</code></p><pre><code class="javascript">btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;    fetch(&#39;https://localhost:8080/api/user&#39;,    &#123;        credentials: &#39;include&#39;    &#125;    )      .then(response =&gt; &#123;          return response.json();      &#125;)      // 请求的数据      .then(data =&gt; &#123;          console.log(data);      &#125;).catch(err =&gt; console.log(err));&#125;);</code></pre><p>来看看效果，可以看到警告没了，并且<code>application</code>里看<code>cookie</code>也成功设置上了<br><img src="/images/cors_cookie7.gif"></p><p>最后来看看设置成功后，请求会不会带上当前的cookie，发送给服务端（最终版）</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);const fs = require(&#39;fs&#39;);const https = require(&#39;https&#39;);const sslify = require(&#39;koa-sslify&#39;).default;var options = &#123;    key: fs.readFileSync(&#39;./private_key.pem&#39;),  //私钥文件路径    cert: fs.readFileSync(&#39;./ca-cert.pem&#39;)  //证书文件路径&#125;;let server = new koa();server.use(sslify());let router = new Router();server.use(router.routes());https.createServer(options, server.callback()).listen(8080, (err) =&gt; &#123;    if (err) &#123;      console.log(&#39;服务启动出错&#39;, err);    &#125; else &#123;      console.log(&#39;guessWord-server运行在&#39; + 8080 + &#39;端口&#39;);    &#125;&#125;);// cookie循环秘钥server.keys = [    &#39;sdf7as9d8f7asd7f9sdfa9s&#39;,    &#39;sdfasd6fgjhgjgdgjsfgsf5&#39;,    &#39;nk54h3k2klj78kh89kh5kh3&#39;,];router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,        sameSite: &#39;none&#39;,        secure: true    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);router.get(&#39;/api/cookie&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    console.log(ctx.cookies.get(&#39;username&#39;));    ctx.body = ctx.cookies.get(&#39;username&#39;); // 将cookie的值作为返回值&#125;);</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;button id=&quot;btn_cookie&quot;&gt;send cookie&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;https://localhost:8080/api/user&#39;,        &#123;            credentials: &#39;include&#39;        &#125;        )            .then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);    let btn_cookie = document.getElementById(&#39;btn_cookie&#39;);    btn_cookie.addEventListener(&#39;click&#39;, () =&gt; &#123;        fetch(&#39;https://localhost:8080/api/cookie&#39;,&#123;            credentials: &#39;include&#39;        &#125;).then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/cors_cookie8.gif"></p><p>可以看到，最终<code>cookie</code>值会放到请求头中，发送给服务端，而接口的返回值也是服务器读到的<code>cookie</code>中的值;</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域资源共享(CORS)</title>
      <link href="/2021/07/22/%E5%89%8D%E7%AB%AF/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-CORS/"/>
      <url>/2021/07/22/%E5%89%8D%E7%AB%AF/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-CORS/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>跨域是前端开发中常见的一个问题，其本身跟http协议没有关系，而是浏览器的一种安全机制，称之为同源策略；</p><p>同源策略指的是当前网站和需要访问的目标网站的<code>协议</code>、<code>域名</code>、<code>端口</code>都要相同，其中主要有一个不相同，就会产生跨域问题；</p><table><thead><tr><th>当前url</th><th>目标url</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="http://www.test.com/index.html">http://www.test.com/index.html</a></td><td>否</td><td>同源（协议、域名、端口相同）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="https://www.test.com/index.html">https://www.test.com/index.html</a></td><td>是</td><td>协议不同（http&#x2F;https），不只是这两种协议、如本地的file协议，websocket的ws协议等都算</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="http://www.test1.com/index.html">http://www.test1.com/index.html</a></td><td>是</td><td>主域名不同（test&#x2F;test1）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="http://mail.test.com/index.html">http://mail.test.com/index.html</a></td><td>是</td><td>子域名不同（www&#x2F;mail）</td></tr><tr><td><a href="http://www.test.com:8000/">http://www.test.com:8000</a></td><td><a href="http://www.test.com:8080/index.html">http://www.test.com:8080/index.html</a></td><td>是</td><td>端口不同（8000&#x2F;8080）</td></tr></tbody></table><h1 id="跨域会造成的问题"><a href="#跨域会造成的问题" class="headerlink" title="跨域会造成的问题"></a>跨域会造成的问题</h1><p>跨域会造成很多问题，比如</p><ul><li>无法读取非同源网页的 <code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexedDB</code></li><li>无法接触非同源网页的 <code>DOM</code></li><li>无法向非同源地址发送 <code>AJAX</code> 请求</li></ul><p>对于现在前后端分离的开发模式，我们最常见的跨域问题就是当请求后端接口时候发生的。如果遇到以下错误，就是发生了跨域问题，我们通过<code>fetch</code>，去请求后端接口（<code>http://localhost.com/api/user</code>），由于当前url是本地的，协议是<code>file</code>协议，就会发生跨域问题<br><img src="/images/cors.png"></p><h1 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h1><h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>在之前最常见的解决跨域问题是通过<code>jsonp</code>来进行的，<code>jsonp</code>的原理是在标签中的请求不会发生跨域问题，可以将请求放到标签上，然后再后台进行数据返回，前端定义一个获取数据的函数，后端将执行函数的代码当做字符串返回，前端会自动执行该代码，从而获取到了数据，但是<code>jsonp</code>有个最大的问题就是<code>jsonp</code>跨域<strong>只能处理</strong><code>get</code>请求。</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);router.get(&#39;/api/jsonp&#39;, async (ctx, next) =&gt; &#123;    const user = JSON.stringify(&#123;username: &#39;daryl&#39;, age: 18&#125;);    // jsonp就是这样处理，拿到客户端定义的callback函数，返回函数调用的字符串，将数据包在里面    const &#123; callback &#125; = ctx.query    ctx.body = `$&#123;callback&#125;($&#123;user&#125;)`;&#125;);</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;button id=&quot;btn_jsonp&quot;&gt;jsonp&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;http://localhost:8080/api/user&#39;,        )            .then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);    // jsonp     let btn_jsonp = document.getElementById(&#39;btn_jsonp&#39;);    btn_jsonp.addEventListener(&#39;click&#39;, () =&gt; &#123;        // 删除上个请求的script标签，避免html中充斥大量的无用script标签        let prevScript = document.querySelector(`script[src=&#39;http://localhost:8080/api/jsonp?callback=getUser&#39;]`);        if (prevScript) &#123;            document.body.removeChild(prevScript);        &#125;        let script = document.createElement(&#39;script&#39;);        script.setAttribute(&#39;src&#39;, &#39;http://localhost:8080/api/jsonp?callback=getUser&#39;);        document.body.appendChild(script);    &#125;)        // 这里的函数名就是上面的callback参数指定的名字    function getUser(data) &#123;        console.log(data);    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/cors1.gif"></p><p>我们可以看到，当我们直接去<code>fetch</code>的时候，发生了跨域，但是当我们通过<code>jsonp</code>处理后，可以拿到后端返回的数据</p><h2 id="后端设置"><a href="#后端设置" class="headerlink" title="后端设置"></a>后端设置</h2><p>浏览器将<code>CORS</code>请求分成两类：简单请求（<code>simple request</code>）和非简单请求（<code>not-so-simple request</code>）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><ol><li>请求方法是以下三种方法之一：</li></ol><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><ol start="2"><li>HTTP的头信息不超出以下几种字段：</li></ol><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li></ul><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器对这两种请求的处理，是不一样的</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>对于简单请求，浏览器直接发出<code>CORS</code>请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br><img src="/images/cors2.png"><br>上面的<code>Origin</code>字段是<code>null</code>，是因为我们是使用浏览器直接打开的本地文件，当我们使用<code>live server</code>模拟真实环境时，就会变成真实的<code>Origin</code><br><img src="/images/cors3.png"></p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的<code>HTTP</code>回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个跨域错误；<br><img src="/images/cors4.png"></p><p>我们可以在后端设置<code>Access-Control-Allow-Origin</code>，表示允许那些源进行跨域请求</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    // * 表示允许所有源进行跨域请求    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p><img src="/images/cors5.png"></p><p>后端还可以设置其他响应头，有其他作用，比如：</p><ul><li><p>Access-Control-Allow-Credentials</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在<code>CORS</code>请求之中。设为<code>true</code>，即表示服务器明确许可，<code>Cookie</code>可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。</p><p>注意：如果要把<code>Cookie</code>发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>为<code>true</code>，还要将客户端的<code>ajax</code>请求指定<code>withCredentials</code>，例如：</p><pre><code class="javascript">var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></pre><p>或者</p><pre><code class="javascript">fetch(url, &#123;  credentials: &#39;include&#39;&#125;)</code></pre><p>这篇文章<a href="https://www.baihuzi.com/2021/07/26/%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AEcookie/">跨域设置cookie</a>详细讲解了这个属性和客户端设置<code>cookie</code>相关的内容</p></li><li><p>Access-Control-Expose-Headers</p><p>该字段可选。<code>CORS</code>请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到7个基本字段（简单响应首部）：<code>Cache-Control</code>、<code>Content-Length</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。<br>例如：<br>我们设置了自定义头<code>Other-Header</code>，值为<code>other-header</code></p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    // 我们设置了自定义头Other-Header，值为other-header    ctx.set(&quot;Other-Header&quot;, &quot;other-header&quot;);    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p>此时通过<code>fetch</code>的<code>api</code>去获取响应头，是拿不到<code>Other-Header</code>的</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;http://localhost:8080/api/user&#39;,        )            .then(response =&gt; &#123;                for (let [key, value] of response.headers) &#123;                     console.log(`$&#123;key&#125; : $&#123;value&#125;`);                  &#125;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/cors6.gif"></p><p>但如果我们加上<code>ctx.set(&quot;Access-Control-Expose-Headers&quot;, &quot;Other-Header&quot;);</code>此时就可以拿到了</p><pre><code class="javascript">router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.set(&quot;Other-Header&quot;, &quot;other-header&quot;);    ctx.set(&quot;Access-Control-Expose-Headers&quot;, &quot;Other-Header&quot;);    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p><img src="/images/cors7.gif"></p></li></ul><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的<code>CORS</code>请求，会在正式通信之前，增加一次<code>HTTP</code>查询请求，称为”预检”请求（<code>preflight</code>）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些<code>HTTP</code>动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>我们来模拟一个非简单请求，在请求头中加入一个自定义字段<code>Authorization</code></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;http://localhost:8080/api/user&#39;,        &#123;            headers: &#123;                &#39;Authorization&#39;: &#39;some token&#39;            &#125;        &#125;        )            .then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/cors8.gif"></p><p>预检请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p><p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p><ul><li><p>Access-Control-Request-Method</p><p>该字段是必须的，用来列出浏览器的<code>CORS</code>请求会用到哪些<code>HTTP</code>方法，上例是<code>GET</code>。</p></li><li><p>Access-Control-Request-Headers</p><p>该字段是一个逗号分隔的字符串，指定浏览器<code>CORS</code>请求会额外发送的头信息字段，上例是<code>authorization</code>。</p></li></ul><p>预检请求也是一个真实的请求，我们后端需要对其进行处理，否则就会出现<code>404</code>错误（如上图），对于预检请求的响应，关键的是<code>Access-Control-Allow-Origin</code>字段，表示哪些源可以请求数据，如果在预检请求里面没有指定这个资源，而仅在需要的请求中指定，则也会发生跨域问题；例如：</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);router.options(&#39;*&#39;, async (ctx, next) =&gt; &#123;    // 如果预检请求这里没有指定Access-Control-Allow-Origin，而仅在上面设置了，也会发生跨域问题    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.set(&quot;Access-Control-Allow-Methods&quot;, &quot;OPTIONS, GET, PUT, POST, DELETE&quot;);    ctx.set(&quot;Access-Control-Allow-Headers&quot;, &quot;authorization&quot;);    ctx.set(&quot;Access-Control-Max-Age&quot;, &quot;1728000&quot;);    ctx.body = &#39;ok&#39;;&#125;)</code></pre><p>还有一些其他的相关字段：</p><ul><li><p>Access-Control-Allow-Methods</p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p></li><li><p>Access-Control-Allow-Headers</p><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p></li><li><p>Access-Control-Max-Age</p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p></li><li><p>Access-Control-Allow-Credentials</p><p>该字段与简单请求时的含义相同</p></li></ul><h2 id="vue跨域配置"><a href="#vue跨域配置" class="headerlink" title="vue跨域配置"></a>vue跨域配置</h2><ul><li><p>vue3.0</p><p>首先声明我们真实的接口地址是<code>http://localhost:8080/api/user</code></p><p><strong>vite.config.js</strong></p><pre><code class="javascript">  import &#123; defineConfig &#125; from &#39;vite&#39;  import vue from &#39;@vitejs/plugin-vue&#39;  import path from &#39;path&#39;  // https://vitejs.dev/config/  export default defineConfig(&#123;      plugins: [vue()],      server:&#123;          port: 3000,          proxy: &#123;              // /api 属性声明axios中url以/api开头的请求都适用于该规则，例如axios.get(&#39;/api/xxx&#39;)，对应下面按钮1的请求              &#39;/api&#39; : &#123;                  target: &#39;http://localhost:8080&#39;,                  changeOrigin: true,              &#125;,              // /local_api 属性声明axios中url以/local_api开头的请求都适用于该规则，例如axios.get(&#39;/local_api/api/xxx&#39;)，对应下面按钮2的请求              // 但是由于我们真实的接口地址是http://localhost:8080/api/user，而此时请求的是http://localhost:8080/local_api/api/user，因此需要将多余的路径进行重写，需要rewrite一下，将local_api/去掉，使其成为http://localhost:8080/api/user              &#39;/local_api&#39; : &#123;                  target: &#39;http://localhost:8080&#39;,                  changeOrigin: true,                  rewrite: (path) =&gt; &#123;console.log(path) ;return path.replace(/^\/local_api/, &#39;&#39;)&#125;              &#125;          &#125;      &#125;  &#125;)</code></pre><pre><code class="html">  &lt;template&gt;  &lt;div&gt;      &lt;button @click=&quot;getData&quot;&gt;按钮1&lt;/button&gt;      &lt;button @click=&quot;getData2&quot;&gt;按钮2&lt;/button&gt;  &lt;/div&gt;  &lt;/template&gt;  &lt;script&gt;  import axios from &#39;axios&#39;  export default &#123;      methods: &#123;          getData() &#123;              axios.get(&#39;/api/user&#39;).then(res =&gt; &#123;                  console.log(res.data)              &#125;)          &#125;,          getData2() &#123;              axios.get(&#39;/local_api/api/user&#39;).then(res =&gt; &#123;                  console.log(res.data)              &#125;)          &#125;,      &#125;  &#125;  &lt;/script&gt;</code></pre><p><img src="/images/cors7.png"><br><img src="/images/cors8.png"></p><p>两个请求都成功了，请求中的地址是本地的地址，正是因为我们做了代理</p></li><li><p>vue2.0</p><p>vue2.0的配置原理是相同的，只不过写法有一点差异而已，下面是相关配置</p><p><strong>vue.config.js</strong></p><pre><code class="javascript">  const path = require(&#39;path&#39;)  module.exports = &#123;      devServer: &#123;          proxy: &#123;              &#39;^/api&#39;: &#123;                  // 注意是以/api开头，即：axios.get(&#39;/api/xxx&#39;)，不能带接口的域名及端口                  target: &#39;http://localhost:8080&#39;, // 代理目标                  ws: true, // 启用websocket                  changeOrigin: true              &#125;,              &#39;^/local_api&#39;: &#123;                  // 注意是以/local_api开头，即：axios.get(&#39;/local_api/api/xxx&#39;)，不能带接口的域名及端口                  target: &#39;http://localhost:8080&#39;, // 代理目标                  changeOrigin: true,                  ws: true, // 启用websocket                  // 匹配到的地址重写， /local_api/api/xxx  =&gt;  https://www.baihuzi.com/api/xxx                  pathRewrite: &#123; &#39;^/local_api&#39;: &#39;&#39; &#125;              &#125;          &#125;      &#125;,  &#125;</code></pre><p>注意和<code>vite</code>的配置的写法不一样</p></li></ul><h2 id="react跨域配置"><a href="#react跨域配置" class="headerlink" title="react跨域配置"></a>react跨域配置</h2><p>react跨域配置需要使用第三方库<code>http-proxy-middleware</code>来解决，之前在<code>package.json</code>文件中配置<code>proxy</code>的方式已经不适用了，可能是希望将跨域配置放到后端来做，这样既省事也能保证安全。</p><p>首先需要安装<code>http-proxy-middleware</code></p><pre><code class="bash">yarn add http-proxy-middleware</code></pre><p>然后在<code>src</code>目录下新建文件<code>setupProxy.js</code>文件，项目启动的时候，会自动去找这个文件，我们不需要我们在其他地方引入</p><pre><code class="javascript">const &#123;createProxyMiddleware&#125; = require(&#39;http-proxy-middleware&#39;)module.exports = function (app) &#123;    // proxy第一个参数为要代理的路由    // 第二参数中target为代理后的请求网址，changeOrigin是否改变请求头，其他参数请看官网    app.use(createProxyMiddleware(&#39;/api&#39;, &#123;        target: &#39;http://localhost:8080&#39;,        changeOrigin: true,    &#125;))    app.use(createProxyMiddleware(&#39;/local_api&#39;, &#123;        target: &#39;http://localhost:8080&#39;,        changeOrigin: true,        pathRewrite: &#123; &#39;^/local_api&#39;: &#39;&#39; &#125;    &#125;))&#125;</code></pre><p>测试</p><pre><code class="javascript">import React from &#39;react&#39;import axios from &#39;axios&#39;const GetData = () =&gt; &#123;    const getData = () =&gt; &#123;        axios.get(&#39;/api/user&#39;).then(res =&gt; &#123;            console.log(res.data);        &#125;)    &#125;    const getData2 = () =&gt; &#123;        axios.get(&#39;/local_api/api/user&#39;).then(res =&gt; &#123;            console.log(res.data);        &#125;)    &#125;    return &lt;&gt;        &lt;button onClick=&#123;getData&#125;&gt;按钮1&lt;/button&gt;        &lt;button onClick=&#123;getData2&#125;&gt;按钮2&lt;/button&gt;    &lt;/&gt;&#125;export default GetData</code></pre><p><img src="/images/cors9.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CORS </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的强缓存和协商缓存</title>
      <link href="/2021/07/09/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
      <url>/2021/07/09/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在前端工程化中，前端代码打包之后的生成的静态资源就要发布到静态服务器上，这时候就要做对这些静态资源做一些运维配置，其中，<code>gzip</code>和设置缓存是必不可少的。这两项是最直接影响到网站性能和用户体验的。</p><p>浏览器缓存主要有以下几个优点：</p><ul><li>减少重复数据请求，避免通过网络再次加载资源，节省流量。</li><li>降低服务器的压力，提升网站性能。</li><li>加快客户端加载网页的速度， 提升用户体验。</li></ul><p>浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：</p><ul><li>强缓存在资源过期之前，不会向服务器发送网络请求，直接从本地缓存读取资源，响应码为<code>200  (from memory cache)</code>或者 <code>200  (from disk cache)</code>;</li><li>协商缓存会向服务器发送一次请求，服务器会根据这个请求的<code>Request Headers</code>的一些参数来判断是否命中协商缓存，如果命中，则返回<code>304</code>状态码并带上新的<code>Response Headers</code>通知浏览器从缓存中读取资源;</li></ul><h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><p>强缓存是根据返回头中的<code>expires</code>（http 1.0 规范）或者<code>Cache-Control</code>（http 1.1 规范）两个字段来控制的，都是表示资源的缓存有效时间。</p><ul><li><p><code>expires</code>的值是一个<code>GMT</code>格式的时间，这个时间代表资源的过期时间，在这个时间之前请求该资源，将直接命中强缓存。但是这个时间有个缺点，它是一个绝对时间，如果本地时间被修改，则将会导致缓存失效，所以<code>expires</code>还是有些缺陷的。</p></li><li><p>为了解决上述问题，http 1.1协议重新给了一个参数<code>Cache-Control</code>，这个值也是设置资源的过期时间，但是这个参数的值是一个相对时间，比如<code>cache-control: max-age=3600</code>，浏览器会根据这个相对时间结合响应头的<code>date</code>参数，得出资源的过期时间是<code>date</code>的时间加上3600秒，需要注意的是，并不是每次请求都进行计算生效时间，只有当当前请求是200，或者304的时候，才会进行计算，否则每次计算，每次都加3600秒，那资源永远都不会过期了。</p><p><code>Cache-Control</code>还有一些其他的值可以设置</p><ol><li><code>no-cache</code>：不使用强缓存，直接使用协商缓存。</li><li><code>no-store</code>：直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 <code>network</code> 中的 <code>disabled cache</code>。</li><li><code>public</code>：可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。</li><li><code>private</code>：只能被终端用户的浏览器缓存。</li></ol></li></ul><p>如果 <code>Cache-Control</code> 与 <code>expires</code> 同时存在的话， <code>Cache-Control</code> 的优先级高于 <code>expires</code></p><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, <code>last-modified</code> 或者 <code>etag</code>，则后续请求则会带上对应的请求字段 <code>if-modified-since</code>或者 <code>if-none-match</code>，若响应头没有 <code>last-modified</code> 或者 <code>etag</code> 字段，则请求头也不会有对应的字段。</p><ul><li><p><code>last-modified/if-modified-since</code>，值是<code>GMT</code>格式的时间字符串， <code>last-modified</code> 标记最后文件修改时间， 下一次请求时，请求头中会带上的 <code>if-modified-since</code> 值就是 <code>last-modified</code> ，告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 <code>304 Not Modified</code> ，请求不会返回资源内容，浏览器直接使用本地缓存。如果有变化，则返回<code>200</code>，返回最新的资源。</p></li><li><p><code>etag/if-none-match</code>， 值是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个唯一值并通过 <code>etag</code>字段返回给浏览器。当下次请求时，浏览器会将上次接收到的<code>etag</code>值赋给 <code>if-none-match</code> 字段，服务器通过比较两者是否一致来判定文件内容是否被改变。</p></li></ul><p><code>etag</code>的优先级比<code>last-modified</code>要高，先判断资源是否有更新</p><h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><p>浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：</p><ul><li>浏览器会获取该缓存资源的 header 中的信息，根据 <code>Response Headers</code> 中的 <code>expires</code> 和 <code>cache-control</code> 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。</li><li>如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 <code>IF-Modified-Since</code> 或者 <code>IF-None-Match</code>, 它们的值分别是第一次请求返回 <code>Last-Modified</code> 或者 <code>Etag</code>，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。</li></ul><p><img src="/images/%E7%BC%93%E5%AD%98%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png"></p><p>我们通过几个例子来实际看看会是什么效果，注意，设置缓存可以通过代理服务器设置，也可以直接使用代码设置，这里我们为了方便，直接使用<code>nginx</code>进行设置，<code>nginx</code>设置请求头需要<code>ngx_http_headers_module</code>模块支持，通过<code>yum</code>安装的<code>nginx</code>默认不支持此模块，需要另行编译安装；</p><blockquote><p>下面的例子，我们设置缓存事件都设置为30s，只是为了看效果，实际上不可能设置这么短的时间</p></blockquote><h2 id="设置expires"><a href="#设置expires" class="headerlink" title="设置expires"></a>设置<code>expires</code></h2><pre><code class="nginx">location ~* \.(js|css)$ &#123;  expires 30s;&#125;</code></pre><p>第一次请求直接返回200，可以看到虽然我们仅仅设置了<code>expires</code>，但是响应头中也会带上<code>cache-control</code>。<code>expires</code>是一个绝对时间，该时间由<code>date</code>的时间加上设置的<code>30s</code>；<br><img src="/images/expires1.png"><br>在过期时间内重复请求，都会命中强缓存，直接从浏览器本地读取资源<br><img src="/images/expires2.png"><br>如果超过了过期时间，则不会命中强缓存，走协商缓存，返回304（因为资源没有发生变化），同时我们可以看到，<code>date</code>和<code>expires</code>都更新了，重新计算缓存过期时间<br><img src="/images/expires3.png"></p><h2 id="设置cache-control-max-age-30"><a href="#设置cache-control-max-age-30" class="headerlink" title="设置cache-control: max-age=30"></a>设置<code>cache-control: max-age=30</code></h2><pre><code class="nginx">location ~* \.(js|css)$ &#123;  add_header Cache-Control max-age=30;&#125;</code></pre><p>设置了<code>cache-control</code>，此时可以看到响应头中已经不存在<code>expires</code>了，其他的请求行为和设置<code>expires</code>行为一样，这里不贴图了。<br><img src="/images/cache_control1.png"></p><h2 id="设置cache-control-no-cache，不使用强缓存，使用协商缓存"><a href="#设置cache-control-no-cache，不使用强缓存，使用协商缓存" class="headerlink" title="设置cache-control: no-cache，不使用强缓存，使用协商缓存"></a>设置<code>cache-control: no-cache</code>，不使用强缓存，使用协商缓存</h2><pre><code class="nginx">location ~* \.(js|css)$ &#123;  add_header Cache-Control no-cache;&#125;</code></pre><p>第一次请求直接返回200，并设置<code>cache-control</code>为<code>no-cache</code><br><img src="/images/cache_control2.png"><br>因为不使用强缓存，直接使用协商缓存，则之后每次都会返回304（因为资源没有发生变化）<br>注意每次请求都会讲上次响应头里的<code>etag</code>值（通过<code>if-none-match</code>请求头）和<code>last-modified</code>（通过<code>if-modified-since</code>请求头）发送给服务端<br><img src="/images/cache_control3.png"></p><h2 id="使用协商缓存，资源发生了改变（etag会发生变化）"><a href="#使用协商缓存，资源发生了改变（etag会发生变化）" class="headerlink" title="使用协商缓存，资源发生了改变（etag会发生变化）"></a>使用协商缓存，资源发生了改变（<code>etag</code>会发生变化）</h2><p>如果不使用强缓存，并且资源没有发生变化，则之后的每次请求都会返回304，但是如果我们的资源发生了变化，此时会将上次<code>etag</code>值（通过<code>if-none-match</code>请求头发送给服务器）和服务器上的最新资源<code>etag</code>值进行比较，发现资源更新了，则返回响应码200，并返回最新的资源。<br>资源没有发生变化，多次请求返回304，<code>etag</code>值为<code>60ede052-5dd</code><br><img src="/images/cache_control3.png"><br>修改<code>config.js</code>文件，更新资源，此时<code>etag</code>值会发生变化，此时<code>etag</code>值为<code>60ede48c-5eb</code>，响应码为200，请求了最新的资源。<br><img src="/images/cache_control4.png"></p><h2 id="使用协商缓存，资源没有改变，但是文件时间戳更新了（last-modified会发生变化）"><a href="#使用协商缓存，资源没有改变，但是文件时间戳更新了（last-modified会发生变化）" class="headerlink" title="使用协商缓存，资源没有改变，但是文件时间戳更新了（last-modified会发生变化）"></a>使用协商缓存，资源没有改变，但是文件时间戳更新了（<code>last-modified</code>会发生变化）</h2><p>我们先将<code>config.js</code>文件还原，避免混淆；<br>我们先看看当前文件的最后修改时间是多少，我们通过<code>linux</code>的<code>stat</code>命令查看，时间是<code>2021-07-14 03:17:06.109141809 +0800</code>，注意是<code>UTC</code>时间。<br><img src="/images/cache_control5.png"><br>多次请求，返回304，注意此时<code>last-modified</code>时间为<code>Tue, 13 Jul 2021 19:17:06 GMT</code>，<code>GMT</code>格式，加8个小时，正好是上面的<code>UTC</code>时间<br><img src="/images/cache_control6.png"><br>此时我们更新一下时间戳，通过<code>linux</code>的<code>touch</code>命令，更新<code>config.js</code>文件的时间戳（修改时间也会被修改），此时修改时间为<code>2021-07-14 03:25:30.121617196 +0800</code><br><img src="/images/cache_control7.png"><br>再次请求资源，响应头中的<code>last-modified</code>时间正好是我们更新时间戳后的时间，而上次的<code>last-modified</code>时间通过请求头中的<code>if-modified-since</code>传递给后端（注意<code>GMT</code>和<code>UTC</code>时间转换），发现两者时间不一致，响应码为200，请求了最新的资源。<br><img src="/images/cache_control8.png"></p><h1 id="etag拓展"><a href="#etag拓展" class="headerlink" title="etag拓展"></a><code>etag</code>拓展</h1><p>HTTP1.1 中<code>etag</code>的出现主要是为了解决几个<code>last-modified</code>比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新请求；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，<code>if-modified-since</code>能检查到的粒度是秒级的，使用<code>etag</code>就能够保证这种需求下客户端在1秒内能刷新 N 次 cache。</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p><code>etag</code>计算方式</p><p><code>etag</code>计算方式并没有明确规定，只要能标识文件唯一性就行了，但是对于大量的http请求，计算<code>etag</code>不能有太高的消耗，否则对响应速度以及服务器的运算能力都会有影响</p><p><code>etag</code>默认格式是<code>xxxxxxxx-xxx</code>，http默认计算<code>etag</code>的方式是通过文件的<code>last-modified</code>和<code>content-length</code>值的十六进制数标识的，形如<code>$&#123;last-modified&#125;-$&#123;content-length&#125;</code></p><p>对于以下<code>config.js</code>文件<br><img src="/images/cache_control9.png"></p><p>通过js计算该文件的<code>etag</code>值</p><pre><code class="javascript">`$&#123;(new Date(&#39;Tue, 13 Jul 2021 19:25:30 GMT&#39;).getTime() / 1000).toString(&#39;16&#39;)&#125;-$&#123;Number(1501).toString(&#39;16&#39;)&#125;`// 60ede8aa-5dd</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的重排与重绘</title>
      <link href="/2021/07/05/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98/"/>
      <url>/2021/07/05/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p>重排和重绘是浏览器运行过程中一个很重要的特性，页面的动画，结构变化都会涉及到重排与重绘，重排与重绘也是影响前端页面性能的一个很重要的因素，如果页面存在大量的重排与重绘，页面会显得非常“卡”，影响用户体验。</p><p>说道重排与重绘，首先要了解浏览器的渲染原理，浏览器渲染展示页面的过程，大致分为以下几步：</p><ul><li>解析<code>HTML</code>结构（<code>HTML Parser</code>），构建<code>DOM树</code>（<code>DOM Tree</code>）</li><li>解析<code>CSS</code>（<code>CSS Parser</code>），构建<code>CSS规则树</code>（<code>Style Rules</code>）</li><li>将<code>DOM树</code>与<code>CSS规则树</code>合并，构建<code>渲染树</code>（<code>Rendering Tree</code>）</li><li>布局（<code>Layout</code>）和绘制（<code>Paint</code>）</li><li>如果在渲染过程中发生了结构变化或者样式变化，则会进行重排（<code>reflow</code>）和重绘（<code>repaint</code>）</li></ul><blockquote><p>重排（<code>reflow</code>）也称为回流</p></blockquote><p>Webkit内核渲染引擎工作原理（Chrome，Safari，Opera）<br><img src="/images/Webkit%E5%86%85%E6%A0%B8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><p>Geoko内核渲染引擎工作原理（Firefox）<br><img src="/images/Geoko%E5%86%85%E6%A0%B8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><h1 id="什么是重排（reflow）？"><a href="#什么是重排（reflow）？" class="headerlink" title="什么是重排（reflow）？"></a>什么是重排（reflow）？</h1><p>当页面布局完成后，由于用户操作，增删了节点，修改了节点的宽高等，浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做<code>reflow</code>.</p><p>reflow(回流)是导致DOM脚本执行效率低的关键因素之一，页面上任何一个节点触发了reflow，会导致它的子节点及祖先节点重新渲染。</p><p>简单解释一下 Reflow：当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程称为 Reflow。</p><p>当页面布局和几何属性改变时就需要重排。下述情况会发生浏览器重排：</p><ul><li>添加或者删除可见的DOM元素</li><li>元素位置改变</li><li>元素尺寸改变（包括：内外边距、边框厚度、宽度和高度等属性的改变）</li><li>内容改变，例如：文本改变或者图片被另一个不同尺寸的图片替代</li><li>页面渲染器初始化</li><li>浏览器窗口尺寸改变</li><li>对可见元素 display：none，或者对不可见元素 display：block 时</li><li>激活伪类(:hover)</li><li>transition对宽高的处理，在整个transition的每一帧中，浏览器都要去重新布局，绘制页面(参考)</li></ul><h1 id="什么是重绘（repaint）？"><a href="#什么是重绘（repaint）？" class="headerlink" title="什么是重绘（repaint）？"></a>什么是重绘（repaint）？</h1><p><code>repaint</code>是在一个元素的外观被改变，但没有改变布局的情况下发生的，如改变了<code>visibility</code>、<code>outline</code>、<code>background</code>等。当<code>repaint</code>发生时，浏览器会验证<code>DOM树</code>上所有其他节点的<code>visibility</code>属性。</p><p>避免过分重绘(<code>Repaints</code>)<br>当元素改变的时候，将不会影响元素在页面当中的位置（比如 <code>background-color</code>, <code>border-color</code>, <code>visibility</code>），浏览器仅仅会应用新的样式重绘此元素，此过程称为 <code>Repaint</code>。</p><p>当 <code>render tree</code> 中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如 <code>background-color</code>，则称之为重绘。</p><ul><li>改变字体</li><li>增加或者移除样式表</li><li>内容变化，比如用户在input框中输入文字</li><li>激活CSS伪类(:hover)</li><li>脚本操作DOM （也有可能造成回流）</li><li>计算 offsetWidth 和 offsetHeight 的属性</li><li>设置style属性的值</li></ul><h1 id="通过例子分析重排和重绘"><a href="#通过例子分析重排和重绘" class="headerlink" title="通过例子分析重排和重绘"></a>通过例子分析重排和重绘</h1><p>我们可以结合浏览器的性能分析工具，来看到浏览器的渲染过程，通过以下代码，我们来分别看看重排和重绘何时发生</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        .main&#123;            border: 1px solid red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;button id=&quot;addNode&quot;&gt;添加节点&lt;/button&gt;  &lt;button id=&quot;changeStyle&quot;&gt;修改颜色&lt;/button&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;ul class=&quot;ul&quot;&gt;      &lt;li&gt;11111&lt;/li&gt;      &lt;li&gt;22222&lt;/li&gt;      &lt;li&gt;33333&lt;/li&gt;      &lt;li&gt;44444&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.bootcss.com/zepto/1.2.0/zepto.min.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    const ul = document.querySelector(&#39;.ul&#39;);    const addNodeBtn = document.querySelector(&#39;#addNode&#39;);    const changeStyleBtn = document.querySelector(&#39;#changeStyle&#39;);    addNodeBtn.onclick = function addNode() &#123;      const newLi = document.createElement(&#39;li&#39;);      newLi.innerText = Math.random() * 10000;      ul.appendChild(newLi);    &#125;    changeStyleBtn.onclick = function changeStyle() &#123;      $(&#39;.main&#39;).css(&#39;color&#39;, &#39;red&#39;)    &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>当我们向<code>ul</code>中添加一个<code>li</code>，此时<code>dom</code>结构发生了变化，会发生重排<br><img src="/images/%E9%87%8D%E6%8E%92.gif"></p><p>当我们仅仅只是修改了文字的颜色，此时并不会发生重排，仅仅会发生重绘<br><img src="/images/%E9%87%8D%E7%BB%98.gif"></p><p>同时我们可以看到，只要发生了重排，则必然会出现重绘，而重绘并不一定会重排，我们可以得出一个结论：<strong>重排必定会引发重绘，但重绘不一定会引发重排。</strong></p><h1 id="渲染树变化的排队与刷新"><a href="#渲染树变化的排队与刷新" class="headerlink" title="渲染树变化的排队与刷新"></a>渲染树变化的排队与刷新</h1><p>浏览器会维护一个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会<code>flush</code>队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。然而你可能会（经常不知不觉）强制刷新队列并要求计划任务立即执行。获取布局信息的操作会导致队列刷新，比如以下方法：</p><ul><li><code>offsetTop</code>，<code>offsetLeft</code>，<code>offsetWidth</code>，<code>offsetHeight</code></li><li><code>scrollTop</code>，<code>scrollLeft</code>，<code>scrollWidth</code>，<code>scrollHeight</code></li><li><code>clientTop</code>，<code>clientLeft</code>，<code>clientWidth</code>，<code>clientHeight</code></li><li><code>width</code>，<code>height</code></li><li><code>getComputedStyle()</code> (<code>currentStyle</code> in IE)</li><li>JS更改元素style</li></ul><p>以上属性和方法需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理”变化并触发重排以返回正确的值。</p><p>在修改样式的过程中，最好避免使用上面列出的属性。它们都会刷新渲染队列，即使你是在获取最近未发生改变的或者与最新变化无关的布局信息。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>上述提到的浏览器自己的优化，维护一个队列，队重排和重绘进行批处理</p><p>开发者需要注意的优化</p><ul><li>直接改变元素的<code>className</code></li><li><code>display：none;</code> 先设置元素为<code>display：none;</code>，然后进行页面布局等操作；设置完成后将元素设置为<code>display：block;</code>，这样的话就只引发两次重绘和重排；</li><li>不要经常访问浏览器的flush队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流；</li><li>使用<code>cloneNode</code>(true or false) 和 <code>replaceChild</code> 技术，引发一次回流和重绘；</li><li>将需要多次重排的元素，<code>position</code>属性设为<code>absolute</code>或<code>fixed</code>，元素脱离了文档流，它的变化不会影响到其他元素；</li><li>如果需要创建多个<code>DOM</code>节点，可以使用<code>DocumentFragment</code>创建完后一次性的加入<code>document</code>；</li><li>尽量不要使用<code>table</code>布局。</li><li>制作动画时，尽量使用 <code>CSS3</code> 的 <code>transform</code>，因为 <code>transform</code> 属性不会改变元素的布局（更详细的知识可以参考：<a href="https://juejin.cn/post/6844903502678867981">详谈层合成composite</a> ）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL通过二进制日志恢复数据</title>
      <link href="/2018/12/28/Mysql/MySQL%E9%80%9A%E8%BF%87%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/12/28/Mysql/MySQL%E9%80%9A%E8%BF%87%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL通过二进制日志恢复数据"><a href="#MySQL通过二进制日志恢复数据" class="headerlink" title="MySQL通过二进制日志恢复数据"></a>MySQL通过二进制日志恢复数据</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="开启二进制日志"><a href="#开启二进制日志" class="headerlink" title="开启二进制日志"></a>开启二进制日志</h3><pre><code class="bash">[root@lyucan ~]# vim /etc/my.cnf[mysqld]server-id=1log-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=statement[root@lyucan ~]# service mysqld restartShutting down MySQL.. SUCCESS!Starting MySQL.. SUCCESS!</code></pre><blockquote><p>上面的 binlog_format&#x3D;statement 参数默认是row，表示用行来记录，这里为了方便观察，直接使用statement模式，这个参数可以动态修改</p></blockquote><h3 id="查看二进制日志是否开启"><a href="#查看二进制日志是否开启" class="headerlink" title="查看二进制日志是否开启"></a>查看二进制日志是否开启</h3><pre><code class="sql">mysql&gt; show variables like &#39;log_bin%&#39;;+---------------------------------+-----------------------------+| Variable_name                   | Value                       |+---------------------------------+-----------------------------+| log_bin                         | ON                          || log_bin_basename                | /data/mysql/mysql-bin       || log_bin_index                   | /data/mysql/mysql-bin.index || log_bin_trust_function_creators | OFF                         || log_bin_use_v1_row_events       | OFF                         |+---------------------------------+-----------------------------+</code></pre><h2 id="常用binlog操作命令"><a href="#常用binlog操作命令" class="headerlink" title="常用binlog操作命令"></a>常用binlog操作命令</h2><h3 id="1、查看所有binlog列表"><a href="#1、查看所有binlog列表" class="headerlink" title="1、查看所有binlog列表"></a>1、查看所有binlog列表</h3><pre><code class="sql">mysql&gt; show master logs;+------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |      2052 || mysql-bin.000002 |       943 || mysql-bin.000003 |       154 |+------------------+-----------+3 rows in set (0.00 sec)</code></pre><h3 id="2、查看master状态，即最后（最新）的一个binlog日志的编号及最后一个position的值"><a href="#2、查看master状态，即最后（最新）的一个binlog日志的编号及最后一个position的值" class="headerlink" title="2、查看master状态，即最后（最新）的一个binlog日志的编号及最后一个position的值"></a>2、查看master状态，即最后（最新）的一个binlog日志的编号及最后一个position的值</h3><pre><code class="sql">mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000003 |      154 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><h3 id="3、flush-logs刷新日志"><a href="#3、flush-logs刷新日志" class="headerlink" title="3、flush logs刷新日志"></a>3、flush logs刷新日志</h3><pre><code class="sql">mysql&gt; flush logs;Query OK, 0 rows affected (0.01 sec)mysql&gt; show master logs;+------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |      2052 || mysql-bin.000002 |       943 || mysql-bin.000003 |       201 || mysql-bin.000004 |       154 |+------------------+-----------+4 rows in set (0.00 sec)</code></pre><blockquote><p>注意：当mysql服务器重启时，自动刷新binlog；</p></blockquote><h3 id="4、清空所有日志"><a href="#4、清空所有日志" class="headerlink" title="4、清空所有日志"></a>4、清空所有日志</h3><pre><code class="sql">mysql&gt; reset master;Query OK, 0 rows affected (0.01 sec)mysql&gt; show master logs;+------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |       154 |+------------------+-----------+1 row in set (0.00 sec)</code></pre><h2 id="查看二进制日志的方法"><a href="#查看二进制日志的方法" class="headerlink" title="查看二进制日志的方法"></a>查看二进制日志的方法</h2><h3 id="1、使用mysqlbinlog工具来查看二进制日志；"><a href="#1、使用mysqlbinlog工具来查看二进制日志；" class="headerlink" title="1、使用mysqlbinlog工具来查看二进制日志；"></a>1、使用mysqlbinlog工具来查看二进制日志；</h3><pre><code class="bash">[root@lyucan ~]# mysqlbinlog /data/mysql/mysql-bin.000002......# at 484              ##position号#180410 15:51:27 server id 1  end_log_pos 484 CRC32 0xb489f444       IntvarSET INSERT_ID=1/*!*/;#180410 15:51:27 server id 1  end_log_pos 606 CRC32 0xdbf27bfd       Query       thread_id=3   exec_time=0   error_code=0SET TIMESTAMP=1523346687/*!*/;insert into t_user (user_name) values (&#39;张三&#39;)       ##当binlog_format设置为statement时，可以看到明文的DML语句；     /*!*/;# at 606......</code></pre><pre><code class="bash">[root@lyucan ~]# mysqlbinlog -v -v /data/mysql/mysql-bin.000001......# at 343#180410 15:35:16 server id 1  end_log_pos 390 CRC32 0x554a373c       Write_rows: table id 141 flags: STMT_END_FBINLOG &#39;NGnMWhMBAAAANAAAAFcBAAAAAI0AAAAAAAEABHRlc3QABnRfdXNlcgACAw8CWgAAt/Mk7w==NGnMWh4BAAAALwAAAIYBAAAAAI0AAAAAAAEAAgAC//wEAAAABuW8oOS4iTw3SlU=&#39;/*!*/;### INSERT INTO `test`.`t_user`             ##当binlog_format设置为row时，需要加上-v -v 才能看到明文的DML语句；### SET###   @1=4 /* INT meta=0 nullable=0 is_null=0 */###   @2=&#39;张三&#39; /* VARSTRING(90) meta=90 nullable=0 is_null=0 */# at 390......</code></pre><h3 id="2、在数据库里查；"><a href="#2、在数据库里查；" class="headerlink" title="2、在数据库里查；"></a>2、在数据库里查；</h3><pre><code class="sql">mysql&gt; show binlog events [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count];## FROM pos：起始position号，不指定就是当前文件的第一个开始；## LIMIT offset：偏移量，就是从起始position跳过几个再开始## row_count：查询多少行，不指定就查到文件尾行；</code></pre><pre><code class="sql">mysql&gt; show binlog events in &#39;mysql-bin.000002&#39;;+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                                         |+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+| mysql-bin.000002 |   4 | Format_desc    |         1 |         123 | Server ver: 5.7.21-log, Binlog ver: 4                        || mysql-bin.000002 | 123 | Previous_gtids |         1 |         154 |                                                              || mysql-bin.000002 | 154 | Anonymous_Gtid |         1 |         219 | SET @@SESSION.GTID_NEXT= &#39;ANONYMOUS&#39;                         || mysql-bin.000002 | 219 | Query          |         1 |         308 | use `test`; truncate t_user                                  || mysql-bin.000002 | 308 | Anonymous_Gtid |         1 |         373 | SET @@SESSION.GTID_NEXT= &#39;ANONYMOUS&#39;                         || mysql-bin.000002 | 373 | Query          |         1 |         452 | BEGIN                                                        || mysql-bin.000002 | 452 | Intvar         |         1 |         484 | INSERT_ID=1                                                  || mysql-bin.000002 | 484 | Query          |         1 |         606 | use `test`; insert into t_user (user_name) values (&#39;张三&#39;)   || mysql-bin.000002 | 606 | Xid            |         1 |         637 | COMMIT /* xid=18 */                                          || mysql-bin.000002 | 637 | Anonymous_Gtid |         1 |         702 | SET @@SESSION.GTID_NEXT= &#39;ANONYMOUS&#39;                         || mysql-bin.000002 | 702 | Query          |         1 |         781 | BEGIN                                                        || mysql-bin.000002 | 781 | Query          |         1 |         889 | use `test`; delete from t_user where user_id=1               || mysql-bin.000002 | 889 | Xid            |         1 |         920 | COMMIT /* xid=21 */                                          || mysql-bin.000002 | 920 | Stop           |         1 |         943 |                                                              |+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+14 rows in set (0.00 sec)mysql&gt; show binlog events in &#39;mysql-bin.000002&#39; from 154 limit 5,5;+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                                         |+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+| mysql-bin.000002 | 484 | Query          |         1 |         606 | use `test`; insert into t_user (user_name) values (&#39;张三&#39;)   || mysql-bin.000002 | 606 | Xid            |         1 |         637 | COMMIT /* xid=18 */                                          || mysql-bin.000002 | 637 | Anonymous_Gtid |         1 |         702 | SET @@SESSION.GTID_NEXT= &#39;ANONYMOUS&#39;                         || mysql-bin.000002 | 702 | Query          |         1 |         781 | BEGIN                                                        || mysql-bin.000002 | 781 | Query          |         1 |         889 | use `test`; delete from t_user where user_id=1               |+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+5 rows in set (0.00 sec)</code></pre><blockquote><p>恢复数据一定要和备份一起操作，否则即使有二进制日志，也不能完全恢复数据；</p></blockquote><h2 id="恢复二进制日志的方法"><a href="#恢复二进制日志的方法" class="headerlink" title="恢复二进制日志的方法"></a>恢复二进制日志的方法</h2><pre><code class="bash">mysqlbinlog mysql-bin.0000xx | mysql -u用户名 -p密码 数据库名</code></pre><p>常用参数选项解释：<br>–start-position&#x3D;123 起始pos点<br>–stop-position&#x3D;456 结束pos点<br>–start-datetime&#x3D;”2016-9-25 22:01:08” 起始时间点<br>–stop-datetime&#x3D;”2019-9-25 22:09:46” 结束时间点<br>–database&#x3D;test1 指定只恢复test1数据库(一台主机上往往有多个数据库，只限本地log日志)</p><hr><p>不常用选项：<br>-u –user&#x3D;name 连接到远程主机的用户名<br>-p –password[&#x3D;name] 连接到远程主机的密码<br>-h –host&#x3D;name 从远程主机上获取binlog日志<br>–read-from-remote-server 从某个MySQL服务器上读取binlog日志</p><p>例子：<br>假设t1表里有这几个字段，我们误将第四行记录delete掉了，再通过binlog找回；</p><pre><code class="sql">mysql&gt; select * from t1;+----+--------+-----+--------+| id | name   | age | addr   |+----+--------+-----+--------+|  1 | 张三   |  12 | 南京   ||  2 | 李四   |  21 | 北京   ||  3 | 王五   |  23 | 上海   ||  4 | 二蛋   |  10 | 农村   |+----+--------+-----+--------+4 rows in set (0.00 sec)mysql&gt; delete from t1  where id=4;Query OK, 1 row affected (0.00 sec)mysql&gt; show binlog events in &#39;mysql-bin.000004&#39;\G;......*************************** 75. row ***************************   Log_name: mysql-bin.000004        Pos: 6566Event_type: Query  Server_id: 1End_log_pos: 6685       Info: use `test`; insert into t1 values(4,&#39;二蛋&#39;,10,&#39;农村&#39;)*************************** 76. row ***************************......</code></pre><p>恢复这条数据</p><pre><code class="bash">[root@lyucan mysql]# mysqlbinlog --start-position=6566 --stop-position=6685 mysql-bin.000004 | mysql -uroot -p test</code></pre><p>上面的例子可能举得不是很恰当，因为我们都知道已经丢失的数据是什么了，但是在实际情况中，我们往往不知道丢失了哪些数据，万一drop掉了整个数据库，难道要一条条去恢复吗，显然不可能，这就需要我们定时做好备份工作，一个完整的备份往往是全量备份+增量备份+二进制日志备份，在进行全量备份的时候，我们需要知道当前二进制日志的position号，这样就可以进行完全恢复；</p><p>在进行mysqldump的时候，我们可以指定一个-F参数，在备份的时候刷新下binlog日志，这样新的操作都会记录到另一个新的binlog文件里面去，便于我们进行数据恢复，而不用费时费力去找要从哪里进行我二进制日志的恢复；</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMAN冗余备份和并发备份</title>
      <link href="/2018/12/16/Oracle/RMAN%E5%86%97%E4%BD%99%E5%A4%87%E4%BB%BD%E5%92%8C%E5%B9%B6%E5%8F%91%E5%A4%87%E4%BB%BD/"/>
      <url>/2018/12/16/Oracle/RMAN%E5%86%97%E4%BD%99%E5%A4%87%E4%BB%BD%E5%92%8C%E5%B9%B6%E5%8F%91%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="RMAN冗余备份和并发备份"><a href="#RMAN冗余备份和并发备份" class="headerlink" title="RMAN冗余备份和并发备份"></a>RMAN冗余备份和并发备份</h1><h2 id="RMAN冗余备份（duplex-backup）"><a href="#RMAN冗余备份（duplex-backup）" class="headerlink" title="RMAN冗余备份（duplex backup）"></a>RMAN冗余备份（duplex backup）</h2><p>冗余备份不能放置在闪回区，需要自己定义其他的存放目录；</p><pre><code class="sql">RMAN&gt; backup copies 2 tablespace users;     ##默认使用闪回区Starting backup at 15-MAY-18using channel ORA_DISK_1channel ORA_DISK_1: starting full datafile backup setchannel ORA_DISK_1: specifying datafile(s) in backup setinput datafile file number=00004 name=/oracle/11g/oradata/mysql_master_1003306/users01.dbfchannel ORA_DISK_1: starting piece 1 at 15-MAY-18RMAN-00571: ===========================================================RMAN-00569: =============== ERROR MESSAGE STACK FOLLOWS ===============RMAN-00571: ===========================================================RMAN-03009: failure of backup command on ORA_DISK_1 channel at 05/15/2018 21:09:51ORA-19806: cannot make duplex backups in recovery area</code></pre><p>方法1：</p><pre><code class="sql">CONFIGURE DATAFILE BACKUP COPIES FOR DEVICE TYPE DISK TO 1;           ##1改为2将会备两份CONFIGURE ARCHIVELOG BACKUP COPIES FOR DEVICE TYPE DISK TO 1;</code></pre><p>方法2：</p><pre><code class="sql">backup copies 2 tablespace users format &#39;/oracle/11g/backup/orcl/backup01/%U&#39;,&#39;/oracle/11g/backup/orcl/backup02/%U&#39;;##如果只写一个format，那么两个文件都将放在那个路径下</code></pre><p>方法3：</p><pre><code class="sql">run &#123;    set backup copies 2;    backup device type disk format &#39;/oracle/11g/backup/orcl/backup01/%U&#39;,&#39;/oracle/11g/backup/orcl/backup02/%U&#39; tablespace users,tbs01;&#125;</code></pre><h2 id="RMAN并发备份"><a href="#RMAN并发备份" class="headerlink" title="RMAN并发备份"></a>RMAN并发备份</h2><p>如果一个文件跟大，将需要并行化这一文件的备份，通常，一个通道只能读一个文件，但是用多段关键字可以改变这一行为：</p><pre><code class="sql">run &#123;allocate channel c1 device type disk format &#39;/oracle/11g/backup/orcl/backup01/%U&#39;;allocate channel c2 device type disk format &#39;/oracle/11g/backup/orcl/backup01/%U&#39;;allocate channel c3 device type disk format &#39;/oracle/11g/backup/orcl/backup01/%U&#39;;allocate channel c4 device type disk format &#39;/oracle/11g/backup/orcl/backup01/%U&#39;;backup datafile 1 section size 1m;&#125;##如果format指向不同的路径，那么文件将分布在其路径下，指向同一个路径，则都放在同一个路径下</code></pre><p>这一脚本将启动4个通道，每个通道读取数据文件16的一段10GB的段。每个通道将生成包含段的备份的片（单独的物理文件）。<br>如果文件为200GB, 将有20个这样的片，一次生成4个。没有section size 关键字，并行读将为1（也就是序列化），用一个通道执行整个操作。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-关键字和标识符及命名规范</title>
      <link href="/2018/11/23/Python/Python-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%8A%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/2018/11/23/Python/Python-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%8A%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="关键字和标识符及命名规范"><a href="#关键字和标识符及命名规范" class="headerlink" title="关键字和标识符及命名规范"></a>关键字和标识符及命名规范</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>就是python语言定义的、具有特殊用途的单词，通过内置函数help()查看所有关键字</p><pre><code class="python">&gt;&gt;&gt; help()help&gt; keywordsHere is a list of the Python keywords.  Enter any keyword to get more help.False               class               from                orNone                continue            global              passTrue                def                 if                  raiseand                 del                 import              returnas                  elif                in                  tryassert              else                is                  whileasync               except              lambda              withawait               finally             nonlocal            yieldbreak               for                 not             </code></pre><p>或者导入模块keyword查看</p><pre><code class="python">&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;async&#39;, &#39;await&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</code></pre><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>计算机科学中最难的两件事是命名和缓存失效<br>就是给程序中的变量，函数、方法、类等命名的名字</p><p>标识符命名规则：<br>1、区分大小写<br>2、不能是关键字<br>3、不能以数字开头<br>4、不能包含空格、制表符、数学符号、中划线、箭头灯</p><p>标识符命名规范：<br>1、“见名知意”，由一个或多个有意义的单词组合而成<br> 2、多有单词全部小写，单词之间用下划线分隔，如student_name，student_id</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postfix+sasl进行邮件服务器的搭建</title>
      <link href="/2018/11/21/%E8%BF%90%E7%BB%B4/postfix+sasl%E8%BF%9B%E8%A1%8C%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/11/21/%E8%BF%90%E7%BB%B4/postfix+sasl%E8%BF%9B%E8%A1%8C%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="postfix-sasl进行邮件服务器的搭建"><a href="#postfix-sasl进行邮件服务器的搭建" class="headerlink" title="postfix+sasl进行邮件服务器的搭建"></a>postfix+sasl进行邮件服务器的搭建</h1><p>基本的步骤在另一篇笔记 <a href="http://baihuzi.com/article/066d0943-90b2-412a-8e5f-fac2c71c0415" title="title">postfix搭建邮件服务器</a>中有，不再赘述，包括解析记录的添加、postfix和dovecot软件包的安装、防火墙放通等步骤；</p><p>这里仅介绍sasl的相关的配置；</p><h2 id="配置sasl"><a href="#配置sasl" class="headerlink" title="配置sasl"></a>配置sasl</h2><p>sasl安装</p><pre><code class="bash">[root@lyucan ~]# yum install cyrus-sasl*</code></pre><p>为postfix开启基于cyrus-sasl的认证功能。<br>编辑saslauthd配置文件</p><pre><code class="bash">[root@lyucan ~]# vim /etc/sysconfig/saslauthd# Directory in which to place saslauthd&#39;s listening socket, pid file, and so# on.  This directory must already exist.SOCKETDIR=/run/saslauthd# Mechanism to use when checking passwords.  Run &quot;saslauthd -v&quot; to get a list# of which mechanism your installation was compiled with the ablity to use.#MECH=pamMECH=shadow               ###这里修改成shadow，基于本地用户密码进行认证# Additional flags to pass to saslauthd on the command line.  See saslauthd(8)# for the list of accepted flags.FLAGS=</code></pre><pre><code class="bash">[root@lyucan ~]# vim /etc/sasl2/smtpd.confpwcheck_method: saslauthdmech_list: plain login                       ##按照这样修改</code></pre><p>启动saslauthd</p><pre><code class="bash">[root@lyucan ~]# systemctl enable saslauthd.serviceCreated symlink from /etc/systemd/system/multi-user.target.wants/saslauthd.service to /usr/lib/systemd/system/saslauthd.service.[root@lyucan ~]# systemctl restart saslauthd.service</code></pre><p>验证是否能通过本地用户密码来进行认证</p><pre><code class="bash">[root@lyucan sasl2]# testsaslauthd -u admin -p passwd0: NO &quot;authentication failed&quot;</code></pre><p>如果失败，可能是由于selinux导致的，将selinux关闭或者放通规则</p><pre><code class="bash">[root@lyucan sasl2]# setsebool -P allow_saslauthd_read_shadow 1  ##放通selinux规则[root@lyucan sasl2]# testsaslauthd -u user1 -p user10: OK &quot;Success.&quot;                                              ##返回ok</code></pre><p>验正postfix是否支持cyrus风格的sasl认证</p><pre><code class="bash">[root@lyucan ~]# postconf -acyrus                                 ##有这个则正常dovecot</code></pre><h2 id="配置postfix"><a href="#配置postfix" class="headerlink" title="配置postfix"></a>配置postfix</h2><p>修改postfix的main.cnf配置文件</p><pre><code class="bash">[root@lyucan ~]# cat -b /etc/postfix/main.cf | grep -v &#39;#&#39; | grep -v ^$    29 queue_directory = /var/spool/postfix    33 command_directory = /usr/sbin    38 daemon_directory = /usr/libexec/postfix    43 data_directory = /var/lib/postfix    53 mail_owner = postfix    69 myhostname = mail.lyucan.com    76 mydomain = lyucan.com    92 myorigin = $mydomain   107 inet_interfaces = all   109 inet_protocols = all   156 mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain   168 local_recipient_maps =                           ##这里加不加都可以   209 unknown_local_recipient_reject_code = 550   254 mynetworks = 127.0.0.0/8,127.0.0.1               ##这里就设置成本地地址   284 relay_domains = $mydestination                   ##这里加上转发的地址         365 alias_maps = hash:/etc/aliases   375 alias_database = hash:/etc/aliases   395 home_mailbox = Maildir/   396   503   542   564 debug_peer_level = 2   580 debugger_command =   581         PATH=/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin   582         ddd $daemon_directory/$process_name $process_id &amp; sleep 5   608 sendmail_path = /usr/sbin/sendmail.postfix   612 newaliases_path = /usr/bin/newaliases.postfix   616 mailq_path = /usr/bin/mailq.postfix   621 setgid_group = postdrop   624 html_directory = no   627 manpage_directory = /usr/share/man   631 sample_directory = /usr/share/doc/postfix-2.10.1/samples   634 readme_directory = /usr/share/doc/postfix-2.10.1/README_FILES###这下面的都是需要新添加的配置   636 broken_sasl_auth_clients = yes   637 smtpd_client_restrictions = permit_sasl_authenticated   638 smtpd_recipient_restrictions = permit_mynetworks, permit_sasl_authenticated, reject_unauth_destination   639 smtpd_sasl_auth_enable = yes   640 smtpd_sasl_local_domain = $mydomain   641 smtpd_sasl_security_options = noanonymous   642 message_size_limit = 5242880   643 smtpd_banner = $myhostname ESMTP</code></pre><p>重启postfix和saslauthd</p><pre><code class="bash">[root@lyucan ~]# systemctl restart postfix.service[root@lyucan ~]# systemctl restart saslauthd.service</code></pre><h2 id="验证认证登陆"><a href="#验证认证登陆" class="headerlink" title="验证认证登陆"></a>验证认证登陆</h2><p>创建admin用户，密码为pass</p><pre><code class="bash">[root@lyucan ~]# useradd admin[root@lyucan ~]# passwd adminChanging password for user admin.New password:Retype new password:passwd: all authentication tokens updated successfully.</code></pre><p>生成用户名密码base64的密文</p><pre><code class="bash">[root@lyucan ~]# perl -e &#39;use MIME::Base64; print encode_base64(&quot;admin&quot;)&#39;YWRtaW4=[root@lyucan ~]# perl -e &#39;use MIME::Base64; print encode_base64(&quot;pass&quot;)&#39;ZWNobzEyMy4=</code></pre><pre><code class="bash">[root@lyucan ~]# telnet mail.lyucan.com 25Trying 103.84.88.151...Connected to mail.lyucan.com.Escape character is &#39;^]&#39;.220 mail.lyucan.com ESMTPehlo 163.com250-mail.lyucan.com250-PIPELINING250-SIZE 5242880250-VRFY250-ETRN250-AUTH PLAIN LOGIN250-AUTH=PLAIN LOGIN250-ENHANCEDSTATUSCODES250-8BITMIME250 DSNauth login334 VXNlcm5hbWU6YWRtaW4=334 UGFzc3dvcmQ6ZWNobzEyMy4=235 2.7.0 Authentication successful                 ###表示认证成功quit221 2.0.0 ByeConnection closed by foreign host.</code></pre><h2 id="配置dovecot"><a href="#配置dovecot" class="headerlink" title="配置dovecot"></a>配置dovecot</h2><p>下面三个配置文件均没有变化</p><pre><code class="bash">[root@lyucan ~]# cat -b /etc/dovecot/dovecot.conf | grep -v &#39;#&#39; | grep -v ^$    19 protocols = imap pop3 lmtp    25 listen = *    72 dict &#123;    75 &#125;    79 !include conf.d/*.conf    82 !include_try local.conf</code></pre><pre><code class="bash">[root@lyucan ~]# cat -b /etc/dovecot/conf.d/10-auth.conf | grep -v &#39;#&#39; | grep -v ^$     9 disable_plaintext_auth = no    82 auth_mechanisms = plain login   100 !include auth-system.conf.ext</code></pre><pre><code class="bash">[root@lyucan ~]# vim /etc/dovecot/conf.d/10-ssl.confssl = no##同时注释掉下面两行配置#ssl_cert = &lt;/etc/pki/dovecot/certs/dovecot.pem#ssl_key = &lt;/etc/pki/dovecot/private/dovecot.pem</code></pre><p>这里的邮件存放路径使用另外一个</p><pre><code class="bash">[root@lyucan ~]# cat -b /etc/dovecot/conf.d/10-mail.conf | grep -v &#39;#&#39; | grep -v ^$    31 mail_location = maildir:~/Maildir                     ##这里修改下邮件存放路径    42 namespace inbox &#123;    57   inbox = yes    71 &#125;   143 first_valid_uid = 1000   243 mbox_write_locks = fcntl</code></pre><p>重启dovecot</p><pre><code class="bash">[root@lyucan ~]# systemctl restart dovecot.service</code></pre><p>创建一个新用户用于连接</p><pre><code class="bash">[root@lyucan ~]# useradd -s /sbin/nologin user1               ##用户不能登录系统[root@lyucan ~]# passwd user1Changing password for user user1.New password:BAD PASSWORD: The password is shorter than 7 charactersRetype new password:passwd: all authentication tokens updated successfully.</code></pre><h2 id="使用foxmail连接登录"><a href="#使用foxmail连接登录" class="headerlink" title="使用foxmail连接登录"></a>使用foxmail连接登录</h2><p><img src="/images/85d1f1ab-2cf4-4ad2-969d-57f6aeb723d0-Image.png" alt="85d1f1ab-2cf4-4ad2-969d-57f6aeb723d0-Image.png" title="85d1f1ab-2cf4-4ad2-969d-57f6aeb723d0-Image.png"></p><p>发送邮件<br><img src="/images/09335285-b95f-474d-a4b9-570f77b00d63-Image.png" alt="09335285-b95f-474d-a4b9-570f77b00d63-Image.png" title="09335285-b95f-474d-a4b9-570f77b00d63-Image.png"></p><p>接收邮件</p><pre><code class="bash">[root@lyucan new]# pwd/home/user1/Maildir/new[root@lyucan new]# lltotal 4-rw-------. 1 user1 user1 3989 Apr 14 03:19 1523647178.Vfd02I13c00cM35424.lyucan.com</code></pre><p>客户端收取后，服务器上的邮件文件就会消失<br><img src="/images/b7a4ecaa-491c-4779-b80e-14a2ef16e7cb-Image.png" alt="b7a4ecaa-491c-4779-b80e-14a2ef16e7cb-Image.png" title="b7a4ecaa-491c-4779-b80e-14a2ef16e7cb-Image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-super()函数</title>
      <link href="/2018/11/08/Python/Python-super()%E5%87%BD%E6%95%B0/"/>
      <url>/2018/11/08/Python/Python-super()%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="子类中调用父类中被重写了的方法（super-函数）"><a href="#子类中调用父类中被重写了的方法（super-函数）" class="headerlink" title="子类中调用父类中被重写了的方法（super()函数）"></a>子类中调用父类中被重写了的方法（super()函数）</h1><p>子类重写父类的构造函数，那么父类定义的构造函数就不能用了，假如父类中的构造函数定义了很多属性，而子类想要继承这些属性，由于重写了<code>__init__()</code>方法，不能使用父类中定义的构造函数，就需要自己再一个个的重写那些属性，就造成了很多重复代码，为了避免这种情况，python可以在子类中调用父类的方法，有以下三种方式：</p><h2 id="直接在子类中调用父类"><a href="#直接在子类中调用父类" class="headerlink" title="直接在子类中调用父类"></a>直接在子类中调用父类</h2><p>例如</p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    def __init__(self, name):        self.name = nameclass ChildClass(ParentClass):    def __init__(self, name, age):        ParentClass.__init__(self, name)           # 直接调用父类需要传入self，相当于直接调用函数，需要传入参数，父类有self，name两个形参，子类调用时需要传入两个实参        self.age = agec1 = ChildClass(&#39;tom&#39;, 23)print(c1.name, c1.age)</code></pre><pre><code class="python">[root@lyucan ~]# ./18.pytom 23</code></pre><h2 id="使用super-class-obj-ins-obj-函数调用父类"><a href="#使用super-class-obj-ins-obj-函数调用父类" class="headerlink" title="使用super(class_obj, ins_obj)函数调用父类"></a>使用super(class_obj, ins_obj)函数调用父类</h2><p>class_obj表示类对象，该参数表示：根据继承的MRO，从class_obj右边第一个类开始依次搜索方法。ins_obj表示实例对象， 一般为self。<br>调用<code>super()</code>函数时，方法的参数不需要写self，因为self在super()函数中传递。<br>例如：</p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    def __init__(self, name):        self.name = nameclass ChildClass(ParentClass):    def __init__(self, name, age):        super(ChildClass, self).__init__(name)                # 这行代码表示：根据self实例对象（即下面的c1）对应的类对象（即ChildClass）的MRO，从ChildClass（第一个参数）类对象的右边一个对象（即ParentClass）开始搜索__init__方法，将搜索到的方法绑定给self实例对象，这里的self指的是ChildClass类对象的实例对象，即下面的c1        self.age = agec1 = ChildClass(&#39;tom&#39;, 23)print(c1.name, c1.age)print(ChildClass.__mro__)</code></pre><pre><code class="python">[root@lyucan ~]# ./18.pytom 23(&lt;class &#39;__main__.ChildClass&#39;&gt;, &lt;class &#39;__main__.ParentClass&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><p>假如子类有两个父类，两个父类都有重写的方法，但是第一个父类不是我们想要的，第二个父类才是我们想要的，这个时候，python只要搜索到方法名相同的就进行调用，不会继续往后搜索，例如：</p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    def __init__(self, name):        self.name = nameclass ParentClass1(object):    def __init__(self, name, age):        self.name = name        self.age = ageclass ChildClass(ParentClass, ParentClass1):    def __init__(self, name, age, gender):        super().__init__(name, age)               # 想要调用的是父类ParentClass1中的__init__方法        self.gender = genderc1 = ChildClass(&#39;tom&#39;, 23, &#39;male&#39;)print(c1.name, c1.age, c1.gender)print(ChildClass.__mro__)</code></pre><pre><code class="python">[root@lyucan ~]# ./19.pyTraceback (most recent call last):  File &quot;./19.py&quot;, line 17, in &lt;module&gt;    c1 = ChildClass(&#39;tom&#39;, 23, &#39;male&#39;)  File &quot;./19.py&quot;, line 14, in __init__    super().__init__(name, age)TypeError: __init__() takes 2 positional arguments but 3 were given   # 但是这里找到的是ParentClass中的__init__方法，并直接进行调用</code></pre><p>当我们注释掉ParentClass中的<code>__init__</code>后，就会找到PraentClass1中的<code>__init__</code>方法：</p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):#    def __init__(self, name):#        self.name = name    passclass ParentClass1(object):    def __init__(self, name, age):        self.name = name        self.age = ageclass ChildClass(ParentClass, ParentClass1):    def __init__(self, name, age, gender):        super().__init__(name, age)        self.gender = genderc1 = ChildClass(&#39;tom&#39;, 23, &#39;male&#39;)print(c1.name, c1.age, c1.gender)print(ChildClass.__mro__)</code></pre><pre><code class="python">[root@lyucan ~]# ./19.pytom 23 male(&lt;class &#39;__main__.ChildClass&#39;&gt;, &lt;class &#39;__main__.ParentClass&#39;&gt;, &lt;class &#39;__main__.ParentClass1&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><p>如果需要跳过ParentClass，调用父类的<code>__init__</code>方法，可以做如下修改：</p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    def __init__(self, name):        self.name = nameclass ParentClass1(object):    def __init__(self, name, age):        self.name = name        self.age = ageclass ChildClass(ParentClass, ParentClass1):    def __init__(self, name, age, gender):        super(ParentClass, self).__init__(name, age)  # 定义了从ParentClass的右边第一个开始搜索，不包括ParentClass，因此，调用的就是ParentClass1中的__init__方法        self.gender = genderc1 = ChildClass(&#39;tom&#39;, 23, &#39;male&#39;)print(c1.name, c1.age, c1.gender)print(ChildClass.__mro__)</code></pre><pre><code class="python">[root@lyucan ~]# ./19.pytom 23 male(&lt;class &#39;__main__.ChildClass&#39;&gt;, &lt;class &#39;__main__.ParentClass&#39;&gt;, &lt;class &#39;__main__.ParentClass1&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><h2 id="使用super-函数调用父类"><a href="#使用super-函数调用父类" class="headerlink" title="使用super()函数调用父类"></a>使用<code>super()</code>函数调用父类</h2><p>不传参数，默认就是<code>super()</code>函数所在的类对象和<code>self</code>（即该类对象的实例对象），例如</p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    def __init__(self, name):        self.name = nameclass ChildClass(ParentClass):    def __init__(self, name, age):        super().__init__(name)               # 调用super()函数时，方法的参数不需要传递self        self.age = agec1 = ChildClass(&#39;tom&#39;, 23)print(c1.name, c1.age)</code></pre><pre><code class="python">[root@lyucan ~]# ./18.pytom 23</code></pre><p>直接调用和使用<code>super()</code>的优劣：</p><ul><li>直接调用简单直观，但是对于钻石继承，直接调用会调用两边父类的方法</li><li>使用super()方法可以有效的避免钻石继承带来的问题，但是理解起来有点不那么直观</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle redo log管理</title>
      <link href="/2018/11/07/Oracle/Oracle%20redo%20log%E7%AE%A1%E7%90%86/"/>
      <url>/2018/11/07/Oracle/Oracle%20redo%20log%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle-redo-log管理"><a href="#Oracle-redo-log管理" class="headerlink" title="Oracle redo log管理"></a>Oracle redo log管理</h1><h2 id="redo-log一般有4种状态，"><a href="#redo-log一般有4种状态，" class="headerlink" title="redo log一般有4种状态，"></a>redo log一般有4种状态，</h2><ul><li>ACTIVE：日志组记录的缓存里的脏数据已经写回磁盘后的状态</li><li>INACTIVE：日志组记录的缓存里的脏数据还未写回磁盘后的状态</li><li>CURRENT：当前正在使用的日志组</li><li>UNUSED：没有使用的，一般为新建的日志组才会出现这种状态</li></ul><h2 id="查看日志组"><a href="#查看日志组" class="headerlink" title="查看日志组"></a>查看日志组</h2><pre><code class="sql">select * from v$log;</code></pre><p><img src="/images/ef67170f-17e8-4c77-a2c8-b3bd917cfce3-Image.png" alt="ef67170f-17e8-4c77-a2c8-b3bd917cfce3-Image.png" title="ef67170f-17e8-4c77-a2c8-b3bd917cfce3-Image.png"></p><h2 id="查看日志文件"><a href="#查看日志文件" class="headerlink" title="查看日志文件"></a>查看日志文件</h2><pre><code class="sql">select * from v$logfile;</code></pre><p><img src="/images/b0778c0b-8897-4c55-8cdb-31ee8d551650-Image.png" alt="b0778c0b-8897-4c55-8cdb-31ee8d551650-Image.png" title="b0778c0b-8897-4c55-8cdb-31ee8d551650-Image.png"></p><pre><code class="sql">select a.group#,a.thread#,b.member,a.bytes/1024/1024 size_MB,a.members,a.archived,a.status from v$log a,v$logfile b where a.group#=b.group#;</code></pre><p><img src="/images/3b200d92-211d-47b8-8d17-b8e7d06ea474-Image.png" alt="3b200d92-211d-47b8-8d17-b8e7d06ea474-Image.png" title="3b200d92-211d-47b8-8d17-b8e7d06ea474-Image.png"></p><h2 id="列出日志切换的线程号和切换时间"><a href="#列出日志切换的线程号和切换时间" class="headerlink" title="列出日志切换的线程号和切换时间"></a>列出日志切换的线程号和切换时间</h2><pre><code class="sql">col 00 for &#39;999&#39;  col 01 for &#39;999&#39;  col 02 for &#39;999&#39;  col 03 for &#39;999&#39;  col 04 for &#39;999&#39;  col 05 for &#39;999&#39;  col 06 for &#39;999&#39;  col 07 for &#39;999&#39;  col 08 for &#39;999&#39;  col 09 for &#39;999&#39;  col 10 for &#39;999&#39;  col 11 for &#39;999&#39;  col 12 for &#39;999&#39;  col 13 for &#39;999&#39;  col 14 for &#39;999&#39;  col 15 for &#39;999&#39;  col 16 for &#39;999&#39;  col 17 for &#39;999&#39;  col 18 for &#39;999&#39;  col 19 for &#39;999&#39;  col 20 for &#39;999&#39;  col 21 for &#39;999&#39;  col 22 for &#39;999&#39;  col 23 for &#39;999&#39;  SELECT   thread#, a.ttime, SUM (c8) &quot;08&quot;, SUM (c9) &quot;09&quot;, SUM (c10) &quot;10&quot;,           SUM (c11) &quot;11&quot;, SUM (c12) &quot;12&quot;, SUM (c13) &quot;13&quot;, SUM (c14) &quot;14&quot;,           SUM (c15) &quot;15&quot;, SUM (c16) &quot;16&quot;, SUM (c17) &quot;17&quot;, SUM (c18) &quot;18&quot;,           SUM (c0) &quot;00&quot;, SUM (c1) &quot;01&quot;, SUM (c2) &quot;02&quot;, SUM (c3) &quot;03&quot;,           SUM (c4) &quot;04&quot;, SUM (c5) &quot;05&quot;, SUM (c6) &quot;06&quot;, SUM (c7) &quot;07&quot;,           SUM (c19) &quot;19&quot;, SUM (c20) &quot;20&quot;, SUM (c21) &quot;21&quot;, SUM (c22) &quot;22&quot;,           SUM (c23) &quot;23&quot;      FROM (SELECT thread#, ttime, DECODE (tthour, &#39;00&#39;, 1, 0) c0,                   DECODE (tthour, &#39;01&#39;, 1, 0) c1,                   DECODE (tthour, &#39;02&#39;, 1, 0) c2,                   DECODE (tthour, &#39;03&#39;, 1, 0) c3,                   DECODE (tthour, &#39;04&#39;, 1, 0) c4,                   DECODE (tthour, &#39;05&#39;, 1, 0) c5,                   DECODE (tthour, &#39;06&#39;, 1, 0) c6,                   DECODE (tthour, &#39;07&#39;, 1, 0) c7,                   DECODE (tthour, &#39;08&#39;, 1, 0) c8,                   DECODE (tthour, &#39;09&#39;, 1, 0) c9,                   DECODE (tthour, &#39;10&#39;, 1, 0) c10,                   DECODE (tthour, &#39;11&#39;, 1, 0) c11,                   DECODE (tthour, &#39;12&#39;, 1, 0) c12,                   DECODE (tthour, &#39;13&#39;, 1, 0) c13,                   DECODE (tthour, &#39;14&#39;, 1, 0) c14,                   DECODE (tthour, &#39;15&#39;, 1, 0) c15,                   DECODE (tthour, &#39;16&#39;, 1, 0) c16,                   DECODE (tthour, &#39;17&#39;, 1, 0) c17,                   DECODE (tthour, &#39;18&#39;, 1, 0) c18,                   DECODE (tthour, &#39;19&#39;, 1, 0) c19,                   DECODE (tthour, &#39;20&#39;, 1, 0) c20,                   DECODE (tthour, &#39;21&#39;, 1, 0) c21,                   DECODE (tthour, &#39;22&#39;, 1, 0) c22,                   DECODE (tthour, &#39;23&#39;, 1, 0) c23              FROM (SELECT thread#, TO_CHAR (first_time, &#39;yyyy-mm-dd&#39;) ttime,                           TO_CHAR (first_time, &#39;hh24&#39;) tthour                      FROM v$log_history                     WHERE (SYSDATE - first_time &lt; 30))) a  GROUP BY thread#, ttime  order by ttime;   THREAD# TTIME       08  09  10  11  12  13  14  15  16  17  18  00  01  02  03  04  05  06  07  19  20  21  22  23---------- ---------- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---         1 2018-04-29   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   4   0   0         1 2018-05-05   1   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0         1 2018-05-07   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0         1 2018-05-08   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   1   0         1 2018-05-11   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0         1 2018-05-12   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   1   0   0   0   0   0   0         1 2018-05-13   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   1   0   0   0   0   1   0         1 2018-05-14   0   0   0   0   0   0   0   0   0  11   2   0   0   0   0   0   0   0   0   5   1   8   0   0         1 2018-05-15   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   4   6   0   1   0         1 2018-05-16   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   2   0         1 2018-05-17   0   0   0   0   0   0   0   0   0   0   5   0   0   0   0   0   0   0   0   2   0   0   0   0         1 2018-05-21   0   0   3   2   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   012 rows selected</code></pre><h2 id="新增日志组"><a href="#新增日志组" class="headerlink" title="新增日志组"></a>新增日志组</h2><pre><code class="sql">sys@MYSQL_MA&gt; alter database add logfile group 4 (&#39;/oracle/11g/oradata/mysql_master_1003306/redo04a.log&#39;,&#39;/oracle/11g/oradata/mysql_master_1003306/redo04b.log&#39;) size 50M;Database altered.</code></pre><p><img src="/images/47d7457c-0cc7-4ecf-95a5-b272d2cb8d82-Image.png" alt="47d7457c-0cc7-4ecf-95a5-b272d2cb8d82-Image.png" title="47d7457c-0cc7-4ecf-95a5-b272d2cb8d82-Image.png"></p><h2 id="给已有的日志组添加成员"><a href="#给已有的日志组添加成员" class="headerlink" title="给已有的日志组添加成员"></a>给已有的日志组添加成员</h2><pre><code class="sql">sys@MYSQL_MA&gt; alter database add logfile member &#39;/oracle/11g/oradata/mysql_master_1003306/redo04c.log&#39; to group 4;Database altered.</code></pre><p><img src="/images/c7a4d513-1799-4b2b-9933-f20f9c95f08e-Image.png" alt="c7a4d513-1799-4b2b-9933-f20f9c95f08e-Image.png" title="c7a4d513-1799-4b2b-9933-f20f9c95f08e-Image.png"></p><h2 id="删除日志组成员，并不会删除物理数据文件"><a href="#删除日志组成员，并不会删除物理数据文件" class="headerlink" title="删除日志组成员，并不会删除物理数据文件"></a>删除日志组成员，并不会删除物理数据文件</h2><pre><code class="sql">sys@MYSQL_MA&gt; alter database drop logfile member &#39;/oracle/11g/oradata/mysql_master_1003306/redo04a.log&#39;;Database altered.</code></pre><p><img src="/images/a440d868-8f7e-49a6-8711-2beea39b3078-Image.png" alt="a440d868-8f7e-49a6-8711-2beea39b3078-Image.png" title="a440d868-8f7e-49a6-8711-2beea39b3078-Image.png"></p><h2 id="删除日志组，并不会删除物理数据文件"><a href="#删除日志组，并不会删除物理数据文件" class="headerlink" title="删除日志组，并不会删除物理数据文件"></a>删除日志组，并不会删除物理数据文件</h2><pre><code class="sql">sys@MYSQL_MA&gt; alter database drop logfile group 4;Database altered.</code></pre><p><img src="/images/dd792f1b-624c-4e55-a342-e27f9a0fe4eb-Image.png" alt="dd792f1b-624c-4e55-a342-e27f9a0fe4eb-Image.png" title="dd792f1b-624c-4e55-a342-e27f9a0fe4eb-Image.png"></p><h2 id="redo-log恢复"><a href="#redo-log恢复" class="headerlink" title="redo log恢复"></a>redo log恢复</h2><p>如果inactive的日志组成员丢失，不会丢失数据，数据库没有关闭的情况下，只需要把该日志组删掉，再新建日志组即可，如果数据库关闭了，数据库是打不开的，使用以下方法恢复：</p><pre><code class="sql">sys@MYSQL_MA&gt; ! rm -rf /oracle/11g/oradata/mysql_master_1003306/redo01.logsys@MYSQL_MA&gt;sys@MYSQL_MA&gt; shutdown immediateDatabase closed.Database dismounted.ORACLE instance shut down.sys@MYSQL_MA&gt; startup;ORACLE instance started.Total System Global Area  409194496 bytesFixed Size          2213856 bytesVariable Size          335546400 bytesDatabase Buffers        67108864 bytesRedo Buffers             4325376 bytesDatabase mounted.ORA-03113: end-of-file on communication channelProcess ID: 6188Session ID: 1 Serial number: 5</code></pre><p>alert 日志如下</p><pre><code class="sql">Errors in file /oracle/11g/diag/rdbms/mysql_ma/orcl/trace/orcl_lgwr_6154.trc:ORA-00313: open failed for members of log group 1 of thread 1ORA-00312: online log 1 thread 1: &#39;/oracle/11g/oradata/mysql_master_1003306/redo01.log&#39;ORA-27037: unable to obtain file statusLinux-x86_64 Error: 2: No such file or directoryAdditional information: 3Errors in file /oracle/11g/diag/rdbms/mysql_ma/orcl/trace/orcl_lgwr_6154.trc:ORA-00313: open failed for members of log group 1 of thread 1ORA-00312: online log 1 thread 1: &#39;/oracle/11g/oradata/mysql_master_1003306/redo01.log&#39;ORA-27037: unable to obtain file statusLinux-x86_64 Error: 2: No such file or directoryAdditional information: 3Errors in file /oracle/11g/diag/rdbms/mysql_ma/orcl/trace/orcl_ora_6188.trc:ORA-00313: open failed for members of log group 1 of threadORA-00312: online log 1 thread 1: &#39;/oracle/11g/oradata/mysql_master_1003306/redo01.log&#39;USER (ospid: 6188): terminating the instance due to error 313Instance terminated by USER, pid = 6188</code></pre><p>恢复redolog</p><pre><code class="sql">##启动到mount状态idle&gt; start mount;SP2-0310: unable to open file &quot;mount.sql&quot;idle&gt; startup mount;ORACLE instance started.Total System Global Area  409194496 bytesFixed Size          2213856 bytesVariable Size          335546400 bytesDatabase Buffers        67108864 bytesRedo Buffers             4325376 bytesDatabase mounted.idle&gt;idle&gt; select group#,thread#,sequence#,bytes/1024/1024 size_MB,members,archived,status,first_change#,to_char(FIRST_TIME,&#39;yyyy-mm-dd hh24:mi:ss&#39;) first_time from v$log;GROUP# THREAD# SEQUENCE#    SIZE_MB MEMBERS ARC STATUS           FIRST_CHANGE# FIRST_TIME------ ------- --------- ---------- ------- --- ---------------- ------------- -------------------     1          1           12    50    1 YES INACTIVE            1580033 2018-05-21 19:42:52     3          1           10    50    1 YES INACTIVE            1580027 2018-05-21 19:42:47     2          1           13    50    1 NO     CURRENT           1580036 2018-05-21 19:42:53##重建group 1idle&gt; alter database clear logfile group 1;Database altered.idle&gt; alter database open;Database altered.idle&gt; !ls -l /oracle/11g/oradata/mysql_master_1003306/redo01.log-rw-r-----. 1 oracle oinstall 52429312 May 21 20:06 /oracle/11g/oradata/mysql_master_1003306/redo01.log</code></pre><p>如果active日志组成员丢失，如果数据库关闭了，则会丢失数据，需要进行不完全恢复。在数据库尚未关闭的情况下，需要将active日志组转化为inactive，再按照inactive日志组丢失的方法恢复<br>使用alter system checkpoint可以将active日志组转化为inactive</p><p>current日志组成员丢失，在数据库尚未关闭的前提下，需要切换日志将current转化为active状态，再通过检查点转化为inactive状态，最后按照inactive日志组丢失的情况进行恢复。如果数据库已经关闭了，则需要进行不完全恢复</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle表空间管理</title>
      <link href="/2018/11/05/Oracle/oracle%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"/>
      <url>/2018/11/05/Oracle/oracle%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="oracle表空间管理"><a href="#oracle表空间管理" class="headerlink" title="oracle表空间管理"></a>oracle表空间管理</h1><h2 id="表空间类型"><a href="#表空间类型" class="headerlink" title="表空间类型"></a>表空间类型</h2><p>系统表空间</p><ul><li>数据库创建的时候创建</li><li>存在数据字典</li><li>存在系统回滚段<br>非系统表空间</li><li>分隔不同的段</li><li>对用户对象限制使用空间</li></ul><h2 id="创建表空间基本语法"><a href="#创建表空间基本语法" class="headerlink" title="创建表空间基本语法"></a>创建表空间基本语法</h2><pre><code class="sql">CREATE [UNDO]  TABLESPACE tablespace_name          [DATAFILE datefile_spec1 [,datefile_spec2] ......   [&#123;MININUM EXTENT integer [k|m]   |BLOCKSIZE integer [k]   |logging clause | FORCE LOGGING   |DEFAULT &#123;data_segment_compression&#125; storage_clause   |[online|offline]   |[PERMANENT|TEMPORARY]   |extent_manager_clause   |segment_manager_clause&#125;]</code></pre><ul><li>1、undo<br>说明系统将创建一个回滚表空间。<br>在9i中数据库管理员可以不必管理回滚段，只有建立了undo表空间，系统就会自动管理回滚段的分配，回收的工作。<br>当然,也可以创建一般的表空间,在上面创建回滚段.不过对于用户来说,系统管理比自己管理要好很多.<br>如果需要自己管理,请参见回滚段管理的命令详解.<br>当没有为系统指定回滚表空间时,系统将使用system系统回滚段来进行事务管理。   </li><li>2、tablespace_name<br>指出表空间的名称。   </li><li>3、datafile  datefile_spec1<br>指出表空间包含什么空间文件。<br>datefile_spec1是形如:[ ‘filename’ ] [SIZE integer [ K | M ]] [REUSE] [autoextend_clause]<br>[autoextend_clause]是形如：AUTOEXTEND { OFF | ON [ NEXT integer [ K | M ] ] [maxsize_clause] }<br>其中filename是数据文件的路径名，可以是相对路径，也可以是绝对路径。<br>size是文件的大小,<br>REUSE表示文件是否被重用.<br>AUTOEXTEND表明是否自动扩展.<br>OFF | ON  表示自动扩展是否被关闭.<br>NEXT 表示数据文件满了以后,扩展的大小.<br>maxsize_clause表示数据文件的最大大小.形如MAXSIZE { UNLIMITED | integer [ K | M ] }.<br>UNLIMITED 表示无限的表空间.<br>integer是数据文件的最大大小.<br> DATAFILE  ‘D:”oracle”oradata”IMAGEDATA01.dbf’  SIZE 2000M,<br>           ‘D:”oracle”oradata”IMAGEDATA02.dbf’  SIZE 2000M   </li><li>4、MININUM EXTENT integer [k|m]<br>指出在表空间中范围的最小值。这个参数可以减小空间碎片，保证在表空间的范围是这个数值的整数倍。   </li><li>5、BLOCKSIZE integer [k]<br>这个参数可以设定一个不标准的块的大小。如果要设置这个参数，必须设置db_block_size,<br>至少一个db_nk_block_size,并且声明的integer的值必须等于db_nk_block_size.<br>注意：在临时表空间不能设置这个参数。   </li><li>6、logging clause<br>这个子句声明这个表空间上所有的用户对象的日志属性（缺省是logging），<br>包括表，索引，分区，物化视图，物化视图上的索引，分区。   </li><li>7、FORCE LOGGING<br>使用这个子句指出表空间进入强制日志模式。此时，系统将记录表空间上对象的所有改变，除了临时段的改变。<br>这个参数高于对象的nologging选项。<br>注意：设置这个参数数据库不行open并且出于读写模式。而且，在临时表空间和回滚表空间中不能使用这个选项。   </li><li>8、DEFAULT storage_clause<br>声明缺省的存储子句。   </li><li>9、online|offline<br>改变表空间的状态。online使表空间创建后立即有效.这是缺省值.<br>offline使表空间创建后无效.这个值，可以从dba_tablespace中得到。   </li><li>10、PERMANENT|TEMPORARY<br>指出表空间的属性，是永久表空间还是临时表空间。<br>永久表空间存放的是永久对象，临时表空间存放的是session生命期中存在的临时对象。<br>这个参数生成的临时表空间创建后一直都是字典管理，不能使用extent management local选项。<br>如果要创建本地管理表空间，必须使用create temporary tablespace<br>注意，声明了这个参数后，不能声明block size   </li><li>11、extent_management_clause<br>这是最重要的子句，说明了表空间如何管理范围。一旦你声明了这个子句，只能通过移植的方式改变这些参数。<br>如果希望表空间本地管理的话，声明local选项。本地管理表空间是通过位图管理的。<br>autoallocate说明表空间自动分配范围，用户不能指定范围的大小。只有9.0以上的版本具有这个功能。<br>uniform说明表空间的范围的固定大小，缺省是1m。<br>不能将本地管理的数据库的system表空间设置成字典管理。<br>oracle公司推荐使用本地管理表空间。<br>如果没有设置extent_management_clause，oracle会给他设置一个默认值。<br>如果初始化参数compatible小于9.0.0,那么系统创建字典管理表空间。<br>如果大于9.0.0,那么按照如下设置：<br>如果没有指定 default  storage_clause,oracle创建一个自动分配的本地管理表空间。<br>否则，<br>如果指定了mininum extent,那么oracle判断mininum extent 、initial、next是否相等,以及pctincrease是否&#x3D;0.<br>如果满足以上的条件，oracle创建一个本地管理表空间，extent size是initial.<br>如果不满足以上条件，那么oracle将创建一个自动分配的本地管理表空间。<br>如果没有指定mininum extent。initial、那么oracle判断next是否相等,以及pctincrease是否&#x3D;0。<br>如果满足oracle创建一个本地管理表空间并指定uniform。否则oracle将创建一个自动分配的本地管理表空间。<br>注意：本地管理表空间只能存储永久对象。<br>如果你声明了local,将不能声明 default  storage_clause,mininum extent、temporary.<br>EXTENT MANAGEMENT LOCAL   </li><li>12、segment_management_clause<br>段空间管理的方式，自动或者手动:<br>SEGMENT SPACE MANAGEMENT {AUTO|MANUAL}</li></ul><h2 id="查看表空间"><a href="#查看表空间" class="headerlink" title="查看表空间"></a>查看表空间</h2><pre><code class="sql">SQL&gt; select tablespace_name,file_name,bytes from dba_data_files;</code></pre><p><img src="/images/b50e6144-3b17-449d-9731-66d40fb6a08c-Image.png" alt="b50e6144-3b17-449d-9731-66d40fb6a08c-Image.png" title="b50e6144-3b17-449d-9731-66d40fb6a08c-Image.png"></p><h2 id="大文件表空间"><a href="#大文件表空间" class="headerlink" title="大文件表空间"></a>大文件表空间</h2><p>大文件表空间(bigfile tablespaces)</p><ul><li>Oracle Database允许你创建大文件表空间,大文件表空间由单个文件组成</li><li>最大可以包含4G(2^32)个blocks.</li></ul><p>大文件表空间使得Oracle获得如下收益:</p><ul><li>显著的增强了Oracle数据库的存储容量</li><li>检查点的性能提升</li><li>对于8k的blocks,最大数据文件可以达到32T；对于32K的blocks，最大数据文件可达128T</li><li>缩减了超大型数据库的数据文件的数量</li><li>简化了管理</li></ul><h2 id="创建大文件表空间"><a href="#创建大文件表空间" class="headerlink" title="创建大文件表空间"></a>创建大文件表空间</h2><pre><code class="sql">SQL&gt; create bigfile tablespace bigtbs datafile &#39;/oracle/11g/oradata/oracle/bigtbs.dbf&#39; size 1G;Tablespace created.</code></pre><p>对于大文件 表空间，只能为LMT（本地管理表空间）和ASSM（自动段空间管理）管理</p><pre><code class="sql">SQL&gt; select TABLESPACE_NAME,EXTENT_MANAGEMENT,SEGMENT_SPACE_MANAGEMENT from dba_tablespaces where tablespace_name=&#39;BIGTBS&#39;;  2 TABLESPACE_NAME             EXTENT_MAN SEGMEN--------------------------- ---------- ------BIGTBS                      LOCAL      AUTO</code></pre><p>对于undo、temp、system表空间可以使LMT+MANUAL</p><p>oracle默认采用小文件表空间，可以使用以下sql查看</p><pre><code class="sql">SQL&gt; SELECT PROPERTY_VALUE FROM DATABASE_PROPERTIES WHERE PROPERTY_NAME = &#39;DEFAULT_TBS_TYPE&#39;;PROPERTY_VALUE--------------------------------------------------------------------------------SMALLFILE</code></pre><p>更改默认表空间方式</p><pre><code class="sql">system@MYSQL_MA&gt; ALTER DATABASE SET DEFAULT BIGFILE TABLESPACE;Database altered.</code></pre><h2 id="表空间的空间管理"><a href="#表空间的空间管理" class="headerlink" title="表空间的空间管理"></a>表空间的空间管理</h2><p>在Oracle8i的版本中，Oracle推出了一种全新的表空间管理方式：本地化管理的表空间。所谓本地化管理，就是指Oracle不再利用数据字典表来记录Oracle表空间里面的区的使用状况，而是在每个表空间的数据文件的头部加入了一个位图区，在其中记录每个区的使用状况。每当一个区被使用，或者被释放以供重新使用时，Oracle都会更新数据文件头部的这个记录，反映这个变化。</p><p>   本地化管理的表空间的创建过程：<br>   语法：</p><pre><code class="sql">CREATE TABLESPACE 表空间名字 DATAFILE &#39;数据文件详细信息&#39; [EXTENT MANAGEMENT &#123; LOCAL &#123;AUTOALLOCATE | UNIFORM [SIZE INTETER [K|M]]&#125;&#125;]</code></pre><p> 关键字EXTENT MANAGEMENT LOCAL 指定这是一个本地化管理的表空间。对于系统表空间，只能在创建数据库的时候指定EXTENT MANGEMENT LOCAL，因为它是数据库创建时建立的第一个表空间。   在8i中，字典管理还是默认的管理方式，当选择了LOCAL关键字，即表明这是一个本地管理的表空间。当然还可以继续选择更细的管理方式：是 AUTOALLOCATE 还是 UNIFORM。若为AUTOALLOCATE，则表明让Oracle来决定区块的使用办法；若选择了UNIFORM，则还可以详细指定每个区块的大小，若不加指定，则为每个区使用1M大小。   Oracle之所以推出了这种新的表空间管理方法，让我们来看一下这种表空间组织方法的优点：   </p><ol><li>本地化管理的表空间避免了递归的空间管理操作。而这种情况在数据字典管理的表空间是经常出现的，当表空间里的区的使用状况发生改变时，数据字典的表的信息发生改变，从而同时也使用了在系统表空间里的回滚段。    </li><li>本地化管理的表空间避免了在数据字典相应表里面写入空闲空间、已使用空间的信息，从而减少了数据字典表的竞争，提高了空间管理的并发性    </li><li>区的本地化管理自动跟踪表空间里的空闲块，减少了手工合并自由空间的需要。    </li><li>表空间里的区的大小可以选择由Oracle系统来决定，或者由数据库管理员指定一个统一的大小，避免了字典表空间一直头疼的碎片问题。    </li><li>从由数据字典来管理空闲块改为由数据文件的头部记录来管理空闲块，这样避免产生回滚信息，不再使用系统表空间里的回滚段。因为由数据字典来管理的话，它会把相关信息记在数据字典的表里，从而产生回滚信息。   由于这种表空间的以上特性，所以它支持在一个表空间里边进行更多的并发操作，并减少了对数据字典的依赖。</li></ol><h2 id="LMT（本地表空间管理）"><a href="#LMT（本地表空间管理）" class="headerlink" title="LMT（本地表空间管理）"></a>LMT（本地表空间管理）</h2><p>本地管理表空间:</p><ul><li>在表空间里面管理自由的范围</li><li>Bitmap用于记录自由的范围</li><li>每位对应一个block或者一组block</li><li>位的值表明空闲或者被使用</li><li>减少在数据字典中的竞争</li><li>当空间分配或释放时不产生回滚信息</li><li>不需要表空间空闲空间的合并</li></ul><p>示例：</p><pre><code class="sql">SQL&gt; CREATE TABLESPACE tbsDATAFILE &#39;/oracle/11g/oradata/oracle/tbs01.dbf&#39; SIZE 500MEXTENT MANAGEMENT LOCAL UNIFORM SIZE 128K;            ##指定每个区的大小为128K，也可以使用autoallocateTablespace created.</code></pre><blockquote><p>DMT（数据字典表空间管理，已经被弃用）</p></blockquote><h2 id="回滚表空间"><a href="#回滚表空间" class="headerlink" title="回滚表空间"></a>回滚表空间</h2><ul><li>用于排序操作</li><li>可以被多个用户共享</li><li>不能存在任何永久的对象</li></ul><pre><code class="sql">SQL&gt; CREATE TEMPORARY TABLESPACE tempTEMPFILE &#39;/oracle/11g/oradata/oracle/temp01.dbf&#39; SIZE 20MEXTENT MANAGEMENT LOCAL UNIFORM SIZE 4M;</code></pre><p>系统的默认临时表空间<br>限制：</p><ul><li>只能在创建一个新的默认临时表空间后原来的才可以删除</li><li>不能离线</li><li>不能修改为一个永久的表空间</li></ul><h2 id="只读表空间"><a href="#只读表空间" class="headerlink" title="只读表空间"></a>只读表空间</h2><p>设置表空间为只读状态，将会有以下影响：</p><ul><li>引起一个检查点</li><li>数据只能被读取</li><li>表空间中的对象能被删除</li></ul><p>使用下面sql把表空间设置为只读&#x2F;读写状态</p><pre><code class="sql">SQL&gt; ALTER TABLESPACE tbs READ ONLY;Tablespace altered.SQL&gt; ALTER TABLESPACE tbs READ WRITE;Tablespace altered.</code></pre><h2 id="离线-在线表空间"><a href="#离线-在线表空间" class="headerlink" title="离线&#x2F;在线表空间"></a>离线&#x2F;在线表空间</h2><p>若表空间离线，将会有以下影响：</p><ul><li>表空间中的所有数据都不能被访问</li><li>有些表空间是不能被离线的:<ul><li>系统表空间</li><li>存在激活的回滚段的表空间</li><li>默认的临时表空间</li></ul></li></ul><p>使用以下sql把表空间设置为离线&#x2F;在线状态</p><pre><code class="sql">SQL&gt; ALTER TABLESPACE tbs OFFLINE;Tablespace altered.SQL&gt; ALTER TABLESPACE tbs ONLINE;Tablespace altered.</code></pre><h2 id="修改表空间大小"><a href="#修改表空间大小" class="headerlink" title="修改表空间大小"></a>修改表空间大小</h2><p>1）在创建表空间的时候指定自动增长</p><pre><code class="sql">SQL&gt; CREATE TABLESPACE tbsDATAFILE &#39;/u01/oradata/tbs01.dbf&#39; SIZE 200MAUTOEXTEND ON NEXT 10M MAXSIZE 500M;</code></pre><p>2）修改表空间数据文件的大小</p><ul><li>手工使用ALTER DATABASE增大或减小一个数据文件的大小</li><li>增大数据文件的空间不用增加更多的数据文件</li><li>手工改变数据文件的大小是回收未用的空间<pre><code class="sql">SQL&gt; ALTER DATABASEDATAFILE &#39;/u03/oradata/tbs02.dbf&#39;RESIZE 200M;</code></pre></li></ul><p>3）增加表空间的数据文件</p><ul><li>增大表空间大小通过增加数据文件</li><li>ADD DATAFILE语句用于增加数据文件<pre><code class="sql">SQL&gt; ALTER TABLESPACE tbsADD DATAFILE &#39;/u01/oradata/tbs03.dbf&#39;SIZE 200M;</code></pre></li></ul><h2 id="移动表空间数据文件"><a href="#移动表空间数据文件" class="headerlink" title="移动表空间数据文件"></a>移动表空间数据文件</h2><p>1）ALTER DATABASE</p><ul><li>数据库必须(需要)在MOUNT状态</li><li>目标数据文件必须存在<pre><code class="sql">SQL&gt; ALTER DATABASE RENAMEFILE &#39;/u01/oradata/tbs01.dbf&#39;TO &#39;/u03/oradata/tbs01.dbf&#39;;</code></pre></li></ul><p>2）ALTER TABLESPACE</p><ul><li>表空间必须离线</li><li>目标数据文件必须存在<pre><code class="sql">SQL&gt; ALTER TABLESPACE tbs RENAMEDATAFILE &#39;/u01/oradata/tbs01.dbf&#39;TO &#39;/u02/oradata/tbs01.dbf&#39;;</code></pre></li></ul><h2 id="重命名表空间名"><a href="#重命名表空间名" class="headerlink" title="重命名表空间名"></a>重命名表空间名</h2><p>Oracle允许使用rename命令直接修改表空间名称，数据文件名称不会随之改变。</p><pre><code class="sql">SQL&gt; alter tablespace TBS rename to TBS_NEW;Tablespace altered.</code></pre><h2 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h2><ul><li>下列情况不能删除表空间:<ul><li>系统表空间</li><li>有激活段的表空间</li></ul></li><li>INCLUDING CONTENTS将删除段</li><li>INCLUDING CONTENTS AND DATAFILES将删除数据文件</li><li>CASCADE CONSTRAINTS将删除所有一致性的限制</li></ul><pre><code class="sql">SQL&gt; DROP TABLESPACE tbs_newINCLUDING CONTENTS AND DATAFILES;Tablespace dropped.</code></pre><pre><code class="sql">--删除空的表空间，但是不包含物理文件drop tablespace tablespace_name;--删除非空表空间，但是不包含物理文件drop tablespace tablespace_name including contents;--删除空表空间，包含物理文件drop tablespace tablespace_name including datafiles;--删除非空表空间，包含物理文件drop tablespace tablespace_name including contents and datafiles;--如果其他表空间中的表有外键等约束关联到了本表空间中的表的字段，就要加上CASCADE CONSTRAINTSdrop tablespace tablespace_name including contents and datafiles CASCADE CONSTRAINTS;</code></pre><h2 id="获取表空间相关信息"><a href="#获取表空间相关信息" class="headerlink" title="获取表空间相关信息"></a>获取表空间相关信息</h2><p>获取表空间和数据文件的信息:<br>表空间信息:</p><ul><li>DBA_TABLESPACES</li><li>V$TABLESPACE</li></ul><p>数据文件信息:</p><ul><li>DBA_DATA_FILES</li><li>V$DATAFILE</li></ul><p>临时数据文件信息:</p><ul><li>DBA_TEMP_FILES</li><li>V$TEMPFILE</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-获取对象信息dir()、__dict__</title>
      <link href="/2018/11/04/Python/Python-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AFdir()%E3%80%81__dict__/"/>
      <url>/2018/11/04/Python/Python-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AFdir()%E3%80%81__dict__/</url>
      
        <content type="html"><![CDATA[<h1 id="获取对象信息——dir-、-dict"><a href="#获取对象信息——dir-、-dict" class="headerlink" title="获取对象信息——dir()、__dict__"></a>获取对象信息——dir()、<code>__dict__</code></h1><p>对于指定的类对象或实例对象，可以调用内置函数dir()获取其所有可以访问的属性和方法（包括从父类中继承的属性和方法）的列表。<br>类对象与实例对象的结果是有区别的，类对象的结果中不包含实例属性。</p><pre><code class="python">&gt;&gt;&gt; class MyClass(object):...     ca = &#39;ca&#39;...     def __init__(self):...         self.ia = &#39;ia&#39;...     def im(self):...         pass...     @classmethod...     def cm(cls):...         pass...     @staticmethod...     def sm():...         pass...&gt;&gt;&gt; dir(MyClass)[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;ca&#39;, &#39;cm&#39;, &#39;im&#39;, &#39;sm&#39;]             # 类对象中不包含实例属性 &gt;&gt;&gt; dir(MyClass())           [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;ca&#39;, &#39;cm&#39;, &#39;ia&#39;, &#39;im&#39;, &#39;sm&#39;]       # 实例对象中包含实例属性</code></pre><p>获取对象信息——特殊属性<code>__dict__</code></p><ul><li>对于指定的类对象或实例对象，我们可以访问特殊属性<code>__dict__</code>获得该类对象或实例对象所绑定的所有属性和方法的字典，其中字典中的键为属性名或方法名。</li><li>子类有子类的<code>__dict__</code>，父类有父类的<code>__dict__</code>，两者是独立的，不会随着继承而继承</li></ul><p>类对象的<code>__dict__</code>存储所有实例共享的变量和函数(类属性，方法等)，类的<code>__dict__</code>并不包含其父类的属性。<br>实例对象的<code>__dict__</code>仅存储与该实例相关的实例属性。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    ca = &#39;ca&#39;    def __init__(self):        self.ia = &#39;ia&#39;    def im(self):        pass    @classmethod    def cm(cls):        pass    @staticmethod    def sm():        passprint(MyClass.__dict__)print(MyClass().__dict__)class ChildClass(MyClass):    ca1 = &#39;ca1&#39;    def __init__(self):        self.ia1 = &#39;ia1&#39;print(ChildClass.__dict__)print(ChildClass().__dict__)</code></pre><pre><code class="python">[root@lyucan ~]# ./24.py&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;ca&#39;: &#39;ca&#39;, &#39;__init__&#39;: &lt;function MyClass.__init__ at 0x7f91a5921bf8&gt;, &#39;im&#39;: &lt;function MyClass.im at 0x7f91a5921c80&gt;, &#39;cm&#39;: &lt;classmethod object at 0x7f91a59ba8d0&gt;, &#39;sm&#39;: &lt;staticmethod object at 0x7f91a59ba908&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;MyClass&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;MyClass&#39; objects&gt;, &#39;__doc__&#39;: None&#125;    # 类对象的__dict__&#123;&#39;ia&#39;: &#39;ia&#39;&#125;             # 实例对象的__dict__&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;ca1&#39;: &#39;ca1&#39;, &#39;__init__&#39;: &lt;function ChildClass.__init__ at 0x7f91a5921e18&gt;, &#39;__doc__&#39;: None&#125;    # 类对象的__dict__&#123;&#39;ia1&#39;: &#39;ia1&#39;&#125;           # 实例对象的__dict__</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle修改数据库监听的端口号</title>
      <link href="/2018/11/02/Oracle/Oracle%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7/"/>
      <url>/2018/11/02/Oracle/Oracle%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle修改数据库监听的端口号"><a href="#Oracle修改数据库监听的端口号" class="headerlink" title="Oracle修改数据库监听的端口号"></a>Oracle修改数据库监听的端口号</h1><h2 id="先停止监听"><a href="#先停止监听" class="headerlink" title="先停止监听"></a>先停止监听</h2><pre><code class="bash">[oracle@oracle admin]$ lsnrctl stopLSNRCTL for Linux: Version 11.2.0.1.0 - Production on 06-MAY-2018 16:09:51Copyright (c) 1991, 2009, Oracle.  All rights reserved.Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1521)))The command completed successfully</code></pre><h2 id="修改listener-ora配置文件，将端口号1521修改为1526"><a href="#修改listener-ora配置文件，将端口号1521修改为1526" class="headerlink" title="修改listener.ora配置文件，将端口号1521修改为1526"></a>修改listener.ora配置文件，将端口号1521修改为1526</h2><pre><code class="bash">[oracle@oracle admin]$ cat listener.ora# listener.ora Network Configuration File: /oracle/11g/product/11.2.0/dbhome_1/network/admin/listener.ora# Generated by Oracle configuration tools.LISTENER =  (DESCRIPTION_LIST =    (DESCRIPTION =      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1526))    )  )ADR_BASE_LISTENER = /oracle/11gSID_LIST_LISTENER =    (SID_LIST =        (SID_DESC =            (GLOBAL_DBNAME = orcl1)            (ORACLE_HOME = /oracle/11g/product/11.2.0/dbhome_1)            (SID_NAME =orcl)        )    )</code></pre><h2 id="登录并修改local-listener参数"><a href="#登录并修改local-listener参数" class="headerlink" title="登录并修改local_listener参数"></a>登录并修改local_listener参数</h2><pre><code class="bash">[oracle@oracle admin]$ sqlplus / as sysdbaSQL&gt; show parameter local_listener;             ##查出来应该是空值NAME                                 TYPE        VALUE------------------------------------ ----------- ------------------------------local_listener                       string##修改参数SQL&gt; alter system set local_listener=&quot;(address = (protocol = tcp)(host = 10.10.10.101)(port = 1526))&quot;;System altered.SQL&gt; show parameter local_listener;NAME                                 TYPE        VALUE------------------------------------ ----------- ------------------------------local_listener                       string      (address = (protocol = tcp)(ho                                                 st = 10.10.10.101)(port = 1526                                                 ))</code></pre><h2 id="启动监听，查看状态"><a href="#启动监听，查看状态" class="headerlink" title="启动监听，查看状态"></a>启动监听，查看状态</h2><pre><code class="bash">[oracle@oracle admin]$ lsnrctl start[oracle@oracle admin]$ lsnrctl statusLSNRCTL for Linux: Version 11.2.0.1.0 - Production on 06-MAY-2018 16:17:17Copyright (c) 1991, 2009, Oracle.  All rights reserved.Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1521)))STATUS of the LISTENER------------------------Alias                     LISTENERVersion                   TNSLSNR for Linux: Version 11.2.0.1.0 - ProductionStart Date                06-MAY-2018 16:16:21Uptime                    0 days 0 hr. 0 min. 56 secTrace Level               offSecurity                  ON: Local OS AuthenticationSNMP                      OFFListener Parameter File   /oracle/11g/product/11.2.0/dbhome_1/network/admin/listener.oraListener Log File         /oracle/11g/diag/tnslsnr/oracle/listener/alert/log.xmlListening Endpoints Summary...  (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1521)))  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=10.10.10.101)(PORT=1526)))       ##修改成了1526Services Summary...Service &quot;oracle.orcl&quot; has 1 instance(s).  Instance &quot;orcl&quot;, status READY, has 1 handler(s) for this service...Service &quot;orcl1&quot; has 1 instance(s).  Instance &quot;orcl&quot;, status UNKNOWN, has 1 handler(s) for this service...Service &quot;orclXDB.orcl&quot; has 1 instance(s).  Instance &quot;orcl&quot;, status READY, has 1 handler(s) for this service...The command completed successfully</code></pre><h2 id="检查端口"><a href="#检查端口" class="headerlink" title="检查端口"></a>检查端口</h2><pre><code class="bash">[oracle@oracle admin]$ netstat -tlunp |grep 1521                            ##1521不存在了(Not all processes could be identified, non-owned process infowill not be shown, you would have to be root to see it all.)[oracle@oracle admin]$[oracle@oracle admin]$ netstat -tlunp |grep 1526                            ##改到1526上了(Not all processes could be identified, non-owned process infowill not be shown, you would have to be root to see it all.)tcp        0      0 10.10.10.101:1526       0.0.0.0:*               LISTEN      21080/tnslsnr      </code></pre><h2 id="远程连接，注意方通1526端口的防火墙限制"><a href="#远程连接，注意方通1526端口的防火墙限制" class="headerlink" title="远程连接，注意方通1526端口的防火墙限制"></a>远程连接，注意方通1526端口的防火墙限制</h2><pre><code class="bash">[oracle@mysql-master-1003306 admin]$ cat tnsnames.oraorcl1 =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1526))             ##这里端口写1526    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = orcl1)    )  )[oracle@mysql-master-1003306 admin]$ tnsping orcl1TNS Ping Utility for Linux: Version 11.2.0.1.0 - Production on 07-MAY-2018 02:13:36Copyright (c) 1997, 2009, Oracle.  All rights reserved.Used parameter files:/oracle/11g/product/11.2.0/dbhome_1/network/admin/sqlnet.oraUsed TNSNAMES adapter to resolve the aliasAttempting to contact (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1526)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl1)))OK (10 msec)                                    ##tnsping 结果为OK[oracle@mysql-master-1003306 admin]$ sqlplus  sys/Oracle_1@orcl1 as sysdba              ##连接成功SQL*Plus: Release 11.2.0.1.0 Production on Mon May 7 02:15:02 2018Copyright (c) 1982, 2009, Oracle.  All rights reserved.Connected to:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options   </code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储引擎类型</title>
      <link href="/2018/10/22/Mysql/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/10/22/Mysql/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL存储引擎类型"><a href="#MySQL存储引擎类型" class="headerlink" title="MySQL存储引擎类型"></a>MySQL存储引擎类型</h1><h2 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h2><p>1、支持事务，面向在线事务处理（OLTP）方面的应用，支持行锁（锁粒度），支持外键；<br>2、通过多版本并发控制MVCC来获得高并发性，并且实现了sql标准的4种隔离级别（默认为repeatable read 可重复读）；<br>3、提供插入缓冲（insert buffer），二次写（double write），自适应哈斯索引（ahi），预读（read ahead）；<br>4,、对表中数据的存储，innodb采用clustered。每张表的存储按逐渐的顺序存放，如果没有显示的为飚定义主键，innodb会为每一张行生成一个6字节的rowid，作为主键</p><p>.ibd innodb数据文件，索引也存在里面，既缓存数据，也缓存索引<br>.frm 表结构文件</p><h2 id="myisam"><a href="#myisam" class="headerlink" title="myisam"></a>myisam</h2><p>1、不支持事务，表锁（锁粒度）、全文索引，对OLAP在线分析处理，操作速度快；<br>2、myisam存储引擎表由MYD和MYI组成，MYD存放数据文件，MYI存放索引文件；<br>3、从mysql5.0开始，mysql默认支持256T单表数据<br>4、对于myisam存储引擎表，mysql数据库只缓存其索引文件，数据文件的缓存交由硝唑系统本身来完成，区别在于使用LRU算法缓存数据的大部分数据库；</p><p>select count(*) 查询 myisam快 innodb慢<br>myisam有个计数器，直接读取计数器的数据<br>innodb需要全表扫描</p><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>1、数据放在内存中，数据库重启或掉电，表中的数据将丢失<br>2、只支持表锁，速度非常快，哈希索引，并发性能差<br>3、不支持text和blob列类型，一般用于创建临时表</p><h2 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h2><p>1、只支持insert和select操作<br>2、使用zlib算法将数据行（row）进行压缩后存储，压缩比可达1:10<br>3、适合存储归档数据，如日志信息</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有其他存储引擎，比如：<br>Merge、CSV、Sphinx、infobright、Federated、NDB<br><img src="/images/5925adc9-8c8d-40dd-b05b-bff8f91923f6-Image.png" alt="5925adc9-8c8d-40dd-b05b-bff8f91923f6-Image.png" title="5925adc9-8c8d-40dd-b05b-bff8f91923f6-Image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2018/10/22/%E8%BF%90%E7%BB%B4/Nginx/"/>
      <url>/2018/10/22/%E8%BF%90%E7%BB%B4/Nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>http 反向代理 mail反向代理<br>高并发连接，官方测试可支持5w并发量，实际3w左右<br>使用epoll和kqueue网络I&#x2F;O模型<br>内存消耗小，开启10个Nginx进程消耗15M*10&#x3D;150M内存<br>支持负载均衡，反向代理</p><p>Nginx请求连接的方法<br>select模型，阻塞I&#x2F;O<br>epoll模型，多路复用I&#x2F;O，并发量更大，速度更快</p><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><h3 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h3><pre><code class="bash">yum -y install gcc gcc-c++ autoconf automakeyum -y install zlib zlib-devel openssl openssl-devel pcre-devel</code></pre><blockquote><p>zlib：Nginx提供gzip模块，需zli库支持<br>openssl：Nginx提供ssl功能<br>pcre：提供地址重写rewrite功能</p></blockquote><h3 id="创建nginx系统用户和组"><a href="#创建nginx系统用户和组" class="headerlink" title="创建nginx系统用户和组"></a>创建nginx系统用户和组</h3><pre><code class="bash">groupadd  -r nginxuseradd -s /sbin/nologin -g nginx -r  nginx</code></pre><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><pre><code class="bash">./configure \--prefix=/usr/local \--sbin-path=/usr/sbin/nginx \--conf-path=/etc/nginx/nginx.conf \--error-log-path=/var/log/nginx/error.log \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--user=nginx \--group=nginx \--with-http_ssl_module \--with-http_flv_module \--with-http_gzip_static_module \--http-log-path=/var/log/nginx/access.log \--http-client-body-temp-path=/var/tmp/nginx/client \--http-proxy-temp-path=/var/tmp/nginx/proxy \--http-fastcgi-temp-path=/var/tmp/nginx/fcgi \--with-http_stub_status_modulemake &amp;&amp; make install</code></pre><p>编译完成后可以启动nginx，不能通过systemd服务控制启动</p><h2 id="nginx控制方法"><a href="#nginx控制方法" class="headerlink" title="nginx控制方法"></a>nginx控制方法</h2><pre><code class="bash">[root@localhost ~]# /usr/sbin/nginx -c /etc/nginx/nginx.conf</code></pre><p>从容关闭Nginx，就是给nginx发信号</p><pre><code class="bash">[root@localhost ~]# kill -QUIT $(cat /var/run/nginx/nginx.pid)</code></pre><p>平滑重启nginx</p><pre><code class="bash">[root@localhost ~]# kill -HUP $(cat /var/run/nginx/nginx.pid)</code></pre><p>快速停止</p><pre><code class="bash">[root@localhost ~]# kill -TERM $(cat /var/run/nginx/nginx.pid)</code></pre><p>强制结束所有的nginx进程</p><pre><code class="bash">[root@localhost ~]# pkill -9 nginx</code></pre><p>发送信号重新读取配置文件</p><pre><code class="bash">[root@localhost ~]# pkill -1 nginx</code></pre><p>检测nginx配置文件语法</p><pre><code class="bash">[root@localhost ~]# /usr/sbin/nginx  -t -c /etc/nginx/nginx.confnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful</code></pre><h2 id="配置文件语法"><a href="#配置文件语法" class="headerlink" title="配置文件语法"></a>配置文件语法</h2><p>每一个server代表一个虚拟主机，每一个location代表一个目录，如果在location外面指定root目录，location定义的目录就是根据root定义的目录结构来的，定义的内容每行最后都要以<code>;</code>结尾</p><h2 id="location匹配规则"><a href="#location匹配规则" class="headerlink" title="location匹配规则"></a>location匹配规则</h2><p>语法：<code>location [=|~|~*|^~] /url/ &#123;...&#125;</code><br>默认值：no<br>使用字段：server下的location<br>这个参数根据URL的不同需求来进行配置，可以使用字符串与正则表达式匹配，如果要使用正则表达式，你必须指定下列前缀<br><code>~</code>：区分大小写<br><code>~*</code>：不区分大小写<br><code>^~</code>：禁止表达式匹配<br><code>=</code>: 精确匹配<br>如果有重复匹配，则匹配最精确的行<br>EXAMPLE：</p><pre><code class="bash">location = / &#123;#只匹配/的查询[configuration A]&#125;</code></pre><pre><code class="bash">location / &#123;#匹配任何以/开始的查询，但是正则表达式与一些较长的字符串将被首先匹配[configuration B]&#125;</code></pre><pre><code class="bash">location ^~ /images/ &#123;#匹配任何以/images/开始的查询并且停止搜索，不检查正则表达式[configuration C]&#125;</code></pre><pre><code class="bash">location ~* \.(gif|jgp|jpeg)$｛＃匹配任何以gif，jpg，或jpeg结尾的文件，但是有/images/目录的请求将在configuration C 中处理[configuration D]&#125;</code></pre><h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><p>每一个server都是一个虚拟主机</p><pre><code class="bash">[root@localhost redhatb2]# cat /etc/nginx/nginx.conf | grep -v \# | grep -v ^$</code></pre><pre><code class="bash">#user  nobody；        指定用于运行worker进程的用户和组【user  nginx  nginx 】编译过程中指定了user和group此处就无需再指定#pid  /PATH/TO/PID_FILE；指定nginx进程的pid文件路径#worker_cpu_affinity；           cpu绑定#worker_priority [-20-19];       指定nice值，默认为0worker_processes  1;   ======&gt;可以设置为auto自动匹配cpu个数events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    server &#123;        listen       80;        server_name  redhatb1.example.com;        root /var/www/redhatb1;        location / &#123;            index  index.html index.htm;        &#125;        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;    &#125;    server &#123;           listen 80 default_server;           server_name redhatb2.example.com;           root /var/www/redhatb2;           index  index.html;         &#125;&#125;</code></pre><blockquote><p>上面的redhatb2.example.com主机设置成为了默认主机，此时，如果有域名解析到服务器的IP地址并请求，但是nginx配置文件中没有相对应的虚拟主机条目，此时就会跳转到redhatb2这个默认的虚拟主机上。如果所有的虚拟主机都没有配置成为默认主机选项，那么默认跳转到第一条虚拟主机条目。</p></blockquote><p>当默认条目附加到以下条目的时候，配置中没有响应条目的请求就会跳到以下配置上，就会返回错误信息</p><pre><code class="bash">    server &#123;         listen       80  default_server;         server_name  _;         return       444;    &#125;</code></pre><h2 id="自定义日志"><a href="#自定义日志" class="headerlink" title="自定义日志"></a>自定义日志</h2><p>可以根据不同的虚拟主机定义不同的错误日志</p><pre><code class="bash">server &#123;           listen 80 default_server;           server_name redhatb2.example.com;           root /var/www/redhatb2;           index  index.html;           access_log /var/log/nginx/redhatb2-access.log main;           error_log /var/log/nginx/redhatb2-error.log warn;     =====&gt;可以指定级别，出于调试目的，可以指定为debug级别，但是仅在编译时，使用了“--with-debug”选项时才有效      &#125;</code></pre><h2 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h2><p>可以根据自己需求自定义错误页面</p><pre><code class="bash">server &#123;           listen 80 default_server;           server_name redhatb2.example.com;           root /var/www/redhatb2;           index  index.html;           access_log /var/log/nginx/redhatb2-access.log main;           error_log /var/log/nginx/redhatb2-error.log warn;           error_page   403 404  /40x.html;           location = /40x.html &#123;           root   /var/www/error;        &#125;&#125;</code></pre><p>要在&#x2F;var&#x2F;www&#x2F;error下面创建40x.html，里面的内容是自定义的错误页面</p><p>可以一起定义，也可以分开定义如下所示，这样403和404错误可以显示不同的内容，同时，也需要在&#x2F;var&#x2F;www&#x2F;error下创建403.html和404.html错误页面</p><pre><code class="bash">server &#123;           listen 80 default_server;           server_name redhatb2.example.com;           root /var/www/redhatb2;           index  index.html;           access_log /var/log/nginx/redhatb2-access.log main;           error_log /var/log/nginx/redhatb2-error.log warn;           error_page   403  /403.html;           location = /403.html &#123;           root   /var/www/error;        &#125;           error_page   404  /404.html;           location = /404.html &#123;           root   /var/www/error;        &#125;&#125;</code></pre><h2 id="自动索引功能"><a href="#自动索引功能" class="headerlink" title="自动索引功能"></a>自动索引功能</h2><pre><code class="bash">server &#123;           listen 80 default_server;           server_name redhatb2.example.com;           root /var/www/redhatb2;           index  index.html;           location /data &#123;           autoindex on;           &#125;      &#125;</code></pre><p>开启这个功能后，访问redhatb2.example.com&#x2F;data时将自动把&#x2F;data目录下的所有文件列出来，和Apache里的Options Indexes功能一样，当用户请求&#x2F;data目录的时候，会直接列出目录里面的内容，不会报403错误，这种方式很不安全，除非作为下载站使用。</p><h2 id="别名功能"><a href="#别名功能" class="headerlink" title="别名功能"></a>别名功能</h2><pre><code class="bash">server &#123;           listen 80 default_server;           server_name redhatb2.example.com;           root /var/www/redhatb2;           index  index.html;           access_log /var/log/nginx/redhatb2-access.log main;           error_log /var/log/nginx/redhatb2-error.log warn;           location /a &#123;           alias /var/www/alias/test;        &#125;&#125;</code></pre><p>假如当你访问&#x2F;a&#x2F;top.gif的时候，实际上访问的是&#x2F;var&#x2F;www&#x2F;alias&#x2F;test&#x2F;top.gif<br><strong>！！注意！！当location后面定义的目录以&#x2F;结尾时，下面alias定义的目录也要以&#x2F;结尾，否则报错</strong></p><p>像这样就不会报错，和上面不以&#x2F;结尾时一样的，要么都加，要么都不加</p><pre><code class="bash">   location /a/ &#123;           alias /var/www/alias/test/;        &#125;</code></pre><p><strong>但是如果加上&#x2F;的话，用户在浏览器中也必须以&#x2F;结尾，如果只是对一条路径的其中一段做别名，可以加上&#x2F;，也可以不加，所以综合来看，还是不加要方便一点</strong><br>Apache里面做别名有一个Alias模块专门定义别名，而不在directory里面定义</p><h2 id="控制站点的访问"><a href="#控制站点的访问" class="headerlink" title="控制站点的访问"></a>控制站点的访问</h2><pre><code class="bash">server &#123;           listen 80 default_server;           server_name redhatb2.example.com;           root /var/www/redhatb2;           index  index.html;           access_log /var/log/nginx/redhatb2-access.log main;           error_log /var/log/nginx/redhatb2-error.log warn;           location /a &#123;           deny 192.168.0.123;           allow 192.168.0.0/24;           allow 192.168.1.1;           deny all;        &#125;&#125;</code></pre><p>这种控制有先后顺序，和Apache不一样，nginx是从上到下依次匹配，和防火墙的匹配规则类似</p><h2 id="目录身份验证"><a href="#目录身份验证" class="headerlink" title="目录身份验证"></a>目录身份验证</h2><p>和Apache的目录身份验证类似，只是语法不一样</p><pre><code class="bash">server &#123;           listen 80 default_server;           server_name redhatb2.example.com;           root /var/www/redhatb2;           index  index.html;           access_log /var/log/nginx/redhatb2-access.log main;           error_log /var/log/nginx/redhatb2-error.log warn;           location /data &#123;           autoindex on;           auth_basic &quot;AwstatAuth&quot;;           auth_basic_user_file /etc/nginx/htpasswd;        &#125;&#125;</code></pre><p>同时也需要使用htpasswd命令创建htpasswd文件，详细操作参考 的基于认证的网页登录笔记</p><h2 id="nginx状态检查"><a href="#nginx状态检查" class="headerlink" title="nginx状态检查"></a>nginx状态检查</h2><pre><code class="bash">server &#123;           listen 80 default_server;           server_name redhatb2.example.com;           root /var/www/redhatb2;           index  index.html;           access_log /var/log/nginx/redhatb2-access.log main;           error_log /var/log/nginx/redhatb2-error.log warn;           location /status &#123;           stub_status on;           access_log off;        &#125;&#125;</code></pre><p>&#x2F;status目录可以不存在，进入<code>redhatb2.example.com/status</code>可以查看nginx的状态信息，例如<br>Active connections: 2 server accepts handled requests 46 46 198 Reading: 0 Writing: 1 Waiting: 1</p><h2 id="nginx地址重写rewrite"><a href="#nginx地址重写rewrite" class="headerlink" title="nginx地址重写rewrite"></a>nginx地址重写rewrite</h2><p>Rewrite主要的功能就是实现URL的重写，如果需要nginx的地址重写功能，那么在编译之前，需要编译安装PCRE库（兼容perl的正则表达式）</p><p>URL：统一资源定位符，用户浏览器里面输入的是URL地址<br>URI：由一个通过通用资源标识符进行定位，配置文件中location定义的是URI地址</p><p>变量名可以使用“&#x3D;”或“！&#x3D;”运算符<br>“<del>”表示区分大小写字母的匹配<br>“</del>*”表示不区分大小写的匹配<br>“！<del>”和“！</del>*”与“<del>”“！</del>”相反<br>“-f”和“！-f”用来判断文件是否存在<br>“-d”和“！-d”用来判断目录是否存在<br>“-e”和“！-e”用来判断文件或目录是否存在<br>“-x”和“！-x”用来判断文件是否可以执行<br>同时支持$1到$9的位置化参数</p><p>rewrite最后一项参数为flag标记，支持以下几种<br>last：相当于Apache里面的【L】标记，表示完成rewrite<br>break：本条规则匹配完成后，终止匹配，不再匹配后面的规则<br>redirect：返回302临时重定向，浏览器地址会显示跳转后的URL地址<br>permanent：返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</p><p>last和break用来实现URI重写，浏览器地址栏URL地址不变<br>redirect和permanent用来实现URL跳转，浏览器地址栏会显示跳转后的URL地址<br>一般在跟location中（即location &#x2F;  {……}）或直接在server标签中编写rewrite规则，推荐使用last标记<br>在非根location中（location &#x2F;data {……}），则使用break标记</p><h3 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h3><p>规则语法</p><pre><code class="bash">if（$http_user_agent ~ MSIE）&#123;     rewrite ^(.*)$/mesi/$1 break;&#125;</code></pre><p>$1代表位置化参数，引用root后面的URI路径</p><pre><code class="bash">if(!-f $request_filename)&#123;rewrite ^/img/(.*)$ /site/$host/imgages/$1 last;&#125;</code></pre><h3 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h3><p>规则语法</p><pre><code class="bash">location ~ .*\.(sh|bash)?$&#123;return 403;&#125;</code></pre><h3 id="将原来要访问-pub目录重写为-download"><a href="#将原来要访问-pub目录重写为-download" class="headerlink" title="将原来要访问&#x2F;pub目录重写为&#x2F;download"></a>将原来要访问&#x2F;pub目录重写为&#x2F;download</h3><pre><code class="bash">server &#123;        listen       80;        server_name  redhatb1.example.com;        root /var/www/redhatb1;        location / &#123;            index  index.html index.htm;        &#125;        location /pub &#123;           rewrite ^/pub/?$ /download permanent;        &#125;        location /download &#123;         autoindex on;        &#125;&#125;</code></pre><p>将所有请求<code>redhatb1.example.com/pub</code>的链接重写到<code>redhatb1.example.com/download</code><br>rewrite可以写在location里面，也可以写在location外面</p><h3 id="根据不同的浏览器将得到不同的结果"><a href="#根据不同的浏览器将得到不同的结果" class="headerlink" title="根据不同的浏览器将得到不同的结果"></a>根据不同的浏览器将得到不同的结果</h3><pre><code class="bash">server &#123;        listen       80;        server_name  redhatb1.example.com;        root /var/www/redhat1;        if ($http_user_agent ~ Firefox )&#123;        rewrite ^/data/(.*)$ /firefox/data/$1 last;        &#125;        if ($http_user_agent ~ MSIE) &#123;        rewrite ^(.*)$  /msie/$1 last;        &#125;&#125;</code></pre><h3 id="实现域名跳转"><a href="#实现域名跳转" class="headerlink" title="实现域名跳转"></a>实现域名跳转</h3><pre><code class="bash">server &#123;    listen      80;    server_name  redhatb3.example.com;    root /var/www/redhatb3;    index index.html;    rewrite ^(.*)$ http://redhatb1.example.com/$1 permanent;    location /firefox/data &#123;        index index.html;    &#125;&#125;</code></pre><p>当访问<code>redhatb3.example.com</code>的时候，将自动跳转到<code>redhatb1.example.com</code></p><h2 id="TLS认证的配置"><a href="#TLS认证的配置" class="headerlink" title="TLS认证的配置"></a>TLS认证的配置</h2><pre><code class="bash">server &#123;        listen       443 ssl;        server_name  redhatb.example.com;        ssl_certificate      /etc/pki/tls/certs/nginx.crt;        ssl_certificate_key  /etc/pki/tls/private/nginx.key;        ssl_session_cache    shared:SSL:1m;        ssl_session_timeout  5m;        ssl_ciphers  HIGH:!aNULL:!MD5;        ssl_prefer_server_ciphers  on;        location / &#123;            root   /var/www/redhatb;            index  index.html index.htm;        &#125;    &#125;</code></pre><p>通过keygen命令生成证书和私钥，证书放在&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs里面，私钥放在&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;private里面，重启nginx生效</p><h2 id="nginx日志管理"><a href="#nginx日志管理" class="headerlink" title="nginx日志管理"></a>nginx日志管理</h2><p>log_format指令用来设置日志的记录格式，语法如下：<br>log_format name format  [format……]<br>默认的日志格式</p><pre><code class="bash">log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</code></pre><ul><li>$remote_addr：客户端的IP地址</li><li>$remote_user：用来记录远程客户端用户名称，一般不会有记录，除非用账号密码认证了的，才会记录用户名</li><li>$time_local：用来记录访问时间及时区</li><li>$request：用于记录请求的URL和HTTP协议</li><li>$status：用于记录请求的状态，例如成功时状态为200，页面找不到时为404</li><li>$bady_bytes_sent：用于记录发送给客户端的文件主体内容大小</li><li>$http_referer：用于记录是从哪个页面链接访问过来的</li><li>$http_user_agemt：用于记录客户端浏览器的相关信息</li><li>$http_x_forwarded_for：用于记录远程用户真正的IP地址。一旦有了缓存，代理，后端日志记录的是缓存，代理的IP地址，而不会记录原来真正的IP地址，此字段就是用于记录真正的来源IP地址。</li></ul><p>可以给每个server或者每个location分别定义日志，更精确<br>可以将日志放在缓存里面例如：<br>access_log  &#x2F;data&#x2F;log&#x2F;$server_name.log main buffer&#x3D;32k;<br>buffer&#x3D;32k：表示设置内存缓冲区的大小<br>注意：尽量不要用变量，当主机不多的时候，直接用主机名</p><p>开启日志打开缓存<br>对于每一条日志记录，日志文件都将先打开文件，再写入日志记录，然后马上关闭，为了提高包含变量的日志文件存放路径的性能，可以使用open_log_file_cache指令来设置，格式如下：</p><pre><code class="bash">open_log_file_cache  max=N [incative=time] [min_user=N] [valid=time] | off</code></pre><p>该指令默认是禁止的，等同于open_log_file_cache off;</p><ul><li>max：设置缓存中的最大文件描述符数量</li><li>inactive：设置一个时间，如果在设置的时间内没有使用此文件描述符，则自动删除此描述符</li><li>min_uses：在参数inactive指定的时间范围内，如果日志文件超过被使用的次数，则将该日志文件的描述符计入缓存，默认为10秒钟</li><li>valid：设置多长时间检查一次，看日志文件路径与文件名是否仍然存在，默认60秒</li><li>open_log_file_cache max&#x3D;1000 inactive&#x3D;20s min_uses&#x3D;2 valid&#x3D;1m;<br>这条指令的意思是，设置1000个文件描述符，每1分钟检查一次，如果检查到20秒内该文件没有被使用2次，则将它从缓存中删除，如果使用了2次及2次以上，则计入缓存。</li></ul><h3 id="nginx日志的分割"><a href="#nginx日志的分割" class="headerlink" title="nginx日志的分割"></a>nginx日志的分割</h3><p>编辑一个脚本<br>vim &#x2F;var&#x2F;log&#x2F;nginx&#x2F;nginx_log.sh</p><pre><code class="bash">#!/bin/bash#定义日志目录log_path=&#39;/var/log/nginx&#39;#创建每天的目录mkdir -p  $log_path/$(date -d yesterday +%Y)/$(date -d yesterday +%m)/$(date -d yesterday +%d)/#把日志移动到相应的目录mv $log_path/redhatb2-access.log $log_path/$(date -d yesterday +%Y)/$(date -d yesterday +%m)/$(date -d yesterday +%d)/$(date -d yesterday +%Y-%m-%d)-redhatb2.access.log#重启nginx生成新的日志文件kill -HUP $(cat /var/run/nginx/nginx.pid)</code></pre><p>创建计划任务</p><pre><code class="bash">crontab -e01 01 * * * /bin/bash /var/log/nginx/nginx_log.sh</code></pre><p>每天的1点1分执行一次<br>上述脚本及计划任务的作用就是，把每天的日志分割出来，放到相应的目录里面去，便于管理，不至于日志文件过于庞大</p><h2 id="nginx开启压缩功能"><a href="#nginx开启压缩功能" class="headerlink" title="nginx开启压缩功能"></a>nginx开启压缩功能</h2><p>在http{……}中间，启用压缩<br>#vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><pre><code class="bash">gzip on；gzip_mon_length 1k ;gzip_buffer 4 16k ;gzip_http_version 1.1 ;gzip_comp_level 2 ;gzip_type text/plain application/x-javascript text/css application/xml;gzip_vary on；</code></pre><h2 id="nginx的浏览器本地缓存设置"><a href="#nginx的浏览器本地缓存设置" class="headerlink" title="nginx的浏览器本地缓存设置"></a>nginx的浏览器本地缓存设置</h2><p>#vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><pre><code class="bash">location  ~  .*\.(gif|jpg|jpge|png|bmp|swf)$&#123;    expires 30d;&#125;location  ~  .*\.(js|css)?$&#123;    expires 1h;&#125;</code></pre><h2 id="设定限速"><a href="#设定限速" class="headerlink" title="设定限速"></a>设定限速</h2><pre><code class="bash">location /download &#123;    limit_rate_after 20m;    limit_rate 256k;    autoindex on;&#125;</code></pre><p>设置前20M不限速，下载完20M之后开始限速，每秒256KB</p><h2 id="设置反向代理及缓冲，下面是整个的配置"><a href="#设置反向代理及缓冲，下面是整个的配置" class="headerlink" title="设置反向代理及缓冲，下面是整个的配置"></a>设置反向代理及缓冲，下面是整个的配置</h2><p>需要在http和location字段中同时设置</p><pre><code class="bash">http &#123;    include       mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    sendfile        on;    keepalive_timeout  65;client_max_body_size 300m;   client_body_buffer_size 128k;    proxy_read_timeout 600;   proxy_send_timeout 600;proxy_buffer_size 16k;proxy_buffers 4 32k;proxy_busy_buffers_size 64k;proxy_temp_file_write_size 64k;proxy_temp_path  /proxy/nginx/temp;proxy_cache_path  /proxy/nginx/cache  levels=1:2  keys_zone=cache_one:500m  inactive=1d   max_size=1g;#上面这一段可以写到下面的location中，写在这里表示全局适用server &#123;         listen      80;         server_name  redhatb3.example.com;         root /var/www/redhatb3;         index index.html;         location /firefox/data &#123;           index index.html;         &#125;         location /sms &#123;             proxy_pass http://172.25.254.121;             proxy_set_header Host $host;             proxy_set_header X-Real-IP $remote_addr;             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;             proxy_cache_valid 200 10m;             proxy_cache_valid 304 1m;             proxy_cache_valid 301 302 1h;             proxy_cache_valid any 1m;             proxy_cache_key $host$uri$is_args$args;         &#125;   &#125;&#125;</code></pre><h3 id="在http段进行设置中的各个指令的意义"><a href="#在http段进行设置中的各个指令的意义" class="headerlink" title="在http段进行设置中的各个指令的意义"></a>在http段进行设置中的各个指令的意义</h3><p>http  {<br> #允许客户端请求的最大的单个文件字节数<br>    client_max_body_size 300m;   </p><p>#缓冲区代理缓冲用户端请求的最大字节数，可以理解为先保存到本地再传给用户<br>    client_body_buffer_size 128k;    </p><p>#跟后端服务器连接的超时时间，发起握手等候响应的超时时间<br>    proxy_connent_timeout 600;</p><p>#连接成功后，等候后端服务器响应时间，其实已经进入后端的排队之中等候处理<br>    proxy_read_timeout 600;   </p><p>#后端服务器回传时间，就是在规定时间之内后端服务器必须传完所有的数据<br>    proxy_send_timeout 600;   </p><p>#代理请求缓存区，这个缓存区会保存用户的头信息以供nginx进行规则处理，一般只要能保存下头信息即可<br>    proxy_buffer_size 16k;   </p><p>#告诉nginx保存单个用的几个buffer及最大用多大空间<br>    proxy_buffers 4 32k;</p><p>#如果系统很忙的时候可以申请更大的proxy_buffers，官方推荐*2<br>    proxy_busy_buffers_size 64k;</p><p>#proxy缓存临时文件的大小<br>    proxy_temp_file_write_size 64k;</p><p>proxy_temp_path  &#x2F;data1&#x2F;proxy_temp_path;</p><p>proxy_cache_path  &#x2F;data1&#x2F;proxy_cache_path  levels&#x3D;1:2  keys_zone&#x3D;cache_one:500m  inactive&#x3D;1d   max_size&#x3D;1g;<br>}<br>###上面keys_zone&#x3D;cache_one:500m指定的500m是存放在内存中的，不要设置的太大，cache_one是cache的名字，inactive&#x3D;1d 缓存一天</p><h3 id="在location中设置的指令的意义"><a href="#在location中设置的指令的意义" class="headerlink" title="在location中设置的指令的意义"></a>在location中设置的指令的意义</h3><p>location &#x2F;sms {<br>#根据目录将请求丢到后端服务器，而本地不能有&#x2F;sms目录，否则将访问本地的&#x2F;sms目录<br>proxy_pass <a href="http://172.25.254.111/">http://172.25.254.111</a>;      #后面可以接IP也可以接ip加端口号</p><p>#这个字段的意思是记录来源IP，而不是记录代理服务器，就是后端的日志里面记录的不是代理服务器IP，而是，真正远端客户端的IP<br>proxy_set_header Host $host;   </p><p>#引用的cache<br>proxy_cache cache_one;</p><p>#记录远程IP，加入中间有代理，则没经过一次，加一个上一级代理IP，此时第一个ip为客户端原始ip<br>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</p><p>上面这些设置仅仅是把请求丢到后端，并没有做缓存，如果需要缓存，加上以下字段<br>proxy_cache_valid 200 10m;<br>proxy_cache_valid 304 1m;<br>proxy_cache_valid 301 302 1h;<br>proxy_cache_valid any 1m;<br>#以域名、URI、参数组合成Web缓存key值，nginx根据key值哈希，存储缓存内容到二级缓存目录内<br>proxy_cache_key $host$uri$is_args$args;<br>}</p><h2 id="upstream模块实现负载均衡"><a href="#upstream模块实现负载均衡" class="headerlink" title="upstream模块实现负载均衡"></a>upstream模块实现负载均衡</h2><p>upstream这个字段应该设置在http段里面</p><pre><code class="bash">http &#123;......upstream my_server_pool &#123;    server 172.25.254.121:80 weight=1 max_fails=2 fail_timeout=30s;    server 172.25.254.123:80 weight=2 max_fails=2 fail_timeout=30s;    &#125;   location /sms &#123;         proxy_pass http://my_server_pool;    &#125;&#125;</code></pre><p>在上面的配置中，my_server_pool是upstream的名字，可以随便取，weight代表权重，就是丢给那个主机的次数，权重为2表示丢给它两次，再丢给下个主机，以上面的为例，121处理一次，123处理2次，再丢给121处理1次，然后再丢给123处理2次。max_fails为最大失败次数，失败两次后，丢给下一台主机，fail_timeout表示超时时间，超过30秒，丢给下一台主机</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle数据库四种状态</title>
      <link href="/2018/10/14/Oracle/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
      <url>/2018/10/14/Oracle/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="oracle数据库四种状态"><a href="#oracle数据库四种状态" class="headerlink" title="oracle数据库四种状态"></a>oracle数据库四种状态</h1><ul><li>SHUTDOWN状态： oracle数据库没有启动 ,完全关闭状态 关闭命令是shutdown immediate(立即关闭)</li><li>NOMOUNT状态： 在这个状态下，oracle会打开参数文件，分配SGA并打开后台进程, SGA和后台进程已经启动</li><li>MOUNT状态： oralce会在nomount的基础上,通过参数读取控制文件，拥有sysdba权限的可以进行一些数据的备份和恢复操作，其他用户还不能访问。在nomount的基础上，进入此状态的命令是：alter database mount</li><li>OPEN状态:在mount的基础上根据控制文件的记录打开所有的数据文件和重做日志。这个状态表示数据库完全打开，其他用户正常访问.在mount的基础上，使用命令alter database open</li></ul><p><strong>startup不加参数，那么直接就是进入open状态。</strong></p><p>如果使用<code>alter database ****</code>才启动oracle ，必须按照顺序启动，即：nomount–&gt;mount–&gt;open。不能越级，不能反方向。</p><h2 id="SHUTDOWN-–-NOMOUNT"><a href="#SHUTDOWN-–-NOMOUNT" class="headerlink" title="SHUTDOWN –&gt;NOMOUNT"></a>SHUTDOWN –&gt;NOMOUNT</h2><pre><code class="sql">SQL&gt; startup nomount   ORACLE 例程已经启动。   tal System Global Area  431038464 bytes   xed Size                  1333676 bytes   riable Size             276825684 bytes   tabase Buffers          146800640 bytes   do Buffers                6078464 bytes   </code></pre><p>一个数据库实例开始：</p><p>首先从spfile或者pfile中读取数据库参数文件：<br>然后分配SGA和创建后台进程。<br>相当于生产线和工人都到位了<br>但是没有开始生产，生产线上没有产品。</p><p>一些参数查询：</p><pre><code class="sql">SQL&gt; show parameter db_name;   NAME                                 TYPE                    VALUE------------------------------------ ----------------------  ------------------------------   db_name                              string                  orcl   SQL&gt; show parameter db_block_size;   NAME                                 TYPE                    VALUE------------------------------------ ----------------------  ------------------------------db_block_size                        integer                 8192   </code></pre><h2 id="NOMOUNT—-MOUNT"><a href="#NOMOUNT—-MOUNT" class="headerlink" title="NOMOUNT—-&gt;MOUNT"></a>NOMOUNT—-&gt;MOUNT</h2><p>就相当于把 数据库和实例建立关系。<br>首先根据初始化参数文件中的CONTROL_FILE参数找到相应的控制文件然后打开它们。<br>在控制文件中包含了数据库的数据文件和redo log文件信息。<br>这个时候数据库还没有打开，仍然处于关闭状态，这个时候普通的用户还不能<br>连接到数据库，只有数据库管理员可以进行一些备份恢复等工作。</p><h2 id="MOUNT-—-OPEN"><a href="#MOUNT-—-OPEN" class="headerlink" title="MOUNT —-&gt; OPEN"></a>MOUNT —-&gt; OPEN</h2><p>通过控制文件信息找到 联机数据文件和redo log 文件，<br>如果没有以上两个文件，数据库就会报错。如果这两个文件坏了，<br>数据库无法打开，这个时候可以通过sysdba权限进入mount挂载状态后，对<br>这两个数据文件进行恢复操作后再打开数据库。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GTID主从复制</title>
      <link href="/2018/10/12/Mysql/GTID%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2018/10/12/Mysql/GTID%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="GTID主从复制"><a href="#GTID主从复制" class="headerlink" title="GTID主从复制"></a>GTID主从复制</h1><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>master开启gtid，ip为10.10.10.100<br>slave开启gtid，ip为10.10.10.101</p><h2 id="master配置文件"><a href="#master配置文件" class="headerlink" title="master配置文件"></a>master配置文件</h2><pre><code class="bash"># master[mysqld]server-id=1003306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1    enforce_gtid_consistency=1</code></pre><h2 id="slave配置文件"><a href="#slave配置文件" class="headerlink" title="slave配置文件"></a>slave配置文件</h2><pre><code class="bash"># slave[mysqld]server-id=1013306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1enforce_gtid_consistency=1read-only=1    ##保证数据一致性</code></pre><h2 id="导出master上的数据，导入到slave中；"><a href="#导出master上的数据，导入到slave中；" class="headerlink" title="导出master上的数据，导入到slave中；"></a>导出master上的数据，导入到slave中；</h2><pre><code class="bash"># master[root@mysql-master-1003306 ~]# mysqldump -uroot -p --single-transaction -A --master-data=2 &gt; all.sqlEnter password:##这里加不加--master-data=2都行，因为复制已经不再是基于position号的形式了。[root@mysql-master-1003306 ~]# scp all.sql 10.10.10.101:/root               #将备份文件拷贝到从库</code></pre><h2 id="从库导入数据"><a href="#从库导入数据" class="headerlink" title="从库导入数据"></a>从库导入数据</h2><pre><code class="sql"># slave[root@mysql-slave-1013306 ~]# mysql -uroot -p &lt; all.sqlEnter password:ERROR 1840 (HY000) at line 24: @@GLOBAL.GTID_PURGED can only be set when @@GLOBAL.GTID_EXECUTED is empty.## 从库导入时报这个错误，是因为从库当前的GLOBAL.GTID_EXECUTED不为空，使用reset master可以重置；mysql&gt; show master status;+------------------+----------+--------------+------------------+----------------------------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                      |+------------------+----------+--------------+------------------+----------------------------------------+| mysql-bin.000002 |      398 |              |                  | 8d3e071d-41b8-11e8-aaef-000c29661dd8:1 |+------------------+----------+--------------+------------------+----------------------------------------+1 row in set (0.00 sec)mysql&gt; reset master;Query OK, 0 rows affected (0.01 sec)mysql&gt;mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      154 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)##再次导入[root@mysql-slave-1013306 ~]# mysql -uroot -p &lt; all.sqlEnter password:##导入成功</code></pre><h2 id="在master上创建复制账号"><a href="#在master上创建复制账号" class="headerlink" title="在master上创建复制账号"></a>在master上创建复制账号</h2><pre><code class="sql">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;repluser&#39;@&#39;10.10.10.%&#39; IDENTIFIED BY &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><h2 id="在slave上开启复制"><a href="#在slave上开启复制" class="headerlink" title="在slave上开启复制"></a>在slave上开启复制</h2><pre><code class="sql">mysql&gt;  CHANGE MASTER TO MASTER_HOST=&#39;10.10.10.100&#39;,MASTER_USER=&#39;repluser&#39;,MASTER_PASSWORD=&#39;echo123.&#39;,MASTER_PORT=3306,MASTER_AUTO_POSITION=1;Query OK, 0 rows affected, 2 warnings (0.04 sec)</code></pre><h2 id="查看主从状态"><a href="#查看主从状态" class="headerlink" title="查看主从状态"></a>查看主从状态</h2><pre><code class="sql"># slavemysql&gt; start slave;Query OK, 0 rows affected (0.06 sec)mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.100                  Master_User: repluser                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000010          Read_Master_Log_Pos: 1719               Relay_Log_File: mysql-relay-bin.000002                Relay_Log_Pos: 1220        Relay_Master_Log_File: mysql-bin.000010             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 1719              Relay_Log_Space: 1427              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1003306                  Master_UUID: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:4-6            Executed_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:1-6                Auto_Position: 1         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)</code></pre><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在主库上插入数据</p><pre><code class="sql"># mastermysql&gt; select * from t1;+----+| id |+----+|  1 ||  2 ||  3 |+----+3 rows in set (0.00 sec)mysql&gt; insert into t1 values (4);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into t1 values (5);Query OK, 1 row affected (0.01 sec)</code></pre><p>在从库上查看</p><pre><code class="sql">mysql&gt; select * from t1;+----+| id |+----+|  1 ||  2 ||  3 |+----+3 rows in set (0.00 sec)mysql&gt; select * from t1;+----+| id |+----+|  1 ||  2 ||  3 ||  4 ||  5 |+----+5 rows in set (0.00 sec)</code></pre><h2 id="GTID如何跳过事务冲突"><a href="#GTID如何跳过事务冲突" class="headerlink" title="GTID如何跳过事务冲突"></a>GTID如何跳过事务冲突</h2><p>1、这个功能主要跳过事务，代替原来的set global sql_slave_skip_counter &#x3D; 1。<br>2、由于在这个GTID必须是连续的，正常情况同一个服务器产生的GTID是不会存在空缺的。所以不能简单的skip掉一个事务，只能通过注入空事物的方法替换掉一个实际操作事务。<br>3、注入空事物的方法：</p><pre><code class="bash">stop slave;set gtid_next=&#39;xxxxxxx:N&#39;;   ##这里的xxxxx:N 也就是你的slave sql thread报错的GTID，或者说是你想要跳过的GTID。begin;commit;set gtid_next=&#39;AUTOMATIC&#39;;start slave;</code></pre><pre><code class="bash">mysql&gt; stop slave;Query OK, 0 rows affected (0.02 sec)mysql&gt; set gtid_next=&#39;91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:15&#39;;   ##跳过的GTID号Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;commit;Query OK, 0 rows affected (0.00 sec)Query OK, 0 rows affected (0.01 sec)mysql&gt; set gtid_next=&#39;AUTOMATIC&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-文件读写</title>
      <link href="/2018/10/08/Python/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>/2018/10/08/Python/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><p>读写文件之前，必须先打开文件。</p><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>内置函数<code>open()</code>用于打开文件，函数的返回值是一个文件对象，通过该对象就可以操作文件了。<br>第一个参数是文件的路径，必须要指定。既可以指定绝对路径也可以指定相对路径<br>第二个参数是文件的打开方式，默认值是<code>&#39;r&#39;</code>，表示以只读方式打开。<br>其他参数都是带默认值的，可以参考官方文档。</p><table><thead><tr><th align="left">文件的打开方式</th><th align="left">说明</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">‘r’</td><td align="left">以只读方式打开，只能读文件</td><td align="left">文件的默认打开方式<br>如果文件不存在，则抛出异常FileFoundError</td></tr><tr><td align="left">‘w’</td><td align="left">以只写方式打开，只能写文件</td><td align="left">如果文件存在，则清空文件<br>如果文件不存在，则创建文件</td></tr><tr><td align="left">‘a’</td><td align="left">以追加方式打开，只能写文件</td><td align="left">如果文件存在，则从文件末尾开始写<br>如果文件不存在，则创建文件</td></tr><tr><td align="left">‘x’</td><td align="left">以只写方式打开，只能写文件</td><td align="left">如果文件存在，则抛出异常FileExistsError<br>如果文件不存在，则创建文件</td></tr><tr><td align="left">‘+’</td><td align="left">以读写方式打开，可以读写文件</td><td align="left">不能单独使用，只能添加到其他打开方式的后面<br>‘r+’：参见’r’的备注<br>‘w+’：参见’w’的备注<br>‘a+’：参见’a’的备注<br>‘x+’：参见’x’的备注</td></tr><tr><td align="left">‘t’</td><td align="left">以文本方式打开</td><td align="left">文件默认打开方式，不能单独使用，只能添加到其他打开方式的后面：<br>‘rt’，’wt’，’at’，’rt+’，’wt+’，’at+’，’xt+’</td></tr><tr><td align="left">‘b’</td><td align="left">以二进制方式打开</td><td align="left">例如：打开图片不能单独使用，只能添加到其他打开方式的后面：<br>‘rb’，’wb’，’ab’，’xb’，’rb+’，’wb+’，’ab+’，’xb+’</td></tr></tbody></table><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>可以调用内置函数<code>open()</code>并以只读方式或读写方式打开文件。返回的文件对象有三个用于读文件的方法：<br>1、read([size])，如果不关闭文件，每次调用此方法，将从上一次调用此方法的地方继续读取文件。</p><ul><li>如果不传参数，读到文件尾部。</li><li>如果传入参数size，用于指定字节数，<br>当指定的字节数小于读到文件尾的字节数时，读取指定的字节数；<br>当指定的字节数大于读到文件尾的字节数时，或当指定的字节数小于0时，读取到文件尾部；</li></ul><pre><code class="python">&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)&gt;&gt;&gt; fh.read()&#39;1234567890\nqwertyuiop\nasdfghjkl\nzxcvbnm\n&#39;&gt;&gt;&gt; fh.read()   # 由于已经读到了文件尾部且没有关闭文件，再次调用将从尾部读取，没有读取到数据&#39;&#39;&gt;&gt;&gt; fh.close()</code></pre><pre><code class="python">&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)   &gt;&gt;&gt; fh.read(-2)     # 传入负数，将直接读取到文件尾部&#39;1234567890\nqwertyuiop\nasdfghjkl\nzxcvbnm\n&#39;&gt;&gt;&gt; fh.close()</code></pre><p>注意：如果文件较大，使用read()读取全部文件会导致内存占用较大，因此，最好多次调用read([size])，指定的size不要超过默认缓冲区的大小，否则，可能并不能读取到指定的字节数。<br>默认缓冲区大小通过标准库中io模块的DEFAULT_BUFFER_SIZE获取</p><pre><code class="python">&gt;&gt;&gt; import io&gt;&gt;&gt; io.DEFAULT_BUFFER_SIZE8192</code></pre><p>2、readline([size])，如果不关闭文件，每次调用此方法，将从上一次调用此方法的地方继续读取文件。</p><ul><li>如果不传参数，读到行尾。</li><li>如果传入参数size，用于指定字节数，<br>当指定的字节数小于读到行尾的字节数时，读取指定的字节数；<br>当指定的字节数大于读到行尾的字节数时，或当指定的字节数小于0时，读取到行尾部；<br>总之，最多读到行尾。</li></ul><pre><code class="python"># 如果不传参数，读到行尾&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)&gt;&gt;&gt; fh.readline()&#39;1234567890\n&#39;&gt;&gt;&gt; fh.readline()&#39;qwertyuiop\n&#39;&gt;&gt;&gt; fh.readline()&#39;asdfghjkl\n&#39;&gt;&gt;&gt; fh.readline()&#39;zxcvbnm\n&#39;&gt;&gt;&gt; fh.readline()&#39;&#39;&gt;&gt;&gt; fh.close()</code></pre><pre><code class="python"># 当指定的字节数小于读到行尾的字节数时，读取指定的字节数&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)&gt;&gt;&gt; fh.readline(7)&#39;1234567&#39;&gt;&gt;&gt; fh.readline(7)      # 当指定的字节数大于读到行尾的字节数时，或当指定的字节数小于0时，读取到行尾部&#39;890\n&#39;&gt;&gt;&gt; fh.readline(7)&#39;qwertyu&#39;&gt;&gt;&gt; fh.readline(7)&#39;iop\n&#39;&gt;&gt;&gt; fh.readline(7)&#39;asdfghj&#39;&gt;&gt;&gt; fh.readline(7)&#39;kl\n&#39;&gt;&gt;&gt; fh.readline(7)&#39;zxcvbnm&#39;&gt;&gt;&gt; fh.readline(7)&#39;\n&#39;&gt;&gt;&gt; fh.readline(7)&#39;&#39;&gt;&gt;&gt; fh.close()</code></pre><pre><code class="python"># 当指定的字节数大于读到行尾的字节数时，或当指定的字节数小于0时，读取到行尾部&gt;&gt;&gt; fh.close()&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)&gt;&gt;&gt; fh.readline(20)&#39;1234567890\n&#39;&gt;&gt;&gt; fh.readline(20)&#39;qwertyuiop\n&#39;&gt;&gt;&gt; fh.readline(20)&#39;asdfghjkl\n&#39;&gt;&gt;&gt; fh.readline(20)&#39;zxcvbnm\n&#39;&gt;&gt;&gt; fh.readline(20)&#39;&#39;&gt;&gt;&gt; fh.close()</code></pre><p>3、readlines([size])</p><ul><li>如果不传参数，读到文件尾部，返回每一行组成的列表。</li><li>如果传入参数，size用于指定字节数，<br>  当指定的字节数小于读到文件尾的字节数时，一直读取到最后一个字符所在的行尾；<br>  当指定的字节数大于读到文件尾的字节数时，或当指定的字节数小于0时，读取到文件尾部；</li></ul><pre><code class="python"># 如果不传参数，读到文件尾部，返回每一行组成的列表&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)&gt;&gt;&gt; fh.readlines()[&#39;1234567890\n&#39;, &#39;qwertyuiop\n&#39;, &#39;asdfghjkl\n&#39;, &#39;zxcvbnm\n&#39;]&gt;&gt;&gt;&gt;&gt;&gt; fh.readlines()[]&gt;&gt;&gt; fh.close()</code></pre><pre><code class="python"># 当指定的字节数小于读到文件尾的字节数时，一直读取到最后一个字符所在的行尾&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)&gt;&gt;&gt;&gt;&gt;&gt; fh.readlines(5)[&#39;1234567890\n&#39;]&gt;&gt;&gt; fh.readlines(5)[&#39;qwertyuiop\n&#39;]&gt;&gt;&gt; fh.readlines(5)[&#39;asdfghjkl\n&#39;]&gt;&gt;&gt; fh.readlines(5)[&#39;zxcvbnm\n&#39;]&gt;&gt;&gt; fh.readlines(5)[]&gt;&gt;&gt; fh.close()</code></pre><pre><code class="python"># 当指定的字节数大于读到文件尾的字节数时，或当指定的字节数小于0时，读取到文件尾部&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)&gt;&gt;&gt; fh.readlines(-5)[&#39;1234567890\n&#39;, &#39;qwertyuiop\n&#39;, &#39;asdfghjkl\n&#39;, &#39;zxcvbnm\n&#39;]&gt;&gt;&gt; fh.close()</code></pre><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>写文件之前，必须打开文件。<br>可以调用内置函数<code>open()</code>并且以只写方式、追加方式、读写方式打开文件。这样，返回的文件对象有两个用于写文件的方法：<br>1、write(text)</p><ul><li>用于将指定的字符串写入到文件中。方法的返回值是写入的字符数，即指定的字符串的长度。</li></ul><pre><code class="python">&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;w&#39;)  &gt;&gt;&gt; fh.write(&#39;hello&#39;)5&gt;&gt;&gt; fh.write(&#39; python&#39;)7&gt;&gt;&gt; fh.close()&gt;&gt;&gt;</code></pre><p>2、writelines(seq)</p><ul><li>用于将指定的字符串序列写入到文件中</li></ul><pre><code class="python">&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;w&#39;)&gt;&gt;&gt; fh.writelines([&#39;qwe\n&#39;, &#39;asd\n&#39;, &#39;zxc\n&#39;])&gt;&gt;&gt; fh.close()</code></pre><p>调用这个两个方法后，会将指定的字符串写入到缓存中，手动调用方法<code>flush()</code>或者<code>close()</code>，或者当写入的数据量大于等于缓存的容量时，缓存中的字符串才会被写入文件中</p><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>文件在使用完毕后必须要关闭，这是因为文件对象会占用操作系统的资源，并且操作系统在某一时刻所能打开的文件数量也是有限的。</p><p>读文件或写文件时都有可能发生异常，从而导致方法<code>close()</code>不会被调用，为了保证方法<code>close()</code>总能被调用，可以把读文件或写文件的操作放在<code>try</code>语句块中，把方法<code>close()</code>的调用放在<code>finally</code>中，<br>伪代码如下：</p><pre><code class="python">try:    读文件或写文件finally:    调用方法close()关闭文件</code></pre><p>由于文件对象实现了特殊方法<code>__enter__()</code>和<code>__exit__()</code>，所以文件对象可以作为上下文管理器。其中特殊方法<code>__enter__()</code>用于返回打开的文件对象，特殊方法<code>__exit__()</code>中关闭打开的文件，因此，上面的伪代码可以使用with语句实现：</p><pre><code class="python">with 打开文件 as file:    读写文件</code></pre><h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><p>任何文件对象都有一个文件指针，用于指向文件中的某个位置。<br>读写文件时，是从文件指针的当前位置开始读写的，在读写过程中，文件指针会随之往后移动。</p><p>打开文件后，文件指针的位置<br>    以追加（’a’）方式打开文件后，文件指针指向文件的结尾位置；以其他方式打开文件后，文件指针指向文件的起始位置。<br>    调用文件对象的方法tell()，返回文件指针的当前位置。</p><pre><code class="python">&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)&gt;&gt;&gt; fh.tell()0&gt;&gt;&gt; fh.close()</code></pre><pre><code class="python">&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;a&#39;)  # 追加方式文件指针在文件的末尾&gt;&gt;&gt;&gt;&gt;&gt; fh.tell()11&gt;&gt;&gt;&gt;&gt;&gt; fh.close()</code></pre><p>在读写文件时，文件指针移动过程</p><pre><code class="python">&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)&gt;&gt;&gt; fh.tell()        # 起始位置是00&gt;&gt;&gt; fh.read(3)&#39;qwe&#39;&gt;&gt;&gt;&gt;&gt;&gt; fh.tell()3&gt;&gt;&gt; fh.read(5)&#39;\nasd\n&#39;&gt;&gt;&gt; fh.tell()8&gt;&gt;&gt; fh.close()</code></pre><p>自由移动文件指针<br>    可以调用文件对象的方法<code>seek()</code>，将文件指针自由移动到参数指定的位置<br>语法格式：</p><pre><code class="python">seek(offset, [whence])</code></pre><p>参数offset表示偏移量，可以为正数和负数，正数表示往后偏移，负数表示往前偏移。<br>参数whence是可选的，表示相对偏移位置，有三种取值：<br>1、os.SEEK_SET：相对文件的起始位置，值为0，默认值<br>2、os.SEEK_CUR：相对文件的当前位置，值为1<br>3、os.SEEK_END：相对文件的结尾位置，值为2</p><p>只有以二进制方式打开的文件，才能支持上述三种方式，如果以文本方式打开的文件，只支持相对文件的起始位置。<br>如果要使用os.SEEK_SET、os.SEEK_CUR、os.SEEK_END，需要导入os模块，但是这三个属性其实就是相当于数值0、1、2<br>os.SEEK_SET &#x3D;&#x3D; 0<br>os.SEEK_CUR &#x3D;&#x3D; 1<br>os.SEEK_END &#x3D;&#x3D; 2</p><pre><code class="python">&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;r&#39;)   # 因为是以文本方式打开的，因此只支持相对文件的起始位置&gt;&gt;&gt; fh.tell()0&gt;&gt;&gt; fh.seek(5)              # 从文件的起始位置，偏移5个指针5&gt;&gt;&gt; fh.tell()5&gt;&gt;&gt; fh.read(2)&#39;56&#39;&gt;&gt;&gt;&gt;&gt;&gt; fh.seek(0)0&gt;&gt;&gt;&gt;&gt;&gt; fh.tell()          # 从文件的起始位置，偏移0个指针，回到文件的起始位置0&gt;&gt;&gt; fh.read(2)&#39;01&#39;&gt;&gt;&gt; fh.seek(-5, 2)                   # 因为是以文本方式打开的，因此只支持相对文件的起始位置，另外两种方式就会抛出异常Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;io.UnsupportedOperation: can&#39;t do nonzero end-relative seeks</code></pre><pre><code class="python">&gt;&gt;&gt; fh = open(&#39;a.txt&#39;, &#39;rb&#39;)&gt;&gt;&gt; fh.tell()0&gt;&gt;&gt; fh.seek(-2, 2)20&gt;&gt;&gt; fh.tell()20&gt;&gt;&gt;&gt;&gt;&gt; fh.read()b&#39;j\n&#39;&gt;&gt;&gt; fh.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVS负载均衡模式</title>
      <link href="/2018/10/07/%E8%BF%90%E7%BB%B4/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/07/%E8%BF%90%E7%BB%B4/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="LVS负载均衡"><a href="#LVS负载均衡" class="headerlink" title="LVS负载均衡"></a>LVS负载均衡</h1><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>LVS-DR模式 （直接路由模式）<br>LVS-NAT模式 （NAT）<br>LVS-TUN模式 （隧道模式）</p><p><strong>硬件设备</strong><br>    F5，BIG IP<br>    Citrix，Netscaler<br>    A10<br><strong>软件</strong></p><ul><li>四层<br>  LVS</li><li>七层<br>  nginx<br>      http，smtp，pop3，imap<br>  haproxy<br>      http，tcp（mysql，smtp）</li></ul><h2 id="负载均衡调度算法"><a href="#负载均衡调度算法" class="headerlink" title="负载均衡调度算法"></a>负载均衡调度算法</h2><p>静态调度算法</p><ol><li>轮循调度（Round Robin）（rr）</li><li>加权轮循（Weight Round Robin）（wrr）</li><li>目标地址散列（Destination Hashing）（DH）<br>根据请求的目标IP地址，作为散列键（hash key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。<br>当一个请求访问时将其丢给一台机器响应，当它下次再来请求时，将他丢给同一台机器进行响应</li><li>源地址散列（Source Hashing）（SH）<br>根据请求的源IP地址，作为散列键（hash key）从静态分配的散列键表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。<br>当出口有多个时，根据源IP地址，出去是经过哪个接口，回来还是经过那个接口</li></ol><h2 id="动态调度算法"><a href="#动态调度算法" class="headerlink" title="动态调度算法"></a>动态调度算法</h2><ol><li>最少连接（Least Connections）（LC）<br>根据活动连接和非活动连接计算开销，计算公式为：活动连接*256+非活动连接，哪个计算结果小，就将请求丢给哪个服务器</li><li>加权最少连接（Weight Least Connections）（WLC）（最优秀的调度算法，系统默认也是这个）<br>在集群系统的服务器想能差异较大的情况下，调度器采用“加权最少连接”调度算法优化负载均衡性能，具有较高的服务器将承受较大比例的活动连接负载。调度器可以自动询问真实服务器的负载情况，并动态的调整其权值。<br>根据计算公式：（活动连接*256+非活动连接）&#x2F;权重，哪个计算结果小，就将请求丢给哪个服务器</li><li>最短的期望延迟（Shortest Expected Delay）(SED)<br>在WLC的基础上做了一下微调，不考虑非活动连接数，只考虑活动连接。<br>计算公式为：（（活动连接+1）*256）&#x2F;权重</li><li>最少队列调度（Never Queue ）（NQ）<br>无需队列，如果连接数等于0，就直接分配一个连接过去，不需要进行SED运算</li><li>基于局部性的最少连接（Locality-Based Least Connections）（LBLC）<br>针对目标地址的负载均衡，目前主要用于cache集群系统。该算法根据请求的目标IP地址找到该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器，若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少连接的”原则选出一个可用的服务器，将其发送到该服务器</li><li>带复制的基于局部性最少连接（Locality-Based Least Connections with Replication）（LBLCR）<br>这个调度算法也是针对目标IP地址的负载均衡，目前主要用于cache聚群系统。它与LBLC算法打不通之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务区；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制程度。</li></ol><h2 id="LVS-NAT"><a href="#LVS-NAT" class="headerlink" title="LVS-NAT"></a>LVS-NAT</h2><p><img src="/images/ce476b36-bca9-4d06-9de0-eb71b90ce32c-Image.png" alt="ce476b36-bca9-4d06-9de0-eb71b90ce32c-Image.png" title="ce476b36-bca9-4d06-9de0-eb71b90ce32c-Image.png"></p><h3 id="LVS-NAT特性"><a href="#LVS-NAT特性" class="headerlink" title="LVS-NAT特性"></a>LVS-NAT特性</h3><ul><li>RS必须与DR在同一网络，仅用于与DR服务器通讯</li><li>DR接受所有的数据包通讯（包括客户端Direcor、Dirctor和realserver直接的通讯）</li><li>RealServer的默认网关必须要指向到Director</li><li>Director支持端口映射，可以将客户端的请求映射到RealServer的另一端口</li><li>能支持任意操作系统</li><li>单一的Director是整个集群的瓶颈</li></ul><h3 id="配置LVS-NAT"><a href="#配置LVS-NAT" class="headerlink" title="配置LVS-NAT"></a>配置LVS-NAT</h3><p>实验环境，4台虚拟机CentOS7.0，一台DR调度器，两台后端Real Server，一台客户端。<br><strong>Director调度器：</strong></p><pre><code class="bash">vip：10.10.10.1（对外的公网ip）内网ip：192.168.10.1（用于和后端RS通信）掩码：255.255.255.0</code></pre><p><strong>RealServer1：</strong></p><pre><code class="bash">ip：192.168.10.100gateway：192.168.10.1（网关一定要指向调度器的内网ip）掩码：255.255.255.0</code></pre><p><strong>RealServer：</strong></p><pre><code class="bash">ip：192.168.10.200gateway：192.168.10.1（网关一定要指向调度器的内网ip）掩码：255.255.255.0</code></pre><p><strong>Client：</strong></p><pre><code class="bash">ip：10.10.10.2掩码：255.255.255.0</code></pre><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p><strong>Director：</strong></p><pre><code class="bash">[root@Director ~]# cat /etc/sysconfig/network-scripts/ifcfg-eno16777736 TYPE=EthernetBOOTPROTO=noneNAME=eno16777736ONBOOT=yesIPADDR=192.168.10.1NETMASK=255.255.255.0HWADDR=00:0c:29:9a:a1:85</code></pre><pre><code class="bash">[root@Director ~]# cat /etc/sysconfig/network-scripts/ifcfg-eno33554992 TYPE=EthernetBOOTPROTO=noneNAME=eno33554992ONBOOT=yesIPADDR=10.10.10.1NETMASK=255.255.255.0HWADDR=00:0c:29:9a:a1:8f</code></pre><p><strong>RS1：</strong></p><pre><code class="bash">[root@RealServer1 network-scripts]# cat /etc/sysconfig/network-scripts/ifcfg-eno16777736 TYPE=EthernetBOOTPROTO=noneNAME=eno16777736ONBOOT=yesIPADDR=192.168.10.100NETMASK=255.255.255.0GATEWAY=192.168.10.1HWADDR=00:0c:29:fb:45:31</code></pre><p><strong>RS2：</strong></p><pre><code class="bash">[root@RealServer2 network-scripts]# cat /etc/sysconfig/network-scripts/ifcfg-eno16777736 TYPE=EthernetBOOTPROTO=noneNAME=eno16777736ONBOOT=yesIPADDR=192.168.10.200NETMASK=255.255.255.0GATEWAY=192.168.10.1HWADDR=00:0c:29:35:4b:51</code></pre><p><strong>Client：</strong></p><pre><code class="bash">[root@Client network-scripts]# cat /etc/sysconfig/network-scripts/ifcfg-eno16777736 TYPE=EthernetBOOTPROTO=noneNAME=eno16777736ONBOOT=yesIPADDR=10.10.10.2NETMASK=255.255.255.0HWADDR=00:0c:29:fa:16:ed</code></pre><h3 id="lvs的配置"><a href="#lvs的配置" class="headerlink" title="lvs的配置"></a>lvs的配置</h3><p>配置完网络后，进行lvs的配置，以下配置只在Director上操作。<br>ipvs已经集成在我们内核里面了，不需要重新编译内核，只需要安装管理套件即可。<br>如何查看我们内核是否支持ipvs呢，使用以下命令：</p><pre><code class="bash">$ cat /boot/config-3.10.0-123.el7.x86_64 | grep -i ipvs# IPVS transport protocol load balancing support# IPVS scheduler# IPVS application helper</code></pre><p>如果出现以上信息，即表示内核支持ipvs</p><h3 id="安装ipvsadm套件："><a href="#安装ipvsadm套件：" class="headerlink" title="安装ipvsadm套件："></a>安装ipvsadm套件：</h3><pre><code class="bash">yum -y install ipvsadm</code></pre><h3 id="开启转发功能："><a href="#开启转发功能：" class="headerlink" title="开启转发功能："></a>开启转发功能：</h3><pre><code class="bash">echo 1 &gt; /proc/sys/net/ipv4/ip_forward </code></pre><h3 id="ipvsadm的配置"><a href="#ipvsadm的配置" class="headerlink" title="ipvsadm的配置"></a>ipvsadm的配置</h3><pre><code class="bash">$ ipvsadm -A -t 10.10.10.1:80 -s wrr$ ipvsadm -a -t 10.10.10.1:80 -r 192.168.10.100 -m -w 1  （-m使用NAT模式，默认是-g的DR模式）$ ipvsadm -a -t 10.10.10.1:80 -r 192.168.10.200 -m -w 3</code></pre><p>这里我们的调度算法使用加权轮循，ipvsadm的具体参数使用方法用–help自行查看</p><p>随后在RS1和RS2上分别安装httpd服务，然后写一个index.html页面，为了区分两台RS的内容，我们RS1上写This is RealServer 1，RS2上我们写This is RealServer 2，随后可以进行测试了，为了排除防火墙的干扰，我们先把防火墙关掉再进行测试。iptables -F</p><p>切换到Client进行请求，注意这里我们请求的地址应该是Director上的公网ip地址，不要搞错了</p><pre><code class="bash">[root@Client ~]# curl http://10.10.10.1This is RealServer 2[root@Client ~]# curl http://10.10.10.1This is RealServer 2[root@Client ~]# curl http://10.10.10.1This is RealServer 2[root@Client ~]# curl http://10.10.10.1This is RealServer 1[root@Client ~]# curl http://10.10.10.1This is RealServer 2[root@Client ~]# curl http://10.10.10.1This is RealServer 2[root@Client ~]# curl http://10.10.10.1This is RealServer 2[root@Client ~]# curl http://10.10.10.1This is RealServer 1</code></pre><p>可以看到，我们的请求丢给RS2三次，然后丢给RS1一次，再丢给RS2三次，lvs的调度基本上而没有出现问题。</p><p>然后我们使用压力测试工具ab进行大量的请求模拟</p><pre><code class="bash">ab -c 10 -n 10000 http://10.10.10.1/index.html</code></pre><p>完成后切换到Director查看一下连接数，可以看到大致是1:3的比例。</p><pre><code class="bash">[root@Director ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  10.10.10.1:80 wrr  -&gt; 192.168.10.100:80            Masq    1      0          2501        -&gt; 192.168.10.200:80            Masq    3      0          7503     </code></pre><h2 id="LVS-DR"><a href="#LVS-DR" class="headerlink" title="LVS-DR"></a>LVS-DR</h2><p><img src="/images/8a7a14ff-5d26-4be6-92e3-75df124b4c8f-Image.png" alt="8a7a14ff-5d26-4be6-92e3-75df124b4c8f-Image.png" title="8a7a14ff-5d26-4be6-92e3-75df124b4c8f-Image.png"></p><h3 id="LVS-DR特性"><a href="#LVS-DR特性" class="headerlink" title="LVS-DR特性"></a>LVS-DR特性</h3><ul><li>RealServer必须与Director在同一网络</li><li>RealServer不需要是一个私有ip地址</li><li>Director将接收进来的数据包，根据调度算法将数据包转发到后端的RealServer上</li><li>RealServer不需要使用Director作为默认网关</li><li>能支持更多操作系统</li><li>相对于NAT模式来说，能支持更多的RealServer</li></ul><h3 id="lvs中内核参数作用"><a href="#lvs中内核参数作用" class="headerlink" title="lvs中内核参数作用"></a>lvs中内核参数作用</h3><p>在2.4.26及2.6.4以后的内核中，系统默认支持两个内核参数</p><ul><li><p>arp_announce：对网络接口上本地ip地址发出的ARP回应做出相应级别的限制<br>  0（默认）：在任意网络接口上的任何本地地址<br>  1：尽量避免不在该网络接口子网段的本地地址，当发起ARP请求的源地址是被设置应该经由路由达到此网络接口的时候很有用，此时会检查来访ip是否为所有接口上的子网段内ip之一，如果该来访ip不属于各个网络接口上的子网段内，那么将采用级别2的方式来进行处理。<br>  2：对查询目标使用最适当的本地地址，在此模式下将忽略这个ip数据包的源地址并尝试选择与能与该地址通信的本地地址。首要是选择所有的网络接口的子网中外出访问子网中包含该目标ip地址的本地地址。如果没有合适的地址被发现，将选择当前的发送网络接口或其他的有可能接收到该ARP回应的网络接口来进行发送。</p></li><li><p>arp_ignore：定义对目标地址为本地ip的ARP询问不同的应答模式<br>  0（默认）：回应任何网络接口上对任何本地ip地址的ARP查询请求<br>  1：只回答目标ip地址是来访网络接口本地地址的ARP查询请求<br>  2：只回答目标ip地址是来访网络接口本地地址的ARP查询请求，且来访ip必须在该网络接口的子网段内<br>  3：不回应该网络界面的ARP请求，而只对设置的唯一和链接地址做出回应addresses are<br>  4-7：保留未使用<br>  8：不回应所有（本地地址）的ARP查询请求</p></li></ul><h3 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h3><p><strong>Director：</strong></p><pre><code class="bash">192.168.10.1（eno16777736）192.168.10.250（eno16777736:1）（vip）</code></pre><p><strong>RS1：</strong></p><pre><code class="bash">192.168.10.100（eno16777736）192.168.10.250（lo:1）（vip）</code></pre><p><strong>RS2：</strong></p><pre><code class="bash">192.168.10.200（eno16777736）192.168.10.250（lo:1）（vip）</code></pre><h3 id="Director上配置："><a href="#Director上配置：" class="headerlink" title="Director上配置："></a>Director上配置：</h3><pre><code class="bash">ifconfig eno16777736:1 $vip broadcast $vip netmask 255.255.255.255 uproute add -host $vip dev eno16777736:1ipvsadm -Cipvsadm -A -t $vip:80 -s wlcipvsadm -a -t $vip:80 -r 192.169.10.100 -g -w 1   （-g使用DR模式，也是默认的模式）ipvsadm -a -t $vip:80 -r 192.169.10.200 -g -w 2</code></pre><h3 id="RS上配置（1和2配置相同）："><a href="#RS上配置（1和2配置相同）：" class="headerlink" title="RS上配置（1和2配置相同）："></a>RS上配置（1和2配置相同）：</h3><pre><code class="bash">echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignoreecho 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announceecho 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announceifconfig lo:1 $vip broadcast $vip netmask 255.255.255.255 uproute add -host $vip dev lo:1</code></pre><p>上面绑定VIP的掩码是”255.255.255.255″，说明广播地址是其本身，那么他就不会将ARP发送到实际的自己该属于的广播域了，这样防止与LVS上VIP冲突，而导致IP冲突。</p><h3 id="客户端配置："><a href="#客户端配置：" class="headerlink" title="客户端配置："></a>客户端配置：</h3><p>将ip设置为<code>192.168.10.*</code>，同一网段即可（注意不要冲突）。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="bash">[root@Client ~]# curl http://192.168.10.250This is RealServer 1[root@Client ~]# curl http://192.168.10.250This is RealServer 2[root@Client ~]# curl http://192.168.10.250This is RealServer 2[root@Client ~]# curl http://192.168.10.250This is RealServer 1[root@Client ~]# curl http://192.168.10.250This is RealServer 2[root@Client ~]# curl http://192.168.10.250This is RealServer 2[root@Client ~]# curl http://192.168.10.250</code></pre><h2 id="LVS-TUN"><a href="#LVS-TUN" class="headerlink" title="LVS-TUN"></a>LVS-TUN</h2><h3 id="LVS-TUN特性"><a href="#LVS-TUN特性" class="headerlink" title="LVS-TUN特性"></a>LVS-TUN特性</h3><ul><li>集群节点可以跨越互联网</li><li>RIP必须是公网地址</li><li>Director仅处理入站请求，响应报文直接由RS响应</li><li>RS网关不能指向Director</li><li>只有支持隧道功能的OS才能用于RS</li><li>不支持端口映射</li></ul><h2 id="LVS持久连接"><a href="#LVS持久连接" class="headerlink" title="LVS持久连接"></a>LVS持久连接</h2><p>无论使用什么算法，LVS持久都能实现在一定时间内，将来自同一个客户端请求派发至此前选定的RS</p><p>持久连接模板（内存缓冲区）：<br>每一个客户端，及分配给它的RS的映射关系；</p><p>ipvsadm -A …-p timeout：<br>timeout：持久连接时长，默认300秒</p><p>在基于SSL，需要用到持久连接；</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用sysbench进行压力测试</title>
      <link href="/2018/10/06/Mysql/%E4%BD%BF%E7%94%A8sysbench%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/10/06/Mysql/%E4%BD%BF%E7%94%A8sysbench%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="使用sysbench进行压力测试"><a href="#使用sysbench进行压力测试" class="headerlink" title="使用sysbench进行压力测试"></a>使用sysbench进行压力测试</h1><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>之前尝试使用sysbench1.0+版本进行测试，但是装上去后不知道什么原因（可能是我环境不干净），出现Illegal instruction错误，放弃1.0，使用0.4.12版本，成功完成安装测试。</p><p>操作系统</p><pre><code class="bash">[root@lyucan lib]# cat /etc/redhat-releaseCentOS Linux release 7.1.1503 (Core)</code></pre><p>mysql安装路径</p><pre><code class="bash">[root@lyucan mysql]# pwd/usr/local/mysql[root@lyucan mysql]# ls -ltotal 72drwxr-xr-x.  2 root  root   4096 Apr  9 01:01 bin-rw-r--r--.  1  7161 31415 17987 Dec 28 11:46 COPYINGdrwxr-xr-x.  2 root  root     52 Apr  9 01:01 docsdrwxr-xr-x.  3 root  root   4096 Apr  9 01:01 includedrwxr-xr-x.  5 root  root   4096 Apr  9 01:01 libdrwxr-xr-x.  4 root  root     28 Apr  9 01:01 man-rw-r-----.  1 mysql mysql 27793 Apr  9 19:45 mysqld.err-rw-r-----.  1 mysql mysql     6 Apr  9 19:45 mysqld.pid-rw-r--r--.  1  7161 31415  2478 Dec 28 11:46 READMEdrwxr-xr-x. 28 root  root   4096 Apr  9 01:01 sharedrwxr-xr-x.  2 root  root     86 Apr  9 01:01 support-files</code></pre><p>mysql数据文件路径</p><pre><code class="bash">[root@lyucan mysql]# pwd/data/mysql[root@lyucan mysql]# ls -ltotal 122928-rw-r-----. 1 mysql mysql       56 Apr  9 01:07 auto.cnf-rw-r-----. 1 mysql mysql      367 Apr  9 19:45 ib_buffer_pool-rw-r-----. 1 mysql mysql 12582912 Apr  9 19:58 ibdata1-rw-r-----. 1 mysql mysql 50331648 Apr  9 19:58 ib_logfile0-rw-r-----. 1 mysql mysql 50331648 Apr  9 01:07 ib_logfile1-rw-r-----. 1 mysql mysql 12582912 Apr  9 19:56 ibtmp1drwxr-x---. 2 mysql mysql     4096 Apr  9 01:07 mysqldrwxr-x---. 2 mysql mysql     8192 Apr  9 01:07 performance_schemadrwxr-x---. 2 mysql mysql     8192 Apr  9 01:07 sys-rw-rw-rw-. 1 mysql mysql       57 Apr  9 19:46 t1_bak-rw-rw-rw-. 1 mysql mysql       57 Apr  9 19:52 t1_bak_1drwxr-x---. 2 mysql mysql       79 Apr  9 19:58 test-rw-rw-rw-. 1 mysql mysql      346 Apr  9 19:45 user_bak</code></pre><h2 id="安装sysbench"><a href="#安装sysbench" class="headerlink" title="安装sysbench"></a>安装sysbench</h2><p>软件地址 <a href="http://qncdn-open.baihuzi.com/files/sysbench-0.4.12.14.tar.gz">http://qncdn-open.baihuzi.com/files/sysbench-0.4.12.14.tar.gz</a></p><p>解压sysbench</p><pre><code class="bash">[root@lyucan ~]# tar -xf sysbench-0.4.12.14.tar.gz</code></pre><p>安装依赖库</p><pre><code class="bash">[root@lyucan mysql]# yum install automake libtool -y</code></pre><p>编译安装sysbench</p><pre><code class="bash">[root@lyucan ~]# cd sysbench-0.4.12.14/[root@lyucan sysbench-1.0]# ./configure --with-mysql-includes=/usr/local/mysql/include/ --with-mysql-libs=/usr/local/mysql/lib/[root@lyucan sysbench-1.0]# make &amp;&amp; make install</code></pre><p>安装完成后，可能出现下面的问题</p><pre><code class="bash">[root@lyucan ~]# sysbench --helpsysbench: error while loading shared libraries: libmysqlclient.so.20: cannot open shared object file: No such file or directory</code></pre><p>是由于找不到mysql 的libmysqlclient.so.20 文件导致的，执行下面命令可解决上述问题</p><pre><code class="bash">[root@lyucan lib]# export LD_LIBRARY_PATH=&#39;/usr/local/mysql/lib/&#39;      ##这里的lib路径根据实际情况修改</code></pre><h2 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h2><h3 id="创建测试数据库"><a href="#创建测试数据库" class="headerlink" title="创建测试数据库"></a>创建测试数据库</h3><pre><code class="sql">mysql&gt; create database dbtest;Query OK, 1 row affected (0.00 sec)</code></pre><p>测试的时候可以把线程数设置成机器的线程个数：</p><pre><code class="bash">#查看物理cpu个数[root@lyucan test]# grep &quot;physical id&quot; /proc/cpuinfo | sort -u | wc -l1#查看核心数量[root@lyucan test]# grep &quot;core id&quot; /proc/cpuinfo | sort -u | wc -l1#查看线程数量[root@lyucan test]# grep &quot;processor&quot; /proc/cpuinfo | sort -u | wc -l4</code></pre><p>可以使用帮助命令查看测试不同的性能所需要的参数，cpu，内存等；</p><pre><code class="bash">[root@lyucan ~]# sysbench --test=cpu helpsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkcpu options:  --cpu-max-prime=N      upper limit for primes generator [10000]--cpu-max-prime=N      用来选项指定最大的素数，具体参数可以根据CPU的性能来设置，默认为10000</code></pre><h3 id="cpu测试实例"><a href="#cpu测试实例" class="headerlink" title="cpu测试实例"></a>cpu测试实例</h3><pre><code class="bash">[root@lyucan ~]# sysbench --test=cpu --cpu-max-prime=10000 --num-threads=4 runsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkRunning the test with following options:Number of threads: 4Random number generator seed is 0 and will be ignoredDoing CPU performance benchmarkPrimer numbers limit: 10000Threads started!Done.General statistics:    total time:                          3.2167s    total number of events:              10000    total time taken by event execution: 12.8329    response time:         min:                                  1.11ms         avg:                                  1.28ms         max:                                  2.56ms         approx.  95 percentile:               1.57msThreads fairness:    events (avg/stddev):           2500.0000/133.41    execution time (avg/stddev):   3.2082/0.00</code></pre><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><pre><code class="bash">[root@lyucan ~]# sysbench --test=memory helpsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkmemory options:  --memory-block-size=SIZE    size of memory block for test [1K]  --memory-total-size=SIZE    total size of data to transfer [100G]  --memory-scope=STRING       memory access scope &#123;global,local&#125; [global]  --memory-hugetlb=[on|off]   allocate memory from HugeTLB pool [off]  --memory-oper=STRING        type of memory operations &#123;read, write, none&#125; [write]  --memory-access-mode=STRING memory access mode &#123;seq,rnd&#125; [seq]参数详解：  --memory-block-size=SIZE      测试内存块的大小，默认为1K  --memory-total-size=SIZE       数据传输的总大小，默认为100G  --memory-scope=STRING       内存访问的范围，包括全局和本地范围，默认为global  --memory-hugetlb=[on|off]     是否从HugeTLB池分配内存的开关，默认为off  --memory-oper=STRING        内存操作的类型，包括read, write, none，默认为write  --memory-access-mode=STRING 内存访问模式，包括seq,rnd两种模式，默认为seq</code></pre><h3 id="内存测试实例："><a href="#内存测试实例：" class="headerlink" title="内存测试实例："></a>内存测试实例：</h3><pre><code class="bash">[root@lyucan ~]# sysbench --test=memory --num-threads=2 --memory-block-size=8192 --memory-total-size=1G runsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkRunning the test with following options:Number of threads: 2Random number generator seed is 0 and will be ignoredDoing memory operations speed testMemory block size: 8KMemory transfer size: 1024MMemory operations type: writeMemory scope type: globalThreads started!Done.Operations performed: 131072 (190211.43 ops/sec)1024.00 MB transferred (1486.03 MB/sec)General statistics:    total time:                          0.6891s    total number of events:              131072    total time taken by event execution: 0.6851    response time:         min:                                  0.00ms         avg:                                  0.01ms         max:                                  0.10ms         approx.  95 percentile:               0.01msThreads fairness:    events (avg/stddev):           65536.0000/1391.00    execution time (avg/stddev):   0.3425/0.01</code></pre><h3 id="oltp事务"><a href="#oltp事务" class="headerlink" title="oltp事务"></a>oltp事务</h3><pre><code class="bash">[root@lyucan ~]# sysbench --test=oltp helpsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkoltp options:  --oltp-test-mode=STRING                  test type to use &#123;simple,complex,nontrx,sp&#125; [complex]  --oltp-reconnect-mode=STRING             reconnect mode &#123;session,transaction,query,random&#125; [session]  --oltp-sp-name=STRING                    name of store procedure to call in SP test mode []  --oltp-read-only=[on|off]                generate only &#39;read&#39; queries (do not modify database) [off]  --oltp-avoid-deadlocks=[on|off]          generate update keys in increasing order to avoid deadlocks [off]  --oltp-skip-trx=[on|off]                 skip BEGIN/COMMIT statements [off]  --oltp-range-size=N                      range size for range queries [100]  --oltp-point-selects=N                   number of point selects [10]  --oltp-use-in-statement=N                Use IN-statement with 10 PK lookups per query [0]  --oltp-simple-ranges=N                   number of simple ranges [1]  --oltp-sum-ranges=N                      number of sum ranges [1]  --oltp-order-ranges=N                    number of ordered ranges [1]  --oltp-distinct-ranges=N                 number of distinct ranges [1]  --oltp-index-updates=N                   number of index update [1]  --oltp-non-index-updates=N               number of non-index updates [1]  --oltp-nontrx-mode=STRING                mode for non-transactional test &#123;select, update_key, update_nokey, insert, delete&#125; [select]  --oltp-auto-inc=[on|off]                 whether AUTO_INCREMENT (or equivalent) should be used on id column [on]  --oltp-connect-delay=N                   time in microseconds to sleep after connection to database [10000]  --oltp-user-delay-min=N                  minimum time in microseconds to sleep after each request [0]  --oltp-user-delay-max=N                  maximum time in microseconds to sleep after each request [0]  --oltp-table-comment-string=STRING       comment on table []  --oltp-table-name=STRING                 name of test table [sbtest]  --oltp-table-size=N                      number of records in test table [10000]  --oltp-dist-type=STRING                  random numbers distribution &#123;uniform,gaussian,special&#125; [special]  --oltp-dist-iter=N                       number of iterations used for numbers generation [12]  --oltp-dist-pct=N                        percentage of values to be treated as &#39;special&#39; (for special distribution) [1]  --oltp-dist-res=N                        percentage of &#39;special&#39; values to use (for special distribution) [75]  --oltp-point-select-mysql-handler=[on|off]Use MySQL HANDLER for point select [off]  --oltp-point-select-all-cols=[on|off]    select all columns for the point-select query [off]  --oltp-secondary=[on|off]                Use a secondary index in place of the PRIMARY index [off]  --oltp-num-partitions=N                  Number of partitions used for test table [0]  --oltp-num-tables=N                      Number of test tables [1]General database options:  --db-driver=STRING  specifies database driver to use (&#39;help&#39; to get list of available drivers)  --db-ps-mode=STRING prepared statements usage mode &#123;auto, disable&#125; [auto]Compiled-in database drivers:  mysql - MySQL drivermysql options:  --mysql-host=[LIST,...]       MySQL server host [localhost]  --mysql-port=N                MySQL server port [3306]  --mysql-socket=STRING         MySQL socket  --mysql-user=STRING           MySQL user [sbtest]  --mysql-password=STRING       MySQL password []  --mysql-db=STRING             MySQL database name [sbtest]  --mysql-table-engine=STRING   storage engine to use for the test table &#123;myisam,innodb,bdb,heap,ndbcluster,federated&#125; [innodb]  --mysql-engine-trx=STRING     whether storage engine used is transactional or not &#123;yes,no,auto&#125; [auto]  --mysql-ssl=[on|off]          use SSL connections, if available in the client library [off]  --myisam-max-rows=N           max-rows parameter for MyISAM tables [1000000]  --mysql-create-options=STRING additional options passed to CREATE TABLE []参数详解：  --memory-block-size=SIZE      测试内存块的大小，默认为1K  --oltp-user-delay-min=N    每个请求最短等待时间。单位是ms。默认是0  --oltp-user-delay-max=N    每个请求最长等待时间。单位是ms。默认是0  --oltp-table-name=STRING  测试时使用到的表名。默认是sbtest  --oltp-table-size=N         测试表的记录数。默认是10000  --oltp-dist-type=STRING    分布的随机数&#123;uniform(均匀分布),Gaussian(高斯分布),special(空间分布)&#125;。默认是special  --oltp-dist-iter=N    产生数的迭代次数。默认是12  --oltp-dist-pct=N    特殊分布的百分比值 (for special distribution)。 默认是1  --oltp-dist-res=N    ‘special’的百分比值。默认是75General database options:  --db-driver=STRING  specifies database driver to use (&#39;help&#39; to get list of available drivers)  --db-ps-mode=STRING prepared statements usage mode &#123;auto, disable&#125; [auto]Compiled-in database drivers:  mysql - MySQL driver  pgsql - PostgreSQL driver  mysql options:  --mysql-host=[LIST,...]       MySQL server 地址 默认[localhost]  --mysql-port=N                MySQL server 端口 默认[3306]  --mysql-socket=STRING         MySQL socket  --mysql-user=STRING           MySQL 用户名 默认[sbtest]  --mysql-password=STRING       MySQL 密码 默认[]  --mysql-db=STRING             MySQL database name [sbtest]  --mysql-table-engine=STRING   使用的存储引擎包括&#123;myisam,innodb,bdb,heap,ndbcluster,federated&#125; 默认[innodb]  --mysql-engine-trx=STRING     whether storage engine used is transactional or not &#123;yes,no,auto&#125; [auto]  --mysql-ssl=[on|off]          use SSL connections, if available in the client library [off]  --myisam-max-rows=N           max-rows parameter for MyISAM tables [1000000]  --mysql-create-options=STRING additional options passed to CREATE TABLE []pgsql options:  --pgsql-host=STRING     PostgreSQL server host [localhost]  --pgsql-port=N          PostgreSQL server port [5432]  --pgsql-user=STRING     PostgreSQL user [sbtest]  --pgsql-password=STRING PostgreSQL password []  --pgsql-db=STRING       PostgreSQL database name [sbtest]</code></pre><h3 id="事务测试实例："><a href="#事务测试实例：" class="headerlink" title="事务测试实例："></a>事务测试实例：</h3><pre><code class="bash">#准备数据[root@lyucan ~]# sysbench --test=oltp --mysql-db=dbtest --mysql-table-engine=innodb --db-driver=mysql --mysql-socket=/tmp/mysql.sock --mysql-user=root --mysql-password=echo123. --num-threads=4 --oltp-num-tables=10 --oltp-table-size=500000 preparesysbench 0.4.12.10:  multi-threaded system evaluation benchmarkCreating table &#39;sbtest6&#39;...Creating table &#39;sbtest5&#39;...Creating table &#39;sbtest&#39;...Creating table &#39;sbtest4&#39;...Creating table &#39;sbtest1&#39;...Creating table &#39;sbtest3&#39;...Creating table &#39;sbtest2&#39;...Creating table &#39;sbtest7&#39;...Creating table &#39;sbtest9&#39;...Creating table &#39;sbtest8&#39;...Creating 500000 records in table &#39;sbtest3&#39;...Creating 500000 records in table &#39;sbtest6&#39;...Creating 500000 records in table &#39;sbtest&#39;...Creating 500000 records in table &#39;sbtest8&#39;...Creating 500000 records in table &#39;sbtest7&#39;...Creating 500000 records in table &#39;sbtest1&#39;...Creating 500000 records in table &#39;sbtest9&#39;...Creating 500000 records in table &#39;sbtest4&#39;...Creating 500000 records in table &#39;sbtest5&#39;...Creating 500000 records in table &#39;sbtest2&#39;...#运行测试[root@lyucan ~]# sysbench --test=oltp --mysql-db=dbtest --mysql-table-engine=innodb --db-driver=mysql --mysql-socket=/tmp/mysql.sock --mysql-user=root --mysql-password=echo123. --num-threads=4 --oltp-num-tables=10 --oltp-table-size=500000 runsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkRunning the test with following options:Number of threads: 4Random number generator seed is 0 and will be ignoredDoing OLTP test.Running mixed OLTP testUsing Special distribution (12 iterations,  1 pct of values are returned in 75 pct cases)Using &quot;BEGIN&quot; for starting transactionsUsing auto_inc on the id columnMaximum number of requests for OLTP test is limited to 10000Using 10 test tablesThreads started!Done.OLTP test statistics:    queries performed:        read:                            140000                      #读总数        write:                           50000                       #写总数        other:                           20000                       #其他操作总数        total:                           210000                      #全部总数    transactions:                        10000  (565.77 per sec.)    #总事务数（每秒处理事务数）    deadlocks:                           0      (0.00 per sec.)      #总死锁（每秒死锁）    read/write requests:                 190000 (10749.72 per sec.)  #总读写请求（每秒读写请求）    other operations:                    20000  (1131.55 per sec.)   #其他操作General statistics:    total time:                          17.6749s                    #总耗时    total number of events:              10000                       #总事务数    total time taken by event execution: 70.5829                     #所有事务耗时总时间    response time:         min:                                  4.21ms         avg:                                  7.06ms         max:                                189.03ms         approx.  95 percentile:               9.24msThreads fairness:    events (avg/stddev):           2500.0000/2.45    execution time (avg/stddev):   17.6457/0.00#清理数据[root@lyucan ~]# sysbench --test=oltp --mysql-db=dbtest --mysql-table-engine=innodb --db-driver=mysql --mysql-socket=/tmp/mysql.sock --mysql-user=root --mysql-password=echo123. --num-threads=4 --oltp-num-tables=10 --oltp-table-size=500000 cleanupsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkDropping table &#39;sbtest&#39;...Dropping table &#39;sbtest1&#39;...Dropping table &#39;sbtest2&#39;...Dropping table &#39;sbtest3&#39;...Dropping table &#39;sbtest4&#39;...Dropping table &#39;sbtest5&#39;...Dropping table &#39;sbtest6&#39;...Dropping table &#39;sbtest7&#39;...Dropping table &#39;sbtest8&#39;...Dropping table &#39;sbtest9&#39;...Done.</code></pre><h3 id="io"><a href="#io" class="headerlink" title="io"></a>io</h3><pre><code class="bash">[root@lyucan ~]# sysbench --test=fileio helpsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkfileio options:  --file-num=N                  number of files to create [128]  --file-block-size=N           block size to use in all IO operations [16384]  --file-total-size=SIZE        total size of files to create [2G]  --file-test-mode=STRING       test mode &#123;seqwr, seqrewr, seqrd, rndrd, rndwr, rndrw&#125;  --file-io-mode=STRING         file operations mode &#123;sync,async,mmap&#125; [sync]  --file-extra-flags=STRING     additional flags to use on opening files &#123;sync,dsync,direct&#125; []  --file-fsync-freq=N           do fsync() after this number of requests (0 - don&#39;t use fsync()) [100]  --file-fsync-all=[on|off]     do fsync() after each write operation [off]  --file-fsync-end=[on|off]     do fsync() at the end of test [on]  --file-fsync-mode=STRING      which method to use for synchronization &#123;fsync, fdatasync&#125; [fsync]  --file-merged-requests=N      merge at most this number of IO requests if possible (0 - don&#39;t merge) [0]  --file-rw-ratio=N             reads/writes ratio for combined test [1.5]参数详解：  --file-num=N          代表生成测试文件的数量，默认为128。  --file-block-size=N      测试时所使用文件块的大小，如果想磁盘针对innodb存储引擎进行测试，可以将其设置为16384，即innodb存储引擎页的大小。默认为16384。  --file-total-size=SIZE     创建测试文件的总大小，默认为2G大小。  --file-test-mode=STRING 文件测试模式，包含：seqwr(顺序写), seqrewr(顺序读写), seqrd(顺序读), rndrd(随机读), rndwr(随机写), rndrw(随机读写)。  --file-io-mode=STRING   文件操作的模式，sync（同步）,async（异步）,fastmmap（快速mmap）,slowmmap（慢速mmap），默认为sync同步模式。  --file-async-backlog=N   对应每个线程队列的异步操作数，默认为128。  --file-extra-flags=STRING 打开文件时的选项，这是与API相关的参数。  --file-fsync-freq=N      执行fsync()函数的频率。fsync主要是同步磁盘文件，因为可能有系统和磁盘缓冲的关系。 0代表不使用fsync函数。默认值为100。  --file-fsync-all=[on|off]  每执行完一次写操作，就执行一次fsync。默认为off。  --file-fsync-end=[on|off] 在测试结束时执行fsync函数。默认为on。  --file-fsync-mode=STRING文件同步函数的选择，同样是和API相关的参数，由于多个操作系统对于fdatasync支持不同，因此不建议使用fdatasync。默认为fsync。  --file-merged-requests=N 大多情况下，合并可能的IO的请求数，默认为0。  --file-rw-ratio=N         测试时的读写比例，默认时为1.5，即可3：2。</code></pre><h3 id="io测试实例："><a href="#io测试实例：" class="headerlink" title="io测试实例："></a>io测试实例：</h3><pre><code class="bash">#准备数据[root@lyucan test]# sysbench --test=fileio --file-total-size=2G --file-num=8 --file-test-mode=rndrw --num-threads=4  preparesysbench 0.4.12.10:  multi-threaded system evaluation benchmark8 files, 262144Kb each, 2048Mb totalCreating files for the test...Extra file open flags: 0Creating file test_file.0Creating file test_file.1Creating file test_file.2Creating file test_file.3Creating file test_file.4Creating file test_file.5Creating file test_file.6Creating file test_file.72147483648 bytes written in 18.36 seconds (111.52 MB/sec).#运行测试[root@lyucan test]# sysbench --test=fileio --file-total-size=2G --file-num=8 --file-test-mode=rndrw --num-threads=4  runsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkRunning the test with following options:Number of threads: 4Random number generator seed is 0 and will be ignoredExtra file open flags: 08 files, 256Mb each2Gb total file sizeBlock size 16KbNumber of random requests for random IO: 10000Read/Write ratio for combined random IO test: 1.50Periodic FSYNC enabled, calling fsync() each 100 requests.Calling fsync() at the end of test, Enabled.Using synchronous I/O modeDoing random r/w testThreads started!Done.Operations performed:  6000 reads, 4000 writes, 800 Other = 10800 TotalRead 93.75Mb  Written 62.5Mb  Total transferred 156.25Mb  (10.638Mb/sec)  680.81 Requests/sec executedGeneral statistics:    total time:                          14.6885s    total number of events:              10000    total time taken by event execution: 0.2046    response time:         min:                                  0.01ms         avg:                                  0.02ms         max:                                  0.14ms         approx.  95 percentile:               0.04msThreads fairness:    events (avg/stddev):           2500.0000/27.23    execution time (avg/stddev):   0.0511/0.00#清理数据[root@lyucan test]# sysbench --test=fileio --file-total-size=2G --file-num=8 --file-test-mode=rndrw --num-threads=4  cleanupsysbench 0.4.12.10:  multi-threaded system evaluation benchmarkRemoving test files...</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防火墙iptables和firewall-cmd</title>
      <link href="/2018/10/06/%E8%BF%90%E7%BB%B4/%E9%98%B2%E7%81%AB%E5%A2%99iptables%E5%92%8Cfirewall-cmd/"/>
      <url>/2018/10/06/%E8%BF%90%E7%BB%B4/%E9%98%B2%E7%81%AB%E5%A2%99iptables%E5%92%8Cfirewall-cmd/</url>
      
        <content type="html"><![CDATA[<h1 id="防火墙iptables和firewall-cmd"><a href="#防火墙iptables和firewall-cmd" class="headerlink" title="防火墙iptables和firewall-cmd"></a>防火墙iptables和firewall-cmd</h1><p>防火墙是通过定义一些有序的规则，并管理进入到网络内的主机数据包的一种机制，更广义的来说，只要能分析与过滤进出我们管理的网络的数据包的数据，就可以称之为防火墙。</p><p>防火墙最大的功能就是帮助你限制某些服务的访问来源。这就是为什么搭建服务器的时候有些服务启动不了的原因。<br>防火墙并不能有效阻挡病毒或者密码程序，且防火墙对来自内部的攻击无能为力</p><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>iptables 是一种软件防火墙，称为数据包过滤软件。iptables是一种低级工具，他仅能调整IPv4防火墙规则。为保证更完整的防火墙覆盖率，需要使用其他的实用程序，例如用于IPv6的ip6tables和用于软件桥的ebtables</p><p>数据包进入流程：规则顺序的重要性<br>iptables 利用的是分析数据包的报头数据，根据报头数据与定义的规则来决定该数据包是否可以进入主机或者是被丢弃。也就是说，根据数据包的分析资料对比预先定义的规则内容，若数据包与规则内容相同则进行相关动作，否则进入下一条负责的比对。如果对比第一条就成功了，则不会比对后面的规则，所以规则的顺序非常重要。当规则顺序排列错误时，就会产生很严重的错误。</p><p>iptables的表格（table）与链（chain）<br>(三表（filter、NAT、Mangle）五链（INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING）)<br>iptables里面有多个表格，每个表格定义出自己的默认策略与规则，且每个表格的用途都不一样。</p><ul><li><p>Filter（过滤器）：主要跟进入linux本机的数据包有关，是默认的table<br>  INPUT：主要与想进入本机的数据包有关<br>  OUTPUT：主要与linux本机想要送出的数据包有关<br>  FORWARD：与linux本机没有关系，它可以传递数据包到后端的计算机中，与NAT的table相关性较高</p></li><li><p>NAT（地址转换，Network Address Translation）：这个表格的作用是进行来源于目的地的IP或port转换，与linux本机无关，主要与linux主机后的局域网内的计算机有关<br>  PREROUTING：在进行路由判断之前所要进行的规则（DNAT&#x2F;REDIRECT）<br>  POSTROUTING：在进行路由判断之后所要进行的规则（SNAT&#x2F;MASOUERADE）<br>  OUTPUT：与发送出去的数据包有关</p></li><li><p>Mangle （破坏者）：这个表格主要是与特殊的数据包的路由标志有关，这个表格与特殊标志相关性较高。</p></li></ul><h3 id="查看iptables"><a href="#查看iptables" class="headerlink" title="查看iptables"></a>查看iptables</h3><p>表格定义下面的就是链（chain）<br>由一条条规则组成。</p><p>本机iptables的语法</p><pre><code class="bash">iptables -t filter  -L  -n </code></pre><p>查看规则<br>-t ：指定table，不使用-t选项，则是默认的filter表格<br>-L ：列出目前的table的规则<br>-n：不进行IP与hostname的反查，显示信息的速度会快很多</p><pre><code class="bash">[root@nisa ~]# iptables -t filter -L -n   （-n 以IP形式输出）Chain INPUT (policy ACCEPT)   &lt;=== 针对INPUT链，默认策略为可接受target     prot   opt     source               destination</code></pre><ul><li>target：代表进行的操作，ACCEPT（放行），REJECT（拒绝），DROP（丢弃）,LOG（记录日志，继续匹配下一条规则）</li><li>prot：代表使用的数据包协议，主要有TCP，UDP，ICMP3种</li><li>opt：额外的选项说明</li><li>source：代表此规则是针对哪个来源IP进行限制</li><li>destination：代表此规则是针对哪个目标IP进行限制</li></ul><p>iptables-save列出完整的防火墙规则，输出没有格式化</p><h3 id="定义默认策略"><a href="#定义默认策略" class="headerlink" title="定义默认策略"></a>定义默认策略</h3><pre><code class="bash">iptables -t 【filter，nat】 -P【INPUT，OUTPUT，FORWARD】 【ACCEPT，DROP（这里不能使用REJECT）】这里修改的是 Chain INPUT (policy ACCEPT) 括号里面的默认策略[root@nisa ~]# iptables -t filter -P INPUT DROP[root@nisa ~]# iptables -L  Chain INPUT (policy DROP)  &lt;===设置成了DROPtarget     prot    opt      source                destination     </code></pre><h3 id="自定义链"><a href="#自定义链" class="headerlink" title="自定义链"></a>自定义链</h3><p>添加一个新的链</p><pre><code class="bash">iptables -N RHCEiptables -A RHCE -s 172.25.254.122  -j  ACCEPTiptables -A ACCEPT -j RHCE</code></pre><p>清空自定义链</p><pre><code class="bash">iptables -F  RHCE</code></pre><h3 id="DNAT转换"><a href="#DNAT转换" class="headerlink" title="DNAT转换"></a>DNAT转换</h3><pre><code class="bash"># INBOUNDiptables -t nat -A PREROUTING -p  tcp -d 172.16.1.1  --dport 80  -j DNAT --to-dest  192.128.1.1:8080# OUTBOUNDiptables -t  nat  -A OUTPUT -p tcp --deport 80 -j DNAT --to-dest  192.128.2.1:3128</code></pre><h3 id="SNAT地址伪装"><a href="#SNAT地址伪装" class="headerlink" title="SNAT地址伪装"></a>SNAT地址伪装</h3><pre><code class="bash">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADEiptables -t nat -A POSTROUTING -j SNAT  --to-source 1.2.3.45</code></pre><h3 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h3><pre><code class="bash">iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作-t&lt;表&gt;：指定要操纵的表；包括：       filter包过滤，用于防火墙规则，默认       nat地址转换，用于网关路由器       mangle数据包修改（QOS），用于实现服务质量规则链名：       INPUT：处理输入数据包       OUTPUT：处理输出数据包       FORWARD：处理转发数据包       PREROUTING：用于目标地址转换（DNAT）       POSTROUTING：用于源地址转换（SNAT）-A：向规则链中添加条目；-D：从规则链中删除条目；-I：向规则链中插入条目；-R：替换规则链中的条目；-L：显示规则链中已有的条目；-F：清楚规则链中已有的条目；-Z：清空规则链中的数据包计算器和字节计数器；-N：创建新的用户自定义规则链；-P：定义规则链中的默认目标；-h：显示帮助信息；-p：指定要匹配的数据包协议类型；-s：指定要匹配的数据包源ip地址；-j&lt;目标&gt;：指定要跳转的目标；包括：       accept接收       drop丢弃       redirect重定向、映射、透明代理       snat源地址转换       dnat目标地址转换       masquerade IP地址伪装       log日志记录-i&lt;网络接口&gt;：指定数据包进入本机的网络接口；-o&lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。</code></pre><h3 id="清除已有iptables规则"><a href="#清除已有iptables规则" class="headerlink" title="清除已有iptables规则"></a>清除已有iptables规则</h3><pre><code class="bash">iptables -Fiptables -Xiptables -Z</code></pre><h3 id="开放指定的端口"><a href="#开放指定的端口" class="headerlink" title="开放指定的端口"></a>开放指定的端口</h3><pre><code class="bash">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT #允许本地回环接口(即运行本机访问本机)iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许已建立的或相关连的通行iptables -A OUTPUT -j ACCEPT #允许所有本机向外的访问iptables -A INPUT -p tcp --dport 22 -j ACCEPT #允许访问22端口iptables -A INPUT -p tcp --dport 80 -j ACCEPT #允许访问80端口iptables -A INPUT -p tcp --dport 21 -j ACCEPT #允许ftp服务的21端口iptables -A INPUT -p tcp --dport 20 -j ACCEPT #允许FTP服务的20端口iptables -A INPUT -j reject #禁止其他未允许的规则访问iptables -A FORWARD -j REJECT #禁止其他未允许的规则访问</code></pre><h3 id="屏蔽IP"><a href="#屏蔽IP" class="headerlink" title="屏蔽IP"></a>屏蔽IP</h3><pre><code class="bash">iptables -I INPUT -s 123.45.6.7 -j DROP #屏蔽单个IP的命令iptables -I INPUT -s 123.0.0.0/8 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令iptables -I INPUT -s 124.45.0.0/16 -j DROP #封IP段即从123.45.0.1到123.45.255.254的命令iptables -I INPUT -s 123.45.6.0/24 -j DROP #封IP段即从123.45.6.1到123.45.6.254的命令是</code></pre><h3 id="查看已添加的iptables规则"><a href="#查看已添加的iptables规则" class="headerlink" title="查看已添加的iptables规则"></a>查看已添加的iptables规则</h3><pre><code class="bash">[root@localhost ~]# iptables -nvLChain INPUT (policy ACCEPT 0 packets, 0 bytes)pkts bytes target     prot opt in     out     source               destination        33355   16M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED    0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0          1285 77555 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0              0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22  811 47992 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibitedChain FORWARD (policy ACCEPT 0 packets, 0 bytes)pkts bytes target     prot opt in     out     source               destination            0     0 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibitedChain OUTPUT (policy ACCEPT 35021 packets, 16M bytes)pkts bytes target     prot opt in     out     source               destination        </code></pre><h3 id="删除已添加的iptables规则"><a href="#删除已添加的iptables规则" class="headerlink" title="删除已添加的iptables规则"></a>删除已添加的iptables规则</h3><p>将所有iptables以序号标记显示，执行：</p><pre><code class="bash">iptables -L -n --line-numbers</code></pre><p>比如要删除INPUT里序号为8的规则，执行：</p><pre><code class="bash">iptables -D INPUT 8</code></pre><h3 id="特殊的标志"><a href="#特殊的标志" class="headerlink" title="特殊的标志"></a>特殊的标志</h3><p>除了端口之外，tcp数据包还有特殊的标志，最常见的就是主动链接的SYN标志，在iptables里面还支持“–syn”的处理方式<br>例如，将来自任何地方来源port 1到1023端口主动链接到本地端的1到1023端口的链接丢弃</p><pre><code class="bash">[root@nisa ~]# iptables -A INPUT -i eth0  -p tcp --sport 1:1023 --dport 1:1023 --syn -j DROP</code></pre><h3 id="iptables的外挂模块：state和mac"><a href="#iptables的外挂模块：state和mac" class="headerlink" title="iptables的外挂模块：state和mac"></a>iptables的外挂模块：state和mac</h3><pre><code class="bash">iptables -A INPUT 【-m state】【--state 状态】</code></pre><ul><li>-m：一些外挂模块，主要常见的有state（状态模块），mac（网卡硬件地址）</li><li>–state：一些数据包的状态，主要有：<br>INVALID：无效的数据包，例如破损的数据包状态<br>ESTABLISHED：已经建立成功的状态<br>NEW：想要新建立连接的数据包状态<br>RELATED：这个最常用，表示这个数据包是与主机发送出去的数据包有关</li></ul><p>将已经建立或已发出的请求的相关数据包放行</p><pre><code class="bash">[root@nisa ~]# iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code></pre><p>将无效的数据包丢弃</p><pre><code class="bash">[root@nisa ~]# iptables -A INPUT -m state --state INVALID -j DROP</code></pre><p>另外，iptables还可以针对网卡来进行放行与防御</p><pre><code class="bash">[root@nisa ~]# iptables -A INPUT -m mac --mac-source aa:bb:cc:dd:ee:ff -j REJECT</code></pre><ul><li>–mac-source：就是来源主机的mac</li></ul><p>mutiport指定多个端口</p><pre><code class="bash">[root@nisa ~]# iptables -A INPUT -p tcp -m mutiport --dport 1,2,3,4,5 -j REJECT</code></pre><h2 id="Firewall防火墙工具"><a href="#Firewall防火墙工具" class="headerlink" title="Firewall防火墙工具"></a>Firewall防火墙工具</h2><p>redhat7.0中引入了一种新的与netfilter交互的方法：firewall。该守护进程不仅涵盖了IPv4，IPv6，还能ebtables设置。</p><p>redhat7.0中，可以通过三种方式与netfilter交互：<br>1、直接编辑&#x2F;etc&#x2F;firewall&#x2F;中的配置文件<br>2、使用firewall-config图形工具<br>3、firewall-cmd命令行配置</p><blockquote><p>！！！使用firewall-config进行图形化配置时，左上方Configuration是Runtime时，防火墙配置将不会写入配置文件，重启后规则将失效，若想生成永久配置，需要将其勾选成Permanent，配置完成后，需要立即生效的话，需要在Options中进行Reload Firewalld操作。</p></blockquote><h3 id="使用firewall-cmd命令配置防火墙"><a href="#使用firewall-cmd命令配置防火墙" class="headerlink" title="使用firewall-cmd命令配置防火墙"></a>使用firewall-cmd命令配置防火墙</h3><h4 id="查看默认区域"><a href="#查看默认区域" class="headerlink" title="查看默认区域"></a>查看默认区域</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --get-default-zone public</code></pre><h4 id="设置默认的区域"><a href="#设置默认的区域" class="headerlink" title="设置默认的区域"></a>设置默认的区域</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd  --set-defaults-zone=dmz（默认的区域是public）</code></pre><h4 id="来自192-168-0-0-24网络的所有流量都被分配给internal区域，而且internal区域上打开了mysql的网络接口"><a href="#来自192-168-0-0-24网络的所有流量都被分配给internal区域，而且internal区域上打开了mysql的网络接口" class="headerlink" title="来自192.168.0.0&#x2F;24网络的所有流量都被分配给internal区域，而且internal区域上打开了mysql的网络接口"></a>来自192.168.0.0&#x2F;24网络的所有流量都被分配给internal区域，而且internal区域上打开了mysql的网络接口</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --permanent --zone=internal --add-source=192.168.0.0/24[root@nisa ~]# firewall-cmd --permanent --zone=internal --add-service=mysql[root@nisa ~]# firewall-cmd --reload （重新加载，立即生效）</code></pre><pre><code class="bash">[root@nisa ~]# firewall-cmd --list-all  public (default, active)  interfaces: eno16777736    &lt;===接口名  sources:                        &lt;===源地址  services: dhcpv6-client nfs ssh     &lt;===预定义的各种服务  ports:                     &lt;===端口和协议        masquerade: no   &lt;===地址伪装，私有的网络地址可以被映射到公开的ip地址，这是一次正规的地址转换  forward-ports:      &lt;===地址转发，端口可以映射到另一个端口以及/或者其他主机  icmp-blocks:         &lt;===icmp阻塞  rich rules:              &lt;===自定义规则</code></pre><h4 id="查看接口所属的区域"><a href="#查看接口所属的区域" class="headerlink" title="查看接口所属的区域"></a>查看接口所属的区域</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --get-zone-of-interface=eno16777736 public</code></pre><h4 id="添加源地址到internal区域"><a href="#添加源地址到internal区域" class="headerlink" title="添加源地址到internal区域"></a>添加源地址到internal区域</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --permanent --zone=internal --add-source=192.168.0.0/24success</code></pre><h4 id="添加mysql服务"><a href="#添加mysql服务" class="headerlink" title="添加mysql服务"></a>添加mysql服务</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --permanent --zone=internal --add-service=mysqlsuccess</code></pre><h4 id="添加8080-tcp端口"><a href="#添加8080-tcp端口" class="headerlink" title="添加8080&#x2F;tcp端口"></a>添加8080&#x2F;tcp端口</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --permanent --add-port=8080/tcp；firewall-cmd --reloadsuccesssuccess</code></pre><h4 id="添加端口转发"><a href="#添加端口转发" class="headerlink" title="添加端口转发"></a>添加端口转发</h4><pre><code class="bash">firewall-cmd --permanent --add-forward-ports=【port=xx】：【proto=tcp/udp】：【toport=xx】：【toaddr=ipaddress】</code></pre><h4 id="将22端口的tcp转发到192-168-0-1的32端口"><a href="#将22端口的tcp转发到192-168-0-1的32端口" class="headerlink" title="将22端口的tcp转发到192.168.0.1的32端口"></a>将22端口的tcp转发到192.168.0.1的32端口</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --add-forward-port=port=22:proto=tcp:toport=32:toaddr=192.168.0.1success</code></pre><h4 id="添加地址伪装"><a href="#添加地址伪装" class="headerlink" title="添加地址伪装"></a>添加地址伪装</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --permanent --add-masquerade success</code></pre><h4 id="添加icmp阻塞"><a href="#添加icmp阻塞" class="headerlink" title="添加icmp阻塞"></a>添加icmp阻塞</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --permanent --add-icmp-block=【有以下一些icmp报文类别】destination-unreachable  parameter-problem        router-solicitationecho-reply               redirect                 source-quenchecho-request             router-advertisement     time-exceeded</code></pre><h4 id="添加rich-rules"><a href="#添加rich-rules" class="headerlink" title="添加rich rules"></a>添加rich rules</h4><pre><code class="bash">[root@nisa ~]# firewall-cmd --permanent --add-rich-rule=&#39;rule family=&quot;ipv4&quot; source address=&quot;192.168.0.1&quot; destination address=&quot;192.168.0.2&quot; service name=&quot;ssh&quot; log prefix=&quot;ssh&quot; level=&quot;warning&quot; limit value=&quot;1/m&quot; reject&#39;</code></pre><p>在 –add-rich-rule&#x3D; 后面的全部内容要用单引号或双引号全部括起来，各个小项的值也需要用双引号括起来</p><ul><li>rule family：IP家族，可以使ipv4或ipv6</li><li>source address：源IP地址，也可以是网段</li><li>destination address：目标IP地址，也可以是网段</li><li>service name：服务名</li><li>log prefix：日志名</li><li>level：日志级别</li><li>limit value：日志写入限制，上述定义的是1分钟1次（value后面没有s）</li><li>reject：操作，也可以是accept，drop</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL统计信息收集</title>
      <link href="/2018/09/19/Mysql/MySQL%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2018/09/19/Mysql/MySQL%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL统计信息收集"><a href="#MySQL统计信息收集" class="headerlink" title="MySQL统计信息收集"></a>MySQL统计信息收集</h1><p>1、重启MySQL数据库<br>2、遍历 information_schema.tables表<br>这个库里面的表只支持select查询</p><p>每天读取一下information_schema.tables的信息,读这个表:相当于完成了一次表信息的收集</p><h2 id="统计每个库大小"><a href="#统计每个库大小" class="headerlink" title="统计每个库大小"></a>统计每个库大小</h2><pre><code class="sql">mysql&gt; use information_schema ;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; SELECT TABLE_SCHEMA,SUM(DATA_LENGTH)/1024/1024/1024 as DATA_LENGTH,SUM(INDEX_LENGTH)/1024/1024/1024    as INDEX_LENGTH,SUM(DATA_LENGTH+INDEX_LENGTH)/1024/1024/1024 as SUM_DATA_INDEX FROM information_schema.TABLES    WHERE TABLE_SCHEMA!=&#39;information_schema&#39; AND TABLE_SCHEMA!=&#39;mysql&#39; GROUP BY TABLE_SCHEMA;+--------------------+----------------+----------------+----------------+| TABLE_SCHEMA       | DATA_LENGTH    | INDEX_LENGTH   | SUM_DATA_INDEX |+--------------------+----------------+----------------+----------------+| performance_schema | 0.000000000000 | 0.000000000000 | 0.000000000000 || sys                | 0.000015258789 | 0.000000000000 | 0.000015258789 || test               | 0.000015258789 | 0.000000000000 | 0.000015258789 |+--------------------+----------------+----------------+----------------+2 rows in set (0.08 sec)mysql&gt;</code></pre><h2 id="统计库里每个表的大小"><a href="#统计库里每个表的大小" class="headerlink" title="统计库里每个表的大小"></a>统计库里每个表的大小</h2><pre><code class="sql">mysql&gt; SELECT TABLE_NAME,DATA_LENGTH,INDEX_LENGTH,SUM(DATA_LENGTH+INDEX_LENGTH) AS TOTAL_SIZE    FROM information_schema.TABLES    WHERE TABLE_SCHEMA=&#39;test&#39; GROUP BY TABLE_NAME;+------------+-------------+--------------+------------+| TABLE_NAME | DATA_LENGTH | INDEX_LENGTH | TOTAL_SIZE |+------------+-------------+--------------+------------+| t1         |       16384 |            0 |      16384 |+------------+-------------+--------------+------------+1 row in set (0.00 sec)</code></pre><h2 id="统计所有数据库的大小"><a href="#统计所有数据库的大小" class="headerlink" title="统计所有数据库的大小"></a>统计所有数据库的大小</h2><pre><code class="sql">mysql&gt; select sum(data_length+index_length)/1024/1024/1024 from information_schema.tables;+----------------------------------------------+| sum(data_length+index_length)/1024/1024/1024 |+----------------------------------------------+|                               0.002552489750 |+----------------------------------------------+1 row in set (0.04 sec)</code></pre><blockquote><p>index_length 都为0, 表示只有主键,或是没索引</p></blockquote><h2 id="统计客户端连接数"><a href="#统计客户端连接数" class="headerlink" title="统计客户端连接数"></a>统计客户端连接数</h2><pre><code class="sql">[root@lyucan ~]# netstat -anlp|grep 3306|grep tcp|awk &#39;&#123;print $5&#125;&#39;|awk -F: &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -n20      3 119.123.76.61      1[root@lyucan ~]# mysql -uroot -p -e &quot;show processlist&quot;|awk &#39;&#123;print $3&#125;&#39; |awk -F: &#39;&#123;print $1&#125;&#39; |sort |uniq -c |sort -nrEnter password:      3 119.123.76.61      2 localhost      1 Host[root@lyucan ~]#</code></pre><h2 id="MySQL在什么状态收集统计信息"><a href="#MySQL在什么状态收集统计信息" class="headerlink" title="MySQL在什么状态收集统计信息"></a>MySQL在什么状态收集统计信息</h2><ol><li>访问information_schema.tables 会收集</li><li>数据库重启</li><li>show table status;</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类对象特殊方法__call__()</title>
      <link href="/2018/09/04/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__call__()/"/>
      <url>/2018/09/04/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__call__()/</url>
      
        <content type="html"><![CDATA[<h1 id="类对象特殊方法-call"><a href="#类对象特殊方法-call" class="headerlink" title="类对象特殊方法__call__()"></a>类对象特殊方法__call__()</h1><p>如果在类对象中实现了特殊方法<code>__call__()</code>，那么就可以像调用函数一样直接调用这个类对象的实例对象，从而会自动调用特殊方法<code>__call__()</code>。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def __call__(self):        print(&#39;__call__()被调用了&#39;)mc = MyClass()mc()MyClass()()</code></pre><pre><code class="python">[root@lyucan ~]# ./30.py__call__()被调用了__call__()被调用了</code></pre><p>内置函数<code>callable()</code>用于判断指定对象是否是可调用的，除了函数对象是可调用的之外，对于实现了特殊方法<code>__call__()</code>的类对象，其实例对象也是可调用的。 </p><pre><code class="python">#!/usr/bin/python3def func():    passclass MyClass(object):    def __call__(self):        print(&#39;__call__()被调用了&#39;)print(callable(func))print(callable(MyClass))print(callable(MyClass()))</code></pre><pre><code class="python">[root@lyucan ~]# ./30.pyTrueTrueTrue</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类对象特殊方法——__iter__()、__next__()</title>
      <link href="/2018/09/01/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94__iter__()%E3%80%81__next__()/"/>
      <url>/2018/09/01/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94__iter__()%E3%80%81__next__()/</url>
      
        <content type="html"><![CDATA[<h1 id="类对象特殊方法——iter-、next"><a href="#类对象特殊方法——iter-、next" class="headerlink" title="类对象特殊方法——iter()、next()"></a>类对象特殊方法——<strong>iter</strong>()、<strong>next</strong>()</h1><p>之所以for-in语句可以用于某些内置类对象（例如：list、tuple、str等）的实例对象，是因为这些内置类对象中都实现了特殊方法__iter__()和__next__()。</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; for item in L:...     print(item)...12345</code></pre><p>for-in语句在默认情况下不能用于自定义类对象的实例对象。</p><pre><code class="python">&gt;&gt;&gt; class MyClass(object):...     pass...&gt;&gt;&gt; for item in MyClass():...     print(item)...Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#39;MyClass&#39; object is not iterable</code></pre><p>如果想让for-in语句可以用于自定义类对象的实例对象，必须在自定义类对象中实现特殊方法__iter__()和__next__()。<br>for-in语句首先会调用 特殊方法__iter__()返回一个可迭代对象，然后不断调用可迭代对象的特殊方法__next__()返回下一次迭代的值，直到遇到StopIteration时退出循环。<br>只实现了特殊方法__iter__()的类对象，被称为可迭代对象；同时实现了特殊方法__iter__()和__next__()的类对象，被称为迭代器类对象</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def __init__(self, data):        self.data = 0    def __iter__(self):                   # 先自动调用__iter__()返回一个可迭代对象。如果没有这个方法，则依然会报TypeError: &#39;MyClass&#39; object is not iterable错误        return self    def __next__(self):                   # 再自动调用__next__()依次返回可迭代对象的值，注意设置退出迭代条件，否则容易死循环        if self.data &gt;= 5:            raise StopIteration        else:            self.data += 1            return self.datamc = MyClass(5)for i in mc:    print(i)</code></pre><pre><code class="python">[root@lyucan ~]# ./iter.py12345</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORACLE备份恢复及RMAN工具的使用</title>
      <link href="/2018/08/17/Oracle/ORACLE%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E5%8F%8ARMAN%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/08/17/Oracle/ORACLE%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E5%8F%8ARMAN%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ORACLE备份恢复及RMAN工具的使用"><a href="#ORACLE备份恢复及RMAN工具的使用" class="headerlink" title="ORACLE备份恢复及RMAN工具的使用"></a>ORACLE备份恢复及RMAN工具的使用</h1><h2 id="备份与恢复的定义及分类"><a href="#备份与恢复的定义及分类" class="headerlink" title="备份与恢复的定义及分类"></a>备份与恢复的定义及分类</h2><p>1）备份的定义及分类：<br>备份就是把数据库复制到转储设备的过程。其中，转储设备是指用于放置数据库副本的磁带或磁盘。通常也将存放于转储设备中的数据库的副本称为原数据库的备份或转储。备份是一份数据副本，从不同的角度分类如下：</p><p>从物理与逻辑的角度来分类：<br>从物理与逻辑的，备份可以分为物理备份和逻辑备份。</p><ul><li>物理备份：对数据库操作系统的物理文件（数据文件，控制文件和日志文件）的备份。物理备份又可以分为脱机备份（冷备份）和联机备份（热备份），前者是在关闭数据库的时候进行的，后者是以归档日志的方式对运行的数据库进行备份。可以使用oracle的恢复管理器（RMAN）或操作系统命令进行数据库的物理备份。</li><li>逻辑备份：对数据库逻辑组件（如表和存储过程等数据库对象）的备份。逻辑备份的手段很多，如传统的EXP，数据泵（EXPDP），数据库闪回技术等第三方工具，都可以进行数据库的逻辑备份。</li></ul><p>从数据库的备份角度分类：<br>从数据库的备份角度，备份可以分为完全备份和增量备份和差异备份</p><ul><li>完全备份：每次对数据库进行完整备份，当发生数据丢失的灾难时，完全备份无需依赖其他信息即可实现100%的数据恢复，其恢复时间最短且操作最方便。</li><li>增量备份：只有那些在上次完全备份或增量备份后被修改的文件才会被备份。优点是备份数据量小，需要的时间短，缺点是恢复的时候需要依赖以前备份记录，出问题的风险较大。</li><li>差异备份：备份那些自从上次完全备份之后被修改过的文件。从差异备份中恢复数据的时间较短，因此只需要两份数据—最后一次完整备份和最后一次差异备份，缺点是每次备份需要的时间较长。</li></ul><p>2）恢复的定义及分类<br>恢复就是发生故障后，利用已备份的数据文件或控制文件，重新建立一个完整的数据库，恢复分为以下两种类型：<br>实例恢复：当oracle实例出现失败后，oracle自动进行的恢复</p><ul><li>介质恢复：当存放数据库的介质出现故障时所作的恢复。介质恢复又分为完全恢复和不完全恢复</li><li>完全恢复：将数据库恢复到数据库失败时的状态。这种恢复是通过装载数据库备份并应用全部的重做日志做到的。</li><li>不完全恢复：将数据库恢复到数据库失败前的某一时刻的状态。这种恢复是通过装载数据库备份并应用部分的重做日志做到的。进行不完全恢复后，必须在启动数据库时用resetlogs选项重设联机重做日志。</li></ul><h2 id="RMAN备份"><a href="#RMAN备份" class="headerlink" title="RMAN备份"></a>RMAN备份</h2><p>RMAN的存储类型有三种方式：</p><ol><li>备份集 默认类型</li><li>压缩备份集</li><li>镜像copy</li></ol><p>组成每个备份集的每个文件称之为备份片<br>RMAN备份可以存放在两种位置：</p><ol><li>目标数据库的控制文件</li><li>恢复目录中</li></ol><p>RMAN备份的优点：</p><ol><li>RMAN只备份有效数据</li><li>RMAN可以实现增量备份</li></ol><h2 id="使用RMAN工具"><a href="#使用RMAN工具" class="headerlink" title="使用RMAN工具"></a>使用RMAN工具</h2><p>RMAN是oracle的一个重要工具，用于备份和恢复数据文件，归档日志和控制文件，也可以用来执行完全或不完全的数据库恢复。RMAN有3中不同的用户接口，命令行方式，GUI方式（集成在OEM中的备份管理器），API方式（用于集成到第三方的备份软件中），它具有以下特点：</p><ul><li>支持在线热备份</li><li>支持多级增量备份</li><li>支持并行备份、恢复</li><li>减少所需要备份量</li><li>备份、恢复使用简单</li><li>需要目标数据库开启归档日志</li></ul><h2 id="RMAN的组件"><a href="#RMAN的组件" class="headerlink" title="RMAN的组件"></a>RMAN的组件</h2><ul><li><p>target database（目标数据库）<br>目标数据库就是需要RMAN对其进行备份与恢复的数据库，RMAN可以备份数据文件，控制文件，归档日志，spfile；</p></li><li><p>service session（服务器会话）<br>RMAN启动数据库上的oracle服务器进程，将建立一个与目标数据库的会话，有目标数据库上的服务器进程进行备份、还原、恢复的实际操作。</p></li><li><p>RMAN Repository（RMAN资料库）<br>RMAN使用过程中会用到的控制信息，是一些关于备份、归档日志及RMAN活动的元数据</p></li><li><p>Recovery Catalog（恢复目录）<br>恢复目录是建立在RMAN恢复目录数据库上的一种schema对象，用于保存RMAN资料库数据。恢复目录是一个可选的组件。RMAN会将资料数据记录在目标数据库的控制文件中，但这样不够安全，因为一旦目标数据库的控制文件损坏就意味着所有的RMAN备份失效。所以建议在单独的一个数据库中建立一个恢复目录另外保存一份资料库数据。</p></li><li><p>MML（媒体管理库）<br>MML是第三方工具或软件，用于管理对磁带的读写与文件的跟踪管理。如果你想直接通过RMAN备份到磁带上，就必须配置媒体管理层，媒体管理层的工具和RMAN共同配合完成备份与恢复。</p></li><li><p>快闪恢复区<br>快闪恢复区是oracle数据库用于保存所有与恢复相关的文件的默认磁盘位置。这些相关文件包括归档日志，RMAN备份，控制文件自动备份，复用的控制文件和重做日志副本及闪回日志文件。</p></li><li><p>辅助数据库<br>在正常使用时，RMAN会与目标数据库一起使用，如果创建了恢复目录数据库，那么也会与恢复目录数据库一起使用。在某些情况下，希望创建辅助数据库。辅助数据库时使用RMAN从目标数据库的备份中创建的新数据库。辅助数据库能够被创建作为备用数据库使用。在数据库发生灾难时，能够在不丢失任何数据及停机时间最短的情况下切换至备用数据库。</p></li></ul><h2 id="备份与恢复的概念与操作"><a href="#备份与恢复的概念与操作" class="headerlink" title="备份与恢复的概念与操作"></a>备份与恢复的概念与操作</h2><p>1）备份集<br>备份集是一次备份的集合，它包含本次备份的所有备份片，以oracle专有的格式保存，是一个逻辑数据的集合。<br>2）备份片：<br>一个备份集由若干个备份片组成。每个备份片是一个单独输出文件，一个备份片的大小是有限制的，他的大小不能大于文件系统所支持的文件长度的最大值。</p><p><strong>配置备份集文件的格式：</strong><br>使用backup命令进行备份时，需要明确备份文件的存储路径及文件名称的格式。其路径和格式可以使用FORMAT参数进行统一设置。<br>FORMAT格式由两部分组成：即存储路径和文件名称格式；<br>如果没有使用FORMAT指定存储路径和文件名称格式，则默认情况下BACKUP所产生的备份集将存储在快闪恢复区中，RMAN自动使用%U来确定文件名称不会被重复。<br>FORMAT命令格式如下：<br>FORMAT ‘格式字符串’<br>其中格式字符串的文件名称部分可以使用替换变量，例如FORMAT ‘&#x2F;BACKUP&#x2F;YY&#x2F;%U’.<br>常用的替换变量如下：</p><ul><li>%c : 备份片的拷贝数</li><li>%d：数据库名称</li><li>%D : 位于该月中的第几天（DD）</li><li>%M : 位于该年中第几月（MM）</li><li>%F : 一个基于DBID的唯一名称，它的形式为C-DBID-YYYYMMDD-QQ。其中DBID为数据库的DBID，YYYYMMDD为日志，QQ是一个1-256的序列</li><li>%n：数据库名称，向右填补到最大8个字符</li><li>%u：一个8个字符的名称，它是根据备份集个数与创建时间信息生成的。</li><li>%p：该备份集中的备份片号，从1开始到创建的文件数。</li><li>%U：系统生成的一个唯一文件名，对于备份片来说，它的含义相当于%u_%p_%c。</li><li>%s：备份集的号</li><li>%t：备份集时间戳</li><li>%T：年月日格式（YYYYMMDD）</li></ul><p><strong>备份与恢复命令</strong><br>backup命令用于备份数据库文件，可以将多个文件、表空间、整个数据库已备份集形式备份到磁盘或磁带上，在RUN命令外使用BACKUP命令，会自动使用自动通道。在RUN命令内使用BACKUP命令，如果定义了手动通道，则优先使用手动定义通道。<br>使用RMAN备份的数据库也只能使用RMAN提供的恢复命令进行恢复。RMAN的恢复目录中存储了目标数据库的备份信息。RMAN根据恢复目录中的存储信息，自动将数据库同步到某一个数据一致的状态。<br>RMAN恢复数据库时用到两个命令，即RESTORE和RECOVER。RESTORE命令将备份数据恢复到指定的目录，RECOVER命令对数据库进行同步恢复。<br>RESTORE命令：由于备份集中的备份片是以专有的RMAN格式存储的，需要使用RESTORE命令进行重建。重建的结果是自动产生目标数据库的物理文件结构。<br>RECOVER命令：负责把归档日志文件用于重建的数据文件，来完成数据库的同步恢复。在执行RECOVER命令时，RMAN需要读取归档日志。如果没有归档日志，或者数据库运行在非归档模式下，则恢复过程会报错。<br>举例说明在归档模式下备份与恢复<br>要用RMAN进行联机备份，数据库必须处于归档模式，恢复目录必须打开，目标数据库进程必须启动，数据库已加载或者打开。</p><p>2、创建rman恢复目录<br>恢复目录存在于RMAN的目录数据库中，类似于标准的数据库目录，主要包含如下几个部分信息：</p><ul><li>备份恢复信息，可以是多个目标数据库</li><li>存储RMAN脚本，可以存储重复使用</li><li>关于数据文件和日志文件的备份信息</li><li>关于目标数据库的表空间和数据文件信息</li><li>RMAN资料库可以存放在目标数据库控制文件里，也可以存放在恢复目录中</li></ul><h2 id="创建资料库"><a href="#创建资料库" class="headerlink" title="创建资料库"></a>创建资料库</h2><p><strong>rman资料库建议单数创建在一台oracle服务器上，不建议和目标数据库合设。</strong><br>1）创建rman用户所使用的表空间</p><pre><code class="sql">[oracle@oracle admin]$ sqlplus sys/Oracle_1@rman as sysdbaSQL&gt; create tablespace rman datafile &#39;/oracle/11g/oradata/oracle/catalog/rman.dbf&#39; size 200M autoextend on next 5m maxsize unlimited;Tablespace created.</code></pre><p>2）创建rman用户并赋权</p><pre><code class="sql">SQL&gt; create user rman identified by Rman_1 default tablespace rman quota unlimited on rman;User created.SQL&gt; grant connect,resource,recovery_catalog_owner to rman;Grant succeeded.</code></pre><p>3）连接到rman资料库</p><pre><code class="sql">[oracle@oracle admin]$ rman catalog rman/Rman_1@rmanRecovery Manager: Release 11.2.0.1.0 - Production on Sun May 13 21:48:02 2018Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.connected to recovery catalog database</code></pre><p>4）创建恢复目录，这个过程实际上就是在后台创建表，视图等其他东西</p><pre><code class="sql">RMAN&gt; create catalog;recovery catalog created</code></pre><p>5）同时连接目标数据库及资料库，注册目标数据库</p><pre><code class="sql">[oracle@oracle admin]$ rman target sys/Oracle_1@ma catalog rman/Rman_1@rmanRecovery Manager: Release 11.2.0.1.0 - Production on Sun May 13 21:56:25 2018Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.connected to target database: MYSQL_MA (DBID=435464442)connected to recovery catalog databaseRMAN&gt; register database;database registered in recovery catalogstarting full resync of recovery catalogfull resync completeRMAN&gt; report schema;Report of database schema for database with db_unique_name MYSQL_MAList of Permanent Datafiles===========================File Size(MB) Tablespace           RB segs Datafile Name---- -------- -------------------- ------- ------------------------1    680      SYSTEM               YES     /oracle/11g/oradata/mysql_master_1003306/system01.dbf2    570      SYSAUX               NO      /oracle/11g/oradata/mysql_master_1003306/sysaux01.dbf3    75       UNDOTBS1             YES     /oracle/11g/oradata/mysql_master_1003306/undotbs01.dbf4    5        USERS                NO      /oracle/11g/oradata/mysql_master_1003306/users01.dbfList of Temporary Files=======================File Size(MB) Tablespace           Maxsize(MB) Tempfile Name---- -------- -------------------- ----------- --------------------1    29       TEMP                 32767       /oracle/11g/oradata/mysql_master_1003306/temp01.dbf</code></pre><blockquote><p>注册就是把目标库controlfile里面的数据记录到资料库里。report schema可以报告目标数据库里面的数据文件。</p></blockquote><h2 id="删除资料库"><a href="#删除资料库" class="headerlink" title="删除资料库"></a>删除资料库</h2><pre><code class="sql">RMAN&gt; drop catalog;recovery catalog owner is RMANenter DROP CATALOG command again to confirm catalog removalRMAN&gt; drop catalog;recovery catalog dropped</code></pre><h2 id="取消注册数据库"><a href="#取消注册数据库" class="headerlink" title="取消注册数据库"></a>取消注册数据库</h2><pre><code class="sql">RMAN&gt; unregister database;database name is &quot;ORACLE&quot; and DBID is 1848230368Do you really want to unregister the database (enter YES or NO)? ydatabase unregistered from the recovery catalog</code></pre><h2 id="rman配置"><a href="#rman配置" class="headerlink" title="rman配置"></a>rman配置</h2><p>使用show all查看rman的配置</p><pre><code class="sql">RMAN&gt; show all;RMAN configuration parameters for database with db_unique_name ORACLE are:CONFIGURE RETENTION POLICY TO REDUNDANCY 1; # default   ##定义备份保留策略，详情备份保留策略 CONFIGURE RETENTION POLICYCONFIGURE BACKUP OPTIMIZATION OFF; # default   ##是否启用备份优化，详情 RMAN中的备份优化(Backup Optimization)CONFIGURE DEFAULT DEVICE TYPE TO DISK; # default   ##通道类型，disk为磁盘,sbt为磁带。通常为disk，保持默认即可；CONFIGURE CONTROLFILE AUTOBACKUP OFF;  ##是否自动备份控制文件，在进行全备的时候，会自动备份控制文件和spfile，但是当仅备份某些表空间文件时，如果不启用这个参数，将不会自动备份控制文件，强烈建议开启；当开启这个参数后，全备的时候就会使用自动备份来进行控制文件和spfile文件的备份，而不使用全备默认的方式进行备份控制文件CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO &#39;%F&#39;; # default  ##控制文件备份的格式，可以指定路径，不指定将使用闪回区CONFIGURE DEVICE TYPE DISK PARALLELISM 1 BACKUP TYPE TO BACKUPSET; # default ##启动几个通道并发来备份，这个并发是文件级的，假如只有一个文件需要备份，而这里设置为2，将仍然使用一个通道来进行备份 CONFIGURE DATAFILE BACKUP COPIES FOR DEVICE TYPE DISK TO 1; # default  ## 备份的数据文件 有几个副本，这个参数设置为几个就是要设置几个备份路径CONFIGURE ARCHIVELOG BACKUP COPIES FOR DEVICE TYPE DISK TO 1; # default  ## 备份的归档日志 有几个副本CONFIGURE MAXSETSIZE TO UNLIMITED; # default  ##限制备份集的大小，如果备份的文件超过了备份集的大小，备份将会报错；CONFIGURE ENCRYPTION FOR DATABASE OFF; # defaultCONFIGURE ENCRYPTION ALGORITHM &#39;AES128&#39;; # defaultCONFIGURE COMPRESSION ALGORITHM &#39;BASIC&#39; AS OF RELEASE &#39;DEFAULT&#39; OPTIMIZE FOR LOAD TRUE ; # defaultCONFIGURE ARCHIVELOG DELETION POLICY TO NONE; # defaultCONFIGURE SNAPSHOT CONTROLFILE NAME TO &#39;/oracle/11g/product/11.2.0/dbhome_1/dbs/snapcf_orcl.f&#39;; # default##新增CONFIGURE CHANNEL DEVICE TYPE DISK MAXPIECESIZE 2G;  ##设置备份片的大小，如果单个文件超过这个大小，将进行分片CONFIGURE CHANNEL DEVICE TYPE DISK FORMAT &#39;/oracle/11g/oradata/oracle/catalog/backup/%U&#39;;  ##默认通道的备份路径及文件格式CONFIGURE CHANNEL 1 DEVICE TYPE DISK FORMAT &#39;/oracle/11g/oradata/oracle/catalog/backup01/%U&#39;;  ##通道1的备份路径及文件格式，如果有编号为1的通道，将使用1，而不使用默认通道CONFIGURE CHANNEL 2 DEVICE TYPE DISK FORMAT &#39;/oracle/11g/oradata/oracle/catalog/backup02/%U&#39;;  ##通道2的备份路径及文件格式##恢复配置CONFIGURE CHANNEL 2 DEVICE TYPE DISK clear; 所有的配置都是这样恢复默认</code></pre><h2 id="查看哪些文件你需要备份"><a href="#查看哪些文件你需要备份" class="headerlink" title="查看哪些文件你需要备份"></a>查看哪些文件你需要备份</h2><pre><code class="sql">RMAN&gt; report need backup;starting full resync of recovery catalogfull resync completeRMAN retention policy will be applied to the commandRMAN retention policy is set to redundancy 1Report of files with less than 1 redundant backupsFile #bkps Name---- ----- -----------------------------------------------------RMAN&gt; report need backup redundancy 2;   ##仅有一个备份，不满足2个，所以需要再备份一次Report of files with less than 2 redundant backupsFile #bkps Name---- ----- -----------------------------------------------------1    1     /oracle/11g/oradata/mysql_master_1003306/system01.dbf2    1     /oracle/11g/oradata/mysql_master_1003306/sysaux01.dbf3    1     /oracle/11g/oradata/mysql_master_1003306/undotbs01.dbf</code></pre><h2 id="RMAN备份-1"><a href="#RMAN备份-1" class="headerlink" title="RMAN备份"></a>RMAN备份</h2><h3 id="1）备份整个数据库"><a href="#1）备份整个数据库" class="headerlink" title="1）备份整个数据库"></a>1）备份整个数据库</h3><pre><code class="sql">RMAN&gt; backup database;RMAN&gt; backup database plus archivelog;  ##同时备份归档日志，一般使用这种方式进行备份RMAN&gt; backup database plus archivelog delete input;  ##备份完成后把归档日志删除RMAN&gt; backup database plus archivelog delete all input; ##如果归档日志路径设置了多个，要删除全部的归档日志，就需要加上all参数</code></pre><p>查看全库备份备份集</p><pre><code class="sql">RMAN&gt; LIST BACKUP OF DATABASE;      ##仅会列出数据文件的备份，不会列出归档日志和控制文件备份List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------3511    Full    1.01G      DISK        00:00:27     14-MAY-18             BP Key: 3515   Status: AVAILABLE  Compressed: NO  Tag: TAG20180514T190436        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_nnndf_TAG20180514T190436_fhn5j55m_.bkp  List of Datafiles in backup set 3511  File LV Type Ckp SCN    Ckp Time  Name  ---- -- ---- ---------- --------- ----  1       Full 1387367    14-MAY-18 /oracle/11g/oradata/mysql_master_1003306/system01.dbf  2       Full 1387367    14-MAY-18 /oracle/11g/oradata/mysql_master_1003306/sysaux01.dbf  3       Full 1387367    14-MAY-18 /oracle/11g/oradata/mysql_master_1003306/undotbs01.dbf  4       Full 1387367    14-MAY-18 /oracle/11g/oradata/mysql_master_1003306/users01.dbf</code></pre><h3 id="2）备份表空间"><a href="#2）备份表空间" class="headerlink" title="2）备份表空间"></a>2）备份表空间</h3><pre><code class="sql">RMAN&gt; backup tablespace users;   ##如果有多个需要备份，在后面添加，用逗号分隔，如 backup tablespace users,sysaux;Starting backup at 14-MAY-18using channel ORA_DISK_1channel ORA_DISK_1: starting full datafile backup setchannel ORA_DISK_1: specifying datafile(s) in backup setinput datafile file number=00004 name=/oracle/11g/oradata/mysql_master_1003306/users01.dbfchannel ORA_DISK_1: starting piece 1 at 14-MAY-18channel ORA_DISK_1: finished piece 1 at 14-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_nnndf_TAG20180514T213231_fhng5hhl_.bkp tag=TAG20180514T213231 comment=NONEchannel ORA_DISK_1: backup set complete, elapsed time: 00:00:01Finished backup at 14-MAY-18Starting Control File and SPFILE Autobackup at 14-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_14/o1_mf_s_976138353_fhng5k5c_.bkp comment=NONEFinished Control File and SPFILE Autobackup at 14-MAY-18</code></pre><p>查看备份的表空间备份集，如果有全备，也会把全备的备份集也列出来，因为全备里面包含该表空间的备份</p><pre><code class="sql">RMAN&gt; list backup of tablespace users;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------6834    Full    1.30M      DISK        00:00:00     14-MAY-18             BP Key: 6837   Status: AVAILABLE  Compressed: NO  Tag: TAG20180514T213231        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_nnndf_TAG20180514T213231_fhng5hhl_.bkp  List of Datafiles in backup set 6834  File LV Type Ckp SCN    Ckp Time  Name  ---- -- ---- ---------- --------- ----  4       Full 1393085    14-MAY-18 /oracle/11g/oradata/mysql_master_1003306/users01.dbf</code></pre><h3 id="3）备份数据文件"><a href="#3）备份数据文件" class="headerlink" title="3）备份数据文件"></a>3）备份数据文件</h3><pre><code class="sql">##先查看有哪些数据文件sys@MYSQL_MA&gt; select file_id,file_name from dba_data_files;   FILE_ID FILE_NAME---------- ---------------------------------------------      4 /oracle/11g/oradata/mysql_master_1003306/users01.dbf      3 /oracle/11g/oradata/mysql_master_1003306/undotbs01.dbf      2 /oracle/11g/oradata/mysql_master_1003306/sysaux01.dbf      1 /oracle/11g/oradata/mysql_master_1003306/system01.dbf##或者直接在rman中查看RMAN&gt; REPORT SCHEMA;Report of database schema for database with db_unique_name MYSQL_MAList of Permanent Datafiles===========================File Size(MB) Tablespace           RB segs Datafile Name---- -------- -------------------- ------- ------------------------1    680      SYSTEM               YES     /oracle/11g/oradata/mysql_master_1003306/system01.dbf2    590      SYSAUX               NO      /oracle/11g/oradata/mysql_master_1003306/sysaux01.dbf3    75       UNDOTBS1             YES     /oracle/11g/oradata/mysql_master_1003306/undotbs01.dbf4    5        USERS                NO      /oracle/11g/oradata/mysql_master_1003306/users01.dbfList of Temporary Files=======================File Size(MB) Tablespace           Maxsize(MB) Tempfile Name---- -------- -------------------- ----------- --------------------1    29       TEMP                 32767       /oracle/11g/oradata/mysql_master_1003306/temp01.dbf##进行单个备份RMAN&gt; backup datafile 1;              ##多个的话就在后面加上编号，用逗号分隔，如 backup datafile 1,2,3,4;Starting backup at 14-MAY-18using channel ORA_DISK_1channel ORA_DISK_1: starting full datafile backup setchannel ORA_DISK_1: specifying datafile(s) in backup setinput datafile file number=00001 name=/oracle/11g/oradata/mysql_master_1003306/system01.dbfchannel ORA_DISK_1: starting piece 1 at 14-MAY-18channel ORA_DISK_1: finished piece 1 at 14-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_nnndf_TAG20180514T213858_fhngklhk_.bkp tag=TAG20180514T213858 comment=NONEchannel ORA_DISK_1: backup set complete, elapsed time: 00:00:15Finished backup at 14-MAY-18Starting Control File and SPFILE Autobackup at 14-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_14/o1_mf_s_976138754_fhngl27p_.bkp comment=NONEFinished Control File and SPFILE Autobackup at 14-MAY-18##也可以使用文件名RMAN&gt; backup datafile &#39;/oracle/11g/oradata/mysql_master_1003306/users01.dbf&#39;;       ##备份多个，用逗号分隔，如 backup datafile &#39;/oracle/11g/oradata/mysql_master_1003306/users01.dbf&#39;,&#39;/oracle/11g/oradata/mysql_master_1003306/sysaux01.dbf&#39;;Starting backup at 14-MAY-18using channel ORA_DISK_1channel ORA_DISK_1: starting full datafile backup setchannel ORA_DISK_1: specifying datafile(s) in backup setinput datafile file number=00004 name=/oracle/11g/oradata/mysql_master_1003306/users01.dbfchannel ORA_DISK_1: starting piece 1 at 14-MAY-18channel ORA_DISK_1: finished piece 1 at 14-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_nnndf_TAG20180514T215249_fhnhckdb_.bkp tag=TAG20180514T215249 comment=NONEchannel ORA_DISK_1: backup set complete, elapsed time: 00:00:01Finished backup at 14-MAY-18Starting Control File and SPFILE Autobackup at 14-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_14/o1_mf_s_976139570_fhnhcm0r_.bkp comment=NONEFinished Control File and SPFILE Autobackup at 14-MAY-18</code></pre><p>查看备份出来的备份集，如果有全备，也会把全备的备份集也列出来，因为全备里面包含该数据文件的备份</p><pre><code class="sql">RMAN&gt; list backup of datafile 1;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------6890    Full    590.91M    DISK        00:00:13     14-MAY-18             BP Key: 6893   Status: AVAILABLE  Compressed: NO  Tag: TAG20180514T213858        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_nnndf_TAG20180514T213858_fhngklhk_.bkp  List of Datafiles in backup set 6890  File LV Type Ckp SCN    Ckp Time  Name  ---- -- ---- ---------- --------- ----  1       Full 1393487    14-MAY-18 /oracle/11g/oradata/mysql_master_1003306/system01.dbf</code></pre><h3 id="4）备份控制文件和spfile"><a href="#4）备份控制文件和spfile" class="headerlink" title="4）备份控制文件和spfile"></a>4）备份控制文件和spfile</h3><p>方法1：配置自动备份控制文件和spfile</p><pre><code class="sql">CONFIGURE CONTROLFILE AUTOBACKUP ON;  ##开启自动备份控制文件和spfile文件的备份</code></pre><p>方法2：backup current controlfile; 备份控制文件， <strong>这种方式不会备份spfile</strong></p><pre><code class="sql">RMAN&gt; backup current controlfile;Starting backup at 14-MAY-18using channel ORA_DISK_1channel ORA_DISK_1: starting full datafile backup setchannel ORA_DISK_1: specifying datafile(s) in backup setincluding current control file in backup setchannel ORA_DISK_1: starting piece 1 at 14-MAY-18channel ORA_DISK_1: finished piece 1 at 14-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_ncnnf_TAG20180514T195531_fhn8hngc_.bkp tag=TAG20180514T195531 comment=NONEchannel ORA_DISK_1: backup set complete, elapsed time: 00:00:01Finished backup at 14-MAY-18</code></pre><p>方法3：将控制文件复制出来，<strong>这种方式不会产生备份集，但是如果有冗余的话，report obsolete命令会显示出来，delete obsolete命令会将其删除</strong></p><pre><code class="sql">RMAN&gt; copy current controlfile to &#39;/oracle/11g/controlfile_bak.ctl1&#39;;Starting backup at 14-MAY-18using channel ORA_DISK_1channel ORA_DISK_1: starting datafile copycopying current control fileoutput file name=/oracle/11g/controlfile_bak.ctl tag=TAG20180514T195803 RECID=1 STAMP=976132683channel ORA_DISK_1: datafile copy complete, elapsed time: 00:00:01Finished backup at 14-MAY-18RMAN&gt; report obsolete;RMAN retention policy will be applied to the commandRMAN retention policy is set to redundancy 1Report of obsolete backups and copiesType                 Key    Completion Time    Filename/Handle-------------------- ------ ------------------ --------------------Control File Copy     4062   14-MAY-18          /oracle/11g/controlfile_bak.ctlBackup Set           4008   14-MAY-18          Backup Piece       4009   14-MAY-18          /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_ncnnf_TAG20180514T195531_fhn8hngc_.bkpControl File Copy     4115   14-MAY-18          /oracle/11g/controlfile_bak.ctl1</code></pre><p>方法4：backup spfile; 备份spfile，<strong>这种方式不会备份控制文件</strong></p><pre><code class="sql">RMAN&gt; backup spfile;Starting backup at 15-MAY-18allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=50 device type=DISKchannel ORA_DISK_1: starting full datafile backup setchannel ORA_DISK_1: specifying datafile(s) in backup setincluding current SPFILE in backup setchannel ORA_DISK_1: starting piece 1 at 15-MAY-18channel ORA_DISK_1: finished piece 1 at 15-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_15/o1_mf_nnsnf_TAG20180515T201800_fhpy5r7h_.bkp tag=TAG20180515T201800 comment=NONEchannel ORA_DISK_1: backup set complete, elapsed time: 00:00:01Finished backup at 15-MAY-18</code></pre><p>查看控制文件备份集</p><pre><code class="sql">RMAN&gt; list backup of controlfile;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------4171    Full    9.61M      DISK        00:00:01     14-MAY-18             BP Key: 4173   Status: AVAILABLE  Compressed: NO  Tag: TAG20180514T200102        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_ncnnf_TAG20180514T200102_fhn8szhl_.bkp  Control File Included: Ckp SCN: 1389451      Ckp time: 14-MAY-18</code></pre><p>查看spfile文件备份集，下面产生的备份集是开启自动备份控制文件参数备份出来的，里面同时也保存了控制文件备份；</p><pre><code class="sql">RMAN&gt; list backup of spfile;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------4495    Full    9.64M      DISK        00:00:01     14-MAY-18             BP Key: 4497   Status: AVAILABLE  Compressed: NO  Tag: TAG20180514T200923        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_14/o1_mf_s_976133363_fhn99myk_.bkp  SPFILE Included: Modification time: 14-MAY-18  SPFILE db_unique_name: MYSQL_MARMAN&gt; list backup of controlfile;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------4495    Full    9.64M      DISK        00:00:01     14-MAY-18             BP Key: 4497   Status: AVAILABLE  Compressed: NO  Tag: TAG20180514T200923        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_14/o1_mf_s_976133363_fhn99myk_.bkp  Control File Included: Ckp SCN: 1389821      Ckp time: 14-MAY-18</code></pre><h3 id="5）备份归档日志"><a href="#5）备份归档日志" class="headerlink" title="5）备份归档日志"></a>5）备份归档日志</h3><pre><code class="sql">RMAN&gt; BACKUP ARCHIVELOG ALL; Starting backup at 14-MAY-18current log archivedusing channel ORA_DISK_1channel ORA_DISK_1: starting archived log backup setchannel ORA_DISK_1: specifying archived log(s) in backup setinput archived log thread=1 sequence=32 RECID=30 STAMP=976129512input archived log thread=1 sequence=33 RECID=32 STAMP=976133863input archived log thread=1 sequence=34 RECID=35 STAMP=976136698input archived log thread=1 sequence=35 RECID=36 STAMP=976136987channel ORA_DISK_1: starting piece 1 at 14-MAY-18channel ORA_DISK_1: finished piece 1 at 14-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_annnn_TAG20180514T210947_fhndtw16_.bkp tag=TAG20180514T210947 comment=NONEchannel ORA_DISK_1: backup set complete, elapsed time: 00:00:01Finished backup at 14-MAY-18Starting Control File and SPFILE Autobackup at 14-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_14/o1_mf_s_976136989_fhndtxrb_.bkp comment=NONEFinished Control File and SPFILE Autobackup at 14-MAY-18RMAN&gt; BACKUP ARCHIVELOG ALL DELETE INPUT;RMAN&gt; BACKUP ARCHIVELOG FROM TIME &#39;sysdate-1&#39;; ##备份从系统时间一天前到现在的归档日志RMAN&gt; BACKUP ARCHIVELOG UNTIL TIME &#39;sysdate-1&#39;; ##备份直到系统时间一天前的所有日志RMAN&gt; BACKUP ARCHIVELOG SEQUENCE BETWEEN 2 AND 10 FORMAT &#39;/backup/archivelog/arch_%U&#39; DELETE INPUT; ##备份seq号2-10的归档诶只</code></pre><p>查看归档日志</p><pre><code class="sql">RMAN&gt; LIST BACKUP OF ARCHIVELOG ALL;List of Backup Sets===================BS Key  Size       Device Type Elapsed Time Completion Time------- ---------- ----------- ------------ ---------------3558    2.50K      DISK        00:00:00     14-MAY-18             BP Key: 3563   Status: AVAILABLE  Compressed: NO  Tag: TAG20180514T190512        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_14/o1_mf_annnn_TAG20180514T190512_fhn5k8xv_.bkp  List of Archived Logs in backup set 3558  Thrd Seq     Low SCN    Low Time  Next SCN   Next Time  ---- ------- ---------- --------- ---------- ---------  1    32      1387352    14-MAY-18 1387383    14-MAY-18RMAN&gt; LIST BACKUP OF ARCHIVELOG SEQUENCE BETWEEN 1 AND 10;RMAN&gt; LIST BACKUP OF ARCHIVELOG SEQUENCE 20;RMAN&gt; LIST BACKUP OF ARCHIVELOG UNTIL LOGSEQ 20;RMAN&gt; LIST BACKUP OF ARCHIVELOG FROM LOGSEQ 20;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类对象特殊方法__add__()、__radd__()</title>
      <link href="/2018/08/14/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__add__()%E3%80%81__radd__()/"/>
      <url>/2018/08/14/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__add__()%E3%80%81__radd__()/</url>
      
        <content type="html"><![CDATA[<h1 id="类对象特殊方法——add-、radd-（-操作）"><a href="#类对象特殊方法——add-、radd-（-操作）" class="headerlink" title="类对象特殊方法——add()、radd()（+ - * &#x2F;  &#x2F;&#x2F; 操作）"></a>类对象特殊方法——<strong>add</strong>()、<strong>radd</strong>()（+ - * &#x2F;  &#x2F;&#x2F; 操作）</h1><p>标准算数运算符在默认情况下不能用于自定义类对象的实例对象。</p><pre><code class="python">#!/usr/bin/python3class MyClassA(object):    passclass MyClassB(object):    passprint(MyClassA() + MyClassB())</code></pre><pre><code class="python">[root@lyucan ~]# ./25.pyTraceback (most recent call last):  File &quot;./25.py&quot;, line 12, in &lt;module&gt;    print(MyClassA() + MyClassB())TypeError: unsupported operand type(s) for +: &#39;MyClassA&#39; and &#39;MyClassB&#39;</code></pre><p>如果想让标准算数运算符可以用于自定义类对象的实例对象，必须在定义对象中实现标准算数运算符对应的以下特殊方法：<br>1、+对应的特殊方法是__add__()和__radd__()；<br>2、-对应的特殊方法是__sub__()和__rsub__()；<br>3、*对应的特殊方法是__mul__()和__rmul__()；<br>4、&#x2F;对应的特殊方法是__truediv__()和__rtruediv__()；<br>5、&#x2F;&#x2F;对应的特殊方法是__floordiv__()和__rfloordiv__()；</p><p>之所以可以使用+和<em>运算符操作列表，是因为列表所对应的类对象list中实现了+和</em>对应的特殊方法<br>之所以可以使用+和<em>运算符操作字符串，是因为字符串所对应的类对象str中实现了+和</em>对应的特殊方法</p><p>假设两个运算符obj1和obj2，以+为例，对于obj1 +obj2，需要在obj1对应的自定义类对象中实现特殊方法__add__()，或者在obj2对应的自定义类对象中实现特殊方法__radd__()（radd中的r是right的缩写，因为obj2位于运算符+的右边，所以实现的特殊方法是__radd__()；因为obj1位于运算符+的左边，所以实现的特殊方法是__add__() ）。</p><p>流程图：<br><img src="/images/5833a029-6bac-46e9-81ec-53828fa30e39-Image.png" alt="5833a029-6bac-46e9-81ec-53828fa30e39-Image.png" title="5833a029-6bac-46e9-81ec-53828fa30e39-Image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-实例属性和类属性</title>
      <link href="/2018/08/03/Python/Python-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/08/03/Python/Python-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h1><h2 id="实例属性指的是实例对象所绑定的属性"><a href="#实例属性指的是实例对象所绑定的属性" class="headerlink" title="实例属性指的是实例对象所绑定的属性"></a>实例属性指的是实例对象所绑定的属性</h2><p>绑定实例属性（给实例绑定属性）的两种方式：<br>1、在类对象的内部（方法中）</p><ul><li>语法格式：self.属性名 &#x3D; 属性值<br>推荐在特殊方法__init__中进行绑定，这样，在创建实例对象后就会自动调用特殊方法__init__对实例对象进行初始化，从而绑定实例属性。如果在其他方法中进行绑定，可能需要手动调用方法后才会绑定。</li></ul><p>2、在类对象外部进行绑定<br>        python是动态语言，所以，在实例对象创建之后，可以对其动态的绑定属性</p><ul><li>语法格式：实例对象.属性名 &#x3D; 属性值<br>如果指定名称的实例属性已经存在， 如果使用上述方式，则是对实例属性进行修改</li></ul><p>访问实例属性的方式：<br>1、在类对象的内部（方法中）</p><ul><li>语法格式：self.属性名</li></ul><p>2、在类对象外部</p><ul><li>语法格式：实例对象.属性名</li></ul><p>之所以添加前缀“self”或“实例对象”，是为了表明实例属性被哪个实例对象所绑定</p><pre><code class="python">#!/usr/bin/python3class animals(object):    def __init__(self, name, age):        # 在类对象的内部（方法中）绑定实例属性        self.name = name        self.age = age    def run(self):        # 在类对象的内部（方法中）访问实例属性        print(&#39;&#123;&#125; is running&#39;.format(self.name))dog = animals(&#39;kk&#39;, 12)# 在类对象的外部访问实例属性print(dog.name)print(dog.age)dog.run()</code></pre><p>同一个类对象的不同的实例对象所绑定的实例属性是相互独立的，也就是说，给一个实例对象绑定的实例属性，对于另外一个实例对象是不起作用的</p><pre><code class="python">#!/usr/bin/python3class animals(object):    def __init__(self, name, age):        self.name = name        self.age = agedog = animals(&#39;wangcai&#39;, 10)cat = animals(&#39;miaomiao&#39;, 7)print(&#39;dog\&#39;name: %s&#39; %(dog.name))print(&#39;dog\&#39;age: %s&#39; %(dog.age))print(&#39;cat\&#39;name: %s&#39; %(cat.name))print(&#39;cat\&#39;age: %s&#39; %(cat.age))##修改狗的名字为wangwangdog.name = &#39;wangwang&#39;print(&#39;dog\&#39;name: %s&#39; %(dog.name))print(&#39;dog\&#39;age: %s&#39; %(dog.age))print(&#39;cat\&#39;name: %s&#39; %(cat.name))print(&#39;cat\&#39;age: %s&#39; %(cat.age))</code></pre><pre><code class="python">[root@lyucan ~]# ./5.pydog&#39;name: wangcaidog&#39;age: 10cat&#39;name: miaomiaocat&#39;age: 7dog&#39;name: wangwangdog&#39;age: 10cat&#39;name: miaomiaocat&#39;age: 7</code></pre><h2 id="类属性指的是类对象所绑定的属性"><a href="#类属性指的是类对象所绑定的属性" class="headerlink" title="类属性指的是类对象所绑定的属性"></a>类属性指的是类对象所绑定的属性</h2><p>绑定类属性（给类对象绑定属性）的方式有两种：<br>1、在类对象的内部（方法外）</p><ul><li>语法格式：属性名 &#x3D; 属性值</li></ul><p>2、在类对象的外部<br>        python是动态语言，所以，在类对象创建以后，可以对其动态的绑定属性。</p><ul><li>语法格式：类对象名.属性名 &#x3D; 属性值<br>如果指定名称的类属性已经存在，则是对类属性进行修改</li></ul><p>访问类属性的两种方式：<br>1、在类对象的内部（方法中）</p><ul><li>语法格式：类对象.属性名<br>2、在类对象的外部</li><li>语法格式：类对象.属性名 或：实例对象.属性名<br>类对象的所有实例对象都有一个指向类对象的指针，所以，类对象的所有实例对象都可以访问类属性。但是当修改其中一个属性后，另一个属性不会随之更改。</li></ul><p>之所以添加前缀“类对象”，是为了表明类属性被哪个类对象所绑定</p><pre><code class="python">#!/usr/bin/python3class animals(object):    # 在类对象的内部（方法外）绑定类属性    animals_type = &#39;pets&#39;    def __init__(self, name, age):        self.name = name        self.age = age    def print_class(self):        # 在类对象的内部（方法中）访问类属性        print(animals.animals_type)dog = animals(&#39;wangcai&#39;, 10)dog.print_class()# 在类对象外部访问类属性，使用类名或实例名print(animals.animals_type)print(dog.animals_type)</code></pre><pre><code class="python">[root@lyucan ~]# ./6.pypetspetspets</code></pre><p>访问实例属性和类属性都可以通过“实例对象.属性名”来访问。当通过“实例对象.属性名”的方式访问属性时，会先查找指定的实例对象中有没有指定名称的实例属性，如果没有，再查找对应的类对象中有没有指定名称的类属性。所以当通过这种方式访问属性时，如果实例属性和类属性同名，那么实例属性会屏蔽掉类属性。</p><p>当通过“实例对象.属性名 &#x3D; 属性值”绑定属性时，这里的属性只表示实例属性，因为类属性没有这样的绑定方式，所以只会查找指定的实例对象有没有绑定指定名称的实例属性，如果没有则进行绑定，如果绑定了，则对属性值进行修改。</p><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。<br>给实例绑定属性的方法是通过实例变量，或者通过self变量：</p><pre><code class="python">class Student(object):def __init__(self, name):self.name = names = Student(&#39;Bob&#39;)s.score = 90</code></pre><p>但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：</p><pre><code class="python">class Student(object):name = &#39;Student&#39;</code></pre><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p><pre><code class="python">&gt;&gt;&gt; class Student(object):... name = &#39;Student&#39;...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性 Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性 Student&gt;&gt;&gt; s.name = &#39;Michael&#39;# 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性 Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问 Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了 Student</code></pre><p>从上面的例子可以看出，在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。<br><img src="/images/cd084092-7d6d-4b50-9e8f-ad89033e40c6-image.png" alt="cd084092-7d6d-4b50-9e8f-ad89033e40c6-image.png" title="cd084092-7d6d-4b50-9e8f-ad89033e40c6-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静默安装oracle11g</title>
      <link href="/2018/07/25/Oracle/%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85oracle11g/"/>
      <url>/2018/07/25/Oracle/%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85oracle11g/</url>
      
        <content type="html"><![CDATA[<h1 id="静默安装oracle11g"><a href="#静默安装oracle11g" class="headerlink" title="静默安装oracle11g"></a>静默安装oracle11g</h1><h2 id="安装rpm"><a href="#安装rpm" class="headerlink" title="安装rpm"></a>安装rpm</h2><pre><code class="bash">[root@oracle ~]# yum -y install binutils compat-libcap1 compat-libstdc++-33 compat-libstdc++-33*i686  compat-libstdc++-33 gcc gcc-c++ glibc glibc*.i686 glibc-devel glibc-devel*.i686 ksh libaio libaio*.i686 libaio-devel  libgcc libgcc*.i686 libstdc++ libstdc++*.i686 libstdc++-devel  libXi libXi*.i686 libXtst libXtst*.i686 make sysstat unixODBC unixODBC*.i686 unixODBC-devel unixODBC-devel*.i686 unzip[root@oracle ~]# rpm -q binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libaio libaio-devel libgcc libstdc++ libstdc++-devel libXi libXtst make sysstat unixODBC unixODBC-devel</code></pre><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><pre><code class="bash">[root@oracle ~]# /usr/sbin/groupadd oinstall [root@oracle ~]# /usr/sbin/groupadd dba [root@oracle ~]# /usr/sbin/useradd -g oinstall -G dba oracle[root@oracle ~]# echo &quot;Oracle_1&quot; |passwd --stdin oracleChanging password for user oracle.passwd: all authentication tokens updated successfully.</code></pre><h2 id="修改内核参数"><a href="#修改内核参数" class="headerlink" title="修改内核参数"></a>修改内核参数</h2><pre><code class="bash">[root@oracle ~]# vim /etc/sysctl.conffs.aio-max-nr = 1048576fs.file-max = 6815744 kernel.shmall = 2097152 kernel.shmmax = 4294967295 kernel.shmmni = 4096 kernel.sem = 250 32000 100 128 net.ipv4.ip_local_port_range = 9000 65500net.core.rmem_default = 262144 net.core.rmem_max = 4194304net.core.wmem_default = 262144 net.core.wmem_max = 1048576[root@oracle ~]# sysctl -pfs.aio-max-nr = 1048576fs.file-max = 6815744kernel.shmall = 2097152kernel.shmmax = 4294967295kernel.shmmni = 4096kernel.sem = 250 32000 100 128net.ipv4.ip_local_port_range = 9000 65500net.core.rmem_default = 262144net.core.rmem_max = 4194304net.core.wmem_default = 262144net.core.wmem_max = 1048576</code></pre><h2 id="设置oracle用户shell限制"><a href="#设置oracle用户shell限制" class="headerlink" title="设置oracle用户shell限制"></a>设置oracle用户shell限制</h2><pre><code class="bash">[root@oracle ~]# vim /etc/security/limits.conf# oracle-rdbms-server-11gR2-preinstall setting for nofile soft limit is 1024oracle   soft   nofile    1024## # oracle-rdbms-server-11gR2-preinstall setting for nofile hard limit is 65536oracle hard nofile 65536## # oracle-rdbms-server-11gR2-preinstall setting for nproc soft limit is 16384# # refer orabug15971421 for more info.oracle   soft   nproc    16384## # oracle-rdbms-server-11gR2-preinstall setting for nproc hard limit is 16384oracle hard nproc 16384## # oracle-rdbms-server-11gR2-preinstall setting for stack soft limit is 10240KBoracle   soft   stack    10240## # oracle-rdbms-server-11gR2-preinstall setting for stack hard limit is 32768KBoracle   hard   stack    32768</code></pre><h2 id="修改vim-etc-pam-d-login文件"><a href="#修改vim-etc-pam-d-login文件" class="headerlink" title="修改vim &#x2F;etc&#x2F;pam.d&#x2F;login文件"></a>修改vim &#x2F;etc&#x2F;pam.d&#x2F;login文件</h2><pre><code class="bash">[root@oracle ~]# vim /etc/pam.d/loginsession required  /lib64/security/pam_limits.sosession required pam_limits.so</code></pre><h2 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h2><pre><code class="bash">vim /etc/selinux/config# 设置SELINUX=disabled</code></pre><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><pre><code class="bash">service iptables stopsystemctl stop firewalldsystemctl disable firewalld  #可以不执行</code></pre><h2 id="修改主机名及hosts文件"><a href="#修改主机名及hosts文件" class="headerlink" title="修改主机名及hosts文件"></a>修改主机名及hosts文件</h2><pre><code class="bash">[root@localhost ~]# vim /etc/hostnameoracle[root@oracle ~]# vim /etc/hosts10.10.10.101 oracle##不要有非常规字符，如&quot;-&quot; &quot;~&quot;等，可以有“_”“#”“$”“.”</code></pre><h2 id="配置-etc-profile"><a href="#配置-etc-profile" class="headerlink" title="配置&#x2F;etc&#x2F;profile"></a>配置&#x2F;etc&#x2F;profile</h2><pre><code class="bash">[root@oracle ~]# vim /etc/profileif [ $USER = &quot;oracle&quot; ]; then    if [ $SHELL = &quot;/bin/ksh&quot; ]; then        ulimit -p 16384        ulimit -n 65536    else        ulimit -u 16384 -n 65536    fiumask 022fi[root@oracle ~]# source /etc/profile</code></pre><h2 id="创建安装目录"><a href="#创建安装目录" class="headerlink" title="创建安装目录"></a>创建安装目录</h2><pre><code class="bash">[root@oracle ~]# mkdir -p /oracle/11g[root@oracle ~]# mkdir -p /oracle/11g/oraInventory[root@oracle ~]# chown -R oracle:oinstall /oracle/11g[root@oracle ~]# chmod -R 775 /oracle/11g</code></pre><h2 id="配置oracle用户环境变量-home-oracle-bash-profile"><a href="#配置oracle用户环境变量-home-oracle-bash-profile" class="headerlink" title="配置oracle用户环境变量 &#x2F;home&#x2F;oracle&#x2F;.bash_profile"></a>配置oracle用户环境变量 &#x2F;home&#x2F;oracle&#x2F;.bash_profile</h2><pre><code class="bash">[root@oracle ~]# vim /home/oracle/.bash_profileORACLE_BASE=/oracle/11g; export ORACLE_BASEORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1; export ORACLE_HOMEORACLE_SID=orcl; export ORACLE_SIDPATH=$ORACLE_HOME/bin:/usr/sbin:$PATH; export PATHCLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib;LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib;export LD_LIBRARY_PATHTMP=/tmp; export TMPTMPDIR=$TMP; export TMPDIRORACLE_TERM=xterm; export ORACLE_TERM.NLS_LANG=&quot;AMERICAN_AMERICA.AL32UTF8&quot;;export NLS_LANGumask 022[root@oracle ~]# source /home/oracle/.bash_profile</code></pre><h2 id="解压安装包文件，解压出来的文件需要oracle能访问"><a href="#解压安装包文件，解压出来的文件需要oracle能访问" class="headerlink" title="解压安装包文件，解压出来的文件需要oracle能访问"></a>解压安装包文件，解压出来的文件需要oracle能访问</h2><pre><code class="bash">[root@oracle ~]# mkdir /home/oracle_install[root@oracle oracle_install]# cd /home/oracle_install/[root@oracle oracle_install]# unzip linux.x64_11gR2_database_1of2.zip &amp;&amp; unzip linux.x64_11gR2_database_2of2.zip[root@oracle oracle_install]# chown oracle:oinstall -R  /home/oracle_install</code></pre><h2 id="开始安装，安装数据库软件"><a href="#开始安装，安装数据库软件" class="headerlink" title="开始安装，安装数据库软件"></a>开始安装，安装数据库软件</h2><h3 id="修改应答文件"><a href="#修改应答文件" class="headerlink" title="修改应答文件"></a>修改应答文件</h3><pre><code class="bash">[root@oracle oracle_install]# cd /home/oracle_install/[root@oracle oracle_install]# cp -a /home/oracle_install/database/response/ .[root@oracle oracle_install]# cd response/[root@oracle response]# vim db_install.rsp#修改以下内容，其他保持默认即可oracle.install.option=INSTALL_DB_SWONLYORACLE_HOSTNAME=oracleUNIX_GROUP_NAME=oinstallINVENTORY_LOCATION=/oracle/11g/oraInventorySELECTED_LANGUAGES=en,zh_CNORACLE_HOME=/oracle/11g/product/11.2.0/dbhome_1  //不需要提前创建ORACLE_BASE=/oracle/11goracle.install.db.InstallEdition=EEoracle.install.db.isCustomInstall=false   //自定义安装，否，使用默认组件oracle.install.db.DBA_GROUP=dbaoracle.install.db.OPER_GROUP=oinstalloracle.install.db.config.starterdb.type=GENERAL_PURPOSEoracle.install.db.config.starterdb.globalDBName=oracle.orcloracle.install.db.config.starterdb.SID=orcloracle.install.db.config.starterdb.characterSet=AL32UTF8oracle.install.db.config.starterdb.password.ALL=Oracle_1SECURITY_UPDATES_VIA_MYORACLESUPPORT=false   //（手动写了false）DECLINE_SECURITY_UPDATES=true     //设置安全更新（貌似是有bug，这个一定要选true，否则会无限提醒邮件地址有问题，终止安装。PS：不管地址对不对）</code></pre><h3 id="我的应答文件样例"><a href="#我的应答文件样例" class="headerlink" title="我的应答文件样例"></a>我的应答文件样例</h3><pre><code class="bash">[root@oracle response]# cat db_install.rsp  |grep -v &#39;#&#39; |grep -v ^$oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v11_2_0oracle.install.option=INSTALL_DB_SWONLYORACLE_HOSTNAME=oracleUNIX_GROUP_NAME=oinstallINVENTORY_LOCATION=/oracle/11g/oraInventorySELECTED_LANGUAGES=en,zh_CNORACLE_HOME=/oracle/11g/product/11.2.0/dbhome_1   ORACLE_BASE=/oracle/11goracle.install.db.InstallEdition=EEoracle.install.db.isCustomInstall=falseoracle.install.db.customComponents=oracle.server:11.2.0.1.0,oracle.sysman.ccr:10.2.7.0.0,oracle.xdk:11.2.0.1.0,oracle.rdbms.oci:11.2.0.1.0,oracle.network:11.2.0.1.0,oracle.network.listener:11.2.0.1.0,oracle.rdbms:11.2.0.1.0,oracle.options:11.2.0.1.0,oracle.rdbms.partitioning:11.2.0.1.0,oracle.oraolap:11.2.0.1.0,oracle.rdbms.dm:11.2.0.1.0,oracle.rdbms.dv:11.2.0.1.0,orcle.rdbms.lbac:11.2.0.1.0,oracle.rdbms.rat:11.2.0.1.0oracle.install.db.DBA_GROUP=dbaoracle.install.db.OPER_GROUP=oinstalloracle.install.db.CLUSTER_NODES=oracle.install.db.config.starterdb.type=GENERAL_PURPOSEoracle.install.db.config.starterdb.globalDBName=oracle.orcloracle.install.db.config.starterdb.SID=orcloracle.install.db.config.starterdb.characterSet=AL32UTF8oracle.install.db.config.starterdb.memoryOption=trueoracle.install.db.config.starterdb.memoryLimit=oracle.install.db.config.starterdb.installExampleSchemas=falseoracle.install.db.config.starterdb.enableSecuritySettings=trueoracle.install.db.config.starterdb.password.ALL=Oracle_1oracle.install.db.config.starterdb.password.SYS=oracle.install.db.config.starterdb.password.SYSTEM=oracle.install.db.config.starterdb.password.SYSMAN=oracle.install.db.config.starterdb.password.DBSNMP=oracle.install.db.config.starterdb.control=DB_CONTROLoracle.install.db.config.starterdb.gridcontrol.gridControlServiceURL=oracle.install.db.config.starterdb.dbcontrol.enableEmailNotification=falseoracle.install.db.config.starterdb.dbcontrol.emailAddress=oracle.install.db.config.starterdb.dbcontrol.SMTPServer=oracle.install.db.config.starterdb.automatedBackup.enable=falseoracle.install.db.config.starterdb.automatedBackup.osuid=oracle.install.db.config.starterdb.automatedBackup.ospwd=oracle.install.db.config.starterdb.storageType=oracle.install.db.config.starterdb.fileSystemStorage.dataLocation=oracle.install.db.config.starterdb.fileSystemStorage.recoveryLocation=oracle.install.db.config.asm.diskGroup=oracle.install.db.config.asm.ASMSNMPPassword=MYORACLESUPPORT_USERNAME=MYORACLESUPPORT_PASSWORD=SECURITY_UPDATES_VIA_MYORACLESUPPORT=falseDECLINE_SECURITY_UPDATES=truePROXY_HOST=PROXY_PORT=PROXY_USER=PROXY_PWD=</code></pre><h3 id="开始安装，需要用oracle用户进行安装"><a href="#开始安装，需要用oracle用户进行安装" class="headerlink" title="开始安装，需要用oracle用户进行安装"></a>开始安装，需要用oracle用户进行安装</h3><pre><code class="bash">[root@oracle ~]# su - oracle[oracle@oracle ~]$ cd /home/oracle_install/database/[oracle@oracle database]$ ./runInstaller -silent -responseFile /home/oracle_install/response/db_install.rsp</code></pre><p><strong>根据提示查看安装日志，安装完成后还需要手动执行两个脚本，在安装完的信息里面有详细路径</strong></p><h2 id="创建监听器"><a href="#创建监听器" class="headerlink" title="创建监听器"></a>创建监听器</h2><pre><code class="bash">[oracle@oracle ~]$ netca /silent /responsefile /home/oracle_install/response/netca.rspParsing command line arguments:    Parameter &quot;silent&quot; = true    Parameter &quot;responsefile&quot; = /home/oracle_install/response/netca.rspDone parsing command line arguments.Oracle Net Services Configuration:Profile configuration complete.Oracle Net Listener Startup:    Running Listener Control:      /oracle/11g/product/11.2.0/dbhome_1/bin/lsnrctl start LISTENER    Listener Control complete.    Listener started successfully.Listener configuration complete.Oracle Net Services configuration successful. The exit code is 0</code></pre><p><strong>会在$ORACLE_HOME下创建监听文件listenr.ora，可以根据实际情况修改</strong></p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h3 id="修改应答文件，修改GENERAL和CREATEDATABASE里面的内容"><a href="#修改应答文件，修改GENERAL和CREATEDATABASE里面的内容" class="headerlink" title="修改应答文件，修改GENERAL和CREATEDATABASE里面的内容"></a>修改应答文件，修改GENERAL和CREATEDATABASE里面的内容</h3><pre><code class="bash">[oracle@oracle ~]$ vim /home/oracle_install/response/dbca.rsp[GENERAL]RESPONSEFILE_VERSION = &quot;11.2.0&quot;OPERATION_TYPE = &quot;createDatabase&quot;[CREATEDATABASE]GDBNAME = &quot;oracle.orcl&quot;SID = &quot;orcl&quot;TEMPLATENAME = &quot;General_Purpose.dbc&quot;SYSPASSWORD = &quot;Oracle_1&quot;SYSTEMPASSWORD = &quot;Oracle_1&quot;CHARACTERSET = &quot;AL32UTF8&quot;</code></pre><h3 id="开始建库"><a href="#开始建库" class="headerlink" title="开始建库"></a>开始建库</h3><pre><code class="bash">[oracle@oracle ~]$ dbca -silent -responseFile /home/oracle_install/response/dbca.rspCopying database files1% complete3% complete11% complete18% complete26% complete37% completeCreating and starting Oracle instance40% complete45% complete50% complete55% complete56% complete60% complete62% completeCompleting Database Creation66% complete70% complete73% complete85% complete96% complete100% completeLook at the log file &quot;/oracle/11g/cfgtoollogs/dbca/oracle/oracle.log&quot; for further details.</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-对象的引用计数</title>
      <link href="/2018/07/17/Python/Python-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
      <url>/2018/07/17/Python/Python-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>对象的引用计数</p><p>通常情况下，开发人员无需关心内存的分配和释放。当创建一个对象时，系统会自动分配一块内存以存储该对象的信息。当该对象不再被使用时，系统会进行垃圾回收以自动释放其占用的内存。为了确保使用中的对象不会被销毁，python使用引用计数来跟踪和计算内存中每个对象被引用的次数。当对象的引用计数为0时，它才会被销毁。</p><p>对象的引用计数加1的情形：<br>1、对象赋值给变量<br>2、引用对象的变量赋值给另一个变量<br>3、对象作为容器（例如：列表、字典、集合等）中的元素。<br>4、对象作为函数调用时的实参，当函数执行后，对实参的引用会自动销毁</p><p>可以使用标准库<code>sys</code>中的<code>getrefcount()</code>方法获取当前的引用数</p><pre><code class="python">&gt;&gt;&gt; class MyClass(object):...     pass...&gt;&gt;&gt; import sys&gt;&gt;&gt; mc = MyClass()&gt;&gt;&gt; sys.getrefcount(mc)    # 执行此方法的时候，mc被当做实参传递，因此引用次数也会加1，加上之前MyClass赋值给变量的加1，所以结果是22&gt;&gt;&gt;&gt;&gt;&gt; mc1 = mc&gt;&gt;&gt; sys.getrefcount(mc)    # 执行此方法的时候，mc被当做实参传递，因此引用次数也会加1，加上之前MyClass赋值给变量的加2，所以结果是33&gt;&gt;&gt; L = [1, 2, mc]&gt;&gt;&gt; sys.getrefcount(mc)    # 执行此方法的时候，mc被当做实参传递，因此引用次数也会加1，加上之前MyClass赋值给变量的加3，所以结果是44</code></pre><p>对象引用计数减1的情形：<br>1、对象离开它的作用域，例如：对象所在的函数执行完毕<br>2、对象的引用被显式销毁（del语句）<br>3、引用对象的变量被赋予新的变量<br>4、从容器中删除对象，或对象所在的容器被销毁</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-获取对象信息type()</title>
      <link href="/2018/07/15/Python/Python-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AFtype()/"/>
      <url>/2018/07/15/Python/Python-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AFtype()/</url>
      
        <content type="html"><![CDATA[<h1 id="获取对象信息type"><a href="#获取对象信息type" class="headerlink" title="获取对象信息type()"></a>获取对象信息type()</h1><p>用于获得指定对象的类型</p><pre><code class="python">&gt;&gt;&gt; type(123)&lt;class &#39;int&#39;&gt;&gt;&gt;&gt; type(&#39;hello&#39;)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; type([1, 2, 3])&lt;class &#39;list&#39;&gt;&gt;&gt;&gt; type(&#123;&#125;)&lt;class &#39;dict&#39;&gt;&gt;&gt;&gt; type((1,))&lt;class &#39;tuple&#39;&gt;&gt;&gt;&gt; type((1))       # 注意这不是元组，而是整型&lt;class &#39;int&#39;&gt;</code></pre><pre><code class="python">&gt;&gt;&gt; type(str)       # 类对象的类型是type，也就是说类对象是type的一个实例对象&lt;class &#39;type&#39;&gt;&gt;&gt;&gt; type(int)&lt;class &#39;type&#39;&gt;</code></pre><pre><code class="python">&gt;&gt;&gt; type(str)       # 类对象的类型是type，也就是说类对象是type的一个实例对象&lt;class &#39;type&#39;&gt;&gt;&gt;&gt; type(int)&lt;class &#39;type&#39;&gt;</code></pre><pre><code class="python">&gt;&gt;&gt; def func():     # 自定义函数对象的类型是function ...     pass...&gt;&gt;&gt; type(func)&lt;class &#39;function&#39;&gt;</code></pre><pre><code class="python">&gt;&gt;&gt; type(print)     # 内置函数对象的类型是builtin_function_or_method&lt;class &#39;builtin_function_or_method&#39;&gt;</code></pre><p>可以使用运算符“&#x3D;&#x3D;”来判断某个对象的类型是不是指定的类型。<br>对于基本数据类型，可以直接使用其对应的类型；</p><pre><code class="python">&gt;&gt;&gt; type(18) == intTrue&gt;&gt;&gt; type(&#39;hello&#39;) == strTrue&gt;&gt;&gt; type([]) == listTrue</code></pre><p>如果不是基本数据类型，需要使用标准库中的模块types中定义的变量</p><pre><code class="python">&gt;&gt;&gt; def func():...     pass...&gt;&gt;&gt;&gt;&gt;&gt; type(func) == functionTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#39;function&#39; is not defined&gt;&gt;&gt; type(print)&lt;class &#39;builtin_function_or_method&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type(print) == builtin_function_or_methodTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#39;builtin_function_or_method&#39; is not defined&gt;&gt;&gt; import types&gt;&gt;&gt; type(func) == types.FunctionTypeTrue&gt;&gt;&gt; type(print) == types.BuiltinFunctionTypeTrue</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql搭建异步主从复制</title>
      <link href="/2018/07/13/Mysql/Mysql%E6%90%AD%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2018/07/13/Mysql/Mysql%E6%90%AD%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql搭建异步主从复制"><a href="#Mysql搭建异步主从复制" class="headerlink" title="Mysql搭建异步主从复制"></a>Mysql搭建异步主从复制</h1><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>master</p><pre><code class="bash">ip：10.10.10.100存在一个test库，里面有张t1表</code></pre><p>slave</p><pre><code class="bash">ip：10.10.10.101空库</code></pre><h2 id="搭建步骤（异步主从复制）"><a href="#搭建步骤（异步主从复制）" class="headerlink" title="搭建步骤（异步主从复制）"></a>搭建步骤（异步主从复制）</h2><h3 id="检查配置文件"><a href="#检查配置文件" class="headerlink" title="检查配置文件"></a>检查配置文件</h3><p>master</p><pre><code class="bash"># master[mysqld]server-id=1003306                     ##server-id要唯一，最好以ip地址和端口号命名log-bin=mysql-bin                     ##开启二进制日志，必须要sync-binlog=1                         ##日志刷新模式，按需修改binlog_format=row                     ##日志格式最好用row，statement可能会有数据丢失</code></pre><p>slave</p><pre><code class="bash"># slave[mysqld]server-id=1013306                    ##server-id必须唯一log-bin=mysql-bin                    ##一般来说从库不需要开启binlog，如果有特殊需要，如级联方式的复制，需要开启sync-binlog=1binlog_format=rowlog_slave_updates=1                  ##控制slave是否把master的binlog写入自己的binlog中，级联方式需要开启relay-log=mysql-relay-bin            ##中继日志，不写则以主机名命名，建议写上read-only=1                          ##设置从库只读，避免数据不一致的发生</code></pre><h3 id="导出master上的数据，导入到slave中"><a href="#导出master上的数据，导入到slave中" class="headerlink" title="导出master上的数据，导入到slave中"></a>导出master上的数据，导入到slave中</h3><pre><code class="bash"># master[root@mysql-master-1003306 ~]# mysqldump -uroot -p --single-transaction -A --master-data=2 &gt; all.sql## --master-data=2 表示在备份文件中记录当前备份的二进制日志文件和position号-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000007&#39;, MASTER_LOG_POS=1744;  ##记下这一行，后面会用到[root@mysql-master-1003306 ~]# scp all.sql 10.10.10.101:/root               #将备份文件拷贝到从库</code></pre><h3 id="从库导入数据"><a href="#从库导入数据" class="headerlink" title="从库导入数据"></a>从库导入数据</h3><pre><code class="bash"># slave[root@mysql-slave-1013306 ~]# mysql -uroot -p &lt; all.sql              ##导入数据Enter password:</code></pre><blockquote><p>导出数据也可以使用xtrabackup来进行，xtrabackup导出后也可以查到日志文件和position号，基于那里进行复制也可以；</p></blockquote><h3 id="在master上创建复制账号"><a href="#在master上创建复制账号" class="headerlink" title="在master上创建复制账号"></a>在master上创建复制账号</h3><pre><code class="sql"># mastermysql&gt; grant replication slave on *.* to &#39;repl&#39;@&#39;10.10.10.%&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.06 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec)</code></pre><h3 id="在slave上开启复制"><a href="#在slave上开启复制" class="headerlink" title="在slave上开启复制"></a>在slave上开启复制</h3><pre><code class="sql"># slavemysql&gt; change master to master_host=&#39;10.10.10.100&#39;,master_user=&#39;repl&#39;,master_password=&#39;echo123.&#39;,master_port=3306,master_log_file=&#39;mysql-bin.000007&#39;,master_log_pos=1744;Query OK, 0 rows affected, 2 warnings (0.08 sec)## master_log_file=&#39;mysql-bin.000007&#39;,master_log_pos=1744 指定二进制日志号和position号，从库将从这里开始进行复制mysql&gt; start slave;Query OK, 0 rows affected (0.10 sec)</code></pre><h3 id="查看主从状态"><a href="#查看主从状态" class="headerlink" title="查看主从状态"></a>查看主从状态</h3><pre><code class="sql"># slavemysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.100                  Master_User: repl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000008          Read_Master_Log_Pos: 1365               Relay_Log_File: mysql-relay-bin.000003                Relay_Log_Pos: 1578        Relay_Master_Log_File: mysql-bin.000008             Slave_IO_Running: Yes                       ##yes表示正常            Slave_SQL_Running: Yes                       ##yes表示正常              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 1365              Relay_Log_Space: 1951              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1003306                  Master_UUID: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: 0         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在主库上插入数据</p><pre><code class="sql">mysql&gt; select * from t1;+------+| id   |+------+|    1 ||    2 ||    3 ||    4 ||    5 ||    6 ||    7 ||    8 |+------+8 rows in set (0.00 sec)mysql&gt; insert into t1 values (9);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into t1 values (10);Query OK, 1 row affected (0.02 sec)</code></pre><p>在从库上查看</p><pre><code class="sql">mysql&gt; select * from t1;+------+| id   |+------+|    1 ||    2 ||    3 ||    4 ||    5 ||    6 ||    7 ||    8 ||    9 ||   10 |+------+10 rows in set (0.00 sec)</code></pre><p><strong>使用reset slave all可以清空主从配置；</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-函数及其参数</title>
      <link href="/2018/07/12/Python/Python-%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%8F%82%E6%95%B0/"/>
      <url>/2018/07/12/Python/Python-%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数及其参数"><a href="#函数及其参数" class="headerlink" title="函数及其参数"></a>函数及其参数</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>1、代码复用<br>2、隐藏实现细节<br>3、提高代码可维护性<br>4、提高代码可读性，便于调试</p><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><pre><code class="python">def 函数名([形式参数1, 形式参数2, ..., 形式参数n]):    函数体</code></pre><p>函数名需要遵守命名规则和命名规范，最好使用动宾格式，例如handle_message、print_result等</p><p>关于形式参数的说明：<br>1、形式参数简称形参<br>2、形参用于在调用函数是接收输入，也就是接收传递的实际参数（简称实参）<br>3、形参用中括号括起来，表示形参是可选的，也就是说，可以定义也可以不定义<br>4、形参的本质是变量，其作用域仅限于函数体</p><p>关于函数体的说明：<br>1、函数体是用于执行特定任务，以完成特定功能的主体代码<br>2、函数体对应的代码块必须缩进<br>3、如果函数需要有输出（返回值），可以在函数体内通过语句return xxx进行返回，同时结束函数体的执行。如果函数不需要有输出，可以在函数体内通过语句return直接结束函数的执行，或者让函数体正常执行结束，其实在这两种情况下，都是有返回值的，返回值都是None对象<br>4、函数体只有在调用函数时才会被执行，定义函数并不会改变程序的执行流程</p><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>调用函数时，每个实参都被用于初始化相应的形参，所有形参都被初始化后，函数体对应的代码块被执行。程序的执行流会跳转到定义函数的函数体内，执行函数体对应的代码块，执行完函数体后再跳到调用函数的地方，继续执行下一跳语句。</p><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><h3 id="调用函数：位置实参"><a href="#调用函数：位置实参" class="headerlink" title="调用函数：位置实参"></a>调用函数：位置实参</h3><p>按顺序来，一个萝卜一个坑。</p><pre><code class="python">&gt;&gt;&gt; def func(a, b, c):...     print(&#39;a =&#39;, a, &#39;b =&#39;, b , &#39;c =&#39;, c)...&gt;&gt;&gt; func(1, 2, 3)a = 1 b = 2 c = 3&gt;&gt;&gt; func(3, 2, 1)a = 3 b = 2 c = 1&gt;&gt;&gt;&gt;&gt;&gt; func(&#39;1&#39;, &#39;2&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: func() missing 1 required positional argument: &#39;c&#39;</code></pre><h3 id="调用函数：关键字实参"><a href="#调用函数：关键字实参" class="headerlink" title="调用函数：关键字实参"></a>调用函数：关键字实参</h3><p>形参名 &#x3D; 实参名，关键字实参的位置可以是任意的</p><pre><code class="python">&gt;&gt;&gt; def func(a, b, c):...     print(&#39;a =&#39;, a, &#39;b =&#39;, b , &#39;c =&#39;, c)...&gt;&gt;&gt; func(a = 1, b = 2, c = 3)a = 1 b = 2 c = 3&gt;&gt;&gt; func(b = 2, c = 3, a = 1)a = 1 b = 2 c = 3&gt;&gt;&gt; func(b = 2)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: func() missing 2 required positional arguments: &#39;a&#39; and &#39;c&#39;</code></pre><p><em><strong>位置实参和关键字实参可以混用，但是位置实参必须在关键字实参之前</strong></em></p><pre><code class="python">&gt;&gt;&gt; def func(a, b, c):...     print(&#39;a =&#39;, a, &#39;b =&#39;, b , &#39;c =&#39;, c)...&gt;&gt;&gt;&gt;&gt;&gt; func(1, 2, c = 3)a = 1 b = 2 c = 3&gt;&gt;&gt;&gt;&gt;&gt; func(1, b = 2, 3)  File &quot;&lt;stdin&gt;&quot;, line 1SyntaxError: positional argument follows keyword argument&gt;&gt;&gt; func(1, 2, b = 3)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: func() got multiple values for argument &#39;b&#39;</code></pre><h3 id="调用函数：实参形参的传递"><a href="#调用函数：实参形参的传递" class="headerlink" title="调用函数：实参形参的传递"></a>调用函数：实参形参的传递</h3><p>前面讲到，变量相当于标签，对于赋值语句：变量 &#x3D; 对象，相当于给对象贴了一个标签，标签名就是变量名。<br>调用函数时把实参传递给形参从而用实参初始化形参，本质上执行了赋值语句：形参 &#x3D; 实参对象，相当于给实参对象贴了一个标签，标签名就是形参名。<br>如果实参对象是可变类型，在函数体内对形参对象的任何修改，其实就是对实参对象的修改</p><pre><code class="python">#!/usr/bin/python3def func(arg1, arg2):    print(&#39;初始化形参后:&#39;, &#39;arg1 =&#39;, arg1, &#39;arg2 =&#39;, arg2)    arg1 = arg1 * 2    arg2.append(4)    print(&#39;修改形参后:&#39;, &#39;arg1 =&#39;, arg1, &#39;arg2 =&#39;, arg2)i = 10L = [1, 2, 3]print(&#39;调用函数前: i =&#39;, i, &#39;L =&#39;, L)func(i, L)print(&#39;调用函数后: i =&#39;, i, &#39;L =&#39;, L)</code></pre><pre><code class="python">[root@lyucan ~]# ./4.py调用函数前: i = 10 L = [1, 2, 3]初始化形参后: arg1 = 10 arg2 = [1, 2, 3]修改形参后: arg1 = 20 arg2 = [1, 2, 3, 4]调用函数后: i = 10 L = [1, 2, 3, 4]                   ##实参L变了</code></pre><p>对于实参对象是可变类型，如果想要函数体内改变形参时不改变实参，那么可以传递实参对象的值拷贝来实现</p><pre><code class="python">#!/usr/bin/python3def func(arg1, arg2):    print(&#39;初始化形参后:&#39;, &#39;arg1 =&#39;, arg1, &#39;arg2 =&#39;, arg2)    arg1 = arg1 * 2    arg2.append(4)    print(&#39;修改形参后:&#39;, &#39;arg1 =&#39;, arg1, &#39;arg2 =&#39;, arg2)i = 10L = [1, 2, 3]print(&#39;调用函数前: i =&#39;, i, &#39;L =&#39;, L)func(i, L[:])                            ##实参的值拷贝print(&#39;调用函数后: i =&#39;, i, &#39;L =&#39;, L)</code></pre><pre><code class="python">[root@lyucan ~]# ./4.py调用函数前: i = 10 L = [1, 2, 3]初始化形参后: arg1 = 10 arg2 = [1, 2, 3]修改形参后: arg1 = 20 arg2 = [1, 2, 3, 4]调用函数后: i = 10 L = [1, 2, 3]                   ##实参L不变</code></pre><p>如果需要在调用函数后返回多个返回值，可以在定义函数体内使用return语句返回由多个返回值组成的元组</p><pre><code class="python">#!/usr/bin/python3def func(numbers):    odds = []    evens = []    for number in numbers:        if number % 2:            odds.append(number)        else:            evens.append(number)    return odds, evensprint(func([12, 123,214, 231321,41212,765, 6472,534]))</code></pre><pre><code class="python">[root@lyucan ~]# ./5.py([123, 231321, 765], [12, 214, 41212, 6472, 534])</code></pre><h3 id="定义函数：带默认值的位置形参"><a href="#定义函数：带默认值的位置形参" class="headerlink" title="定义函数：带默认值的位置形参"></a>定义函数：带默认值的位置形参</h3><p>定义函数时，可以给形参设置默认值，在调用函数时，如果不传递对应的实参，就会使用设置的默认值初始化对象，给形参设置默认值后，可以简化函数的调用。<br>定义函数时，没有设置默认值的形参必须位于设置了默认值的形参之前，否则无法根据位置来匹配位置实参和对应的形参。<br>当函数有多个形参时，把变化大的形参放在前面，把变化小的形参放在后面，变化小的形参就可以设置默认值。<br>当不按顺序指定默认形参的实参时，需要指定形参的形参名</p><pre><code class="python">&gt;&gt;&gt; def func(a, b = 5, c = 7):...     print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c)...&gt;&gt;&gt; func(3)a = 3 b = 5 c = 7&gt;&gt;&gt; func(3, 6, 8)a = 3 b = 6 c = 8&gt;&gt;&gt; func(3, 6)a = 3 b = 6 c = 7&gt;&gt;&gt; func(3, c = 8)a = 3 b = 5 c = 8&gt;&gt;&gt; func(b = 6, c = 8)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: func() missing 1 required positional argument: &#39;a&#39;</code></pre><p>在定义函数的时候，给形参设置的默认值就已经被计算出来了，因此，如果给形参设置的默认值是可变类型的对象，并且前一次调用函数时在函数体内修改了形参的默认值，那么修改后的值将作为下一次调用函数时形参的默认值，<strong>所以，定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p><pre><code class="python">&gt;&gt;&gt; def func(L = []):...     L.append(&#39;END&#39;)...     print(L)...&gt;&gt;&gt; func()[&#39;END&#39;]&gt;&gt;&gt; func()[&#39;END&#39;, &#39;END&#39;]&gt;&gt;&gt; func()[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;]&gt;&gt;&gt; func()[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;, &#39;END&#39;]##修改如下&gt;&gt;&gt; def func(L = None):...     if L is None:...         L = []...     L.append(&#39;END&#39;)...     print(L)...&gt;&gt;&gt; func()[&#39;END&#39;]&gt;&gt;&gt; func()[&#39;END&#39;]&gt;&gt;&gt; func()[&#39;END&#39;]</code></pre><h3 id="定义函数：使用-定义命名关键字形参"><a href="#定义函数：使用-定义命名关键字形参" class="headerlink" title="定义函数：使用*定义命名关键字形参"></a>定义函数：使用<code>*</code>定义命名关键字形参</h3><p>定义函数时，可以在所有形参的某个位置添加一个<code>*</code>，这样，<code>*</code>后面的所有形参都被定义为只能接受关键字实参的命名关键字形参</p><pre><code class="python">&gt;&gt;&gt; def f(a, b, *, c, d):...     print(a, b, c, d)...&gt;&gt;&gt; f(1, 2, c = 3, d =4)1 2 3 4&gt;&gt;&gt;&gt;&gt;&gt; f(1, 2, 3, 4)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 4 were given</code></pre><h3 id="定义函数：使用-定义个数可变的位置形参"><a href="#定义函数：使用-定义个数可变的位置形参" class="headerlink" title="定义函数：使用*定义个数可变的位置形参"></a>定义函数：使用<code>*</code>定义个数可变的位置形参</h3><p>定义函数时，可能无法事先确定传递的位置实参的个数，在这种情况下，可以在形参前面添加一个<code>*</code>，将形参定义为个数可变的位置形参，从而可以接收0个或任意多个位置实参。这些位置实参会将个数可变的位置形参初始化为一个元组。</p><pre><code class="python">&gt;&gt;&gt; def f(*args):...     print(args)...&gt;&gt;&gt; f()()&gt;&gt;&gt; f(1)(1,)&gt;&gt;&gt; f(1, 2, 3)(1, 2, 3)</code></pre><p>定义函数时，最多只能定义一个个数可变的位置形参</p><pre><code class="python">&gt;&gt;&gt; def f(*args, *args1):  File &quot;&lt;stdin&gt;&quot;, line 1    def f(*args, *args1):                 ^SyntaxError: invalid syntax</code></pre><p>通常，把个数可变的位置形参定义为最后一个形参，以便接收所有剩余的位置实参。</p><pre><code class="python">&gt;&gt;&gt; def f(a, b, *args):...     print(a, b, args)...&gt;&gt;&gt; f(1, 2, 3, 4, 5)1 2 (3, 4, 5)</code></pre><p>如果个数可变的位置形参不是最后一个形参，那么其后面的所有形参都被定义为只能接受关键字实参的关键字形参</p><pre><code class="python">&gt;&gt;&gt; def f(a, b, *c, d, e):...     print(a, b, c, d, e)...&gt;&gt;&gt;&gt;&gt;&gt; f(1, 2, 3, 4, d = 5, e = 6)1 2 (3, 4) 5 6&gt;&gt;&gt; f(1, 2, 3, 4, 5, 6)                  ##3， 4， 5， 6全部被算做了个数可变的位置实参Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() missing 2 required keyword-only arguments: &#39;d&#39; and &#39;e&#39;</code></pre><h3 id="调用函数：使用-将序列中的每个元素都转换为位置实参"><a href="#调用函数：使用-将序列中的每个元素都转换为位置实参" class="headerlink" title="调用函数：使用*将序列中的每个元素都转换为位置实参"></a>调用函数：使用<code>*</code>将序列中的每个元素都转换为位置实参</h3><p>调用函数时，可以在序列前面添加一个<code>*</code>号，从而将序列中的每个元素都转换为一个单独的位置实参。注意和个数可变的位置形参区分，个数可变的位置形参是在定义函数时使用，使用<code>*</code>将序列中每个元素都转换为位置实参是在调用函数时使用</p><pre><code class="python">&gt;&gt;&gt; def f(a, b, c):...     print(a, b, c)...&gt;&gt;&gt; L = [1, 2, 3]&gt;&gt;&gt; f(*L)1 2 3&gt;&gt;&gt; def f(*args):...     print(args)...&gt;&gt;&gt; L = [1, 2, 3]&gt;&gt;&gt;&gt;&gt;&gt; f(*L)                         ##返回的是一个元组(1, 2, 3)</code></pre><h3 id="定义函数：使用-定义个数可变的关键字形参"><a href="#定义函数：使用-定义个数可变的关键字形参" class="headerlink" title="定义函数：使用**定义个数可变的关键字形参"></a>定义函数：使用<code>**</code>定义个数可变的关键字形参</h3><p>定义函数时，可能无法事先确定传递的关键字实参的个数，在这种情况下，可以在形参前面添加一个<code>**</code>，将形参定义为个数可变的关键字形参，从而可以接收0个或任意多个关键字实参。这些关键字实参会将个数可变的关键字形参初始化为一个字典。</p><pre><code class="python">&gt;&gt;&gt; def f(**kwargs):...     print(kwargs)...&gt;&gt;&gt; f(a = 1, b = 2, c = 3)&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</code></pre><p>定义函数时，最多只能定义一个个数可变的关键字形参</p><pre><code class="python">&gt;&gt;&gt; def f(**kwargs, **kwargs):  File &quot;&lt;stdin&gt;&quot;, line 1    def f(**kwargs, **kwargs):                     ^SyntaxError: invalid syntax</code></pre><p>调用函数时，位置实参必须位于关键字实参之前，所以个数可变的位置形参必须位于个数可变的关键字形参之前</p><pre><code class="python">&gt;&gt;&gt; def f(**kwargs, *args):  File &quot;&lt;stdin&gt;&quot;, line 1    def f(**kwargs, *args):                    ^SyntaxError: invalid syntax</code></pre><h3 id="调用函数：使用-将序列中的每个元素都转换为关键字实参"><a href="#调用函数：使用-将序列中的每个元素都转换为关键字实参" class="headerlink" title="调用函数：使用**将序列中的每个元素都转换为关键字实参"></a>调用函数：使用<code>**</code>将序列中的每个元素都转换为关键字实参</h3><p>调用函数时，可以在字典前面添加一个<code>**</code>号，从而将字典中的每个<code>key-value</code>都转换为一个单独的关键字实参，注意和个数可变的关键字形参区分，个数可变的关键字形参是在定义函数时使用，使用<code>**</code>将字典中每个<code>key-value</code>都转换为关键字实参是在调用函数时使用</p><pre><code class="python">&gt;&gt;&gt; def f(a, b, c):...     print(a, b, c)...&gt;&gt;&gt; f(1, 2, 3)1 2 3&gt;&gt;&gt; f(a = 1, b = 2, c = 3)1 2 3&gt;&gt;&gt; d = dict(a = 1, b = 2, c = 3)&gt;&gt;&gt; d&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;&gt;&gt;&gt; f(d)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() missing 2 required positional arguments: &#39;b&#39; and &#39;c&#39;&gt;&gt;&gt; f(**d)1 2 3&gt;&gt;&gt; def f(**kwargs):...     print(kwargs)...&gt;&gt;&gt; d = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;&gt;&gt;&gt;&gt;&gt;&gt; f(**d)                          ##返回的是一个字典&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</code></pre><p>当使用<code>*</code>加序列(列表，元组等)来传递位置实参时，被传递的实参和形参之间没有要求，但是使用<code>**</code>加字典来传递关键字实参时，<code>**</code>后面的字典的键值必须要和关键字形参的形参名相同<br>这个<code>*</code>、<code>**</code>和<code>*args</code>、<code>*kwargs</code>没有任何关系，一个是定义形参的方法，一个是传入实参的方法，两者之间没有一一对应的关系</p><h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>对于函数、模块、类或方法，位于其第一行的字符串被称为文档字符串，通常用单个引号括起来。<br>文档字符串用于对函数、模块、类或方法进行解释说明。</p><p>通过属性__doc__可以访问文档字符串，或者使用内置函数help()也可以访问文档字符串。</p><p>文档字符串编写规范：<br>1、第一行是简明扼要的总结<br>2、第一行首字母大写，第一行以句号结尾<br>3、如果文档字符串有多行，第二行是空行，从第三行开始进行详细的说明</p><h3 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h3><p>1、给形参添加注解：在形参后面添加：和任意的表达式<br>2、给返回值添加注解：在）的后面添加 -&gt;和任意的表达式</p><pre><code class="python">&gt;&gt;&gt; def f(a: &#39;string&#39;, b: int) -&gt; &#39;join a with b&#39;:...     result = a + str(b)...     print(result)...&gt;&gt;&gt; f(&#39;$&#39;, 11.0)$11.0</code></pre><p>访问函数注解<br>通过属性<code>__annotations__</code>访问函数注解</p><pre><code class="python">&gt;&gt;&gt; f.__annotations__&#123;&#39;a&#39;: &#39;string&#39;, &#39;b&#39;: &lt;class &#39;int&#39;&gt;, &#39;return&#39;: &#39;join a with b&#39;&#125;&gt;&gt;&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-集合</title>
      <link href="/2018/07/12/Python/Python-%E9%9B%86%E5%90%88/"/>
      <url>/2018/07/12/Python/Python-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>可以把集合看做是没有存储<code>vlaue</code>的字典，集合的特点和字典类似，如下：</p><ol><li>集合中不能存在重复的数据</li><li>集合中的key是无序的</li><li>集合中的数据可以是任何不可变类型，并且多种类型的数据可以混合存贮在一个集合中</li><li>集合可以根据需要动态伸缩，在使用前无需事先声明集合的容量</li><li>集合会浪费大量的内存，用空间换时间</li></ol><h2 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h2><p>1、使用花括号{}，集合会去除重复的元素，并无序排列</p><pre><code class="python">&gt;&gt;&gt; s = &#123;5, 1, 2, 6, 2, 1&#125;&gt;&gt;&gt; s&#123;1, 2, 5, 6&#125;</code></pre><p>2、调用内置函数<code>set()</code><br>传入迭代器对象</p><pre><code class="python">&gt;&gt;&gt; s = set(range(6))&gt;&gt;&gt; s&#123;0, 1, 2, 3, 4, 5&#125;</code></pre><p>传入字典</p><pre><code class="python">&gt;&gt;&gt; s = set([5, 1, 2, 6, 2, 1])&gt;&gt;&gt;&gt;&gt;&gt; s&#123;1, 2, 5, 6&#125;</code></pre><p>传入元组</p><pre><code class="python">&gt;&gt;&gt; s = set((5, 1, 2, 6, 2, 1))&gt;&gt;&gt; s&#123;1, 2, 5, 6&#125;</code></pre><p>传入字符串</p><pre><code class="python">&gt;&gt;&gt; s = set(&#39;1231231&#39;)&gt;&gt;&gt; s&#123;&#39;1&#39;, &#39;2&#39;, &#39;3&#39;&#125;</code></pre><p>创建空集合</p><pre><code class="python">&gt;&gt;&gt; s = set()&gt;&gt;&gt; sset()</code></pre><h2 id="集合间的关系"><a href="#集合间的关系" class="headerlink" title="集合间的关系"></a>集合间的关系</h2><p>1、判断两个集合是否相等</p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;5, 3, 7, 9, 1&#125;&gt;&gt;&gt; s1 == s2True</code></pre><p>2、判断集合是否是另一个集合的子集</p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s3 = &#123;1, 3, 5, 6, 7, 9&#125;&gt;&gt;&gt;&gt;&gt;&gt; s1.issubset(s2)False&gt;&gt;&gt;&gt;&gt;&gt; s1.issubset(s3)True</code></pre><p>3、判断集合是否是另一个集合的超集</p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s3 = &#123;1, 3, 5, 6, 7, 9&#125;&gt;&gt;&gt; s2.issuperset(s1)False&gt;&gt;&gt; s3.issuperset(s1)True</code></pre><p>4、判断两个集合是否没有交集</p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s3 = &#123;2, 4, 6, 8, 10&#125;&gt;&gt;&gt;&gt;&gt;&gt; s1.isdisjoint(s2)False&gt;&gt;&gt; s1.isdisjoint(s3)True</code></pre><h2 id="集合的数学操作"><a href="#集合的数学操作" class="headerlink" title="集合的数学操作"></a>集合的数学操作</h2><p>1、使用<code>intersection()</code>方法求交集，原集合不变，等价于使用<code>&amp;</code>符号</p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s1.intersection(s2)&#123;3, 7&#125;&gt;&gt;&gt; s1 &amp; s2&#123;3, 7&#125;s1.intersection_update(s2)方法，用s1.intersection(s2)的返回值更新集合s1，s2不变，返回值为None&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s1.intersection_update(s2)&gt;&gt;&gt; s1&#123;3, 7&#125;&gt;&gt;&gt; s2&#123;2, 3, 6, 7, 10&#125;</code></pre><p>2、并集<br>使用<code>union()</code>求并集，原集合不变，不存在方法<code>union_update()</code>，等价于使用<code>|</code>符号</p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s1.union(s2)&#123;1, 2, 3, 5, 6, 7, 9, 10&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 5, 6, 7, 9, 10&#125;</code></pre><p>3、使用difference()方法求补集，原集合不变，等价于使用“-”符号</p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s1.difference(s2)&#123;1, 5, 9&#125;&gt;&gt;&gt; s2.difference(s1)&#123;2, 10, 6&#125;&gt;&gt;&gt; s1 - s2&#123;1, 5, 9&#125;&gt;&gt;&gt; s2 - s1&#123;2, 10, 6&#125;</code></pre><p><code>s1.difference_update(s2)</code>方法，用<code>s1.difference(s2)</code>的返回值更新集合s1，s2不变，返回值为<code>None</code></p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s1.difference_update(s2)&gt;&gt;&gt; s1&#123;1, 5, 9&#125;&gt;&gt;&gt; s2&#123;2, 3, 6, 7, 10&#125;</code></pre><p>4、使用<code>symmetric()</code>方法求对称补集，原集合不变，等价于使用<code>^</code>符号</p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s1.symmetric_difference(s2)&#123;1, 2, 5, 6, 9, 10&#125;&gt;&gt;&gt; s1 ^ s2&#123;1, 2, 5, 6, 9, 10&#125;</code></pre><p><code>s1.symmetric_update(s2)</code>方法，用<code>s1.symmetric(s2)</code>的返回值更新集合s1，s2不变，返回值为<code>None</code></p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; s2 = &#123;2, 3, 6, 7, 10&#125;&gt;&gt;&gt; s1.symmetric_difference_update(s2)&gt;&gt;&gt; s1&#123;1, 2, 5, 6, 9, 10&#125;&gt;&gt;&gt; s2&#123;2, 3, 6, 7, 10&#125;</code></pre><h2 id="集合查操作"><a href="#集合查操作" class="headerlink" title="集合查操作"></a>集合查操作</h2><p>使用<code>in</code>关键字判断</p><pre><code class="python">&gt;&gt;&gt; s1&#123;1, 2, 5, 6, 9, 10&#125;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1 in s1True&gt;&gt;&gt;&gt;&gt;&gt; 3 in s1False</code></pre><h2 id="集合的增操作"><a href="#集合的增操作" class="headerlink" title="集合的增操作"></a>集合的增操作</h2><p>1、使用<code>add()</code>方法，一次只添加一个元素</p><pre><code class="python">&gt;&gt;&gt; s1&#123;1, 2, 5, 6, 9, 10&#125;&gt;&gt;&gt;&gt;&gt;&gt; s1.add(8)&gt;&gt;&gt; s1&#123;1, 2, 5, 6, 8, 9, 10&#125;</code></pre><p>2、使用<code>update()</code>方法，</p><pre><code class="python">&gt;&gt;&gt; s1 = &#123;1, 2, 3, 4, 5&#125;</code></pre><p>传入集合</p><pre><code class="python">&gt;&gt;&gt; s1.update(&#123;6, 7&#125;)&gt;&gt;&gt; s1&#123;1, 2, 3, 4, 5, 6, 7&#125;&gt;&gt;&gt;</code></pre><p>传入列表</p><pre><code class="python">&gt;&gt;&gt; s1.update([8, 9])&gt;&gt;&gt; s1&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</code></pre><p>传入元组</p><pre><code class="python">&gt;&gt;&gt; s1.update((10,))&gt;&gt;&gt; s1&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;</code></pre><h2 id="集合的删操作"><a href="#集合的删操作" class="headerlink" title="集合的删操作"></a>集合的删操作</h2><p>1、使用<code>remove()</code>方法，一次只能删除一个元素</p><pre><code class="python">&gt;&gt;&gt; s1&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;&gt;&gt;&gt; s1.remove(5)&gt;&gt;&gt; s1&#123;1, 2, 3, 4, 6, 7, 8, 9, 10&#125;&gt;&gt;&gt; s1.remove(11)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 11</code></pre><p>2、使用<code>discard()</code>方法，如果指定的元素在集合中不存在，不会抛出错误，一次只能删除一个元素</p><pre><code class="python">&gt;&gt;&gt; s1&#123;1, 2, 3, 4, 6, 7, 8, 9, 10&#125;&gt;&gt;&gt;&gt;&gt;&gt; s1.discard(6)&gt;&gt;&gt; s1&#123;1, 2, 3, 4, 7, 8, 9, 10&#125;&gt;&gt;&gt;&gt;&gt;&gt; s1.discard(11)&gt;&gt;&gt; s1&#123;1, 2, 3, 4, 7, 8, 9, 10&#125;</code></pre><p>3、使用方法<code>pop()</code>，不能传递参数，一次只删除一个元素，并返回被删除的元素</p><pre><code class="python">&gt;&gt;&gt; s1&#123;1, 2, 3, 4, 7, 8, 9, 10&#125;&gt;&gt;&gt; s1.pop()1&gt;&gt;&gt; s1.pop()2&gt;&gt;&gt; s1.pop()3&gt;&gt;&gt; s1&#123;4, 7, 8, 9, 10&#125;</code></pre><p>4、使用<code>clear()</code>方法，清空集合</p><pre><code class="python">&gt;&gt;&gt; s1&#123;4, 7, 8, 9, 10&#125;&gt;&gt;&gt; s1.clear()&gt;&gt;&gt; s1set()</code></pre><h2 id="不可变集合，frozenset"><a href="#不可变集合，frozenset" class="headerlink" title="不可变集合，frozenset"></a>不可变集合，<code>frozenset</code></h2><p><code>frozenset</code>是不可变类型，因此存在<code>hash</code>值，可以作为字典的<code>key</code>，也可以作为<code>set</code>中的元素</p><p>使用内置函数<code>frozenset()</code>，创建<code>frozenset</code></p><pre><code class="python">&gt;&gt;&gt; frozenset()frozenset()&gt;&gt;&gt; frozenset(range(1, 6))frozenset(&#123;1, 2, 3, 4, 5&#125;)&gt;&gt;&gt; frozenset([1, 2, 3, 4, 5])frozenset(&#123;1, 2, 3, 4, 5&#125;)&gt;&gt;&gt; frozenset((1, 2, 3, 4, 5))frozenset(&#123;1, 2, 3, 4, 5&#125;)&gt;&gt;&gt; frozenset(&#39;12345&#39;)frozenset(&#123;&#39;1&#39;, &#39;3&#39;, &#39;2&#39;, &#39;5&#39;, &#39;4&#39;&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-生成器、迭代器</title>
      <link href="/2018/07/10/Python/Python-%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2018/07/10/Python/Python-%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="生成器、迭代器"><a href="#生成器、迭代器" class="headerlink" title="生成器、迭代器"></a>生成器、迭代器</h1><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>不存在元组生成式，元组是不可变类型的对象，无法再代码中动态的创建元组对象。但是，将列表生成式的[]改成()，程序并不会报错，而是得到一个generator（生成器）对象。为了查看生成器对应的所有元素，有两种方式：<br>1、调用next()内置函数，每次调用都返回生成器的下一个元素，直到抛出异常StopIteration为止</p><pre><code class="python">&gt;&gt;&gt; gen = (x for x in range(10))&gt;&gt;&gt; gen&lt;generator object &lt;genexpr&gt; at 0x7f98dff3b840&gt;&gt;&gt;&gt;&gt;&gt;&gt; next(gen)0&gt;&gt;&gt; next(gen)1&gt;&gt;&gt; next(gen)2&gt;&gt;&gt; next(gen)3&gt;&gt;&gt; next(gen)4&gt;&gt;&gt; next(gen)5&gt;&gt;&gt; next(gen)6&gt;&gt;&gt; next(gen)7&gt;&gt;&gt; next(gen)8&gt;&gt;&gt; next(gen)9&gt;&gt;&gt; next(gen)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration                              # 生成器不会循环调用&gt;&gt;&gt; next(gen)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre><p>2、使用for-in循环进行迭代，这样就不需要关心StopIteration异常了</p><pre><code class="python">&gt;&gt;&gt; gen = (x for x in range(10))&gt;&gt;&gt; for i in gen:...     print(i)...0123456789</code></pre><p>生成器中保存的并不是其对应的所有元素，而是如何推算出所有元素的算法。将生成器用于for-in语句时，元素是在循环过程中不断被推算出来的。将生成器作为内置函数next()的实参时，返回的下一个元素也是在调用函数时被推算出来的，因此生成器是惰性推算，也就是说，只有当用到生成器中的某个元素时，才会临时进行推算，而并不会提前退算出来。</p><p>如果需要创建一个元素个数较大的容器，就可以考虑使用生成器，从而节省大量的空间。</p><p>上面我们使用类似生成式的语法得到的生成器被称为生成器表达式。此外，当推算的算法比较复杂时，我们还可以使用生成器函数得到生成器。<br>生成器函数中通过关键字yield返回推算出来的元素。生成器函数与普通函数的区别在于：当调用内置函数next()或使用for-in语句进行迭代时，执行完yield语句就会将生成器函数挂起，下次会从挂起的地方继续执行。</p><pre><code class="python">&gt;&gt;&gt; a, b, c = 1, 2, 3&gt;&gt;&gt;&gt;&gt;&gt; def func():...     print(a)...     yield a...     print(b)...     yield b...     print(c)...     yield c...&gt;&gt;&gt;&gt;&gt;&gt; f = func()&gt;&gt;&gt;&gt;&gt;&gt; next(f)11&gt;&gt;&gt; next(f)22&gt;&gt;&gt; next(f)33&gt;&gt;&gt; next(f)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre><p>斐波那契数列</p><pre><code class="python">#!/usr/bin/python3def fib(num):    n, a, b = 0, 0, 1    while n &lt; num:#        print(b)        yield b        a, b = b, a + b        n += 1</code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可迭代对象和迭代器并不一样<br><strong>可迭代对象</strong><br>可以用于for-in语句的对象被称为可迭代（Iterable）对象，例如：range、列表、元组、字符串、字典、集合、生成器都是可迭代对象。<br>可以调用内置函数isinstance()判断一个对象是否是可迭代对象。标准库模块collections中的类Iterable用于表示可迭代对象。</p><pre><code class="python">&gt;&gt;&gt; from collections import Iterable__main__:1: DeprecationWarning: Using or importing the ABCs from &#39;collections&#39; instead of from &#39;collections.abc&#39; is deprecated, and in 3.8 it will stop working&gt;&gt;&gt; isinstance([1, 2, 3], Iterable)True&gt;&gt;&gt;</code></pre><p><strong>迭代器</strong><br>如果一个可迭代对象可以作为内置函数next()的实参，从而支持惰性推算，那么该对象就被称为迭代器对象（Iterator）。<br>对于range、列表、元组、字符串、字典、集合等可迭代对象，多不能作为内置函数next()的实参，而生成器可以，所以，生成器是迭代器的一种、<br>可以调用内置函数isinstance()判断一个对象时候是迭代器对象，标准库模块collections中的类Iterator用于表示迭代器对象。</p><pre><code class="python">&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt;&gt;&gt;&gt; isinstance([1, 2, 3], Iterator)False&gt;&gt;&gt; isinstance([1, 2, 3], Iterable)True</code></pre><p>可以调用内置函数iter()把不支持惰性推算的可迭代对象转换为迭代器对象。</p><pre><code class="python">&gt;&gt;&gt; isinstance(iter([1, 2, 3]), Iterator)True&gt;&gt;&gt;&gt;&gt;&gt; iter([1, 2, 3])&lt;list_iterator object at 0x7f1970abf780&gt;&gt;&gt;&gt;&gt;&gt;&gt; I = iter([1, 2, 3])&gt;&gt;&gt; I&lt;list_iterator object at 0x7f1970abf6d8&gt;&gt;&gt;&gt;&gt;&gt;&gt; isinstance(I, Iterator)True&gt;&gt;&gt; next(I)1&gt;&gt;&gt; next(I)2&gt;&gt;&gt; next(I)3&gt;&gt;&gt; next(I)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre><p>如果一个对象同时实现了特殊方法<code>__iter__()</code>和<code>__next__()</code>，那么该对象也被称为迭代器对象。</p><p><a href="http://baihuzi.com/article/b3b41df0-ed27-405e-981f-d0c038fc5de6">类对象特殊方法——<strong>iter</strong>()、<strong>next</strong>()</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-5.7安装</title>
      <link href="/2018/07/09/Mysql/Mysql-5.7%E5%AE%89%E8%A3%85/"/>
      <url>/2018/07/09/Mysql/Mysql-5.7%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-5-7安装"><a href="#Mysql-5-7安装" class="headerlink" title="Mysql-5.7安装"></a>Mysql-5.7安装</h1><h2 id="安装前说明"><a href="#安装前说明" class="headerlink" title="安装前说明"></a>安装前说明</h2><p>如果机器上已经有了mysql或者MariaDB，先卸载再安装；</p><pre><code class="bash">[root@lyucan ~]# rpm -e mariadb-libs-5.5.41-2.el7_0.x86_64 --nodeps</code></pre><h2 id="创建mysql用户"><a href="#创建mysql用户" class="headerlink" title="创建mysql用户"></a>创建mysql用户</h2><pre><code class="bash">[root@lyucan ~]# useradd mysql</code></pre><h2 id="下载软件包并解压授权"><a href="#下载软件包并解压授权" class="headerlink" title="下载软件包并解压授权"></a>下载软件包并解压授权</h2><pre><code class="bash">[root@lyucan ~]# wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz[root@lyucan ~]# tar -xf mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz -C /usr/local/[root@lyucan ~]# mv /usr/local/mysql-5.7.21-linux-glibc2.12-x86_64/ /usr/local/mysql[root@lyucan ~]# chown mysql:mysql /usr/local/mysql/</code></pre><h2 id="创建数据目录"><a href="#创建数据目录" class="headerlink" title="创建数据目录"></a>创建数据目录</h2><pre><code class="bash">[root@lyucan ~]# mkdir /data/mysql -p[root@lyucan ~]# chown -R mysql:mysql /data/mysql/</code></pre><h2 id="创建my-cnf配置文件"><a href="#创建my-cnf配置文件" class="headerlink" title="创建my.cnf配置文件"></a>创建my.cnf配置文件</h2><p>mysql5.7没有默认的my_default.cnf文件，需要自己手动创建，下面这个是一个简单的模板；</p><pre><code class="bash">[root@lyucan mysql]# vim /etc/my.cnf[client]port = 3306socket = /tmp/mysql.sock[mysqld]character_set_server=utf8init_connect=&#39;SET NAMES utf8&#39;basedir=/usr/local/mysqldatadir=/data/mysql/socket=/tmp/mysql.socklog-error=/usr/local/mysql/mysqld.errpid-file=/usr/local/mysql/mysqld.pid#不区分大小写lower_case_table_names = 1#sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION#max_connections=5000</code></pre><h2 id="修改my-cnf权限"><a href="#修改my-cnf权限" class="headerlink" title="修改my.cnf权限"></a>修改my.cnf权限</h2><pre><code class="bash">[mysql@lyucan ~]$ chown mysql:mysql /etc/my.cnf</code></pre><h2 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h2><pre><code class="bash">[root@lyucan bin]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql#这条命令没有输出，但是会创建一个临时的root密码，在上面配置文件定义的/usr/local/mysql/mysqld.err文件中，如下所示，临时密码为 5SEAgHPPqK&lt;u[root@lyucan ~]# cat /usr/local/mysql/mysqld.err2018-04-08T16:39:16.991943Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2018-04-08T16:39:17.284209Z 0 [Warning] InnoDB: New log files created, LSN=457902018-04-08T16:39:17.337845Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2018-04-08T16:39:17.395477Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 61308035-3b4b-11e8-9bb4-da8255dea6c5.2018-04-08T16:39:17.396765Z 0 [Warning] Gtid table is not ready to be used. Table &#39;mysql.gtid_executed&#39; cannot be opened.2018-04-08T16:39:17.397767Z 1 [Note] A temporary password is generated for root@localhost: 5SEAgHPPqK&lt;u</code></pre><h2 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h2><pre><code class="bash">[root@lyucan support-files]# cd /usr/local/mysql/support-files/[root@lyucan support-files]# ./mysql.server startStarting MySQL. SUCCESS!</code></pre><h2 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h2><pre><code class="bash">[root@lyucan support-files]# cd /usr/local/mysql/bin/[root@lyucan bin]# ./mysql -uroot -pEnter password:                 ##这里的密码就是上面的临时root密码 5SEAgHPPqK&lt;uWelcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.7.21Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt;</code></pre><h2 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h2><pre><code class="bash">mysql&gt; set password=password(&#39;root123&#39;);Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><h2 id="安装后操作"><a href="#安装后操作" class="headerlink" title="安装后操作"></a>安装后操作</h2><p>设置开机自启动</p><pre><code class="bash">[root@lyucan bin]# cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld[root@lyucan bin]# chkconfig --add mysqld[root@lyucan bin]# chkconfig mysqld on</code></pre><p>当复制到&#x2F;etc&#x2F;init.d&#x2F;mysqld后，可以使用service mysqld start|stop的方式启停</p><pre><code class="bash">[root@lyucan bin]# service mysqld statusSUCCESS! MySQL running (25732)[root@lyucan bin]# service mysqld stopShutting down MySQL.. SUCCESS![root@lyucan bin]# service mysqld startStarting MySQL. SUCCESS!</code></pre><p>将mysql工具的命令添加到PATH环境变量里面去，使用的时候就不用使用绝对路径</p><pre><code class="bash">[root@lyucan bin]# echo &quot;export PATH=$PATH:/usr/local/mysql/bin&quot; &gt;&gt; /etc/profile[root@lyucan bin]# source /etc/profile</code></pre><h2 id="创建远程连接用户"><a href="#创建远程连接用户" class="headerlink" title="创建远程连接用户"></a>创建远程连接用户</h2><pre><code class="sql">mysql&gt; grant all privileges on *.* to &#39;lyucan&#39;@&#39;%&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)</code></pre><h2 id="远程连接检测，注意放通或关掉防火墙；"><a href="#远程连接检测，注意放通或关掉防火墙；" class="headerlink" title="远程连接检测，注意放通或关掉防火墙；"></a>远程连接检测，注意放通或关掉防火墙；</h2><pre><code class="bash">[root@lyucan ~]# firewall-cmd --permanent --add-service=mysqlsuccess[root@lyucan ~]# firewall-cmd --reloadsuccess</code></pre><p><img src="/images/62b46d6c-9248-4c3c-b339-0660aba8ed7e-Image.png" alt="62b46d6c-9248-4c3c-b339-0660aba8ed7e-Image.png" title="62b46d6c-9248-4c3c-b339-0660aba8ed7e-Image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-实例方法、类方法和静态方法</title>
      <link href="/2018/06/26/Python/Python-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2018/06/26/Python/Python-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="实例方法、类方法和静态方法"><a href="#实例方法、类方法和静态方法" class="headerlink" title="实例方法、类方法和静态方法"></a>实例方法、类方法和静态方法</h1><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><pre><code>只有实例对象才可以调用的方法，有两种调用方式：</code></pre><p>1、在类对象的内部（其他实例方法中）<br>        语法格式：self.方法名([实参])<br>2、在类对象的外部<br>        语法格式：实例对象.方法名([实参])<br>        类对象的所有实例对象都有一个指向类对象的指针，所以，类对象的所有实例对象都可以调用类对象中定义的实例方法。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    # 在类对象中定义实例方法    def im1(self, p1, p2):        print(p1, p2)            def im2(self):        # 在类对象的内部（其他实例方法中）调用实例方法        self.im1(3, 4)mc = MyClass()# 在类对象外部调用实例方法mc.im1(1, 2)mc.im2()</code></pre><pre><code class="python">[root@lyucan ~]# ./7.py1 23 4</code></pre><h3 id="给实例对象和类对象动态的绑定实例方法"><a href="#给实例对象和类对象动态的绑定实例方法" class="headerlink" title="给实例对象和类对象动态的绑定实例方法"></a>给实例对象和类对象动态的绑定实例方法</h3><p>python是动态语言，在是对象或类对象创建之后，可以对其动态的绑定实例方法。<br>同一个类对象的不同实例对象所动态绑定的实例方法是相互独立的。也就是说，给一个实例对象动态绑定的实例方法，对于另一个实例对象是不起作用的。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def im1(self, p1, p2):        print(p1, p2)    def im2(self):        self.im1(3, 4)mc = MyClass()#mc.im1(1, 2)#mc.im2()############################## 定义一个函数作为实例方法def do_sth(self):    print(&#39;do_sth被调用了&#39;)from types import MethodType# 给实例对象动态的绑定实例方法mc.do_sth = MethodType(do_sth, mc)# 调用绑定的实例方法mc.do_sth()# 定义一个新的实例对象，分别调用事先定义实例方法和动态绑定的实例方法，动态绑定的方法是不可用的mc2 = MyClass()mc2.im1(1, 2)mc2.do_sth()</code></pre><pre><code class="python">[root@lyucan ~]# ./7.pydo_sth被调用了1 2Traceback (most recent call last):  File &quot;./7.py&quot;, line 31, in &lt;module&gt;    mc2.do_sth()AttributeError: &#39;MyClass&#39; object has no attribute &#39;do_sth&#39;</code></pre><p>为了能让一个类对象的所有实例对象都可以调用某个动态绑定的实例方法，可以给类对象绑定该实例方法</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def im1(self, p1, p2):        print(p1, p2)    def im2(self):        self.im1(3, 4)# 定义一个函数作为实例方法def do_sth2(self):    print(&#39;do_sth2 被调用了&#39;)# 给类对象动态绑定该实例方法MyClass.do_sth2 = do_sth2im1 = MyClass()im2 = MyClass()im1.do_sth2()im2.do_sth2()</code></pre><pre><code class="python">[root@lyucan ~]# ./8.pydo_sth2 被调用了do_sth2 被调用了</code></pre><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>指的是类对象中使用装饰器@classmethod进行装饰的方法<br>在类对象中定义类方法时，必须使用装饰器@classmethod进行装饰，此外，第一个形参表示类对象，其对应的实参由系统自动传入，第一个形参的名称通常是cls，也可以是其他名字。</p><p>类方法可以被类对象所调用，语法格式：类对象.方法名([实参])，或者：cls.方法名([实参])。<br>类方法也可以被实例对象所调用，语法格式：实例对象.方法名([实参])，或者：self.方法名([实参])。</p><p>类对象的所有实例对象都有一个指向类对象的指针，所以，类对象的所有实例对象都可以调用类对象中定义的类方法。</p><p>调用类方法是，系统自动将类对象作为实参传递给第一个形参，第一个实参会传递给第二个形参，第二个实参会传递给第三个形参，依次类推。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    @classmethod    def cm1(cls, p1, p2):        print(p1, p2)    @classmethod    def cm2(cls):        MyClass.cm1(1, 2)        cls.cm1(3, 4)    def im1(self):        # 在实例方法中调用类方法        self.cm2()mc = MyClass()# 使用类对象调用类方法print(&#39;使用类对象调用类方法&#39;)MyClass.cm1(1, 2)MyClass.cm2()print(&#39;&#39;)# 使用实例对象调用类方法print(&#39;使用实例对象调用类方法&#39;)mc.cm1(5, 6)mc.cm2()mc.im1()</code></pre><pre><code class="python">[root@lyucan ~]# ./8.py使用类对象调用类方法1 21 23 4使用实例对象调用类方法5 61 23 41 23 4</code></pre><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类对象的静态方法只是一个普通函数，把某个普通函数归属于某个类对象，可能只是为了易于管理。</p><p>在类对象中定义静态方法时，必须使用装饰器@staticmethod进行装饰，静态方法只是一个普通函数，因此，第一个形参没有普通含义和要求。</p><p>静态方法可以被类对象所调用，语法格式为：类对象.方法名([实参])，或者：cls.方法名([实参])<br>静态方法也可以被实例对象所调用，语法格式为：实例对象.方法名([实参])，或者：self.方法名([实参])</p><p>类对象的所有实例对象都有一个指向类对象的指针，所以，类对象的所有实例对象都可以调用类对象中定义的静态方法。</p><p>调用静态方式时的函数与调用普通函数是一样的</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    @staticmethod    def sm(p1, p2):        print(p1, p2)    @classmethod    def cm(cls):        # 在类方法中调用静态方法        MyClass.sm(1, 2)        cls.sm(3, 4)    def im(self):        # 在实例方法中调用静态方法        self.sm(5, 6)mc = MyClass()# 使用实例调用静态方法mc.sm(11, 22)mc.cm()mc.im()</code></pre><pre><code class="python">[root@lyucan ~]# vim 9.py[root@lyucan ~]# ./9.py11 221 23 45 6</code></pre><p><img src="/images/27963bdd-aed0-4fbd-9472-20dcee6bd5f0-image.png" alt="27963bdd-aed0-4fbd-9472-20dcee6bd5f0-image.png" title="27963bdd-aed0-4fbd-9472-20dcee6bd5f0-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle归档日志</title>
      <link href="/2018/06/21/Oracle/Oracle%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97/"/>
      <url>/2018/06/21/Oracle/Oracle%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle归档日志"><a href="#Oracle归档日志" class="headerlink" title="Oracle归档日志"></a>Oracle归档日志</h1><p>归档日志是用来将redo log里面的日志永久保存下来所使用的日志，我们知道redo log 是循环使用的，新的redo log将覆盖原来的日志，这样的话，如果数据库数据文件损坏，将丢失数据，我们可以用备份来进行恢复，但是利用备份不可能完全恢复，还需要使用日志来恢复到数据库崩溃的那个时间点。</p><h2 id="查看归档日志模式"><a href="#查看归档日志模式" class="headerlink" title="查看归档日志模式"></a>查看归档日志模式</h2><pre><code class="sql">SQL&gt; select log_mode from v$database;LOG_MODE------------NOARCHIVELOG</code></pre><h2 id="查看归档是否启动"><a href="#查看归档是否启动" class="headerlink" title="查看归档是否启动"></a>查看归档是否启动</h2><pre><code class="bash">SQL&gt; select archiver from v$instance;ARCHIVE-------STOPPED</code></pre><h2 id="查看是不是归档方式及归档的路径"><a href="#查看是不是归档方式及归档的路径" class="headerlink" title="查看是不是归档方式及归档的路径"></a>查看是不是归档方式及归档的路径</h2><pre><code class="bash">SQL&gt; archive log list;Database log mode           No Archive ModeAutomatic archival          DisabledArchive destination         USE_DB_RECOVERY_FILE_DEST   ##这里默认使用闪回区作为归档日志的存放目录，存放归档日志格式为xxxx.arcOldest online log sequence     17Current log sequence        19</code></pre><h2 id="打开归档日志"><a href="#打开归档日志" class="headerlink" title="打开归档日志"></a>打开归档日志</h2><pre><code class="bash">sqlplus / as  sysdbasql&gt; shutdown immediate;    sql&gt; startup mount;               #打开控制文件，不打开数据文件  sql&gt; alter database archivelog;   #将数据库切换为归档模式  sql&gt; alter database open;         #将数据文件打开SQL&gt; archive log list;Database log mode           Archive ModeAutomatic archival          EnabledArchive destination         USE_DB_RECOVERY_FILE_DESTOldest online log sequence     17Next log sequence to archive   19Current log sequence        19</code></pre><h2 id="禁用归档日志"><a href="#禁用归档日志" class="headerlink" title="禁用归档日志"></a>禁用归档日志</h2><pre><code class="bash">sql&gt; archive log list;                #查看是否是归档方式  sql&gt; alter system set log_archive_start=false scope=spfile;    ##禁用主动归档sql&gt; shutdown immediate;    sql&gt; startup mount;                   #打开控制文件，不打开数据文件  sql&gt; alter database noarchivelog;     #将数据库切换为非归档模式  sql&gt; alter database open;             #将数据文件打开SQL&gt; archive log list;Database log mode           No Archive ModeAutomatic archival          DisabledArchive destination         USE_DB_RECOVERY_FILE_DESTOldest online log sequence     17Current log sequence        19</code></pre><p>根据上面的USE_DB_RECOVERY_FILE_DEST，来查找DB_RECOVERY_FILE_DEST</p><pre><code class="bash">SQL&gt; show parameter DB_RECOVERY_FILE_DEST;NAME                      TYPE   VALUE------------------------------------ ----------- ------------------------------db_recovery_file_dest           string      /oracle/11g/flash_recovery_are                                 adb_recovery_file_dest_size      big integer 3882M</code></pre><h2 id="修改归档日志的路径"><a href="#修改归档日志的路径" class="headerlink" title="修改归档日志的路径"></a>修改归档日志的路径</h2><p>归档日志默认使用闪回区来存储归档日志，如上所示，可以修改使用其他路径；<br>查看归档日志路径，可以使用31个路径存放归档日志，我们通常只需要1个存储就行了，没必要搞很多，且开启多份归档需要消耗一部分性能。</p><pre><code class="bash">SQL&gt; show parameter log_archive_dest_;NAME                      TYPE   VALUE------------------------------------ ----------- ------------------------------log_archive_dest_1              string......log_archive_dest_31             string</code></pre><pre><code class="bash">sql&gt; archive log list;  #查看是不是归档方式  sql&gt; alter system set log_archive_start=true scope=both; #启用自动归档  sql&gt; alter system set log_archive_dest_1=&quot;location=/oracle/11g/arch/orcl/arch01&quot; scope=both;  sql&gt; alter system set log_archive_dest_2=&quot;location=/oracle/11g/arch/orcl/arch02&quot; scope=both; #如果归档到两个位置，则可以通过上边方法实现，归档日志存放格式为xxxx.dbf</code></pre><p>设置归档日记格式</p><pre><code class="bash">sql&gt; alter system set log_archive_format=&#39;&#39;arch_%d_%t_%r_%s.log&#39;&#39;</code></pre><p>切换日志组 </p><pre><code class="bash">sql&gt; alter system switch logfile;SQL&gt; alter system archive log current;</code></pre><p>这次日志切换将归档写到两个目标地,  即上边的&#x2F;oracle&#x2F;11g&#x2F;arch&#x2F;orcl&#x2F;arch0n<br>alter system switch logfile 是强制日志切换，不一定就归档当前的重做日志文件（若自动归档打开，就归档前的重做日志，若自动归档没有打开，就不归档当前重做日志。）<br>alter system archive log current 是归档当前的重做日志文件，不管自动归档有没有打都归档。</p><p>主要的区别在于:<br>ALTER SYSTEM SWITCH LOGFILE对单实例数据库或RAC中的当前实例执行日志切换;<br>而ALTER SYSTEM ARCHIVE LOG CURRENT会对数据库中的所有实例执行日志切换。<br>为什么执行热备后要执行alter system archive log current 这个语句，看到很多脚本都是这样写的。<br>是不是必须的？</p><p>一般的RMAN脚本都是这样写的，因为RMAN是可以备份归档日志的。alter system archive log current 这样后就可以将所有的归档都备份出来了。这样做是为了保证数据的完整和一致。</p><h2 id="查看现在归档日志的大小"><a href="#查看现在归档日志的大小" class="headerlink" title="查看现在归档日志的大小"></a>查看现在归档日志的大小</h2><pre><code class="sql">select sum(a.BLOCK_SIZE*a.BLOCKS)/1024/1024 from v$archived_log a where a.DELETED=&#39;NO&#39;;</code></pre><h2 id="查看归档日志最大大小"><a href="#查看归档日志最大大小" class="headerlink" title="查看归档日志最大大小"></a>查看归档日志最大大小</h2><pre><code class="sql">show parameter db_recovery_file_dest_size;</code></pre><h2 id="设置归档日志最大值，处理归档日志满，无法启动"><a href="#设置归档日志最大值，处理归档日志满，无法启动" class="headerlink" title="设置归档日志最大值，处理归档日志满，无法启动"></a>设置归档日志最大值，处理归档日志满，无法启动</h2><pre><code class="sql">startup nomount;alter system set db_recovery_file_dest_size = 4G;alter database mount;alter database on;</code></pre><h2 id="查看归档日志的使用率"><a href="#查看归档日志的使用率" class="headerlink" title="查看归档日志的使用率"></a>查看归档日志的使用率</h2><pre><code class="sql">select PERCENT_SPACE_USED from V$FLASH_RECOVERY_AREA_USAGE where file_type LIKE &#39;ARCHIVED LOG&#39;;</code></pre><h2 id="获取闪回区的使用率"><a href="#获取闪回区的使用率" class="headerlink" title="获取闪回区的使用率"></a>获取闪回区的使用率</h2><pre><code class="sql">select sum(PERCENT_SPACE_USED )  from V$RECOVERY_AREA_USAGE;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql半同步主从复制</title>
      <link href="/2018/06/20/Mysql/Mysql%E5%8D%8A%E5%90%8C%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2018/06/20/Mysql/Mysql%E5%8D%8A%E5%90%8C%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql半同步主从复制"><a href="#Mysql半同步主从复制" class="headerlink" title="Mysql半同步主从复制"></a>Mysql半同步主从复制</h1><p>半同步复制可以直接在异步复制的基础上完成 <a href="http://baihuzi.com/article/d690a43d-7dbd-4c59-8a4c-7e5d0bdbcf8f" title="Mysql搭建异步主从复制">Mysql搭建异步主从复制</a></p><h2 id="先检查是否支持动态安装插件"><a href="#先检查是否支持动态安装插件" class="headerlink" title="先检查是否支持动态安装插件"></a>先检查是否支持动态安装插件</h2><pre><code class="sql">mysql&gt; select @@have_dynamic_loading    -&gt; ;+------------------------+| @@have_dynamic_loading |+------------------------+| YES                    |+------------------------+1 row in set (0.00 sec)</code></pre><h2 id="查看插件库的路径"><a href="#查看插件库的路径" class="headerlink" title="查看插件库的路径"></a>查看插件库的路径</h2><pre><code class="sql">mysql&gt; show variables like &#39;plugin_dir&#39;;+---------------+------------------------------+| Variable_name | Value                        |+---------------+------------------------------+| plugin_dir    | /usr/local/mysql/lib/plugin/ |+---------------+------------------------------+1 row in set (0.00 sec)</code></pre><h2 id="有这个两个表示支持在线安装插件，然后在master和slave上同时安装插件"><a href="#有这个两个表示支持在线安装插件，然后在master和slave上同时安装插件" class="headerlink" title="有这个两个表示支持在线安装插件，然后在master和slave上同时安装插件"></a>有这个两个表示支持在线安装插件，然后在master和slave上同时安装插件</h2><pre><code class="sql"># mastermysql&gt; install plugin rpl_semi_sync_master SONAME &#39;semisync_master.so&#39;;Query OK, 0 rows affected (0.10 sec)mysql&gt; select * from mysql.plugin;+----------------------+--------------------+| name                 | dl                 |+----------------------+--------------------+| rpl_semi_sync_master | semisync_master.so |+----------------------+--------------------+1 row in set (0.00 sec)mysql&gt; set global rpl_semi_sync_master_enabled=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; show status like &#39;%semi_sync%&#39;;+--------------------------------------------+-------+| Variable_name                              | Value |+--------------------------------------------+-------+| Rpl_semi_sync_master_clients               | 0     || Rpl_semi_sync_master_net_avg_wait_time     | 0     || Rpl_semi_sync_master_net_wait_time         | 0     || Rpl_semi_sync_master_net_waits             | 0     || Rpl_semi_sync_master_no_times              | 0     || Rpl_semi_sync_master_no_tx                 | 0     || Rpl_semi_sync_master_status                | ON    || Rpl_semi_sync_master_timefunc_failures     | 0     || Rpl_semi_sync_master_tx_avg_wait_time      | 0     || Rpl_semi_sync_master_tx_wait_time          | 0     || Rpl_semi_sync_master_tx_waits              | 0     || Rpl_semi_sync_master_wait_pos_backtraverse | 0     || Rpl_semi_sync_master_wait_sessions         | 0     || Rpl_semi_sync_master_yes_tx                | 0     |+--------------------------------------------+-------+14 rows in set (0.01 sec)</code></pre><pre><code class="sql"># slavemysql&gt; install plugin rpl_semi_sync_slave SONAME &#39;semisync_slave.so&#39;;Query OK, 0 rows affected (0.02 sec)mysql&gt; select * from mysql.plugin;+---------------------+-------------------+| name                | dl                |+---------------------+-------------------+| rpl_semi_sync_slave | semisync_slave.so |+---------------------+-------------------+1 row in set (0.00 sec)mysql&gt; set global rpl_semi_sync_slave_enabled=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; show status like &#39;%semi_sync%&#39;;+----------------------------+-------+| Variable_name              | Value |+----------------------------+-------+| Rpl_semi_sync_slave_status | OFF   |+----------------------------+-------+1 row in set (0.00 sec)## 开启了半同步，为什么还是off呢，是由于我们之前slave是在运行状态，将其重启下就可以了！mysql&gt; stop slave;Query OK, 0 rows affected (0.00 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.01 sec)mysql&gt; show status like &#39;%semi_sync%&#39;;+----------------------------+-------+| Variable_name              | Value |+----------------------------+-------+| Rpl_semi_sync_slave_status | ON    |+----------------------------+-------+1 row in set (0.01 sec)</code></pre><h2 id="查看master上的状态"><a href="#查看master上的状态" class="headerlink" title="查看master上的状态"></a>查看master上的状态</h2><pre><code class="sql">mysql&gt; show status like &#39;%semi%&#39;;+--------------------------------------------+-------+| Variable_name                              | Value |+--------------------------------------------+-------+| Rpl_semi_sync_master_clients               | 1     || Rpl_semi_sync_master_net_avg_wait_time     | 0     || net_wait_time         | 0     || Rpl_semi_sync_master_net_waits             | 0     || Rpl_semi_sync_master_no_times              | 0     || Rpl_semi_sync_master_no_tx                 | 0     || Rpl_semi_sync_master_status                | ON    || Rpl_semi_sync_master_timefunc_failures     | 0     || Rpl_semi_sync_master_tx_avg_wait_time      | 0     || Rpl_semi_sync_master_tx_wait_time          | 0     || Rpl_semi_sync_master_tx_waits              | 0     || Rpl_semi_sync_master_wait_pos_backtraverse | 0     || Rpl_semi_sync_master_wait_sessions         | 0     || Rpl_semi_sync_master_yes_tx                | 0     |+--------------------------------------------+-------+14 rows in set (0.00 sec)#Rpl_semi_sync_master_clients 表示有几台slave连接到了这台master上，有几台，数字就是几；</code></pre><h2 id="将配置写入my-cnf中，避免重启失效"><a href="#将配置写入my-cnf中，避免重启失效" class="headerlink" title="将配置写入my.cnf中，避免重启失效"></a>将配置写入my.cnf中，避免重启失效</h2><p>master</p><pre><code class="sql">[mysqld]rpl_semi_sync_master_enabled=1rpl_semi_sync_master_timeout=10000        ##配置超时多少毫秒切换到异同步复制</code></pre><p>slave</p><pre><code class="sql">[mysqld]rpl_semi_sync_slave_enabled=1</code></pre><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>将 slave 的io thread 停掉，那么将在10秒后切换到异步复制（上面配置文件配置的10秒），也就是插入操作将卡住10秒才插入成功</p><pre><code class="sql"># slavemysql&gt; stop slave io_thread;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; show warnings;+-------+------+-----------------------------------------------------------+| Level | Code | Message                                                   |+-------+------+-----------------------------------------------------------+| Note  | 3084 | Replication thread(s) for channel &#39;&#39; are already stopped. |+-------+------+-----------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; show status like &#39;%semi%&#39;;+----------------------------+-------+| Variable_name              | Value |+----------------------------+-------+| Rpl_semi_sync_slave_status | OFF   |+----------------------------+-------+1 row in set (0.00 sec)# mastermysql&gt; insert into t1 values(17);Query OK, 1 row affected (10.01 sec)           ##可以看到花了10秒才插入成功，此时就切换到了异步复制</code></pre><p>切换到异步复制后，系统不会自动切回半同步，需要手动切，切得方式很简单，就是stop slave；start slave；</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵模式</title>
      <link href="/2018/06/11/%E8%BF%90%E7%BB%B4/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/11/%E8%BF%90%E7%BB%B4/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h1><p>环境</p><table><thead><tr><th align="left">角色</th><th align="left">IP</th><th align="left">端口</th></tr></thead><tbody><tr><td align="left">master</td><td align="left">10.10.10.100</td><td align="left">6379</td></tr><tr><td align="left">slave1</td><td align="left">10.10.10.101</td><td align="left">6379</td></tr><tr><td align="left">slave2</td><td align="left">10.10.10.102</td><td align="left">6379</td></tr><tr><td align="left">sentinel</td><td align="left">10.10.10.100</td><td align="left">26379</td></tr><tr><td align="left">sentinel</td><td align="left">10.10.10.101</td><td align="left">26379</td></tr><tr><td align="left">sentinel</td><td align="left">10.10.10.102</td><td align="left">26379</td></tr></tbody></table><p>主从复制配置很简单，不做赘述</p><pre><code class="bash">10.10.10.100:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip=10.10.10.101,port=6379,state=online,offset=5695,lag=1slave1:ip=10.10.10.102,port=6379,state=online,offset=5695,lag=0master_replid:ed0b450585c5395c1eebce8eb8b5273df35463camaster_replid2:0000000000000000000000000000000000000000master_repl_offset:5695second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:5695</code></pre><pre><code class="bash">10.10.10.101:6379&gt; info replication# Replicationrole:slavemaster_host:10.10.10.100master_port:6379master_link_status:upmaster_last_io_seconds_ago:9master_sync_in_progress:0slave_repl_offset:5737slave_priority:100slave_read_only:1connected_slaves:0master_replid:ed0b450585c5395c1eebce8eb8b5273df35463camaster_replid2:0000000000000000000000000000000000000000master_repl_offset:5737second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:5737</code></pre><pre><code class="bash">10.10.10.102:6379&gt; info replication# Replicationrole:slavemaster_host:10.10.10.100master_port:6379master_link_status:upmaster_last_io_seconds_ago:4master_sync_in_progress:0slave_repl_offset:5807slave_priority:100slave_read_only:1connected_slaves:0master_replid:ed0b450585c5395c1eebce8eb8b5273df35463camaster_replid2:0000000000000000000000000000000000000000master_repl_offset:5807second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1523repl_backlog_histlen:4285</code></pre><p>复制一份安装包里面的配置文件sentinel.conf，修改以下master配置即可</p><pre><code class="bash">sentinel monitor mymaster 10.10.10.100 6379 2##mymaster名字随便取，但是需要保持一致## 2 表示获取的票数，有三台哨兵，2台及2台以上认为master挂掉了，才进行切换，这个值需要大于哨兵总数的一半</code></pre><p><strong>注意！！哨兵模式在配置的时候，如果三个哨兵启动在不同的机器，需要配置bind IPADDR ，否则哨兵将不起作用</strong></p><pre><code class="bash"># *** IMPORTANT ***## By default Sentinel will not be reachable from interfaces different than# localhost, either use the &#39;bind&#39; directive to bind to a list of network# interfaces, or disable protected mode with &quot;protected-mode no&quot; by# adding it to this configuration file.## Before doing that MAKE SURE the instance is protected from the outside# world via firewalling or other means.## For example you may use one of the following:## bind 127.0.0.1 192.168.1.1## protected-mode no# port &lt;sentinel-port&gt;# The port that this sentinel instance will run onbind 10.10.10.100port 26379</code></pre><p>如果不配置bind，将会出现以下现象，会自动断开其他哨兵的连接</p><pre><code class="bash">12642:X 31 May 14:03:12.133 # Sentinel ID is 93f88deff364d6f6842540a85b6ad066b6e1c72d12642:X 31 May 14:03:12.133 # +monitor master mymaster 10.10.10.100 6379 quorum 212642:X 31 May 14:03:12.133 * +slave slave 10.10.10.101:6379 10.10.10.101 6379 @ mymaster 10.10.10.100 637912642:X 31 May 14:03:12.134 * +slave slave 10.10.10.102:6379 10.10.10.102 6379 @ mymaster 10.10.10.100 637912642:X 31 May 14:03:17.880 * +sentinel sentinel f99e627401f6e23d1242c18764b8d820a63ef1b5 10.10.10.101 26379 @ mymaster 10.10.10.100 637912642:X 31 May 14:03:21.432 * +sentinel sentinel d9463b90bd223c6308969dc3a7c7ae7299f4cc93 10.10.10.102 26379 @ mymaster 10.10.10.100 637912642:X 31 May 14:03:47.904 # +sdown sentinel f99e627401f6e23d1242c18764b8d820a63ef1b5 10.10.10.101 26379 @ mymaster 10.10.10.100 637912642:X 31 May 14:03:51.494 # +sdown sentinel d9463b90bd223c6308969dc3a7c7ae7299f4cc93 10.10.10.102 26379 @ mymaster 10.10.10.100 6379</code></pre><p>配置成功后会在配置文件后面添加主从信息和哨兵节点信息</p><pre><code class="bash"># Generated by CONFIG REWRITEsentinel known-slave mymaster 10.10.10.102 6379sentinel known-slave mymaster 10.10.10.101 6379sentinel known-sentinel mymaster 10.10.10.102 26379 d9463b90bd223c6308969dc3a7c7ae7299f4cc93sentinel known-sentinel mymaster 10.10.10.101 26379 f99e627401f6e23d1242c18764b8d820a63ef1b5sentinel current-epoch 4</code></pre><p>把master down掉，观察是否会进行切换，三台哨兵，会选举出来一台进行切换动作</p><pre><code class="bash">12677:X 31 May 14:19:33.030 # +sdown master mymaster 10.10.10.100 637912677:X 31 May 14:19:33.097 # +odown master mymaster 10.10.10.100 6379 #quorum 3/212677:X 31 May 14:19:33.097 # +new-epoch 512677:X 31 May 14:19:33.097 # +try-failover master mymaster 10.10.10.100 637912677:X 31 May 14:19:33.098 # +vote-for-leader 93f88deff364d6f6842540a85b6ad066b6e1c72d 512677:X 31 May 14:19:33.100 # d9463b90bd223c6308969dc3a7c7ae7299f4cc93 voted for 93f88deff364d6f6842540a85b6ad066b6e1c72d 512677:X 31 May 14:19:33.100 # f99e627401f6e23d1242c18764b8d820a63ef1b5 voted for 93f88deff364d6f6842540a85b6ad066b6e1c72d 512677:X 31 May 14:19:33.154 # +elected-leader master mymaster 10.10.10.100 637912677:X 31 May 14:19:33.154 # +failover-state-select-slave master mymaster 10.10.10.100 637912677:X 31 May 14:19:33.238 # +selected-slave slave 10.10.10.102:6379 10.10.10.102 6379 @ mymaster 10.10.10.100 637912677:X 31 May 14:19:33.238 * +failover-state-send-slaveof-noone slave 10.10.10.102:6379 10.10.10.102 6379 @ mymaster 10.10.10.100 637912677:X 31 May 14:19:33.310 * +failover-state-wait-promotion slave 10.10.10.102:6379 10.10.10.102 6379 @ mymaster 10.10.10.100 637912677:X 31 May 14:19:33.835 # +promoted-slave slave 10.10.10.102:6379 10.10.10.102 6379 @ mymaster 10.10.10.100 637912677:X 31 May 14:19:33.835 # +failover-state-reconf-slaves master mymaster 10.10.10.100 637912677:X 31 May 14:19:33.924 * +slave-reconf-sent slave 10.10.10.101:6379 10.10.10.101 6379 @ mymaster 10.10.10.100 637912677:X 31 May 14:19:34.242 # -odown master mymaster 10.10.10.100 637912677:X 31 May 14:19:34.886 * +slave-reconf-inprog slave 10.10.10.101:6379 10.10.10.101 6379 @ mymaster 10.10.10.100 637912677:X 31 May 14:19:34.886 * +slave-reconf-done slave 10.10.10.101:6379 10.10.10.101 6379 @ mymaster 10.10.10.100 637912677:X 31 May 14:19:34.940 # +failover-end master mymaster 10.10.10.100 637912677:X 31 May 14:19:34.940 # +switch-master mymaster 10.10.10.100 6379 10.10.10.102 637912677:X 31 May 14:19:34.940 * +slave slave 10.10.10.101:6379 10.10.10.101 6379 @ mymaster 10.10.10.102 637912677:X 31 May 14:19:34.940 * +slave slave 10.10.10.100:6379 10.10.10.100 6379 @ mymaster 10.10.10.102 637912677:X 31 May 14:20:04.962 # +sdown slave 10.10.10.100:6379 10.10.10.100 6379 @ mymaster 10.10.10.102 6379</code></pre><p>三台哨兵，挂了一台可以继续工作，挂了两台就不行了，因为票数是2，如果票数是1的话，只有一台哨兵也是可以工作的</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-访问控制“__”和“_”</title>
      <link href="/2018/06/05/Python/Python-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E2%80%9C__%E2%80%9D%E5%92%8C%E2%80%9C_%E2%80%9D/"/>
      <url>/2018/06/05/Python/Python-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E2%80%9C__%E2%80%9D%E5%92%8C%E2%80%9C_%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="访问控制“-”和“-”"><a href="#访问控制“-”和“-”" class="headerlink" title="访问控制“__”和“_”"></a>访问控制“__”和“_”</h1><p>访问控制指的是：控制类对象的属性和方法在类对象的外部是否可以直接访问。<br>如果在类对象的某个属性或方法前添加两个下划线<code>__</code>，那么在类对象的外部就不能直接访问该属性或方法了。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def __init__(self):        self.__name = &#39;Hehe&#39;    def __get_name(self):        print(&#39;__get_name() 被调用了&#39;)    def get_name(self):        print(&#39;name:&#39;, self.__name)mc = MyClass()print(mc.__name)   # AttributeError: &#39;MyClass&#39; object has no attribute &#39;__get_name&#39;mc.__get_name()    # AttributeError: &#39;MyClass&#39; object has no attribute &#39;__get_name&#39;mc.get_name()      # name: Hehe   </code></pre><p>之所以不能在类对象的外部直接访问以<code>__</code>开头的属性或方法，是因为python解释器把属性或方法<code>__xxx</code>改成了另一个名字：<code>_类名__xxx</code>。所以在类对象的外部仍然可以通过<code>_类名__xxx</code>访问属性或方法。但是，强烈建议不要这样访问，因为不同版本的python解释器可能会把属性或方法<code>__xxx</code>改成不同的名字。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def __init__(self):        self.__name = &#39;Hehe&#39;    def __get_name(self):        print(&#39;__get_name() 被调用了&#39;)    def get_name(self):        print(&#39;name:&#39;, self.__name)mc = MyClass()print(mc._MyClass__name)mc._MyClass__get_name()mc.get_name()</code></pre><pre><code class="python">[root@lyucan ~]# ./10.pyHehe__get_name() 被调用了name: Hehe</code></pre><p>我们仍然可以在类对象的外部动态的绑定名为<code>__xxx</code>的属性或方法，这与类对象内部名为<code>__xxx</code>的属性或方法是不同的，动态添加的名为<code>__xxx</code>的方法是可以在外部被访问的。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def __init__(self):        self.__name = &#39;Hehe&#39;    def __get_name(self):        print(&#39;__get_name() 被调用了&#39;)    def get_name(self):        print(&#39;name:&#39;, self.__name)mc = MyClass()mc.__age = 18print(mc.__age)</code></pre><pre><code class="python">[root@lyucan ~]# ./10.py18</code></pre><p>除了在类对象的属性或方法前添加两个下划线<code>__</code>，还可以在类对象的属性或方法前添加单下划线<code>_</code>。</p><p>为了在某种程度上实现模块内的数据访问控制，可以在模块内的某些属性前添加单下划线<code>_</code>，这样，就无法使用语句<code>from 模块名 import *</code>导入相应的属性了，但是，使用语句<code>import 模块名</code>仍然可以导入相应的属性。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMAN恢复数据文件和表空间</title>
      <link href="/2018/06/02/Oracle/RMAN%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
      <url>/2018/06/02/Oracle/RMAN%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="RMAN恢复数据文件和表空间"><a href="#RMAN恢复数据文件和表空间" class="headerlink" title="RMAN恢复数据文件和表空间"></a>RMAN恢复数据文件和表空间</h1><p>当数据文件由于操作失误或者介质损坏而丢失或损坏的时候可以进行恢复<br>如果是介质损坏则需要先修复介质<br>system、undo表空间的数据文件损坏需要关闭数据库进行恢复</p><h2 id="恢复数据文件"><a href="#恢复数据文件" class="headerlink" title="恢复数据文件"></a>恢复数据文件</h2><pre><code class="sql">run &#123;sql &#39;alter database datafile 5 offline&#39;;restore datafile 5;recover datafile 5;sql &#39;alter database datafile 5 online&#39;;&#125;</code></pre><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><pre><code class="sql">sys@MYSQL_MA&gt; select file_id,tablespace_name,file_name,online_status from dba_data_files;</code></pre><p><img src="/images/b25b955f-7cc2-4784-a847-b23089545890-Image.png" alt="b25b955f-7cc2-4784-a847-b23089545890-Image.png" title="b25b955f-7cc2-4784-a847-b23089545890-Image.png"></p><p>删除tbs01.dbf</p><pre><code class="sql">[oracle@mysql-master-1003306 ~]$ rm -rf /oracle/11g/oradata/mysql_master_1003306/tbs01.dbf</code></pre><p>使用rman恢复，前提是要先有备份</p><pre><code class="sql">RMAN&gt; run &#123;sql &#39;alter database datafile 5 offline&#39;;restore datafile 5;recover datafile 5;sql &#39;alter database datafile 5 online&#39;;&#125;sql statement: alter database datafile 5 offlineStarting restore at 21-MAY-18allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=41 device type=DISKchannel ORA_DISK_1: starting datafile backup set restorechannel ORA_DISK_1: specifying datafile(s) to restore from backup setchannel ORA_DISK_1: restoring datafile 00005 to /oracle/11g/oradata/mysql_master_1003306/tbs01.dbfchannel ORA_DISK_1: reading from backup piece /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_21/o1_mf_nnndf_TAG20180521T113848_fj5t08z3_.bkpchannel ORA_DISK_1: piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_21/o1_mf_nnndf_TAG20180521T113848_fj5t08z3_.bkp tag=TAG20180521T113848channel ORA_DISK_1: restored backup piece 1channel ORA_DISK_1: restore complete, elapsed time: 00:00:03Finished restore at 21-MAY-18Starting recover at 21-MAY-18using channel ORA_DISK_1starting media recoverymedia recovery complete, elapsed time: 00:00:01Finished recover at 21-MAY-18sql statement: alter database datafile 5 online</code></pre><h2 id="恢复表空间"><a href="#恢复表空间" class="headerlink" title="恢复表空间"></a>恢复表空间</h2><p>恢复表空间包括对该表空间所有数据文件的恢复<br>需要注意离线的数据文件，离线的数据文件在恢复表空间的时候是不会被恢复的，需要单独进行恢复<br>system或undo表空间丢失则数据库要关闭才能进行恢复</p><pre><code class="sql">run &#123;sql &#39;alter tablespace tablespace_name offline immediate&#39;;restore tablespace tablespace_name;recover tablespace tablespace_name;sql &#39;alter tablespace tablespace_name online&#39;;&#125;</code></pre><h3 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h3><pre><code class="sql">RMAN&gt; run &#123;sql &#39;alter tablespace tbs01 offline immediate&#39;;restore tablespace tbs01;recover tablespace tbs01;sql &#39;alter tablespace tbs01 online&#39;;&#125;starting full resync of recovery catalogfull resync completesql statement: alter tablespace tbs01 offline immediateStarting restore at 21-MAY-18using channel ORA_DISK_1channel ORA_DISK_1: starting datafile backup set restorechannel ORA_DISK_1: specifying datafile(s) to restore from backup setchannel ORA_DISK_1: restoring datafile 00005 to /oracle/11g/oradata/mysql_master_1003306/tbs01.dbfchannel ORA_DISK_1: reading from backup piece /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_21/o1_mf_nnndf_TAG20180521T125815_fj5yo89p_.bkpchannel ORA_DISK_1: piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_21/o1_mf_nnndf_TAG20180521T125815_fj5yo89p_.bkp tag=TAG20180521T125815channel ORA_DISK_1: restored backup piece 1channel ORA_DISK_1: restore complete, elapsed time: 00:00:03Finished restore at 21-MAY-18Starting recover at 21-MAY-18using channel ORA_DISK_1starting media recoverymedia recovery complete, elapsed time: 00:00:01Finished recover at 21-MAY-18sql statement: alter tablespace tbs01 onlinestarting full resync of recovery catalogfull resync complete</code></pre><p>如果原介质不可用了，需要把数据文件恢复到不同的位置，可以使用set newname命令来指定新的目录</p><p>针对数据文件使用</p><pre><code class="sql">set newname for datafile 3 to &#39;PATH&#39;</code></pre><p>针对表空间使用</p><pre><code class="sql">set newname for tablespace tablespace_name to &#39;PATH&#39;</code></pre><p>目标文件名可使用变量</p><ul><li>%b：不含目录的文件名</li><li>%f：文件编号</li><li>%I：DBID</li><li>%N：表空间名称</li><li>%U：系统自动生成文件名，data-%I_TS-%N_FNO-%f</li></ul><p>针对数据文件例如：</p><pre><code class="sql">run &#123;sql &#39;alter database datafile 5 offline&#39;;set newname for datafile 5 to &#39;/oracle/11g/oradata/orcl/%U&#39;;restore datafile 5;switch datafile all;recover datafile 5;sql &#39;alter database datafile 5 online&#39;;&#125;</code></pre><p>针对表空间例如：</p><pre><code class="sql">run &#123;sql &#39;alter tablespace tablespace_name offline immediate&#39;;set newname for tablespace tablespace_name to &#39;/oracle/11g/oradata/orcl/%U&#39;;restore tablespace tablespace_name;switch datafile all;recover tablespace tablespace_name;sql &#39;alter tablespace tablespace_name online&#39;;&#125;</code></pre><p>如果认为误操作导致删除了数据文件，又没有备份，短期可以进行恢复，因为删除只是删除了元数据，实际的数据短时间没有被覆盖，且oracle还持有文件句柄，就可以恢复</p><p>例如：<br>删除数据文件TBS01</p><pre><code class="sql">[oracle@mysql-master-1003306 mysql_master_1003306]$ lscontrol01.ctl  redo01.log  redo02.log  redo03.log  sysaux01.dbf  system01.dbf  TBS01  temp01.dbf  undotbs01.dbf  users01.dbf[oracle@mysql-master-1003306 mysql_master_1003306]$ rm -rf TBS01</code></pre><p>恢复步骤<br>1）查看ora_dbw进程</p><pre><code class="bash">[oracle@mysql-master-1003306 mysql_master_1003306]$ ps -ef |grep ora_dbworacle     4388      1  0 13:30 ?        00:00:00 ora_dbw0_orcloracle     4604   3782  0 13:47 pts/2    00:00:00 grep --color=auto ora_dbw</code></pre><p>进到fd里面，被删除的文件会被标记为delete，如下所示</p><pre><code class="bash">[oracle@mysql-master-1003306 fd]$ cd[oracle@mysql-master-1003306 ~]$ cd /proc/4388/fd[oracle@mysql-master-1003306 fd]$ lltotal 0lr-x------. 1 oracle oinstall 64 May 21 13:41 0 -&gt; /dev/nulll-wx------. 1 oracle oinstall 64 May 21 13:41 1 -&gt; /dev/nulll-wx------. 1 oracle oinstall 64 May 21 13:41 10 -&gt; /oracle/11g/diag/rdbms/mysql_ma/orcl/trace/orcl_ora_4323.trcl-wx------. 1 oracle oinstall 64 May 21 13:41 11 -&gt; /oracle/11g/diag/rdbms/mysql_ma/orcl/trace/orcl_ora_4323.trmlr-x------. 1 oracle oinstall 64 May 21 13:41 12 -&gt; /oracle/11g/product/11.2.0/dbhome_1/rdbms/mesg/oraus.msblr-x------. 1 oracle oinstall 64 May 21 13:41 13 -&gt; /dev/zerolr-x------. 1 oracle oinstall 64 May 21 13:41 14 -&gt; /proc/4388/fdlr-x------. 1 oracle oinstall 64 May 21 13:41 15 -&gt; /dev/zerolrwx------. 1 oracle oinstall 64 May 21 13:41 16 -&gt; /oracle/11g/product/11.2.0/dbhome_1/dbs/hc_orcl.datlrwx------. 1 oracle oinstall 64 May 21 13:41 17 -&gt; /oracle/11g/product/11.2.0/dbhome_1/dbs/lkMYSQL_MAlrwx------. 1 oracle oinstall 64 May 21 13:41 18 -&gt; /oracle/11g/oradata/mysql_master_1003306/control01.ctllrwx------. 1 oracle oinstall 64 May 21 13:41 19 -&gt; /oracle/11g/flash_recovery_area/mysql_master_1003306/control02.ctll-wx------. 1 oracle oinstall 64 May 21 13:41 2 -&gt; /dev/nulllrwx------. 1 oracle oinstall 64 May 21 13:41 20 -&gt; /oracle/11g/oradata/mysql_master_1003306/system01.dbflrwx------. 1 oracle oinstall 64 May 21 13:41 21 -&gt; /oracle/11g/oradata/mysql_master_1003306/sysaux01.dbflrwx------. 1 oracle oinstall 64 May 21 13:41 22 -&gt; /oracle/11g/oradata/mysql_master_1003306/undotbs01.dbflrwx------. 1 oracle oinstall 64 May 21 13:41 23 -&gt; /oracle/11g/oradata/mysql_master_1003306/users01.dbflrwx------. 1 oracle oinstall 64 May 21 13:41 26 -&gt; socket:[42915]lrwx------. 1 oracle oinstall 64 May 21 13:41 27 -&gt; /oracle/11g/oradata/mysql_master_1003306/temp01.dbflr-x------. 1 oracle oinstall 64 May 21 13:41 28 -&gt; /oracle/11g/product/11.2.0/dbhome_1/rdbms/mesg/oraus.msblrwx------. 1 oracle oinstall 64 May 21 13:41 29 -&gt; /oracle/11g/oradata/mysql_master_1003306/TBS01 (deleted)l-wx------. 1 oracle oinstall 64 May 21 13:41 3 -&gt; /oracle/11g/product/11.2.0/dbhome_1/rdbms/log/orcl_ora_4323.trclr-x------. 1 oracle oinstall 64 May 21 13:41 4 -&gt; /dev/nulllr-x------. 1 oracle oinstall 64 May 21 13:41 5 -&gt; /dev/nulllr-x------. 1 oracle oinstall 64 May 21 13:41 6 -&gt; /dev/nulllrwx------. 1 oracle oinstall 64 May 21 13:41 7 -&gt; /oracle/11g/product/11.2.0/dbhome_1/dbs/hc_orcl.datlrwx------. 1 oracle oinstall 64 May 21 13:41 8 -&gt; /oracle/11g/product/11.2.0/dbhome_1/dbs/lkinstorcl (deleted)lr-x------. 1 oracle oinstall 64 May 21 13:41 9 -&gt; /proc/4388/fd</code></pre><p>将其拷贝到原有位置，就恢复了</p><pre><code class="bash">[oracle@mysql-master-1003306 fd]$ cp 29 /oracle/11g/oradata/mysql_master_1003306/TBS01[oracle@mysql-master-1003306 fd]$ ls -l /oracle/11g/oradata/mysql_master_1003306/TBS01-rw-r-----. 1 oracle oinstall 209723392 May 21 13:50 /oracle/11g/oradata/mysql_master_1003306/TBS01</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-运算符</title>
      <link href="/2018/06/01/Python/Python-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/06/01/Python/Python-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="标准算数运算符"><a href="#标准算数运算符" class="headerlink" title="标准算数运算符"></a>标准算数运算符</h2><p><code>+</code>：加<br><code>-</code>：减<br><code>*</code>：乘<br><code>/</code>：除<br><code>//</code>：地板除，运算结果只保留整数部分，就是运算一个数值是另一个数值的多少倍<br><code>%</code>：取余，余数是介于0到除数之间<br><code>**</code>：幂运算，也可调用内置函数pow()来进行幂运算</p><pre><code class="python">&gt;&gt;&gt; 1 + 12&gt;&gt;&gt; 3 - 12&gt;&gt;&gt; 5.0 * 630.0&gt;&gt;&gt;&gt;&gt;&gt; 5.0 / 60.8333333333333334&gt;&gt;&gt; 5.0 / 51.0&gt;&gt;&gt; 9 // 42&gt;&gt;&gt; 9 // -4-3&gt;&gt;&gt; 9 % -4-3&gt;&gt;&gt; 2 ** 24&gt;&gt;&gt; -2 ** 2-4&gt;&gt;&gt; pow(2, 2)4&gt;&gt;&gt; pow(-2, 2)4</code></pre><pre><code class="python">a += b  --&gt; a = a + ba -= b  --&gt; a = a - ba *= b  --&gt; a = a * ba /= b  --&gt; a = a / b</code></pre><h2 id="逻辑运算符（布尔运算符）"><a href="#逻辑运算符（布尔运算符）" class="headerlink" title="逻辑运算符（布尔运算符）"></a>逻辑运算符（布尔运算符）</h2><p>and：逻辑与<br>or：逻辑或<br>not：逻辑非</p><p>比较运算符<br><code>&gt;</code><br><code>&lt;</code><br><code>==</code>：用于比较两个运算数时候相等，“相等性测试”<br><code>&gt;=</code><br><code>&lt;=</code><br><code>!=</code><br><code>is</code>：比较两个运算数是否是同一个对象，“同一性测试”<br><code>is not</code></p><h2 id="可变类型的is比较"><a href="#可变类型的is比较" class="headerlink" title="可变类型的is比较"></a>可变类型的is比较</h2><pre><code class="python">&gt;&gt;&gt; a = b = [1, 2, 3]&gt;&gt;&gt; c = [1, 2, 3]&gt;&gt;&gt;&gt;&gt;&gt; id(a)140032055835656&gt;&gt;&gt; id(b)140032055835656&gt;&gt;&gt; id(c)140032060966088&gt;&gt;&gt;&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a == cTrue&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a is cFalse</code></pre><h2 id="不可变类型的is比较"><a href="#不可变类型的is比较" class="headerlink" title="不可变类型的is比较"></a>不可变类型的is比较</h2><p>对于不可变类型的对象，其内存可能被重用，比如数值较小的整数对象</p><pre><code class="python">&gt;&gt;&gt; a = 10&gt;&gt;&gt; b = 10&gt;&gt;&gt; id(a)139944117569408&gt;&gt;&gt; id(b)139944117569408&gt;&gt;&gt; a is bTrue&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c = 111111111111111111111&gt;&gt;&gt; d = 111111111111111111111&gt;&gt;&gt; id(c)139944118708864&gt;&gt;&gt; id(d)139944118708904&gt;&gt;&gt; c is dFalse&gt;&gt;&gt;</code></pre><h2 id="链式比较"><a href="#链式比较" class="headerlink" title="链式比较"></a>链式比较</h2><p>并不是从左到右依次比较，而是两两比较进行与运算</p><pre><code class="python">&gt;&gt;&gt; 3 &gt; 2 &gt; 1True&gt;&gt;&gt; 3 &gt; 2 and 2 &gt; 1True&gt;&gt;&gt; 6 &gt; 4 is True            ##等价于6 &gt; 4 and 4 is True，结果为FalseFalse&gt;&gt;&gt; 6 &gt; 4 and 4 is TrueFalse&gt;&gt;&gt; (6 &gt; 4) is TrueTrue</code></pre><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>先乘除，后加减，有括号先算括号<br><img src="/images/56aff379-b1d3-4076-b44e-b49043e08614-Image.png" alt="56aff379-b1d3-4076-b44e-b49043e08614-Image.png" title="56aff379-b1d3-4076-b44e-b49043e08614-Image.png"></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符="></a>赋值运算符<code>=</code></h2><p>多个变量同事赋值，赋值运算符的左边可以是一个所有元素都为变量的元组或列表，从而一次给多个变量同事赋值</p><pre><code class="python">&gt;&gt;&gt; a, b = 1, 2&gt;&gt;&gt; print(a, b)1 2&gt;&gt;&gt; a, b = [3, 4]&gt;&gt;&gt; print(a, b)3 4&gt;&gt;&gt; a, b = b, a&gt;&gt;&gt; print(a, b)4 3</code></pre><p>赋值运算符左右两边的元素个数必须是相同的，否则会抛出ValueError</p><pre><code class="python">&gt;&gt;&gt; a, b = 1, 2, 3Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: too many values to unpack (expected 2)</code></pre><p>可以在赋值运算符左边的某个变量前添加*，以匹配赋值运算符右边的0个或多个元素。</p><pre><code class="python">&gt;&gt;&gt; a, *b, c = 1, 2, 3, 4&gt;&gt;&gt; print(a, b, c)1 [2, 3] 4&gt;&gt;&gt; *a, b, c = 1, 2, 3, 4&gt;&gt;&gt; print(a, b, c)[1, 2] 3 4&gt;&gt;&gt; a, b, *c = 1, 2, 3, 4&gt;&gt;&gt; print(a, b, c)1 2 [3, 4]&gt;&gt;&gt; *a, b, c = 1, 2&gt;&gt;&gt; print(a, b, c)[] 1 2&gt;&gt;&gt; a, *b, c = 1, 2&gt;&gt;&gt; print(a, b, c)1 [] 2&gt;&gt;&gt; a, b, *c = 1, 2&gt;&gt;&gt; print(a, b, c)1 2 []</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMAN恢复控制文件-控制文件(controlfile)丢失恢复</title>
      <link href="/2018/06/01/Oracle/RMAN%E6%81%A2%E5%A4%8D%E6%8E%A7%E5%88%B6%E6%96%87%E4%BB%B6-%E6%8E%A7%E5%88%B6%E6%96%87%E4%BB%B6(controlfile)%E4%B8%A2%E5%A4%B1%E6%81%A2%E5%A4%8D/"/>
      <url>/2018/06/01/Oracle/RMAN%E6%81%A2%E5%A4%8D%E6%8E%A7%E5%88%B6%E6%96%87%E4%BB%B6-%E6%8E%A7%E5%88%B6%E6%96%87%E4%BB%B6(controlfile)%E4%B8%A2%E5%A4%B1%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="RMAN恢复控制文件-控制文件-controlfile-丢失恢复"><a href="#RMAN恢复控制文件-控制文件-controlfile-丢失恢复" class="headerlink" title="RMAN恢复控制文件-控制文件(controlfile)丢失恢复"></a>RMAN恢复控制文件-控制文件(controlfile)丢失恢复</h1><p>基于控制文件的复合多路径性，它的丢失分为两种，一种是其中某个控制文件的损坏或丢失，另外一种是所有控制文件均丢失。<br>基于第一种情况，只需把好的控制文件复制一份在损坏或丢失的那个控制文件路径下即可。第二种情况下则需要通过备份信息来对控制文件进行恢复或手工重建控制文件。</p><h2 id="情景一：单一控制文件丢失"><a href="#情景一：单一控制文件丢失" class="headerlink" title="情景一：单一控制文件丢失"></a>情景一：单一控制文件丢失</h2><p>查看控制文件</p><pre><code class="sql">SQL&gt; select name from v$controlfile;NAME--------------------------------------------------------------------------------/oracle/11g/oradata/oracle/control01.ctl/oracle/11g/flash_recovery_area/oracle/control02.ctl##或者SQL&gt; show parameter control_file;NAME                            TYPE        VALUE------------------------------------ ----------- ------------------------------control_file_record_keep_time   integer     7control_files                   string      /oracle/11g/oradata/oracle/con                                            trol01.ctl, /oracle/11g/flash_                                            recovery_area/oracle/control02                                            .ctl</code></pre><p>模拟控制文件丢失，删除控制文件&#x2F;oracle&#x2F;11g&#x2F;oradata&#x2F;oracle&#x2F;control01.ctl</p><pre><code class="sql">[oracle@oracle ~]$ rm /oracle/11g/oradata/oracle/control01.ctl</code></pre><p>关闭数据库，数据库无法正常关闭，因为在关闭的时候必须向控制文件中更新scn号，此时需要使用abort关闭</p><pre><code class="sql">SQL&gt; shutdown immediate;ORA-00210: cannot open the specified control fileORA-00202: control file: &#39;/oracle/11g/oradata/oracle/control01.ctl&#39;ORA-27041: unable to open fileLinux-x86_64 Error: 2: No such file or directoryAdditional information: 3SQL&gt; shutdown abort;ORACLE instance shut down.</code></pre><p>启动数据库失败</p><pre><code class="sql">SQL&gt; startup;ORACLE instance started.Total System Global Area  409194496 bytesFixed Size          2213856 bytesVariable Size          335546400 bytesDatabase Buffers        67108864 bytesRedo Buffers             4325376 bytesORA-00205: error in identifying control file, check alert log for more info</code></pre><p>使用其他的控制文件恢复</p><pre><code class="sql">[oracle@oracle ~]$ cp -a /oracle/11g/flash_recovery_area/oracle/control02.ctl /oracle/11g/oradata/oracle/control01.ctl[oracle@oracle ~]$ ll /oracle/11g/oradata/oracle/control01.ctl-rw-r-----. 1 oracle oinstall 9945088 May 17 13:51 /oracle/11g/oradata/oracle/control01.ctl</code></pre><p>重新启动</p><pre><code class="sql">SQL&gt; startup;ORA-32004: obsolete or deprecated parameter(s) specified for RDBMS instanceORA-01081: cannot start already-running ORACLE - shut it down firstSQL&gt; shutdown abort;ORACLE instance shut down.SQL&gt; startup;ORA-32004: obsolete or deprecated parameter(s) specified for RDBMS instanceORACLE instance started.Total System Global Area  409194496 bytesFixed Size          2213856 bytesVariable Size          335546400 bytesDatabase Buffers        67108864 bytesRedo Buffers             4325376 bytesDatabase mounted.Database opened.</code></pre><h2 id="情景二：全部控制文件丢失，但是有自动备份控制文件"><a href="#情景二：全部控制文件丢失，但是有自动备份控制文件" class="headerlink" title="情景二：全部控制文件丢失，但是有自动备份控制文件"></a>情景二：全部控制文件丢失，但是有自动备份控制文件</h2><pre><code class="sql">RMAN&gt; show all;RMAN configuration parameters for database with db_unique_name MYSQL_MA are:CONFIGURE RETENTION POLICY TO REDUNDANCY 1; # defaultCONFIGURE BACKUP OPTIMIZATION OFF; # defaultCONFIGURE DEFAULT DEVICE TYPE TO DISK; # defaultCONFIGURE CONTROLFILE AUTOBACKUP ON;    ##开启自动备份控制文件CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO &#39;%F&#39;; # default   ##保存在闪回区中</code></pre><p>自动备份，备份文件放在闪回区</p><pre><code class="sql">RMAN&gt; backup tablespace users;......Starting Control File and SPFILE Autobackup at 17-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_17/o1_mf_s_976388621_fhw2lg7b_.bkp comment=NONEFinished Control File and SPFILE Autobackup at 17-MAY-18</code></pre><p>删除所有的控制文件</p><pre><code class="sql">[oracle@mysql-master-1003306 ~]$ rm /oracle/11g/oradata/mysql_master_1003306/control01.ctl /oracle/11g/flash_recovery_area/mysql_master_1003306/control02.ctl</code></pre><p>关闭数据库，数据库无法正常关闭，因为在关闭的时候必须向控制文件中更新scn号，此时需要使用abort关闭</p><pre><code class="sql">SQL&gt; shutdown immediate;ORA-00210: cannot open the specified control fileORA-00202: control file: &#39;/oracle/11g/oradata/oracle/control01.ctl&#39;ORA-27041: unable to open fileLinux-x86_64 Error: 2: No such file or directoryAdditional information: 3SQL&gt; shutdown abort;ORACLE instance shut down.</code></pre><p>rman连接到目标库,如果报错<code>ORA-12528: TNS:listener: all appropriate instances are blocking new connections</code>，则需要配置静态注册，使用静态注册的服务名来连，因为此时数据库连接是blocked的</p><pre><code class="sql">[oracle@oracle oracle]$ rman target sys/Oracle_1@ma1 catalog rman/Rman_1@rmanRecovery Manager: Release 11.2.0.1.0 - Production on Thu May 17 18:38:29 2018Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.connected to target database (not started)connected to recovery catalog database</code></pre><p>恢复控制文件</p><pre><code class="sql">RMAN&gt; startup nomount;Oracle instance startedTotal System Global Area     409194496 bytesFixed Size                     2213856 bytesVariable Size                335546400 bytesDatabase Buffers              67108864 bytesRedo Buffers                   4325376 bytesRMAN&gt; restore controlfile from autobackup;  ##自动识别自动备份里面的备份Starting restore at 17-MAY-18allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=19 device type=DISKrecovery area destination: /oracle/11g/flash_recovery_areadatabase name (or database unique name) used for search: MYSQL_MAchannel ORA_DISK_1: AUTOBACKUP /oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_17/o1_mf_s_976388621_fhw2lg7b_.bkp found in the recovery areachannel ORA_DISK_1: looking for AUTOBACKUP on day: 20180517channel ORA_DISK_1: restoring control file from AUTOBACKUP /oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_17/o1_mf_s_976388621_fhw2lg7b_.bkpchannel ORA_DISK_1: control file restore from AUTOBACKUP completeoutput file name=/oracle/11g/oradata/mysql_master_1003306/control01.ctloutput file name=/oracle/11g/flash_recovery_area/mysql_master_1003306/control02.ctlFinished restore at 17-MAY-18RMAN&gt; alter database mount;database mountedreleased channel: ORA_DISK_1RMAN&gt; recover database;Starting recover at 17-MAY-18Starting implicit crosscheck backup at 17-MAY-18allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=19 device type=DISKCrosschecked 1 objectsFinished implicit crosscheck backup at 17-MAY-18Starting implicit crosscheck copy at 17-MAY-18using channel ORA_DISK_1Finished implicit crosscheck copy at 17-MAY-18searching for all files in the recovery areacataloging files...cataloging doneList of Cataloged Files=======================File Name: /oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_17/o1_mf_s_976388621_fhw2lg7b_.bkpusing channel ORA_DISK_1starting media recoveryarchived log for thread 1 with sequence 1 is already on disk as file /oracle/11g/oradata/mysql_master_1003306/redo01.logarchived log file name=/oracle/11g/oradata/mysql_master_1003306/redo01.log thread=1 sequence=1media recovery complete, elapsed time: 00:00:00Finished recover at 17-MAY-18RMAN&gt; alter database open resetlogs;database openednew incarnation of database registered in recovery catalogstarting full resync of recovery catalogfull resync complete</code></pre><p>以上是备份文件放在闪回区内，如果备份文件没有放在闪回区内，可能需要设置DBID，但是在oracle11g中，我试验的时候不需要设置DBID也可以进行恢复；</p><h2 id="情景三：全部控制文件丢失，没有自动备份控制文件，但是有数据库全备"><a href="#情景三：全部控制文件丢失，没有自动备份控制文件，但是有数据库全备" class="headerlink" title="情景三：全部控制文件丢失，没有自动备份控制文件，但是有数据库全备"></a>情景三：全部控制文件丢失，没有自动备份控制文件，但是有数据库全备</h2><p>查看控制文件</p><pre><code class="sql">sys@MYSQL_MA&gt; select name from v$controlfile;NAME-----------------------------------/oracle/11g/oradata/mysql_master_1003306/control01.ctl/oracle/11g/flash_recovery_area/mysql_master_1003306/control02.ctl##或者sys@MYSQL_MA&gt; show parameter control_file;NAME                                  TYPE       VALUE------------------------------------ ----------- ------------------------------control_file_record_keep_time        integer     7control_files                        string      /oracle/11g/oradata/mysql_mast                                                 er_1003306/control01.ctl, /ora                                                 cle/11g/flash_recovery_area/my                                                 sql_master_1003306/control02.c                                                 tl</code></pre><p>RMAN没有开启自动备份控制文件</p><pre><code class="sql">RMAN&gt; show all;RMAN configuration parameters for database with db_unique_name ORACLE are:CONFIGURE RETENTION POLICY TO REDUNDANCY 1; # defaultCONFIGURE BACKUP OPTIMIZATION OFF; # defaultCONFIGURE DEFAULT DEVICE TYPE TO DISK; # default......</code></pre><p>全备数据库</p><pre><code class="sql">RMAN&gt; backup database plus archivelog delete all input;Starting backup at 17-MAY-18current log archivedusing channel ORA_DISK_1channel ORA_DISK_1: starting archived log backup setchannel ORA_DISK_1: specifying archived log(s) in backup setinput archived log thread=1 sequence=55 RECID=59 STAMP=976314177input archived log thread=1 sequence=56 RECID=60 STAMP=976385529channel ORA_DISK_1: starting piece 1 at 17-MAY-18channel ORA_DISK_1: finished piece 1 at 17-MAY-18piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_17/o1_mf_annnn_TAG20180517T181210_fhvzktll_.bkp tag=TAG20180517T181210 comment=NONEchannel ORA_DISK_1: backup set complete, elapsed time: 00:00:03channel ORA_DISK_1: deleting archived log(s)archived log file name=/oracle/11g/flash_recovery_area/MYSQL_MA/archivelog/2018_05_16/o1_mf_1_55_fhssvy7r_.arc RECID=59 STAMP=976314177......</code></pre><p>删除所有的控制文件</p><pre><code class="sql">[oracle@mysql-master-1003306 ~]$ rm /oracle/11g/oradata/mysql_master_1003306/control01.ctl /oracle/11g/flash_recovery_area/mysql_master_1003306/control02.ctl</code></pre><p>停库</p><pre><code class="sql">SQL&gt; shutdown immediate;Database closed.ORA-00210: cannot open the specified control fileORA-00202: control file: &#39;/oracle/11g/oradata/oracle/control01.ctl&#39;ORA-27041: unable to open fileLinux-x86_64 Error: 2: No such file or directoryAdditional information: 3SQL&gt; shutdown abort;ORACLE instance shut down.</code></pre><p>rman连接到目标库,如果报错<code>ORA-12528: TNS:listener: all appropriate instances are blocking new connections，</code>则需要配置静态注册，使用静态注册的服务名来连，因为此时数据库连接是blocked的</p><pre><code class="sql">[oracle@oracle oracle]$ rman target sys/Oracle_1@ma1 catalog rman/Rman_1@rmanRecovery Manager: Release 11.2.0.1.0 - Production on Thu May 17 18:38:29 2018Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.connected to target database (not started)connected to recovery catalog database</code></pre><p>恢复控制文件</p><pre><code class="sql">##将数据库启动到nomount状态RMAN&gt; startup nomount;Oracle instance startedTotal System Global Area     409194496 bytesFixed Size                     2213856 bytesVariable Size                335546400 bytesDatabase Buffers              67108864 bytesRedo Buffers                   4325376 bytes##查看含有控制文件的全备备份集RMAN&gt; list backupset;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------597     Full    13.05M     DISK        00:00:01     17-MAY-18             BP Key: 600   Status: AVAILABLE  Compressed: NO  Tag: TAG20180517T182027        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_17/o1_mf_ncsnf_TAG20180517T182027_fhw02hlh_.bkp  SPFILE Included: Modification time: 17-MAY-18  SPFILE db_unique_name: MYSQL_MA  Control File Included: Ckp SCN: 1517178      Ckp time: 17-MAY-18##使用该备份集恢复控制文件，自动选择最新备份集RMAN&gt; restore controlfile;Starting restore at 17-MAY-18using channel ORA_DISK_1channel ORA_DISK_1: starting datafile backup set restorechannel ORA_DISK_1: restoring control filechannel ORA_DISK_1: reading from backup piece /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_17/o1_mf_ncsnf_TAG20180517T182027_fhw02hlh_.bkpchannel ORA_DISK_1: piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_17/o1_mf_ncsnf_TAG20180517T182027_fhw02hlh_.bkp tag=TAG20180517T182027channel ORA_DISK_1: restored backup piece 1channel ORA_DISK_1: restore complete, elapsed time: 00:00:01output file name=/oracle/11g/oradata/mysql_master_1003306/control01.ctloutput file name=/oracle/11g/flash_recovery_area/mysql_master_1003306/control02.ctlFinished restore at 17-MAY-18##使用该备份集恢复控制文件，手动指定备份集RMAN&gt; restore controlfile to &#39;/oracle/11g/oradata/mysql_master_1003306/control01.ctl&#39; from tag &#39;TAG20180517T182027&#39;;Starting restore at 17-MAY-18allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=19 device type=DISKchannel ORA_DISK_1: starting datafile backup set restorechannel ORA_DISK_1: restoring control fileoutput file name=/oracle/11g/oradata/mysql_master_1003306/control01.ctlchannel ORA_DISK_1: reading from backup piece /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_17/o1_mf_ncsnf_TAG20180517T182027_fhw02hlh_.bkpchannel ORA_DISK_1: piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_17/o1_mf_ncsnf_TAG20180517T182027_fhw02hlh_.bkp tag=TAG20180517T182027channel ORA_DISK_1: restored backup piece 1channel ORA_DISK_1: restore complete, elapsed time: 00:00:01Finished restore at 17-MAY-18</code></pre><p>启动并恢复数据库</p><pre><code class="sql">RMAN&gt; alter database mount;database mountedreleased channel: ORA_DISK_1RMAN&gt; recover database;Starting recover at 17-MAY-18Starting implicit crosscheck backup at 17-MAY-18allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=19 device type=DISKCrosschecked 2 objectsFinished implicit crosscheck backup at 17-MAY-18Starting implicit crosscheck copy at 17-MAY-18using channel ORA_DISK_1Finished implicit crosscheck copy at 17-MAY-18searching for all files in the recovery areacataloging files...cataloging doneList of Cataloged Files=======================File Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_17/o1_mf_ncsnf_TAG20180517T182027_fhw02hlh_.bkpFile Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_17/o1_mf_annnn_TAG20180517T182105_fhw02knm_.bkpusing channel ORA_DISK_1starting media recoveryarchived log for thread 1 with sequence 59 is already on disk as file /oracle/11g/oradata/mysql_master_1003306/redo02.logarchived log for thread 1 with sequence 60 is already on disk as file /oracle/11g/oradata/mysql_master_1003306/redo03.logarchived log file name=/oracle/11g/oradata/mysql_master_1003306/redo02.log thread=1 sequence=59archived log file name=/oracle/11g/oradata/mysql_master_1003306/redo03.log thread=1 sequence=60media recovery complete, elapsed time: 00:00:00Finished recover at 17-MAY-18RMAN&gt; alter database open resetlogs;    ##恢复控制文件也需要resetlogsdatabase openednew incarnation of database registered in recovery catalogstarting full resync of recovery catalogfull resync complete</code></pre><h2 id="情景四：啥都没有，重建控制文件"><a href="#情景四：啥都没有，重建控制文件" class="headerlink" title="情景四：啥都没有，重建控制文件"></a>情景四：啥都没有，重建控制文件</h2><p>删除所有的控制文件</p><pre><code class="sql">[oracle@oracle ~]$ rm /oracle/11g/oradata/oracle/control01.ctl /oracle/11g/flash_recovery_area/oracle/control02.ctl</code></pre><p>关闭数据库，数据库无法正常关闭，因为在关闭的时候必须向控制文件中更新scn号，此时需要使用abort关闭</p><pre><code class="sql">SQL&gt; shutdown immediate;ORA-00210: cannot open the specified control fileORA-00202: control file: &#39;/oracle/11g/oradata/oracle/control01.ctl&#39;ORA-27041: unable to open fileLinux-x86_64 Error: 2: No such file or directoryAdditional information: 3SQL&gt; shutdown abort;ORACLE instance shut down.</code></pre><p>重建控制文件<br>步骤1：获取数据库名及字符集</p><pre><code class="sql">SQL&gt; create pfile from spfile;File created.##查看pfile[oracle@oracle dbs]$ cat initorcl.ora | grep db_name*.db_name=&#39;oracle&#39;##开启到nomount模式，查看字符集SQL&gt; start nomount;SQL&gt; select userenv(&#39;language&#39;) from dual;USERENV(&#39;LANGUAGE&#39;)----------------------------------------------------AMERICAN_AMERICA.US7ASCII</code></pre><p>步骤2：获取数据文件路径及名称</p><pre><code class="sql">[oracle@oracle oracle]$ ll /oracle/11g/oradata/oracle/*.dbf-rw-r-----. 1 oracle oinstall 1073750016 May 17 14:16 /oracle/11g/oradata/oracle/bigtbs.dbf-rw-r-----. 1 oracle oinstall  650125312 May 17 14:16 /oracle/11g/oradata/oracle/sysaux01.dbf-rw-r-----. 1 oracle oinstall  744497152 May 17 14:16 /oracle/11g/oradata/oracle/system01.dbf-rw-r-----. 1 oracle oinstall  524296192 May 17 14:16 /oracle/11g/oradata/oracle/tbs01.dbf-rw-r-----. 1 oracle oinstall   20979712 May  8 03:16 /oracle/11g/oradata/oracle/temp001.dbf-rw-r-----. 1 oracle oinstall   20979712 May  8 03:16 /oracle/11g/oradata/oracle/temp002.dbf-rw-r-----. 1 oracle oinstall   35659776 May 16 22:02 /oracle/11g/oradata/oracle/temp01.dbf-rw-r-----. 1 oracle oinstall   41951232 May 17 14:16 /oracle/11g/oradata/oracle/undo01.dbf-rw-r-----. 1 oracle oinstall   78651392 May 17 14:16 /oracle/11g/oradata/oracle/undotbs01.dbf-rw-r-----. 1 oracle oinstall    5251072 May 17 14:16 /oracle/11g/oradata/oracle/users01.dbf</code></pre><p>步骤3：生成创建控制文件脚本，注意去掉temp表空间</p><pre><code class="sql">STARTUP NOMOUNTCREATE CONTROLFILE REUSE DATABASE &quot;oracle&quot; NORESETLOGS ARCHIVELOG    MAXLOGFILES 5    MAXLOGMEMBERS 3    MAXDATAFILES 100    MAXINSTANCES 1    MAXLOGHISTORY 226LOGFILE  GROUP 1 &#39;/oracle/11g/oradata/oracle/redo01.log&#39; SIZE 50M,  GROUP 2 &#39;/oracle/11g/oradata/oracle/redo02.log&#39; SIZE 50M,  GROUP 3 &#39;/oracle/11g/oradata/oracle/redo03.log&#39; SIZE 50MDATAFILE        &#39;/oracle/11g/oradata/oracle/bigtbs.dbf&#39;,        &#39;/oracle/11g/oradata/oracle/sysaux01.dbf&#39;,        &#39;/oracle/11g/oradata/oracle/system01.dbf&#39;,        &#39;/oracle/11g/oradata/oracle/tbs01.dbf&#39;,        &#39;/oracle/11g/oradata/oracle/undo01.dbf&#39;,        &#39;/oracle/11g/oradata/oracle/undotbs01.dbf&#39;,        &#39;/oracle/11g/oradata/oracle/users01.dbf&#39;CHARACTER SET US7ASCII;</code></pre><p>步骤4：执行脚本</p><pre><code class="sql">SQL&gt; @/oracle/11g/product/11.2.0/dbhome_1/dbs/a.sqlORA-32004: obsolete or deprecated parameter(s) specified for RDBMS instanceORACLE instance started.Total System Global Area  409194496 bytesFixed Size          2213856 bytesVariable Size          331352096 bytesDatabase Buffers        71303168 bytesRedo Buffers             4325376 bytesControl file created.SQL&gt; select status from v$instance;STATUS------------MOUNTEDSQL&gt; alter database open;Database altered.</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MHA高可用架构原理及搭建</title>
      <link href="/2018/05/27/Mysql/MHA%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E5%8F%8A%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/05/27/Mysql/MHA%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E5%8F%8A%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="MHA高可用架构原理及搭建"><a href="#MHA高可用架构原理及搭建" class="headerlink" title="MHA高可用架构原理及搭建"></a>MHA高可用架构原理及搭建</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本DeNA公司youshimaton（现就职于Facebook公司）开发，是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA能在最大程度上保证数据的一致性，以达到真正意义上的高可用。</p><p><strong>该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）</strong>。MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上。MHA Node运行在每台MySQL服务器上，MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。整个故障转移过程对应用程序完全透明。</p><p>在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失，但这并不总是可行的。例如，如果主服务器硬件故障或无法通过ssh访问，MHA没法保存二进制日志，只进行故障转移而丢失了最新的数据。使用MySQL 5.5的半同步复制，可以大大降低数据丢失的风险。MHA可以与半同步复制结合起来。如果只有一个slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性。</p><p>目前MHA主要支持一主多从的架构，<strong>要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器</strong>，一主二从，即一台充当master，一台充当备用master，另外一台充当从库，因为至少需要三台服务器，出于机器成本的考虑，淘宝也在该基础上进行了改造，目前淘宝TMHA已经支持一主一从。另外对于想快速搭建的可以参考：<a href="http://www.cnblogs.com/gomysql/p/6547797.html">MHA快速搭建</a></p><p>我们自己使用其实也可以使用1主1从，但是master主机宕机后无法切换，以及无法补全binlog。master的mysqld进程crash后，还是可以切换成功，以及补全binlog的。</p><p><img src="/images/a604adad-2556-4a7b-936b-123d02e79bf2-Image.png" alt="a604adad-2556-4a7b-936b-123d02e79bf2-Image.png" title="a604adad-2556-4a7b-936b-123d02e79bf2-Image.png"></p><p>MHA工作原理总结</p><ol><li>从宕机崩溃的master保存二进制日志事件（binlog events）;</li><li>识别含有最新更新的slave；</li><li>应用差异的中继日志（relay log）到其他的slave；</li><li>应用从master保存的二进制日志事件（binlog events）；</li><li>提升一个slave为新的master；</li><li>使其他的slave连接新的master进行复制；</li></ol><p>Manager工具:</p><ol><li>masterha_check_ssh : 检查MHA的SSH配置；</li><li>masterha_check_repl : 检查MySQL复制；</li><li>masterha_manager : 启动MHA；</li><li>masterha_stop：停止MHA；</li><li>masterha_check_status : 检测当前MHA运行状态；</li><li>masterha_master_monitor : 监测master是否宕机；</li><li>masterha_master_switch : 控制故障转移(自动或手动)；</li><li>masterha_conf_host : 添加或删除配置的server信息；</li><li>masterha_secondary_check：检查备节点；</li></ol><p>Node工具：</p><ol><li>save_binary_logs : 保存和复制master的二进制日志。</li><li>apply_diff_relay_logs : 识别差异的中继日志事件并应用于其它slave。</li><li>filter_mysqlbinlog : 去除不必要的ROLLBACK事件(MHA已不再使用这个工具)。</li><li>purge_relay_logs : 清除中继日志(不会阻塞SQL线程)。</li></ol><h2 id="部署MHA环境介绍"><a href="#部署MHA环境介绍" class="headerlink" title="部署MHA环境介绍"></a>部署MHA环境介绍</h2><table><thead><tr><th align="left">mysql角色</th><th align="left">主机名</th><th align="left">IP地址</th><th align="left">MHA角色</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">master</td><td align="left">mysql-master-1003306</td><td align="left">10.10.10.100</td><td align="left">node</td><td align="left">主库</td></tr><tr><td align="left">slave1</td><td align="left">mysql-slave-1013306</td><td align="left">10.10.10.101</td><td align="left">node</td><td align="left">从库，当主库宕机时，自动切换到这台从库</td></tr><tr><td align="left">slave2</td><td align="left">mysql-slave-1023306</td><td align="left">10.10.10.102</td><td align="left">node、manager</td><td align="left">从库，只读，不作为master切换节点，由于资源有限，将manager同时安装在slave2上</td></tr></tbody></table><h2 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h2><h3 id="三台机器修改-etc-hosts"><a href="#三台机器修改-etc-hosts" class="headerlink" title="三台机器修改&#x2F;etc&#x2F;hosts"></a>三台机器修改&#x2F;etc&#x2F;hosts</h3><pre><code class="bash"># master slave1 slave2[root@mysql-master-1003306 ~]# cat /etc/hosts127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain610.10.10.100 mysql-master-100330610.10.10.101 mysql-slave-101330610.10.10.102 mysql-slave-1023306</code></pre><h3 id="三台机器互相建立ssh互信，下面仅举一个例子，其他的按照下面方法逐个添加；"><a href="#三台机器互相建立ssh互信，下面仅举一个例子，其他的按照下面方法逐个添加；" class="headerlink" title="三台机器互相建立ssh互信，下面仅举一个例子，其他的按照下面方法逐个添加；"></a>三台机器互相建立ssh互信，下面仅举一个例子，其他的按照下面方法逐个添加；</h3><pre><code class="bash">[root@mysql-master-1003306 ~]# ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsaGenerating public/private rsa key pair.Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:d0:ba:b2:62:09:6e:a1:4b:8a:c9:30:2c:e8:ef:d9:78 root@mysql-master-1003306The key&#39;s randomart image is:+--[ RSA 2048]----+|                 ||       .         ||      . .        ||       o         ||      . S        ||+.     .         ||B+... .          ||X=+ +E           ||*=o*o.           |+-----------------+[root@mysql-master-1003306 ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@10.10.10.101/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@10.10.10.101&#39;s password:Number of key(s) added: 1Now try logging into the machine, with:   &quot;ssh &#39;root@10.10.10.101&#39;&quot;and check to make sure that only the key(s) you wanted were added.</code></pre><blockquote><p><strong>注意使用ssh IP 和 ssh HOSTNAME 进行验证！</strong><br><strong>由于后面我们会把node和manager同时安装在slave2上，所以slave2上需要自己和自己互信，否则后面mha的ssh检测脚本会失败</strong></p></blockquote><h2 id="搭建一主两从架构（基于GTID模式）"><a href="#搭建一主两从架构（基于GTID模式）" class="headerlink" title="搭建一主两从架构（基于GTID模式）"></a>搭建一主两从架构（基于GTID模式）</h2><h3 id="master配置文件"><a href="#master配置文件" class="headerlink" title="master配置文件"></a>master配置文件</h3><pre><code class="bash"># master[mysqld]server-id=1003306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1enforce_gtid_consistency=1##realylogrelay-log=mysql-relay-binrelay_log_purge=0                ## 禁止 SQL 线程在执行完一个 relay log 后自动将其删除，对于MHA场景下，对于某些滞后从库的恢复依赖于其他从库的relaylog，因此采取禁用自动删除功能</code></pre><blockquote><p>后面会介绍如何通过mha清理relay log；</p></blockquote><h3 id="slave1配置文件"><a href="#slave1配置文件" class="headerlink" title="slave1配置文件"></a>slave1配置文件</h3><pre><code class="bash"># slave1[mysqld]server-id=1013306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1enforce_gtid_consistency=1##relaylogrelay-log=mysql-relay-binrelay_log_purge=0</code></pre><h3 id="slave2配置文件"><a href="#slave2配置文件" class="headerlink" title="slave2配置文件"></a>slave2配置文件</h3><pre><code class="bash"># slave2[mysqld]server-id=1023306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1enforce_gtid_consistency=1##relaylogrelay-log=mysql-relay-binrelay_log_purge=0</code></pre><blockquote><p>从库不要在配置文件中开启read-only，因为从库随时可能切换成主库，可以使用动态设置set global read_only&#x3D;1</p></blockquote><h3 id="主库同步数据到两台从库"><a href="#主库同步数据到两台从库" class="headerlink" title="主库同步数据到两台从库"></a>主库同步数据到两台从库</h3><pre><code class="bash"># master[root@mysql-master-1003306 ~]# mysqldump -uroot -p --single-transaction -A --master-data=2 &gt; all.sqlEnter password:##这里加不加--master-data=2都行，因为复制已经不再是基于position号的形式了。[root@mysql-master-1003306 ~]# scp all.sql 10.10.10.101:/root               #将备份文件拷贝到从库[root@mysql-master-1003306 ~]# scp all.sql 10.10.10.102:/root</code></pre><h3 id="从库恢复数据"><a href="#从库恢复数据" class="headerlink" title="从库恢复数据"></a>从库恢复数据</h3><pre><code class="bash"># slave1[root@mysql-slave-1013306 ~]# mysql -uroot -p &lt; all.sqlEnter password:# slave2[root@mysql-slave-1023306 ~]# mysql -uroot -p &lt; all.sqlEnter password:</code></pre><h3 id="开启复制"><a href="#开启复制" class="headerlink" title="开启复制"></a>开启复制</h3><p>在master和slave1上创建复制账号，因为slave1随时会变成master，需要创建复制账号；slave2后面控制其不会成为master，所以不需要创建复制账号，当然，创建也可以；</p><pre><code class="sql"># mastermysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;mharepl&#39;@&#39;10.10.10.%&#39; IDENTIFIED BY &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)# slave1mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;mharepl&#39;@&#39;10.10.10.%&#39; IDENTIFIED BY &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)</code></pre><p>在slave上开启复制</p><pre><code class="sql"># slave1mysql&gt; CHANGE MASTER TO MASTER_HOST=&#39;10.10.10.100&#39;,MASTER_USER=&#39;mharepl&#39;,MASTER_PASSWORD=&#39;echo123.&#39;,MASTER_PORT=3306,MASTER_AUTO_POSITION=1;Query OK, 0 rows affected, 2 warnings (0.03 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.06 sec)# slave2mysql&gt; CHANGE MASTER TO MASTER_HOST=&#39;10.10.10.100&#39;,MASTER_USER=&#39;mharepl&#39;,MASTER_PASSWORD=&#39;echo123.&#39;,MASTER_PORT=3306,MASTER_AUTO_POSITION=1;Query OK, 0 rows affected, 2 warnings (0.03 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.02 sec)</code></pre><p>查看主从状态</p><ul><li>slave1</li></ul><pre><code class="sql">mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.100                  Master_User: mharepl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000011          Read_Master_Log_Pos: 2805               Relay_Log_File: mysql-relay-bin.000002                Relay_Log_Pos: 2978        Relay_Master_Log_File: mysql-bin.000011             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 2805              Relay_Log_Space: 3225              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1003306                  Master_UUID: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:29-36            Executed_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:1-36                Auto_Position: 1         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)</code></pre><ul><li>slave2</li></ul><pre><code class="sql">mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.100                  Master_User: mharepl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000011          Read_Master_Log_Pos: 2805               Relay_Log_File: mysql-relay-bin.000002                Relay_Log_Pos: 2978        Relay_Master_Log_File: mysql-bin.000011             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 2805              Relay_Log_Space: 3185              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1003306                  Master_UUID: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:29-36            Executed_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:1-36                Auto_Position: 1         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>主库创建一张表并插入一行数据 </p><pre><code class="sql"># mastermysql&gt; use test;Database changedmysql&gt; create table t (id int);Query OK, 0 rows affected (0.04 sec)mysql&gt; insert into t values (1);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from t;+------+| id   |+------+|    1 |+------+1 row in set (0.01 sec)</code></pre><p>从库检查数据</p><ul><li>slave1</li></ul><pre><code class="sql">mysql&gt; use test;Database changedmysql&gt; select * from t;+------+| id   |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><ul><li>slave2</li></ul><pre><code class="sql">mysql&gt; use test;Database changedmysql&gt; select * from t;+------+| id   |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><p>将两台从数据库设置为只读set global read_only&#x3D;1，<strong>不要在配置文件里面开启</strong>；</p><ul><li>slave1</li></ul><pre><code class="sql">mysql&gt; set global read_only=1;Query OK, 0 rows affected (0.00 sec)</code></pre><ul><li>slave2</li></ul><pre><code class="sql">mysql&gt; set global read_only=1;Query OK, 0 rows affected (0.00 sec)</code></pre><p>至此，基于GTID的主从搭建完毕，接下来就是搭建MHA高可用集群了；</p><h2 id="安装MHA"><a href="#安装MHA" class="headerlink" title="安装MHA"></a>安装MHA</h2><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><pre><code class="bash"># 163的源[root@mysql-slave-1013306 ~]# wget http://mirrors.163.com/.help/CentOS7-Base-163.repo -O /etc/yum.repos.d/163.repo       # epel源[root@mysql-slave-1013306 ~]# wget http://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-11.noarch.rpm [root@mysql-slave-1013306 ~]# rpm -ivh epel-release-7-11.noarch.rpmwarning: epel-release-7-11.noarch.rpm: Header V3 RSA/SHA256 Signature, key ID 352c64e5: NOKEYPreparing...                          ################################# [100%]Updating / installing...   1:epel-release-7-11                ################################# [100%]</code></pre><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>在master、slave1、slave2三台机器上装node<br>在slave2上装manager，</p><blockquote><p>manager可以单独安装一台机器，我这里资源有限，将其放在slave2上；</p></blockquote><h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><ul><li>master&#x2F;slave1&#x2F;slave2</li></ul><pre><code class="bash">[root@mysql-slave-1013306 ~]# yum -y install perl-DBD-MySQL* perl-ExtUtils* perl-CPAN[root@mysql-slave-1013306 ~]# tar -xf mha4mysql-node-0.57.tar.gz[root@mysql-slave-1013306 ~]# cd mha4mysql-node-0.57/[root@mysql-slave-1013306 mha4mysql-node-0.57]# perl Makefile.PL*** Module::AutoInstall version 1.06*** Checking for Perl dependencies...[Core Features]- DBI        ...loaded. (1.627)- DBD::mysql ...loaded. (4.023)*** Module::AutoInstall configuration finished.Checking if your kit is complete...Looks goodWriting Makefile for mha4mysql::node[root@mysql-slave-1013306 mha4mysql-node-0.57]# make &amp;&amp; make installcp lib/MHA/BinlogManager.pm blib/lib/MHA/BinlogManager.pmcp lib/MHA/BinlogPosFindManager.pm blib/lib/MHA/BinlogPosFindManager.pmcp lib/MHA/BinlogPosFinderXid.pm blib/lib/MHA/BinlogPosFinderXid.pmcp lib/MHA/BinlogHeaderParser.pm blib/lib/MHA/BinlogHeaderParser.pmcp lib/MHA/BinlogPosFinder.pm blib/lib/MHA/BinlogPosFinder.pmcp lib/MHA/NodeUtil.pm blib/lib/MHA/NodeUtil.pmcp lib/MHA/BinlogPosFinderElp.pm blib/lib/MHA/BinlogPosFinderElp.pmcp lib/MHA/SlaveUtil.pm blib/lib/MHA/SlaveUtil.pmcp lib/MHA/NodeConst.pm blib/lib/MHA/NodeConst.pmcp bin/filter_mysqlbinlog blib/script/filter_mysqlbinlog/usr/bin/perl &quot;-Iinc&quot; -MExtUtils::MY -e &#39;MY-&gt;fixin(shift)&#39; -- blib/script/filter_mysqlbinlogcp bin/apply_diff_relay_logs blib/script/apply_diff_relay_logs/usr/bin/perl &quot;-Iinc&quot; -MExtUtils::MY -e &#39;MY-&gt;fixin(shift)&#39; -- blib/script/apply_diff_relay_logscp bin/purge_relay_logs blib/script/purge_relay_logs/usr/bin/perl &quot;-Iinc&quot; -MExtUtils::MY -e &#39;MY-&gt;fixin(shift)&#39; -- blib/script/purge_relay_logscp bin/save_binary_logs blib/script/save_binary_logs/usr/bin/perl &quot;-Iinc&quot; -MExtUtils::MY -e &#39;MY-&gt;fixin(shift)&#39; -- blib/script/save_binary_logsManifying blib/man1/filter_mysqlbinlog.1Manifying blib/man1/apply_diff_relay_logs.1Manifying blib/man1/purge_relay_logs.1Manifying blib/man1/save_binary_logs.1Installing /usr/local/share/perl5/MHA/BinlogManager.pmInstalling /usr/local/share/perl5/MHA/BinlogPosFindManager.pmInstalling /usr/local/share/perl5/MHA/BinlogPosFinderXid.pmInstalling /usr/local/share/perl5/MHA/BinlogHeaderParser.pmInstalling /usr/local/share/perl5/MHA/BinlogPosFinder.pmInstalling /usr/local/share/perl5/MHA/NodeUtil.pmInstalling /usr/local/share/perl5/MHA/BinlogPosFinderElp.pmInstalling /usr/local/share/perl5/MHA/SlaveUtil.pmInstalling /usr/local/share/perl5/MHA/NodeConst.pmInstalling /usr/local/share/man/man1/filter_mysqlbinlog.1Installing /usr/local/share/man/man1/apply_diff_relay_logs.1Installing /usr/local/share/man/man1/purge_relay_logs.1Installing /usr/local/share/man/man1/save_binary_logs.1Installing /usr/local/bin/filter_mysqlbinlogInstalling /usr/local/bin/apply_diff_relay_logsInstalling /usr/local/bin/purge_relay_logsInstalling /usr/local/bin/save_binary_logsAppending installation info to /usr/lib64/perl5/perllocal.pod</code></pre><p>安装完成后会在&#x2F;usr&#x2F;local&#x2F;bin下安装4个可执行文件</p><pre><code class="bash">/usr/local/bin/filter_mysqlbinlog/usr/local/bin/apply_diff_relay_logs/usr/local/bin/purge_relay_logs/usr/local/bin/save_binary_logs</code></pre><h4 id="在slave2上安装manager"><a href="#在slave2上安装manager" class="headerlink" title="在slave2上安装manager"></a>在slave2上安装manager</h4><ul><li>slave2</li></ul><pre><code class="bash">[root@mysql-slave-1023306 ~]# yum -y install perl-Config-Tiny perl-Log-Dispatch perl-Parallel-ForkManager perl-Time-HiRes[root@mysql-slave-1023306 ~]# tar -xf mha4mysql-manager-0.57.tar.gz[root@mysql-slave-1023306 ~]# cd mha4mysql-manager-0.57/[root@mysql-slave-1023306 mha4mysql-manager-0.57]# perl Makefile.PL*** Module::AutoInstall version 1.06*** Checking for Perl dependencies...[Core Features]- DBI                   ...loaded. (1.627)- DBD::mysql            ...loaded. (4.023)- Time::HiRes           ...loaded. (1.9725)- Config::Tiny          ...loaded. (2.14)- Log::Dispatch         ...loaded. (2.41)- Parallel::ForkManager ...loaded. (1.18)- MHA::NodeConst        ...loaded. (0.57)*** Module::AutoInstall configuration finished.Checking if your kit is complete...Looks goodWriting Makefile for mha4mysql::manager[root@mysql-slave-1023306 mha4mysql-manager-0.57]# make &amp;&amp; make installcp lib/MHA/ManagerUtil.pm blib/lib/MHA/ManagerUtil.pmcp lib/MHA/Config.pm blib/lib/MHA/Config.pmcp lib/MHA/HealthCheck.pm blib/lib/MHA/HealthCheck.pm......Installing /usr/local/bin/masterha_stop    Installing /usr/local/bin/masterha_conf_hostInstalling /usr/local/bin/masterha_check_replInstalling /usr/local/bin/masterha_check_statusInstalling /usr/local/bin/masterha_master_monitorInstalling /usr/local/bin/masterha_check_sshInstalling /usr/local/bin/masterha_master_switchInstalling /usr/local/bin/masterha_secondary_checkInstalling /usr/local/bin/masterha_managerAppending installation info to /usr/lib64/perl5/perllocal.pod</code></pre><h2 id="配置MHA"><a href="#配置MHA" class="headerlink" title="配置MHA"></a>配置MHA</h2><h3 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h3><p>安装完成后，在所有数据库节点中中创建用于MHA管理的超管账号；</p><ul><li>master slave1 slave2</li></ul><pre><code class="sql">mysql&gt; grant all privileges on *.* to &#39;mhamanager&#39;@&#39;%&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.18 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.12 sec)</code></pre><h3 id="创建MHA目录"><a href="#创建MHA目录" class="headerlink" title="创建MHA目录"></a>创建MHA目录</h3><p>MHA可以管理多套主从架构，因此我在这里将这套环境所有的配置存放在&#x2F;home&#x2F;mha&#x2F;app1里，如果有其他的环境，可以创建app2、app3等用于区分</p><ul><li>slave2</li></ul><pre><code class="bash"># 创建工作目录[root@mysql-slave-1023306 ~]# mkdir -p /home/mha/app1# 创建配置文件目录[root@mysql-slave-1023306 ~]# mkdir /home/mha/app1/conf#创建脚本存放目录[root@mysql-slave-1023306 ~]# mkdir /home/mha/app1/scripts</code></pre><p>在mha4mysql-manager-0.57.tar.gz解压后的目录里面，有默认的配置文件和脚本，我们将其复制到我们定义的目录中</p><pre><code class="bash">[root@mysql-slave-1023306 ~]# cp mha4mysql-manager-0.57/samples/conf/* /home/mha/app1/conf/[root@mysql-slave-1023306 ~]# cp mha4mysql-manager-0.57/samples/scripts/* /home/mha/app1/scripts/</code></pre><h3 id="修改配置app1-conf文件"><a href="#修改配置app1-conf文件" class="headerlink" title="修改配置app1.conf文件"></a>修改配置app1.conf文件</h3><pre><code class="bash">[root@mysql-slave-1023306 conf]# vim app1.cnf[server default]manager_log=/home/mha/app1/manager.log              ##设置manager的日志文件manager_workdir=/home/mha/app1                      ##设置manager的工作目录master_binlog_dir=/data/mysql                       ##设置master保存binlog的目录，以便MHA找到master的日志master_ip_failover_script= /home/mha/app1/scripts/master_ip_failover   ##设置自动failover时的切换脚本master_ip_online_change_script= /home/mha/app1/scripts/master_ip_online_change  ##设置手动切换时的切换脚本user=mhamanager                                     ##设置监控用户，就是上面创建的超管用户password=echo123.                                   ##设置监控用户密码ping_interval=1                                     ##设置监控主库发送ping包的时间间隔，默认是3，这里设置成1remote_workdir=/home/mysql                          ##设置远端mysql在发生切换时binlog保存的位置repl_user=mharepl                                   ##设置复制环境中的复制用户的用户名repl_password=echo123.                              ##设置复制环境中复制用户的密码report_script=/home/mha/app1/scripts/send_report    ##设置发生切换是的告警脚本secondary_check_script= /usr/local/bin/masterha_secondary_check -s 10.10.10.101 -s 10.10.10.102  --user=root --master_host=10.10.10.100 --master_ip=10.10.10.100 --master_port=3306   ##一旦MHA到master之间监控出现问题，MHA  manager会判断其他从库是否能建立到master_ip 3306的连接shutdown_script=&quot;&quot;                                  ##设置故障发生后关闭故障主机的脚本（防止脑裂现象），我这里不指定ssh_user=root                                       ##设置ssh登录的用户名ssh_port=22                                         ##设置ssh登录的端口[server1]hostname=10.10.10.100port=3306candidate_master=1check_repl_delay=0 [server2]hostname=10.10.10.101port=3306candidate_master=1                                  ##设置为候选mastercheck_repl_delay=0                                  ##默认情况下如果一个slave落后master 100M的relay logs的话，MHA将不会选择该slave作为一个新的master，因为对于这个slave的恢复需要花费很长时间，通过设置check_repl_delay=0,MHA触发切换在选择一个新的master的时候将会忽略复制延时，这个参数对于设置了candidate_master=1的主机非常有用，因为它保证了这个候选主在切换过程中一定是最新的master[server3]hostname=10.10.10.102port=3306no_master=1                                         ##设置其不会成为候选master</code></pre><h3 id="修改master-ip-failover和master-ip-online-change脚本"><a href="#修改master-ip-failover和master-ip-online-change脚本" class="headerlink" title="修改master_ip_failover和master_ip_online_change脚本"></a>修改master_ip_failover和master_ip_online_change脚本</h3><pre><code class="bash">[root@mysql-slave-1023306 scripts]# cd /home/mha/app1/scripts/[root@mysql-slave-1023306 scripts]# cp master_ip_failover master_ip_failover_bak[root@mysql-slave-1023306 scripts]# cp master_ip_online_change master_ip_online_change_bak</code></pre><pre><code class="bash">[root@mysql-slave-1023306 scripts]# vim master_ip_failover#!/usr/bin/env perl use strict;use warnings FATAL =&gt; &#39;all&#39;;use Getopt::Long;my (    $command,          $ssh_user,        $orig_master_host, $orig_master_ip,    $orig_master_port, $new_master_host, $new_master_ip,    $new_master_port);##这下面的根据实际情况修改my $vip = &#39;10.10.10.200/24&#39;;my $key = &#39;0&#39;;my $ssh_start_vip = &quot;/sbin/ifconfig eno16777736:$key $vip&quot;;          my $ssh_stop_vip = &quot;/sbin/ifconfig eno16777736:$key down&quot;;GetOptions(    &#39;command=s&#39;          =&gt; \$command,    &#39;ssh_user=s&#39;         =&gt; \$ssh_user,    &#39;orig_master_host=s&#39; =&gt; \$orig_master_host,    &#39;orig_master_ip=s&#39;   =&gt; \$orig_master_ip,    &#39;orig_master_port=i&#39; =&gt; \$orig_master_port,    &#39;new_master_host=s&#39;  =&gt; \$new_master_host,    &#39;new_master_ip=s&#39;    =&gt; \$new_master_ip,    &#39;new_master_port=i&#39;  =&gt; \$new_master_port,);exit &amp;main();sub main &#123;    print &quot;\n\nIN SCRIPT TEST====$ssh_stop_vip==$ssh_start_vip===\n\n&quot;;    if ( $command eq &quot;stop&quot; || $command eq &quot;stopssh&quot; ) &#123;        my $exit_code = 1;        eval &#123;            print &quot;Disabling the VIP on old master: $orig_master_host \n&quot;;            &amp;stop_vip();            $exit_code = 0;        &#125;;        if ($@) &#123;            warn &quot;Got Error: $@\n&quot;;            exit $exit_code;        &#125;        exit $exit_code;    &#125;    elsif ( $command eq &quot;start&quot; ) &#123;        my $exit_code = 10;        eval &#123;            print &quot;Enabling the VIP - $vip on the new master - $new_master_host \n&quot;;            &amp;start_vip();            $exit_code = 0;        &#125;;        if ($@) &#123;            warn $@;            exit $exit_code;        &#125;        exit $exit_code;    &#125;    elsif ( $command eq &quot;status&quot; ) &#123;        print &quot;Checking the Status of the script.. OK \n&quot;;        exit 0;    &#125;    else &#123;        &amp;usage();        exit 1;    &#125;&#125;sub start_vip() &#123;    `ssh $ssh_user\@$new_master_host \&quot; $ssh_start_vip \&quot;`;&#125;sub stop_vip() &#123;     return 0  unless  ($ssh_user);    `ssh $ssh_user\@$orig_master_host \&quot; $ssh_stop_vip \&quot;`;&#125;sub usage &#123;    print    &quot;Usage: master_ip_failover --command=start|stop|stopssh|status --orig_master_host=host --orig_master_ip=ip              --orig_master_port=port --new_master_host=host --new_master_ip=ip --new_master_port=port\n&quot;;&#125;</code></pre><pre><code class="bash">[root@mysql-slave-1023306 scripts]# vim master_ip_online_change#!/usr/bin/env perl use strict;use warnings FATAL =&gt;&#39;all&#39;;use Getopt::Long;##根据实际情况修改my $vip = &#39;10.10.10.200/24&#39;;  # Virtual IP my $key = &quot;0&quot;;my $ssh_start_vip = &quot;/sbin/ifconfig eno16777736:$key $vip&quot;;my $ssh_stop_vip = &quot;/sbin/ifconfig eno16777736:$key down&quot;;my $exit_code = 0;my (  $command,              $orig_master_is_new_slave, $orig_master_host,  $orig_master_ip,       $orig_master_port,         $orig_master_user,  $orig_master_password, $orig_master_ssh_user,     $new_master_host,  $new_master_ip,        $new_master_port,          $new_master_user,  $new_master_password,  $new_master_ssh_user,);GetOptions(  &#39;command=s&#39;                =&gt; \$command,  &#39;orig_master_is_new_slave&#39; =&gt; \$orig_master_is_new_slave,  &#39;orig_master_host=s&#39;       =&gt; \$orig_master_host,  &#39;orig_master_ip=s&#39;         =&gt; \$orig_master_ip,  &#39;orig_master_port=i&#39;       =&gt; \$orig_master_port,  &#39;orig_master_user=s&#39;       =&gt; \$orig_master_user,  &#39;orig_master_password=s&#39;   =&gt; \$orig_master_password,  &#39;orig_master_ssh_user=s&#39;   =&gt; \$orig_master_ssh_user,  &#39;new_master_host=s&#39;        =&gt; \$new_master_host,  &#39;new_master_ip=s&#39;          =&gt; \$new_master_ip,  &#39;new_master_port=i&#39;        =&gt; \$new_master_port,  &#39;new_master_user=s&#39;        =&gt; \$new_master_user,  &#39;new_master_password=s&#39;    =&gt; \$new_master_password,  &#39;new_master_ssh_user=s&#39;    =&gt; \$new_master_ssh_user,);exit &amp;main();sub main &#123;#print &quot;\n\nIN SCRIPT TEST====$ssh_stop_vip==$ssh_start_vip===\n\n&quot;; if ( $command eq &quot;stop&quot; || $command eq &quot;stopssh&quot; ) &#123;        # $orig_master_host, $orig_master_ip, $orig_master_port are passed.         # If you manage master ip address at global catalog database,         # invalidate orig_master_ip here.         my $exit_code = 1;        eval &#123;            print &quot;\n\n\n***************************************************************\n&quot;;            print &quot;Disabling the VIP - $vip on old master: $orig_master_host\n&quot;;            print &quot;***************************************************************\n\n\n\n&quot;;&amp;stop_vip();            $exit_code = 0;        &#125;;        if ($@) &#123;            warn &quot;Got Error: $@\n&quot;;            exit $exit_code;        &#125;        exit $exit_code;&#125;elsif ( $command eq &quot;start&quot; ) &#123;        # all arguments are passed.         # If you manage master ip address at global catalog database,         # activate new_master_ip here.         # You can also grant write access (create user, set read_only=0, etc) here. my $exit_code = 10;        eval &#123;            print &quot;\n\n\n***************************************************************\n&quot;;            print &quot;Enabling the VIP - $vip on new master: $new_master_host \n&quot;;            print &quot;***************************************************************\n\n\n\n&quot;;&amp;start_vip();            $exit_code = 0;        &#125;;        if ($@) &#123;            warn $@;            exit $exit_code;        &#125;        exit $exit_code;&#125;elsif ( $command eq &quot;status&quot; ) &#123;        print &quot;Checking the Status of the script.. OK \n&quot;;        `ssh $orig_master_ssh_user\@$orig_master_host \&quot; $ssh_start_vip \&quot;`;        exit 0;&#125;else &#123;&amp;usage();        exit 1;&#125;&#125;# A simple system call that enable the VIP on the new master sub start_vip() &#123;`ssh $new_master_ssh_user\@$new_master_host \&quot; $ssh_start_vip \&quot;`;&#125;# A simple system call that disable the VIP on the old_master sub stop_vip() &#123;`ssh $orig_master_ssh_user\@$orig_master_host \&quot; $ssh_stop_vip \&quot;`;&#125;sub usage &#123;print&quot;Usage: master_ip_failover –command=start|stop|stopssh|status –orig_master_host=host –orig_master_ip=ip –orig_master_port=po rt –new_master_host=host –new_master_ip=ip –new_master_port=port\n&quot;;&#125;</code></pre><h3 id="利用mha工具检测ssh"><a href="#利用mha工具检测ssh" class="headerlink" title="利用mha工具检测ssh"></a>利用mha工具检测ssh</h3><pre><code class="bash">[root@mysql-slave-1023306 scripts]# /usr/local/bin/masterha_check_ssh --conf=/home/mha/app1/conf/app1.confWed Apr 18 18:48:14 2018 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Wed Apr 18 18:48:14 2018 - [info] Reading application default configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 18:48:14 2018 - [info] Reading server configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 18:48:14 2018 - [info] Starting SSH connection tests..Wed Apr 18 18:48:16 2018 - [debug]Wed Apr 18 18:48:14 2018 - [debug]  Connecting via SSH from root@10.10.10.100(10.10.10.100:22) to root@10.10.10.101(10.10.10.101:22)..Wed Apr 18 18:48:15 2018 - [debug]   ok.Wed Apr 18 18:48:15 2018 - [debug]  Connecting via SSH from root@10.10.10.100(10.10.10.100:22) to root@10.10.10.102(10.10.10.102:22)..Wed Apr 18 18:48:15 2018 - [debug]   ok.Wed Apr 18 18:48:17 2018 - [debug]Wed Apr 18 18:48:15 2018 - [debug]  Connecting via SSH from root@10.10.10.101(10.10.10.101:22) to root@10.10.10.100(10.10.10.100:22)..Wed Apr 18 18:48:15 2018 - [debug]   ok.Wed Apr 18 18:48:15 2018 - [debug]  Connecting via SSH from root@10.10.10.101(10.10.10.101:22) to root@10.10.10.102(10.10.10.102:22)..Wed Apr 18 18:48:16 2018 - [debug]   ok.Wed Apr 18 18:48:17 2018 - [debug]Wed Apr 18 18:48:15 2018 - [debug]  Connecting via SSH from root@10.10.10.102(10.10.10.102:22) to root@10.10.10.100(10.10.10.100:22)..Wed Apr 18 18:48:16 2018 - [debug]   ok.Wed Apr 18 18:48:16 2018 - [debug]  Connecting via SSH from root@10.10.10.102(10.10.10.102:22) to root@10.10.10.101(10.10.10.101:22)..Wed Apr 18 18:48:16 2018 - [debug]   ok.Wed Apr 18 18:48:17 2018 - [info] All SSH connection tests passed successfully.</code></pre><h3 id="检测复制状态"><a href="#检测复制状态" class="headerlink" title="检测复制状态"></a>检测复制状态</h3><pre><code class="bash">[root@mysql-slave-1023306 scripts]# /usr/local/bin/masterha_check_repl --conf=/home/mha/app1/conf/app1.confWed Apr 18 18:49:23 2018 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Wed Apr 18 18:49:23 2018 - [info] Reading application default configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 18:49:23 2018 - [info] Reading server configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 18:49:23 2018 - [info] MHA::MasterMonitor version 0.57.Wed Apr 18 18:49:24 2018 - [info] GTID failover mode = 1Wed Apr 18 18:49:24 2018 - [info] Dead Servers:Wed Apr 18 18:49:24 2018 - [info] Alive Servers:Wed Apr 18 18:49:24 2018 - [info]   10.10.10.100(10.10.10.100:3306)Wed Apr 18 18:49:24 2018 - [info]   10.10.10.101(10.10.10.101:3306)Wed Apr 18 18:49:24 2018 - [info]   10.10.10.102(10.10.10.102:3306)Wed Apr 18 18:49:24 2018 - [info] Alive Slaves:Wed Apr 18 18:49:24 2018 - [info]   10.10.10.101(10.10.10.101:3306)  Version=5.7.21-log (oldest major version between slaves) log-bin:enabledWed Apr 18 18:49:24 2018 - [info]     GTID ONWed Apr 18 18:49:24 2018 - [info]     Replicating from 10.10.10.100(10.10.10.100:3306)Wed Apr 18 18:49:24 2018 - [info]     Primary candidate for the new Master (candidate_master is set)Wed Apr 18 18:49:24 2018 - [info]   10.10.10.102(10.10.10.102:3306)  Version=5.7.21-log (oldest major version between slaves) log-bin:enabledWed Apr 18 18:49:24 2018 - [info]     GTID ONWed Apr 18 18:49:24 2018 - [info]     Replicating from 10.10.10.100(10.10.10.100:3306)Wed Apr 18 18:49:24 2018 - [info]     Not candidate for the new Master (no_master is set)Wed Apr 18 18:49:24 2018 - [info] Current Alive Master: 10.10.10.100(10.10.10.100:3306)Wed Apr 18 18:49:24 2018 - [info] Checking slave configurations..Wed Apr 18 18:49:24 2018 - [info] Checking replication filtering settings..Wed Apr 18 18:49:24 2018 - [info]  binlog_do_db= , binlog_ignore_db=Wed Apr 18 18:49:24 2018 - [info]  Replication filtering check ok.Wed Apr 18 18:49:24 2018 - [info] GTID (with auto-pos) is supported. Skipping all SSH and Node package checking.Wed Apr 18 18:49:24 2018 - [info] Checking SSH publickey authentication settings on the current master..Wed Apr 18 18:49:24 2018 - [info] HealthCheck: SSH to 10.10.10.100 is reachable.Wed Apr 18 18:49:24 2018 - [info]10.10.10.100(10.10.10.100:3306) (current master)+--10.10.10.101(10.10.10.101:3306)+--10.10.10.102(10.10.10.102:3306)Wed Apr 18 18:49:24 2018 - [info] Checking replication health on 10.10.10.101..Wed Apr 18 18:49:24 2018 - [info]  ok.Wed Apr 18 18:49:24 2018 - [info] Checking replication health on 10.10.10.102..Wed Apr 18 18:49:24 2018 - [info]  ok.Wed Apr 18 18:49:24 2018 - [info] Checking master_ip_failover_script status:Wed Apr 18 18:49:24 2018 - [info]   /home/mha/app1/scripts/master_ip_failover --command=status --ssh_user=root --orig_master_host=10.10.10.100 --orig_master_ip=10.10.10.100 --orig_master_port=3306IN SCRIPT TEST====/sbin/ifconfig eno16777736:0 down==/sbin/ifconfig eno16777736:0 10.10.10.200/24===Checking the Status of the script.. OKWed Apr 18 18:49:24 2018 - [info]  OK.Wed Apr 18 18:49:24 2018 - [warning] shutdown_script is not defined.Wed Apr 18 18:49:24 2018 - [info] Got exit code 0 (Not master dead).MySQL Replication Health is OK.</code></pre><h3 id="在主库添加vip（第一次手动添加）"><a href="#在主库添加vip（第一次手动添加）" class="headerlink" title="在主库添加vip（第一次手动添加）"></a>在主库添加vip（第一次手动添加）</h3><pre><code class="bash">[root@mysql-master-1003306 ~]# /sbin/ifconfig eno16777736:0 10.10.10.200/24[root@mysql-master-1003306 ~]# ip addr show  eno167777362: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:ff:c6:cd brd ff:ff:ff:ff:ff:ff    inet 10.10.10.100/24 brd 10.10.10.255 scope global eno16777736       valid_lft forever preferred_lft forever    inet 10.10.10.200/24 brd 10.10.10.255 scope global secondary eno16777736:0       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:feff:c6cd/64 scope link       valid_lft forever preferred_lft forever</code></pre><h3 id="尝试使用vip连接"><a href="#尝试使用vip连接" class="headerlink" title="尝试使用vip连接"></a>尝试使用vip连接</h3><pre><code class="bash">[root@mysql-slave-1023306 ~]# mysql -uroot -p -h 10.10.10.200 -P 3306Enter password:ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;mysql-slave-1023306&#39; (using password: YES)</code></pre><blockquote><p>由于root仅允许localhost连接，我们需要创建一个账号用于远程连接</p></blockquote><h3 id="在master上创建远程连接用户"><a href="#在master上创建远程连接用户" class="headerlink" title="在master上创建远程连接用户"></a>在master上创建远程连接用户</h3><ul><li>master</li></ul><pre><code class="sql">mysql&gt; grant all privileges on *.* to &#39;user&#39;@&#39;%&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.02 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)</code></pre><h3 id="使用user重新连接"><a href="#使用user重新连接" class="headerlink" title="使用user重新连接"></a>使用user重新连接</h3><pre><code class="bash">[root@mysql-slave-1023306 ~]# mysql -uuser -p -h 10.10.10.200 -P 3306Enter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 40Server version: 5.7.21-log MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt;</code></pre><h2 id="验证MHA切换"><a href="#验证MHA切换" class="headerlink" title="验证MHA切换"></a>验证MHA切换</h2><p>启动MHA，使用nohup后台运行</p><pre><code class="bash">[root@mysql-slave-1023306 app1]# nohup /usr/local/bin/masterha_manager --conf=/home/mha/app1/conf/app1.conf &amp;&gt; /home/mha/app1/nohup.out &amp;[1] 23028[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_status --conf=/home/mha/app1/conf/app1.confapp1 (pid:23028) is running(0:PING_OK), master:10.10.10.100</code></pre><p>模拟主库宕机，观察会不会切换到slave1上，可以看到vip已经迁移走了</p><pre><code class="bash"># master[root@mysql-master-1003306 ~]# service mysqld stopShutting down MySQL............ SUCCESS![root@mysql-master-1003306 ~]# ip addr show eno167777362: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:ff:c6:cd brd ff:ff:ff:ff:ff:ff    inet 10.10.10.100/24 brd 10.10.10.255 scope global eno16777736       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:feff:c6cd/64 scope link       valid_lft forever preferred_lft forever##可以看到vip已经迁移走了</code></pre><p>在slave1上查看</p><pre><code class="bash">#slave1[root@mysql-slave-1013306 ~]# ip addr show eno167777362: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:66:1d:d8 brd ff:ff:ff:ff:ff:ff    inet 10.10.10.101/24 brd 10.10.10.255 scope global eno16777736       valid_lft forever preferred_lft forever    inet 10.10.10.200/24 brd 10.10.10.255 scope global secondary eno16777736:0       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:fe66:1dd8/64 scope link       valid_lft forever preferred_lft forever##vip已经迁移到了slave1上</code></pre><p>在slave2上查看复制指向的是哪个master</p><pre><code class="bash">mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.101              ##可以看到已经指向到了slave1上                  Master_User: mharepl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000004          Read_Master_Log_Pos: 234               Relay_Log_File: mysql-relay-bin.000002                Relay_Log_Pos: 367        Relay_Master_Log_File: mysql-bin.000004             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 234              Relay_Log_Space: 574              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1013306                  Master_UUID: 8d3e071d-41b8-11e8-aaef-000c29661dd8             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set: 8d3e071d-41b8-11e8-aaef-000c29661dd8:1-4,91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:1-42,94a6d6b6-4280-11e8-a2f7-000c295bc4c5:1-2                Auto_Position: 1         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)</code></pre><p>在切换完成后manager上的MHA进程会停掉，并在工作目录下创建一个*.complete的空文件,再次启动的时候，最好把这个文件删掉；</p><pre><code class="bash">[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_status --conf=/home/mha/app1/conf/app1.confapp1 is stopped(2:NOT_RUNNING).[root@mysql-slave-1023306 app1]# lsapp1.failover.compelte conf  manager.log  nohup.out  scripts</code></pre><p>检查复制状态</p><pre><code class="bash">[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_repl --conf=/home/mha/app1/conf/app1.confWed Apr 18 20:19:50 2018 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Wed Apr 18 20:19:50 2018 - [info] Reading application default configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 20:19:50 2018 - [info] Reading server configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 20:19:50 2018 - [info] MHA::MasterMonitor version 0.57.Wed Apr 18 20:19:51 2018 - [error][/usr/local/share/perl5/MHA/ServerManager.pm, ln653] There are 2 non-slave servers! MHA manages at most one non-slave server. Check configurations.Wed Apr 18 20:19:51 2018 - [error][/usr/local/share/perl5/MHA/MasterMonitor.pm, ln427] Error happened on checking configurations.  at /usr/local/share/perl5/MHA/MasterMonitor.pm line 329.Wed Apr 18 20:19:51 2018 - [error][/usr/local/share/perl5/MHA/MasterMonitor.pm, ln525] Error happened on monitoring servers.Wed Apr 18 20:19:51 2018 - [info] Got exit code 1 (Not master dead).MySQL Replication Health is NOT OK!</code></pre><p>出现这个的原因是主库宕机，没有指向新的主库，需要手动指向新的主库，也就是slave2</p><pre><code class="bash">[root@mysql-master-1003306 ~]# service mysqld startStarting MySQL. SUCCESS!mysql&gt; CHANGE MASTER TO MASTER_HOST=&#39;10.10.10.101&#39;,MASTER_USER=&#39;mharepl&#39;,MASTER_PASSWORD=&#39;echo123.&#39;,MASTER_PORT=3306,MASTER_AUTO_POSITION=1;Query OK, 0 rows affected, 2 warnings (0.02 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.01 sec)</code></pre><p>再次检查复制状态，显示成功；</p><pre><code class="bash">[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_repl --conf=/home/mha/app1/conf/app1.confWed Apr 18 20:23:07 2018 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Wed Apr 18 20:23:07 2018 - [info] Reading application default configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 20:23:07 2018 - [info] Reading server configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 20:23:07 2018 - [info] MHA::MasterMonitor version 0.57.Wed Apr 18 20:23:08 2018 - [info] GTID failover mode = 1Wed Apr 18 20:23:08 2018 - [info] Dead Servers:Wed Apr 18 20:23:08 2018 - [info] Alive Servers:Wed Apr 18 20:23:08 2018 - [info]   10.10.10.100(10.10.10.100:3306)Wed Apr 18 20:23:08 2018 - [info]   10.10.10.101(10.10.10.101:3306)Wed Apr 18 20:23:08 2018 - [info]   10.10.10.102(10.10.10.102:3306)Wed Apr 18 20:23:08 2018 - [info] Alive Slaves:Wed Apr 18 20:23:08 2018 - [info]   10.10.10.100(10.10.10.100:3306)  Version=5.7.21-log (oldest major version between slaves) log-bin:enabledWed Apr 18 20:23:08 2018 - [info]     GTID ONWed Apr 18 20:23:08 2018 - [info]     Replicating from 10.10.10.101(10.10.10.101:3306)Wed Apr 18 20:23:08 2018 - [info]     Primary candidate for the new Master (candidate_master is set)Wed Apr 18 20:23:08 2018 - [info]   10.10.10.102(10.10.10.102:3306)  Version=5.7.21-log (oldest major version between slaves) log-bin:enabledWed Apr 18 20:23:08 2018 - [info]     GTID ONWed Apr 18 20:23:08 2018 - [info]     Replicating from 10.10.10.101(10.10.10.101:3306)Wed Apr 18 20:23:08 2018 - [info]     Not candidate for the new Master (no_master is set)Wed Apr 18 20:23:08 2018 - [info] Current Alive Master: 10.10.10.101(10.10.10.101:3306)Wed Apr 18 20:23:08 2018 - [info] Checking slave configurations..Wed Apr 18 20:23:08 2018 - [info]  read_only=1 is not set on slave 10.10.10.100(10.10.10.100:3306).Wed Apr 18 20:23:08 2018 - [info] Checking replication filtering settings..Wed Apr 18 20:23:08 2018 - [info]  binlog_do_db= , binlog_ignore_db=Wed Apr 18 20:23:08 2018 - [info]  Replication filtering check ok.Wed Apr 18 20:23:08 2018 - [info] GTID (with auto-pos) is supported. Skipping all SSH and Node package checking.Wed Apr 18 20:23:08 2018 - [info] Checking SSH publickey authentication settings on the current master..Wed Apr 18 20:23:08 2018 - [info] HealthCheck: SSH to 10.10.10.101 is reachable.Wed Apr 18 20:23:08 2018 - [info]10.10.10.101(10.10.10.101:3306) (current master)+--10.10.10.100(10.10.10.100:3306)+--10.10.10.102(10.10.10.102:3306)Wed Apr 18 20:23:08 2018 - [info] Checking replication health on 10.10.10.100..Wed Apr 18 20:23:08 2018 - [info]  ok.Wed Apr 18 20:23:08 2018 - [info] Checking replication health on 10.10.10.102..Wed Apr 18 20:23:08 2018 - [info]  ok.Wed Apr 18 20:23:08 2018 - [info] Checking master_ip_failover_script status:Wed Apr 18 20:23:08 2018 - [info]   /home/mha/app1/scripts/master_ip_failover --command=status --ssh_user=root --orig_master_host=10.10.10.101 --orig_master_ip=10.10.10.101 --orig_master_port=3306IN SCRIPT TEST====/sbin/ifconfig eno16777736:0 down==/sbin/ifconfig eno16777736:0 10.10.10.200/24===Checking the Status of the script.. OKWed Apr 18 20:23:08 2018 - [info]  OK.Wed Apr 18 20:23:08 2018 - [warning] shutdown_script is not defined.Wed Apr 18 20:23:08 2018 - [info] Got exit code 0 (Not master dead).MySQL Replication Health is OK.</code></pre><p>删除complete文件，再起启动MHA</p><pre><code class="bash">[root@mysql-slave-1023306 app1]# rm -rf app1.failover.complete[root@mysql-slave-1023306 app1]# nohup /usr/local/bin/masterha_manager --conf=/home/mha/app1/conf/app1.conf &amp;&gt; /home/mha/app1/nohup.out &amp;[1] 23424[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_status --conf=/home/mha/app1/conf/app1.confapp1 (pid:23424) is running(0:PING_OK), master:10.10.10.101</code></pre><p>至此，搭建MHA的过程就结束了；</p><hr><p>还有点内容需要补充，就是之前提到了清理relay log的方法；</p><p>MHA在发生切换过程中，从库在恢复的过程中，依赖于relay log的相关信息，所以我们这里要将relay log的自动清楚设置为OFF，采用手动清楚relay log的方式。</p><p>在默认情况下，从服务器上的中继日志会在SQL线程执行完后被自动删除。但是在MHA环境中，这些中继日志在恢复其它从服务器时可能会被用到，因此需要禁用中继日志的自动清除。改为定期手动清除SQL线程应用完的中继日志。</p><p>在ext3文件系统下，删除大的文件需要一定的时间，这样会导致严重的复制延迟，所以在Linux中，一般都是通过硬链接的方式来删除大文件。</p><p>设置定期清理relay脚本<br>MHA节点中包含了purge_relay_logs脚本，它可以为relay log创建硬链接，执行set global relay_log_purge&#x3D;1，等待几秒钟以便SQL线程切换到新的中继日志，再执行set global relay_log_purge&#x3D;0。</p><p>使用方法：</p><pre><code class="bash">[root@mysql-slave-1023306 mysql]# /usr/local/bin/purge_relay_logs --user=mhamanager --password=echo123. --disable_relay_log_purge  --workdir=/home/mysql2018-04-18 20:43:02: purge_relay_logs script started.Found relay_log.info: /data/mysql/relay-log.infoOpening /data/mysql/mysql-relay-bin.000002 ..Opening /data/mysql/mysql-relay-bin.000003 ..Executing SET GLOBAL relay_log_purge=1; FLUSH LOGS; sleeping a few seconds so that SQL thread can delete older relay log files (if it keeps up); SET GLOBAL relay_log_purge=0; .. ok.2018-04-18 20:43:05: All relay log purging operations succeeded.</code></pre><p>可以将该命令写到计划任务里面去，不同的slave进行relay log清理的时间最好错开；</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-封装、继承和多态</title>
      <link href="/2018/05/22/Python/Python-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
      <url>/2018/05/22/Python/Python-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h1><p>封装、继承和多态，是面向对象编程的三大特征</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装有两方面含义：<br>1、将数据（属性）和行为（方法）包装到类对象中。在方法内部对属性进行操作，在类对象的外部调用方法。这样就无需关心方法内部的具体实现细节，从而隔离了复杂度。<br>2、在类对象的内部，可以通过访问控制，把某些属性和方法隐藏起来，不允许在类对象的外部直接访问，而是在类对象的内部对外提供公开的接口方法（如getter、setter  ）以访问隐藏的信息，这样，就对隐藏的信息进行了保护</p><pre><code class="python">&gt;&gt;&gt; class Student(object):...     def __init__(self):...         self.__score = 0...     def set_score(self, score):...         if 0 &lt;= score &lt;= 100:...             self.__score = score...         else:...             raise ValueError(&#39;分数必须在0-100之间&#39;)...     def get_score(self):...         print(self.__score)...&gt;&gt;&gt; &gt;&gt;&gt; s1 = Student()&gt;&gt;&gt; s1.get_score()0&gt;&gt;&gt;&gt;&gt;&gt; s1.set_score(-10)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;&lt;stdin&gt;&quot;, line 8, in set_scoreValueError: 分数必须在0-100之间&gt;&gt;&gt; s1.set_score(100)&gt;&gt;&gt;&gt;&gt;&gt; s1.get_score()100</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>当几个类对象中有共同的属性和方法时，就可以把这些属性和方法抽象并提取到一个基类中，每个类对象特有的属性和方法还是在本类对象中定义，这样，只需要让每个类对象都继承这个基类，就可以访问积累中的属性和方法了，继承基类的每个类对象被称为派生类，基类也被称为父类或者超类，派生类也被称为子类。</p><p>python中的所有类对象都继承自一个统一的基类：object。这就是为什么我们在定义类对象时要在类名后面添加(object)。</p><p>继承是实现代码复用的重要手段</p><pre><code class="python">#!/usr/bin/python3class animals(object):    def eat(self):        print(&#39;吃饭&#39;)    def drink(self):        print(&#39;喝水&#39;)class dog(animals):    def run(self):        print(&#39;奔跑&#39;)class bird(animals):    def fly(self):        print(&#39;飞翔&#39;)dog = dog()bird = bird()dog.eat()dog.drink()dog.run()bird.eat()bird.drink()bird.fly()</code></pre><p>继承的语法格式<br>子类只有一个直接父类时称为单继承，假设子类和父类分别为ChildClass和ParentClass，子类继承父类的语法格式为：</p><pre><code class="python">class ChildClass(ParentClass):    pass</code></pre><p>子类有多个直接父类时称为多继承，假设子类是ChildClass，直接父类是ParentClass1，ParentClass2，……，ParentClassn，子类继承父类的语法格式为：</p><pre><code class="python">class ChildClass(ParentClass1, ParentClass2, ...，ParentClassn):    pass </code></pre><p>子类会继承所有父类（包括所有直接父类和所有间接父类）的所有属性和方法。</p><pre><code class="python">#!/usr/bin/python3class ParentClassA(object):    A1 = &#39;A1&#39;    def imA(self):        passclass ParentClassB(object):    __B1 = &#39;B1&#39;    def __imB(self):        passclass ChildClassC(ParentClassA, ParentClassB):    C1 = &#39;C1&#39;    def imC(self):        passprint(dir(ChildClassC))</code></pre><pre><code class="python"># &#39;A1&#39;,&#39;imA&#39;,&#39;_ParentClassB__B1&#39;,&#39;_ParentClassB__imB&#39; 属性和方法时继承自ParentClassA和ParentClassB，还有自己的属性和方法[root@lyucan ~]# ./13.py[&#39;A1&#39;, &#39;C1&#39;, &#39;_ParentClassB__B1&#39;, &#39;_ParentClassB__imB&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;imA&#39;, &#39;imC&#39;]</code></pre><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>如果子类对继承自父类的某个属性或方法不满意，可以在子类中对其进行重写从而提供自定义的实现。<br>重写的方式为：在子类中定义与父类中同名的属性或方法（包括装饰器）。</p><p>重写的好处是可以具有多态特征</p><p>子类重写父类的属性（或方法）后通过子类或其实例只能访问子类中重写后的属性（或方法），而无法再访问父类中被重写的属性（或方法）。</p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    P1 = &#39;P1（父类）&#39;    def __init__(self):        print(&#39;__init__()方法被调用了（父类）&#39;)    def im(self):        print(&#39;im()方法被调用了（父类）&#39;)    @classmethod    def cm(cls):        print(&#39;cm()方法被调用了（父类）&#39;)    @staticmethod    def sm():        print(&#39;sm()方法被调用了（父类）&#39;)class ChildClass(ParentClass):    P1 = &#39;C1（子类）&#39;    def __init__(self):        print(&#39;__init__()方法被调用了（子类）&#39;)    def im(self):        print(&#39;im()方法被调用了（子类）&#39;)    @classmethod    def cm(cls):        print(&#39;cm()方法被调用了（子类）&#39;)    @staticmethod    def sm():        print(&#39;sm()方法被调用了（子类）&#39;)pc = ParentClass()print(pc.P1)pc.im()pc.cm()pc.sm()cc = ChildClass()print(cc.P1)cc.im()cc.cm()cc.sm()</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>一个变量，具有多种形态，它指的是：即便不知道一个变量所引用的对象是什么类型，仍然可以通过这个变量调用方法，在程序运行过程中根据变量所引用的对象类型，动态的决定调用用哪个对象中的方法。如果子类中不存在指定名称的方法，会到父类中去查找，如果在父类中找到了，则调用父类中的方法，在父类中也没有找到，则抛出异常。</p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    def do_sth(self):        print(&#39;ParentClass调用了do_sth()&#39;)class ChildClass1(ParentClass):    def do_sth(self):        print(&#39;ChildClass1调用了do_sth()&#39;)class ChildClass2(ParentClass):    def do_sth(self):        print(&#39;ChildClass2调用了do_sth()&#39;)class ChildClass3(ParentClass):    def do_sth(self):        print(&#39;ChildClass3调用了do_sth()&#39;)class ChildClass4(object):    def do_sth(self):        print(&#39;ChildClass4调用了do_sth()&#39;)def func(p):    p.do_sth()func(ParentClass())func(ChildClass1())func(ChildClass2())func(ChildClass3())func(ChildClass4())</code></pre><pre><code class="python">[root@lyucan ~]# vim 15.py[root@lyucan ~]# ./15.pyParentClass调用了do_sth()ChildClass1调用了do_sth()ChildClass2调用了do_sth()ChildClass3调用了do_sth()ChildClass4调用了do_sth()</code></pre><p>python是动态语言，在调用函数时不会检查参数的类型，从而导致与静态语言（例如java）的多态是有区别的，对于静态语言，实现多态有三个必要条件：<br>1、继承<br>2、重写<br>3、父类类型的变量引用父类或子类类型的实例对象<br>因此对于静态语言，在上面程序中，要限定形参p的类型是ParentClass，传入的实参只能是ParentClass、ChildClass1、ChildClass2的实例对象。</p><p>动态语言的多态崇尚“鸭子类型”：当看到一只鸟走起来像鸭子，游泳起来像鸭子，并且叫起来也像鸭子，那么这只鸟可以被称为鸭子。<br>在鸭子类型中，我们并不关心对象是什么类型，到底是不是鸭子，我们只关心对象的行为。</p><p>在上面的程序中，我们并不关心变量p所引用的对象是什么类型，到底是不是ParentClass或其子类型，只关心变量p所引用的对象是否有do_sth()这个方法。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql事务</title>
      <link href="/2018/05/13/Mysql/Mysql%E4%BA%8B%E5%8A%A1/"/>
      <url>/2018/05/13/Mysql/Mysql%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h2><p>事务是数据库区别于文件系统的重要特性之一,事务会把数据库从一种一致状态转换为另一种一致状态.在数据库提交工作时，可以确保其要么所有修改都已经保存，要么所有修改都不保存。<br>Innodb存储引擎中的事务完全符合ACID的特性：</p><ol><li>原子性（atomicity）：原子性是指整个数据库事务是不可分割的工作单位.只有使事务中所有的数据库操作执行都成功，才算整个事务成功.如果事务中任何一个sql语句执行失败，那么已经执行成功的sql语句也必须撤销,数据库状态应该退回到执行事务前的状态.</li><li>一致性（consistency）：一致性是指事务将数据库从一种状态转变为下一种一致的状态，在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏.</li><li>隔离性（isolation）：一个事务的影响在该事务提交前对其他事务都不可见</li><li>持久性（durability）：事务一旦提交，其结果就是永久性.</li></ol><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>Sql标准定义的四个隔离级别：</p><ol><li>未提交读（Read uncommitted）</li><li>提交读（Read committed）</li><li>可重复读（Repeatable read）</li><li>串行化（Serializable）<blockquote><p>mysql默认为repeatable read<br>oracle默认为read committed</p></blockquote></li></ol><h2 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h2><p><img src="/images/50a40dba-982d-4e1f-8b11-ca0a3c05e70a-Image.png" alt="50a40dba-982d-4e1f-8b11-ca0a3c05e70a-Image.png" title="50a40dba-982d-4e1f-8b11-ca0a3c05e70a-Image.png"></p><h2 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h2><p> Mysql命令行的默认设置下，事务都是自动提交的,即执行sql语句后就会马上执行commit操作.因此开始一个事务，必须使用begin,start transaction,或者执行set autocommit&#x3D;0,以禁用当前会话的自动提交；</p><ul><li>Start transaction | begin：显示地开启一个事务</li><li>Commit：提交事务，并使得已对数据库做的所有修改成为永久性.</li><li>Rollback：回滚事务，撤销正在进行的所有未提交的修改.</li></ul><h2 id="隐式提交的sql语句"><a href="#隐式提交的sql语句" class="headerlink" title="隐式提交的sql语句"></a>隐式提交的sql语句</h2><p>某些Sql语句会产生一个隐式的提交操作,即执行完这些语句后，会有一个隐式的commit操作；<br><img src="/images/12fefa73-ca93-4963-af51-f9fde8b60281-Image.png" alt="12fefa73-ca93-4963-af51-f9fde8b60281-Image.png" title="12fefa73-ca93-4963-af51-f9fde8b60281-Image.png"></p><blockquote><p>注意点：Truncate table 语句是DDL，虽然和delete整张表的结果一样，但它不能被回滚</p></blockquote><h2 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h2><p>在innodb存储引擎中，事务日志通过重做（redo）日志文件和innodb存储引擎的日志缓冲来实现，当开始一个事务时，会记录该事务的一个lSN;当事务执行时，会往innodb存储引擎的日志缓冲里插入事务日志;当事务提交时，必须将innodb存储引擎的日志缓冲写入磁盘,也就是写数据前，需要先写日志.称为预写日志方式（WAL）；</p><p>Innodb存储引擎通过预写日志的方式，来保证事务的完整性.这意味着磁盘上存储的数据页和内存缓冲池中的页是不同步的,对于内存缓冲池中页的修改，先是写入重做日志文件，然后再写入磁盘，是一种异步方式.；</p><ul><li>Log sequence number 表示当前的LSN</li><li>Log flushed up to 表示刷新到重做日志文件的LSN</li><li>Last checkpoint at表示刷新到磁盘的lSN</li><li>Pages flushed up to 刷新事务和提交后的LSN（新添加的参数）</li></ul><h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>重做日志记录了事务的行为，可以很好地通过其进行重做，但是事务有时还需要撤销，这时就需要undo.undo与redo正好相反，对于数据库进行修改时，数据库不但产生redo，而且还会产生一定量的undo，即使你执行的事务或语句由于某种原因失败了，或者如果你用一条rollback语句请求回滚,就可以利用这些undo信息将数据回滚到修改之前的样子.与redo不同的是，redo存放在重做日志文件中，undo存放在数据库内部的一个特殊段中，undo segment.undo段位于共享表空间内;</p><h1 id="innodb存储引擎中的锁"><a href="#innodb存储引擎中的锁" class="headerlink" title="innodb存储引擎中的锁"></a>innodb存储引擎中的锁</h1><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><ul><li>共享锁（S） ： 允许事务读一行数据</li><li>排他锁(X) ： 允许事务删除或更新一条数据</li><li>意向共享锁（IS）： 事务想要获取一张表中某几行的共享锁</li><li>意向排他锁（IX）： 事务想要获取一张表中某几行的排他锁</li></ul><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><strong>Y：兼容，N：不兼容</strong></p><table><thead><tr><th align="left"></th><th align="left">S</th><th align="left">X</th><th align="left">IS</th><th align="left">IX</th></tr></thead><tbody><tr><td align="left">S</td><td align="left">Y</td><td align="left">N</td><td align="left">Y</td><td align="left">N</td></tr><tr><td align="left">X</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left">IS</td><td align="left">Y</td><td align="left">N</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left">IX</td><td align="left">N</td><td align="left">N</td><td align="left">Y</td><td align="left">Y</td></tr></tbody></table><h2 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h2><ul><li>Record Lock：单行记录上上锁</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-key Lock：Record Lock + Gap Lock，锁定一个范围，并锁定记录本身，目的是为了解决幻读现象</li></ul><h2 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h2><p>一致性非锁定读是值InnoDB存储引擎通过多版本控制（multi versioning）的方式来读取当前执行时间数据库中的数据。如果被读的数据行被加了排他锁，在读取这行数据的时候并不会等待锁释放，而是读取该行的一个快照数据。</p><p>之所以称为非锁定读，因为不需要等待被访问行的X锁的释放。快照数据是指改行之前的数据版本，该实现通过undo段来完成。</p><p>非锁定读的方式极大提高了数据库的并发性。在InnoDB存储引擎中，这是默认的读取方式。</p><p>快照数据其实就是当前行数据的一个历史版本，每行记录可能有多个版本。这种技术成为行多版本技术。由此带来的并发控制，成为多版本并发控制（Multi Version Concurrency Control,MVCC）。</p><p>在事务的隔离级别，READ COMMITED和REPEATABLE READ下，对快照数据的定义不同。在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的数据版本。</p><p>也就是说在READ COMMITTED事务隔离级别下，非锁定读读取到的数据是最新的快照版本数据，也就是可以读到另一个事务已经提交了的快照数据。而在REPEATABLE READ下，只会读到事务开始前的数据。</p><h2 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h2><p>  在默认情况下，InnoDB存储引擎对数据采用的是一致性非锁定读。但是有些情况下为了保证数据逻辑的一致性，需要对SELECT的操作加锁。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）操作：</p><ol><li>SELECT …… FOR UPDATE</li><li>SELECT …… LOCK IN SHARE MODE</li></ol><p>其中，SELECT …… FOR UPDATE对读取的记录加一个X锁，其他事务不能对已锁定的行加任何锁。而SELECT …… LOCK IN SHARE MODE是对读取的记录加一个S锁。</p><p>即使被读取的行被加了一致性锁定读，如果有另一个一致性非锁定读的操作来读取该行数据是不会阻塞的，读取的是该行的快照版本。</p><p>SELECT …… FOR UPDATE和SELECT …… LOCK IN SHARE MODE必须在一个事务中，当一个事务提交了，锁就释放了。因此在使用上述两个SELECT锁定语句时，必须开启事务。</p><p><strong>关于一致性非锁定读和一致性锁定读自己的理解：</strong></p><ul><li>一致性非锁定读情况下，事务A进行了select操作，此时事务B可以对事务A select的行进行update操作，此时事务A再次进行select操作，读取到的结果和事务的隔离级别有关，如果是repeatable read级别，不论事务B有没有进行commit操作，事务A此时查询到的结果还是第一次的结果，如果是read committed级别，若事务B没有提交，此时查询到的结果还是第一次的结果，若事务B提交了，此时查询到的结果就会是事务B更新之后的结果。</li><li>一致性锁定读情况下，事务B无法对事务A select的行进行update操作。</li></ul><h1 id="操作模拟"><a href="#操作模拟" class="headerlink" title="操作模拟"></a>操作模拟</h1><h2 id="可重复读（repeatable-read）"><a href="#可重复读（repeatable-read）" class="headerlink" title="可重复读（repeatable-read）"></a>可重复读（repeatable-read）</h2><table><thead><tr><th align="left">步骤</th><th align="left">事务A（repeatable-read）</th><th align="left">事务B <br> SET @@tx_isolation&#x3D;’repeatable-read’</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">begin;</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 李四</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">begin；</td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">update users set name&#x3D;‘张三’ where user_id&#x3D;1;</td></tr><tr><td align="left">5</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 李四</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">commit;</td></tr><tr><td align="left">7</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 李四</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">commit;</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 张三</td><td align="left"></td></tr></tbody></table><h2 id="提交读（read-committed）"><a href="#提交读（read-committed）" class="headerlink" title="提交读（read-committed）"></a>提交读（read-committed）</h2><table><thead><tr><th align="left">步骤</th><th align="left">事务A（read-committed）幻读 <br> SET @@tx_isolation&#x3D;’read-committed’</th><th align="left">事务B <br> SET @@tx_isolation&#x3D;’read-committed’</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">begin;</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 李四</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">begin；</td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">update users set name&#x3D;‘张三’ where user_id&#x3D;1;</td></tr><tr><td align="left">5</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 李四</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">commit;</td></tr><tr><td align="left">7</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 张三</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">commit;</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 张三</td><td align="left"></td></tr></tbody></table><h2 id="未提交读（read-uncommitted）"><a href="#未提交读（read-uncommitted）" class="headerlink" title="未提交读（read-uncommitted）"></a>未提交读（read-uncommitted）</h2><table><thead><tr><th align="left">步骤</th><th align="left">事务A（read-uncommitted ）脏读 <br> SET @@tx_isolation&#x3D;’read-uncommitted’</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">begin;</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 李四</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">begin；</td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">update users set name&#x3D;‘张三’ where user_id&#x3D;1;</td></tr><tr><td align="left">5</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 张三</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">commit;</td></tr><tr><td align="left">7</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 张三</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">commit;</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">select * from users where user_id&#x3D;1; <br >user_id   &nbsp;&nbsp;&nbsp;&nbsp;name  <br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 张三</td><td align="left"></td></tr></tbody></table><h1 id="外键锁"><a href="#外键锁" class="headerlink" title="外键锁"></a>外键锁</h1><p>对于外键值的插入和更新，首先需要查找父表中的记录，即SELECT父表。但是对于父表的SELECT操作，不是采用一致性非锁定读的方式，因为这样可能会发生数据不一致的问题。此时采用过的是SELECT …… LOCK IN SHARE MODE的方式，给父表的记录加一个S锁。如果此时对父表加一个X锁，则会被阻塞。</p><p><strong>事务和锁最重要的三张表</strong><br>在information_schema下，有三张表记录了事务和锁的信息：<br>INNODB_TRX<br>INNODB_LOCKS<br>INNODB_LOCK_WAITS</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-异常处理</title>
      <link href="/2018/05/12/Python/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2018/05/12/Python/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><pre><code>异常指的是程序在没有语法错误的前提下，在运行期间产生的特定错误。每个特定错误都对应一个异常类对象。当产生某个特定错误时，其异常类对象的实例对象就会被抛出，如果在程序中对抛出的异常实例对象不进行捕获和处理，程序就会停止运行，并且答应错误的详细信息，包括：</code></pre><p>1、Traceback，指的是异常调用堆栈的跟踪信息，其中列出了程序中的相关行数；<br>2、对应的异常类对象的名称以及错误信息；</p><p>如果在程序中对抛出的异常实例对象进行捕获和处理，程序就会继续运行。</p><p>哪些特定的错误会被看做是异常，首先Python内置了很多异常类对象，其次，可以自定义异常类对象，所以，内置的异常类对象和自定义的异常类对象对应的错误会被看做异常。</p><p>内置的异常类对象，<a href="https://docs.python.org/3.7/library/exceptions.html" title="title">https://docs.python.org/3.7/library/exceptions.html</a></p><pre><code class="python">BaseException+-- SystemExit+-- KeyboardInterrupt+-- GeneratorExit+-- Exception      +-- StopIteration      +-- StopAsyncIteration      +-- ArithmeticError      |    +-- FloatingPointError      |    +-- OverflowError      |    +-- ZeroDivisionError      +-- AssertionError      +-- AttributeError      +-- BufferError      +-- EOFError      +-- ImportError      |    +-- ModuleNotFoundError      +-- LookupError      |    +-- IndexError      |    +-- KeyError      +-- MemoryError      +-- NameError      |    +-- UnboundLocalError      +-- OSError      |    +-- BlockingIOError      |    +-- ChildProcessError      |    +-- ConnectionError      |    |    +-- BrokenPipeError      |    |    +-- ConnectionAbortedError      |    |    +-- ConnectionRefusedError      |    |    +-- ConnectionResetError      |    +-- FileExistsError      |    +-- FileNotFoundError      |    +-- InterruptedError      |    +-- IsADirectoryError      |    +-- NotADirectoryError      |    +-- PermissionError      |    +-- ProcessLookupError      |    +-- TimeoutError      +-- ReferenceError      +-- RuntimeError      |    +-- NotImplementedError      |    +-- RecursionError      +-- SyntaxError      |    +-- IndentationError      |         +-- TabError      +-- SystemError      +-- TypeError      +-- ValueError      |    +-- UnicodeError      |         +-- UnicodeDecodeError      |         +-- UnicodeEncodeError      |         +-- UnicodeTranslateError      +-- Warning           +-- DeprecationWarning           +-- PendingDeprecationWarning           +-- RuntimeWarning           +-- SyntaxWarning           +-- UserWarning           +-- FutureWarning           +-- ImportWarning           +-- UnicodeWarning           +-- BytesWarning           +-- ResourceWarning</code></pre><blockquote><p>所有内置异常类对继承自Exception</p></blockquote><h2 id="try-except捕获处理异常"><a href="#try-except捕获处理异常" class="headerlink" title="try-except捕获处理异常"></a>try-except捕获处理异常</h2><p>程序在运行期间产生异常时，为了让程序能够继续执行，可以对抛出的异常实例对象进行捕获和处理，这是通过try-except语句实现的：把可能会产生异常的代码放在try语句块中以捕获异常实例对象，把处理异常的代码放在由若干个except子句组成的except语句块中。</p><p>语法格式：</p><pre><code class="python">try:    可能会产生异常的代码except 异常类对象1:    当前except子句处理的代码except 异常类对象2：    当前except子句处理的代码......except 异常类对象n：    当前except子句处理的代码</code></pre><p><img src="/images/26e3158e-8acf-440d-af11-556d88354371-Image.png" alt="26e3158e-8acf-440d-af11-556d88354371-Image.png" title="26e3158e-8acf-440d-af11-556d88354371-Image.png"></p><pre><code class="python">#!/usr/bin/python3try:    i = 1 / 0except ZeroDivisionError:    print(&#39;0不能作为除数&#39;)</code></pre><p>当try语句块产生异常时，会从上到下依次查找是否有匹配的子句，只要找到一个匹配的except子句，则不会查找剩余的except子句，因此一定要注意各个except子句的顺序</p><pre><code class="python">#!/usr/bin/python3try:    i = 1 / 0except ArithmeticError:    print(&#39;数学错误&#39;)except ZeroDivisionError:    print(&#39;0不能作为除数&#39;)</code></pre><pre><code class="python">[root@lyucan ~]# ./yc.py数学错误</code></pre><p>当多个异常类对象所对应的异常处理代码完全相同时， 可以把这些异常类对象以元组的形式放在一个except子句中。</p><pre><code class="python">#!/usr/bin/python3try:    i = 1 / 0except (ZeroDivisionError,TypeError):    print(&#39;运行出错了&#39;)</code></pre><h2 id="使用as访问异常"><a href="#使用as访问异常" class="headerlink" title="使用as访问异常"></a>使用<code>as</code>访问异常</h2><p>如果想在匹配到的except子句中访问异常实例对象，可以在except子句的冒号前添加关键字as和一个变量。</p><pre><code class="python">#!/usr/bin/python3try:    i = 1 / 0except (ZeroDivisionError, TypeError) as err:    print(type(err))    print(err)</code></pre><pre><code class="python">[root@lyucan ~]# ./yc.py&lt;class &#39;ZeroDivisionError&#39;&gt;division by zero</code></pre><h2 id="使用Exception捕获其他异常"><a href="#使用Exception捕获其他异常" class="headerlink" title="使用Exception捕获其他异常"></a>使用Exception捕获其他异常</h2><p>为了在except语句块中将所有的异常类对象尽可能的覆盖到，可以将最后一个except子句中的异常类对象指定为Exception（内置异常类对象和自定义异常类对象都继承自Exception），或者在最后一个except子句中不指定异常类对象。</p><pre><code class="python">#!/usr/bin/python3try:    i = int(&#39;abc&#39;)except (ZeroDivisionError,TypeError):    print(&#39;除0错误和值错误&#39;)except Exception:               # 这里也可以不指定异常类对象，直接使用 except:    print(&#39;其他错误&#39;)</code></pre><h2 id="使用else从句"><a href="#使用else从句" class="headerlink" title="使用else从句"></a>使用else从句</h2><p>可以在while语句或for-in语句的后面添加else语句，类似的，可以在 try-except语句后面添加else从句。如果没有产生异常时，就会执行else从句里面的代码。<br>语法格式：</p><pre><code class="python">try:    可能会产生异常的代码except 异常类对象1:    当前except子句处理的代码except 异常类对象2：    当前except子句处理的代码......except 异常类对象n：    当前except子句处理的代码else:    try语句块中没有产生异常时执行的代码</code></pre><p><img src="/images/25c0dbe2-014f-4fc7-98d8-2b18b1903ffd-Image.png" alt="25c0dbe2-014f-4fc7-98d8-2b18b1903ffd-Image.png" title="25c0dbe2-014f-4fc7-98d8-2b18b1903ffd-Image.png"></p><h2 id="使用finally从句"><a href="#使用finally从句" class="headerlink" title="使用finally从句"></a>使用finally从句</h2><p>可以在try-except语句的后面添加finally从句，finally从句总会被执行，通常在finally从句中释放资源，例如：关闭文件、关闭网络连接等。<br>语法格式：</p><pre><code class="python">try:    可能会产生异常的代码except 异常类对象1:    当前except子句处理的代码except 异常类对象2：    当前except子句处理的代码......except 异常类对象n：    当前except子句处理的代码finally:    总会被执行的代码</code></pre><p><img src="/images/2ceecabd-68bf-409d-927b-95833a2535ae-Image.png" alt="2ceecabd-68bf-409d-927b-95833a2535ae-Image.png" title="2ceecabd-68bf-409d-927b-95833a2535ae-Image.png"></p><h2 id="同时具有else和finally从句"><a href="#同时具有else和finally从句" class="headerlink" title="同时具有else和finally从句"></a>同时具有else和finally从句</h2><pre><code class="python">try:    可能会产生异常的代码except 异常类对象1:    当前except子句处理的代码except 异常类对象2：    当前except子句处理的代码......except 异常类对象n：    当前except子句处理的代码else:    try语句块中没有产生异常时执行的代码finally:    总会被执行的代码</code></pre><p><img src="/images/85817583-8e7f-4228-a915-34bbbed4631c-Image.png" alt="85817583-8e7f-4228-a915-34bbbed4631c-Image.png" title="85817583-8e7f-4228-a915-34bbbed4631c-Image.png"></p><h2 id="使用raise语句手动抛出异常"><a href="#使用raise语句手动抛出异常" class="headerlink" title="使用raise语句手动抛出异常"></a>使用<code>raise</code>语句手动抛出异常</h2><p>对于前面课程中的示例，在发生异常时的异常实例对象都是被自动抛出的，我们可以使用raise语句手动的抛出异常实例对象，<br>语法格式为：</p><pre><code class="python">raise 异常类对象[([参数])]如果没有传入参数，可以省略小括号</code></pre><pre><code class="python">#!/usr/bin/python3raise ZeroDivisionError(&#39;0不能作为除数&#39;)raise ZeroDivisionError()raise ZeroDivisionError</code></pre><pre><code class="python">#!/usr/bin/python3try:    raise ZeroDivisionErrorexcept ZeroDivisionError:    print(&#39;0不能作为除数&#39;)</code></pre><pre><code class="python">[root@lyucan ~]# ./yc.py0不能作为除数</code></pre><p>如果在except语句块中不想对异常实例对象进行处理，可以使用关键字raise将其原样抛出，或者抛出另外一个异常类对象的实例对象。</p><pre><code class="python">#!/usr/bin/python3try:    raise ZeroDivisionErrorexcept ZeroDivisionError:    raise</code></pre><pre><code class="python">[root@lyucan ~]# ./yc.pyTraceback (most recent call last):  File &quot;./yc.py&quot;, line 4, in &lt;module&gt;    raise ZeroDivisionErrorZeroDivisionError</code></pre><pre><code class="python">#!/usr/bin/python3try:    raise ZeroDivisionErrorexcept ZeroDivisionError:    raise ValueError(&#39;值错误&#39;)</code></pre><pre><code class="python">[root@lyucan ~]# ./yc.pyTraceback (most recent call last):  File &quot;./yc.py&quot;, line 4, in &lt;module&gt;    raise ZeroDivisionErrorZeroDivisionErrorDuring handling of the above exception, another exception occurred:Traceback (most recent call last):  File &quot;./yc.py&quot;, line 6, in &lt;module&gt;    raise ValueError(&#39;值错误&#39;)ValueError: 值错误</code></pre><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>尽管python内置的异常类对象可以满足我们绝大多数的需求，但是有时候我们可能想要创建自定义的异常类对象。正如所有内置异常类对象的基类是Exception，自定义异常类对象只需要继承Exception或其子类。</p><pre><code class="python">#!/usr/bin/python3class MyException(Exception):    def __call__(self):        print(&#39;自定义异常&#39;)try:    raise MyExceptionexcept MyException as err:    err()</code></pre><pre><code class="python">[root@lyucan ~]# ./yc.py自定义异常</code></pre><h2 id="异常和函数"><a href="#异常和函数" class="headerlink" title="异常和函数"></a>异常和函数</h2><p>当函数内发生异常时，异常实例对象会被抛给该函数的调用者，如果该函数的调用者没有捕获和处理，则继续抛给上一撑的调用者，这样一直向上抛，最后会被Python解释器捕获。<br>在异常实例对象在向上抛的过程中，可以选择合适的层对异常实例对象进行捕获和处理，而不需要在每一层进行捕获和处理。</p><pre><code class="python">#!/usr/bin/python3def f1():    print(1 / 0)def f2():    try:        f1()    except ZeroDivisionError as err:        print(err)def f3():    f2()f3()print(&#39;继续执行代码&#39;)</code></pre><pre><code class="python">[root@lyucan ~]# ./yc.pydivision by zero继续执行代码</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMAN备份集管理</title>
      <link href="/2018/05/12/Oracle/RMAN%E5%A4%87%E4%BB%BD%E9%9B%86%E7%AE%A1%E7%90%86/"/>
      <url>/2018/05/12/Oracle/RMAN%E5%A4%87%E4%BB%BD%E9%9B%86%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="RMAN备份集管理"><a href="#RMAN备份集管理" class="headerlink" title="RMAN备份集管理"></a>RMAN备份集管理</h1><h2 id="查看多余的备份集并删除"><a href="#查看多余的备份集并删除" class="headerlink" title="查看多余的备份集并删除"></a>查看多余的备份集并删除</h2><pre><code class="sql">RMAN&gt; report obsolete;   ##报告多余备份信息RMAN retention policy will be applied to the commandRMAN retention policy is set to redundancy 1Report of obsolete backups and copiesType                 Key    Completion Time    Filename/Handle-------------------- ------ ------------------ --------------------Archive Log          8089   15-MAY-18          /oracle/11g/flash_recovery_area/MYSQL_MA/archivelog/2018_05_15/o1_mf_1_52_fhpzqmps_.arcBackup Set           8091   15-MAY-18          Backup Piece       8095   15-MAY-18          /oracle/11g/backup/2rt2vtk5_1_1_20180515Backup Set           8134   15-MAY-18          Backup Piece       8139   15-MAY-18          /oracle/11g/backup/2st2vtlk_1_1_20180515Backup Set           8629   15-MAY-18          Backup Piece       8633   15-MAY-18          /oracle/11g/backup/orcl/backup01/35t2vv2d_1_2Backup Set           8629   15-MAY-18          Backup Piece       8632   15-MAY-18          /oracle/11g/backup/orcl/backup01/35t2vv2d_1_1Backup Set           9643   15-MAY-18          Backup Piece       9645   15-MAY-18          /oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_15/o1_mf_s_976224603_fhq2dw68_.bkpArchive Log          10382  15-MAY-18          /oracle/11g/flash_recovery_area/MYSQL_MA/archivelog/2018_05_15/o1_mf_1_53_fhq5hgv8_.arcBackup Set           10182  15-MAY-18          Backup Piece       10184  15-MAY-18          /oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_15/o1_mf_s_976225127_fhq2x856_.bkpRMAN&gt; delete obsolete;  ##删除多余的备份RMAN retention policy will be applied to the commandRMAN retention policy is set to redundancy 1using channel ORA_DISK_1Deleting the following obsolete backups and copies:Type                 Key    Completion Time    Filename/Handle-------------------- ------ ------------------ --------------------Archive Log          8089   15-MAY-18          /oracle/11g/flash_recovery_area/MYSQL_MA/archivelog/2018_05_15/o1_mf_1_52_fhpzqmps_.arcBackup Set           8091   15-MAY-18          Backup Piece       8095   15-MAY-18          /oracle/11g/backup/2rt2vtk5_1_1_20180515Backup Set           8134   15-MAY-18          Backup Piece       8139   15-MAY-18          /oracle/11g/backup/2st2vtlk_1_1_20180515Backup Set           8629   15-MAY-18          Backup Piece       8633   15-MAY-18          /oracle/11g/backup/orcl/backup01/35t2vv2d_1_2Backup Set           8629   15-MAY-18          Backup Piece       8632   15-MAY-18          /oracle/11g/backup/orcl/backup01/35t2vv2d_1_1Backup Set           9643   15-MAY-18          Backup Piece       9645   15-MAY-18          /oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_15/o1_mf_s_976224603_fhq2dw68_.bkpArchive Log          10382  15-MAY-18          /oracle/11g/flash_recovery_area/MYSQL_MA/archivelog/2018_05_15/o1_mf_1_53_fhq5hgv8_.arcBackup Set           10182  15-MAY-18          Backup Piece       10184  15-MAY-18          /oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_15/o1_mf_s_976225127_fhq2x856_.bkpDo you really want to delete the above objects (enter YES or NO)? ydeleted archived logarchived log file name=/oracle/11g/flash_recovery_area/MYSQL_MA/archivelog/2018_05_15/o1_mf_1_52_fhpzqmps_.arc RECID=56 STAMP=976221875deleted backup piecebackup piece handle=/oracle/11g/backup/2rt2vtk5_1_1_20180515 RECID=85 STAMP=976221829deleted backup piecebackup piece handle=/oracle/11g/backup/2st2vtlk_1_1_20180515 RECID=86 STAMP=976221876deleted backup piecebackup piece handle=/oracle/11g/backup/orcl/backup01/35t2vv2d_1_2 RECID=97 STAMP=976223309deleted backup piecebackup piece handle=/oracle/11g/backup/orcl/backup01/35t2vv2d_1_1 RECID=96 STAMP=976223309deleted backup piecebackup piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_15/o1_mf_s_976224603_fhq2dw68_.bkp RECID=614 STAMP=976224604deleted archived logarchived log file name=/oracle/11g/flash_recovery_area/MYSQL_MA/archivelog/2018_05_15/o1_mf_1_53_fhq5hgv8_.arc RECID=57 STAMP=976227760deleted backup piecebackup piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_15/o1_mf_s_976225127_fhq2x856_.bkp RECID=871 STAMP=976225128Deleted 8 objects</code></pre><h2 id="校验、注册元数据"><a href="#校验、注册元数据" class="headerlink" title="校验、注册元数据"></a>校验、注册元数据</h2><p>如果备份集的物理文件被误删除，那么该备份集将不能作为备份进行恢复，需要重新注册元数据或者将该元数据删除；</p><pre><code class="sql">RMAN&gt; crosscheck backup;RMAN&gt; delete expired backup;</code></pre><p>假如我的备份集元数据没有损坏，但是备份的物理文件损坏了，我们需要删除该备份集的元数据</p><pre><code class="sql">##有users的备份集10460，状态为availableRMAN&gt; list backupset of tablespace users;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------10460   Full    1.30M      DISK        00:00:00     16-MAY-18             BP Key: 10461   Status: AVAILABLE  Compressed: NO  Tag: TAG20180516T202420        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_16/o1_mf_nnndf_TAG20180516T202420_fhslxn4x_.bkp  List of Datafiles in backup set 10460  File LV Type Ckp SCN    Ckp Time  Name  ---- -- ---- ---------- --------- ----  4       Full 1476440    16-MAY-18 /oracle/11g/oradata/mysql_master_1003306/users01.dbf##将备份集的物理文件删除$ rm /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_16/o1_mf_nnndf_TAG20180516T202420_fhslxn4x_.bkp##再次查看，状态还是available，因为没有进行备份集的元数据校验RMAN&gt; list backupset of tablespace users;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------10460   Full    1.30M      DISK        00:00:00     16-MAY-18             BP Key: 10461   Status: AVAILABLE  Compressed: NO  Tag: TAG20180516T202420        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_16/o1_mf_nnndf_TAG20180516T202420_fhslxn4x_.bkp  List of Datafiles in backup set 10460  File LV Type Ckp SCN    Ckp Time  Name  ---- -- ---- ---------- --------- ----  4       Full 1476440    16-MAY-18 /oracle/11g/oradata/mysql_master_1003306/users01.dbf##此时，进行元数据的校验操作，可以看到校验结果为expiredRMAN&gt; crosscheck backup;using channel ORA_DISK_1crosschecked backup piece: found to be &#39;EXPIRED&#39;backup piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_16/o1_mf_nnndf_TAG20180516T202420_fhslxn4x_.bkp RECID=874 STAMP=976307060crosschecked backup piece: found to be &#39;AVAILABLE&#39;backup piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/autobackup/2018_05_16/o1_mf_s_976307061_fhslxp0l_.bkp RECID=875 STAMP=976307062Crosschecked 2 objects##再次查看，状态将显示为expired，此时，该备份集将不可用，不能用于恢复RMAN&gt; list backupset of tablespace users;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------10460   Full    1.30M      DISK        00:00:00     16-MAY-18             BP Key: 10461   Status: EXPIRED  Compressed: NO  Tag: TAG20180516T202420        Piece Name: /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_16/o1_mf_nnndf_TAG20180516T202420_fhslxn4x_.bkp  List of Datafiles in backup set 10460  File LV Type Ckp SCN    Ckp Time  Name  ---- -- ---- ---------- --------- ----  4       Full 1476440    16-MAY-18 /oracle/11g/oradata/mysql_master_1003306/users01.dbf##删除该备份集的元数据RMAN&gt; delete expired backup;using channel ORA_DISK_1List of Backup PiecesBP Key  BS Key  Pc# Cp# Status      Device Type Piece Name------- ------- --- --- ----------- ----------- ----------10461   10460   1   1   EXPIRED     DISK        /oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_16/o1_mf_nnndf_TAG20180516T202420_fhslxn4x_.bkpDo you really want to delete the above objects (enter YES or NO)? ydeleted backup piecebackup piece handle=/oracle/11g/flash_recovery_area/MYSQL_MA/backupset/2018_05_16/o1_mf_nnndf_TAG20180516T202420_fhslxn4x_.bkp RECID=874 STAMP=976307060Deleted 1 EXPIRED objects##再次查看将查不到该备份集的信息RMAN&gt; list backupset of tablespace users;specification does not match any backup in the repository</code></pre><p>如果备份数据文件在，但是元数据损坏了，那么需要重新注册元数据</p><pre><code class="sql">RMAN&gt; catalog backuppiece &#39;/oracle/11g/backup/orcl/backup01/o1_mf_nnndf_TAG20180516T204158_fhsmypvg_.bkp&#39;;RMAN&gt; catalog start with &#39;/oracle/11g/backup/orcl/backup02&#39;;    ##将把该目录下的所有备份文件重新注册，包括该目录下的二级以上的目录RMAN&gt; catalog datafilecopy &#39;/oracle/11g/backup/orcl/users01.dbf&#39;;  ##将手动备份出来的文件注册到rman</code></pre><pre><code class="sql">##注册单个备份文件RMAN&gt; catalog backuppiece &#39;/oracle/11g/backup/orcl/backup01/o1_mf_nnndf_TAG20180516T204158_fhsmypvg_.bkp&#39;;cataloged backup piecebackup piece handle=/oracle/11g/backup/orcl/backup01/o1_mf_nnndf_TAG20180516T204158_fhsmypvg_.bkp RECID=878 STAMP=976308522RMAN&gt; list backupset;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------10629   Full    1.30M      DISK        00:00:00     16-MAY-18             BP Key: 10631   Status: AVAILABLE  Compressed: NO  Tag: TAG20180516T204158        Piece Name: /oracle/11g/backup/orcl/backup01/o1_mf_nnndf_TAG20180516T204158_fhsmypvg_.bkp  List of Datafiles in backup set 10629  File LV Type Ckp SCN    Ckp Time  Name  ---- -- ---- ---------- --------- ----  4       Full 1477024    16-MAY-18 /oracle/11g/oradata/mysql_master_1003306/users01.dbf##注册目录下的所有备份文件[oracle@mysql-master-1003306 backup]$ ls -R orcl/orcl/:backup01  backup02orcl/backup01:o1_mf_nnndf_TAG20180516T205116_fhsnj4wt_.bkporcl/backup02:o1_mf_nnndf_TAG20180516T204158_fhsmypvg_.bkpRMAN&gt; catalog start with &#39;/oracle/11g/backup/orcl&#39;;searching for all files that match the pattern /oracle/11g/backup/orclList of Files Unknown to the Database=====================================File Name: /oracle/11g/backup/orcl/backup01/o1_mf_nnndf_TAG20180516T205116_fhsnj4wt_.bkpFile Name: /oracle/11g/backup/orcl/backup02/o1_mf_nnndf_TAG20180516T204158_fhsmypvg_.bkpDo you really want to catalog the above files (enter YES or NO)? ycataloging files...cataloging doneList of Cataloged Files=======================File Name: /oracle/11g/backup/orcl/backup01/o1_mf_nnndf_TAG20180516T205116_fhsnj4wt_.bkpFile Name: /oracle/11g/backup/orcl/backup02/o1_mf_nnndf_TAG20180516T204158_fhsmypvg_.bkpRMAN&gt; list backupset;List of Backup Sets===================BS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------10859   Full    592.10M    DISK        00:00:00     16-MAY-18             BP Key: 10863   Status: AVAILABLE  Compressed: NO  Tag: TAG20180516T205116        Piece Name: /oracle/11g/backup/orcl/backup01/o1_mf_nnndf_TAG20180516T205116_fhsnj4wt_.bkp  List of Datafiles in backup set 10859  File LV Type Ckp SCN    Ckp Time  Name  ---- -- ---- ---------- --------- ----  1       Full 1477399    16-MAY-18 /oracle/11g/oradata/mysql_master_1003306/system01.dbfBS Key  Type LV Size       Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------10860   Full    1.30M      DISK        00:00:00     16-MAY-18             BP Key: 10864   Status: AVAILABLE  Compressed: NO  Tag: TAG20180516T204158        Piece Name: /oracle/11g/backup/orcl/backup02/o1_mf_nnndf_TAG20180516T204158_fhsmypvg_.bkp  List of Datafiles in backup set 10860  File LV Type Ckp SCN    Ckp Time  Name  ---- -- ---- ---------- --------- ----  4       Full 1477024    16-MAY-18 /oracle/11g/oradata/mysql_master_1003306/users01.dbf##注册手动拷贝出来的数据文件sys@MYSQL_MA&gt; alter tablespace users begin backup;Tablespace altered.[oracle@oracle orcl]$ cp /oracle/11g/oradata/orcl/users01.dbf /oracle/11g/backup/orclsys@MYSQL_MA&gt; alter tablespace users end backup;Tablespace altered.RMAN&gt; catalog datafilecopy &#39;/oracle/11g/backup/orcl/users01.dbf&#39;;cataloged datafile copydatafile copy file name=/oracle/11g/backup/orcl/users01.dbf RECID=3 STAMP=976311159RMAN&gt; list copy of tablespace users;List of Datafile Copies=======================Key     File S Completion Time Ckp SCN    Ckp Time      ------- ---- - --------------- ---------- ---------------10897   4    A 16-MAY-18       1479015    16-MAY-18             Name: /oracle/11g/backup/orcl/users01.dbf</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xtrabackup备份原理</title>
      <link href="/2018/05/11/Mysql/xtrabackup%E5%A4%87%E4%BB%BD%E5%8E%9F%E7%90%86/"/>
      <url>/2018/05/11/Mysql/xtrabackup%E5%A4%87%E4%BB%BD%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="xtrabackup备份原理"><a href="#xtrabackup备份原理" class="headerlink" title="xtrabackup备份原理"></a>xtrabackup备份原理</h1><p>xtrabackup 是用来备份 InnoDB 表的，不能备份非 InnoDB 表，和 mysqld server 没有交互；<br>innobackupex 脚本用来备份非 InnoDB 表，同时会调用 xtrabackup 命令来备份 InnoDB 表，还会和 mysqld server 发送命令进行交互，如加读锁（FTWRL）、获取位点（SHOW SLAVE STATUS）等。</p><p>简单来说，innobackupex 在 xtrabackup 之上做了一层封装。一般情况下，我们是希望能备份 MyISAM 表的，虽然我们可能自己不用 MyISAM 表，但是 mysql 库下的系统表是 MyISAM 的，因此备份基本都通过 innobackupex 命令进行；另外一个原因是我们可能需要保存位点信息。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/images/c83eb472-1f62-4cf5-9f02-42e88463696a-PXB-backup-procedure.png" alt="c83eb472-1f62-4cf5-9f02-42e88463696a-PXB-backup-procedure.png" title="c83eb472-1f62-4cf5-9f02-42e88463696a-PXB-backup-procedure.png"></p><h2 id="备份过程"><a href="#备份过程" class="headerlink" title="备份过程"></a>备份过程</h2><ol><li>innobackupex 在启动后，会先 fork 一个进程，启动 xtrabackup进程，然后就等待 xtrabackup 备份完 ibd 数据文件；</li><li>xtrabackup 在备份 InnoDB 相关数据时，是有2种线程的，1种是 redo 拷贝线程，负责拷贝 redo 文件，1种是 ibd 拷贝线程，负责拷贝 ibd 文件；redo 拷贝线程只有一个，在 ibd 拷贝线程之前启动，在 ibd 线程结束后结束（并不是马上结束，而是等到非innodb存储引擎表备份完再结束，这里强调的是先后顺序）。</li><li>xtrabackup 进程开始执行后，先启动 redo 拷贝线程，从最新的 checkpoint 点开始顺序拷贝 redo 日志；然后再启动 ibd 数据拷贝线程，在 xtrabackup 拷贝 ibd 过程中，innobackupex 进程一直处于等待状态（等待文件被创建）。</li><li>xtrabackup 拷贝完成idb后，通知 innobackupex（通过创建文件），同时自己进入等待（redo 线程仍然继续拷贝）;</li><li>innobackupex 收到 xtrabackup 通知后，执行FLUSH TABLES WITH READ LOCK (FTWRL)，取得一致性位点，然后开始备份非 InnoDB 文件（包括 frm、MYD、MYI、CSV、opt、par等）。拷贝非 InnoDB 文件过程中，因为数据库处于全局只读状态，如果在业务的主库备份的话，要特别小心，非 InnoDB 表（主要是MyISAM）比较多的话整库只读时间就会比较长，这个影响一定要评估到。</li><li>当 innobackupex 拷贝完所有非 InnoDB 表文件后，通知 xtrabackup（通过删文件） ，同时自己进入等待（等待另一个文件被创建）；xtrabackup 收到 innobackupex 备份完非 InnoDB 通知后，就停止 redo 拷贝线程，然后通知 innobackupex redo log 拷贝完成（通过创建文件）；</li><li>innobackupex 收到 redo 备份完成通知后，就开始解锁，执行 UNLOCK TABLES；</li><li>最后 innobackupex 和 xtrabackup 进程各自完成收尾工作，如资源的释放、写备份元数据信息等，innobackupex 等待 xtrabackup 子进程结束后退出。</li></ol><h2 id="恢复过程"><a href="#恢复过程" class="headerlink" title="恢复过程"></a>恢复过程</h2><p>如果看恢复备份集的日志，会发现和 mysqld 启动时非常相似，其实备份集的恢复就是类似 mysqld crash后，做一次 crash recover。</p><p>恢复的目的是把备份集中的数据恢复到一个一致性位点，所谓一致就是指原数据库某一时间点各引擎数据的状态，比如 MyISAM 中的数据对应的是 15:00 时间点的，InnoDB 中的数据对应的是 15:20 的，这种状态的数据就是不一致的。PXB 备份集对应的一致点，就是备份时FTWRL的时间点，恢复出来的数据，就对应原数据库FTWRL时的状态。</p><p>因为备份时 FTWRL 后，数据库是处于只读的，非 InnoDB 数据是在持有全局读锁情况下拷贝的，所以非 InnoDB 数据本身就对应 FTWRL 时间点；InnoDB 的 ibd 文件拷贝是在 FTWRL 前做的，拷贝出来的不同 ibd 文件最后更新时间点是不一样的，这种状态的 ibd 文件是不能直接用的，但是 redo log 是从备份开始一直持续拷贝的，最后的 redo 日志点是在持有 FTWRL 后取得的，所以最终通过 redo 应用后的 ibd 数据时间点也是和 FTWRL 一致的。</p><p>所以恢复过程只涉及 InnoDB 文件的恢复，非 InnoDB 数据是不动的。备份恢复完成后，就可以把数据文件拷贝到对应的目录，然后通过mysqld来启动了。</p><p>备份过程中产生的事务会被备份出来，提交了的前滚，未提交的回滚，保持数据的一致性；</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-issubclass()、isinstance()</title>
      <link href="/2018/05/04/Python/Python-issubclass()%E3%80%81isinstance()/"/>
      <url>/2018/05/04/Python/Python-issubclass()%E3%80%81isinstance()/</url>
      
        <content type="html"><![CDATA[<h1 id="issubclass-、isinstance"><a href="#issubclass-、isinstance" class="headerlink" title="issubclass()、isinstance()"></a>issubclass()、isinstance()</h1><h2 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass()"></a>issubclass()</h2><p>用于判断类对象是否是另一个（或一组）类对象的子类<br><code>issubclass()</code>接收两个参数，第一个参数时类对象，第二个参数时类对象或由类对象组成的元组 。<br>当第二个实参是类对象的时候，如果第一个实参是第二个实参的子类，则返回True。<br>当第二个实参是类对象组成的元组时，如果第一个参是第二个实参中任意一个类对象的子类，则返回True。</p><pre><code class="python">#!/usr/bin/python3class A(object):    passclass B(object):    passclass C(object):    passclass D(A):    passclass E(D):    passprint(issubclass(D, A))    # Trueprint(issubclass(D, D))    # True  自己是自己的子类print(issubclass(D, E))    # Falseprint(issubclass(E, A))    # Trueprint(issubclass(D, (A, B)))    # Trueprint(issubclass(D, (B, C)))    # Falseprint(issubclass(E, (D, A)))    # True</code></pre><pre><code class="python">[root@lyucan ~]# ./23.pyTrueTrueFalseTrueTrueFalseTrue</code></pre><h2 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h2><p>用于判断实例对象和类对象之间的关系<br><code>isinstance()</code>接收两个参数，第一个参数是实例对象，第二个参数是类对象或由类对象组成的元组 。<br>当第二个实参是类对象的时候，如果第一个实参是第二个实参的实例对象，或者第一个实参是第二个实参的子类的实例对象，则返回True。<br>当第二个实参是类对象组成的元组时，如果第一个参是第二个实参中任意一个类对象的实例对象，则返回True。</p><pre><code class="python">#!/usr/bin/python3class A(object):    passclass B(object):    passclass C(object):    passclass D(A):    passclass E(D):    passprint(isinstance(D(), A)) # Trueprint(isinstance(D(), D)) # Trueprint(isinstance(D(), E)) # Falseprint(isinstance(E(), A)) # Trueprint(isinstance(D(), (A, B))) # Trueprint(isinstance(D(), (B, C))) # Falseprint(isinstance(E(), (D, A))) # True</code></pre><pre><code class="python">[root@lyucan ~]# ./23.pyTrueTrueFalseTrueTrueFalseTrue</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类对象的特殊方法__del__()</title>
      <link href="/2018/05/01/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__del__()/"/>
      <url>/2018/05/01/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__del__()/</url>
      
        <content type="html"><![CDATA[<h1 id="类对象的特殊方法-del"><a href="#类对象的特殊方法-del" class="headerlink" title="类对象的特殊方法__del__()"></a>类对象的特殊方法<code>__del__()</code></h1><p>系统会自动销毁不再需要的对象以释放内存。因此，当对象被销毁时通常不需要手动的执行清理工作。但是，当使用我们自己创建的资源时，可能需要执行一些额外的清理工作，例如：如果创建了以一个自定义的类对象来打开一个文件并写入一些数据，可能需要在实例对象被销毁之前关闭该文件。为了执行这些额外的清理工作，可以在自定义的类对象中实现特殊方法<code>__del__()</code>。</p><p>当内存那种的对象被销毁（垃圾回收）之前，会自动调用其对应的特殊方法<code>__del__()</code>。</p><p>当对象的引用计数为0时，对象并不会立刻被销毁（垃圾回收），何时进行垃圾回收是不确定的。因此，特殊方法<code>__del__()</code>何时被调用也是不确定的。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def __del__(self):        print(&#39;__del__()被调用了&#39;)mc = MyClass()del mc</code></pre><pre><code class="python">[root@lyucan ~]# ./27.py__del__()被调用了</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASM安装基本环境配置</title>
      <link href="/2018/04/28/Oracle/ASM%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/04/28/Oracle/ASM%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="ASM安装基本环境配置"><a href="#ASM安装基本环境配置" class="headerlink" title="ASM安装基本环境配置"></a>ASM安装基本环境配置</h1><h2 id="1）安装rpm"><a href="#1）安装rpm" class="headerlink" title="1）安装rpm"></a>1）安装rpm</h2><pre><code class="bash">[root@oracle ~]# yum -y install binutils compat-libcap1 compat-libstdc++-33 compat-libstdc++-33*i686  compat-libstdc++-33 gcc gcc-c++ glibc glibc*.i686 glibc-devel glibc-devel*.i686 ksh libaio libaio*.i686 libaio-devel  libgcc libgcc*.i686 libstdc++ libstdc++*.i686 libstdc++-devel  libXi libXi*.i686 libXtst libXtst*.i686 make sysstat unixODBC unixODBC*.i686 unixODBC-devel unixODBC-devel*.i686 elfutils-libelf-devel unzip[root@oracle ~]# rpm -q binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libaio libaio-devel libgcc libstdc++ libstdc++-devel libXi libXtst make sysstat unixODBC unixODBC-devel</code></pre><h2 id="2）创建用户及用户组"><a href="#2）创建用户及用户组" class="headerlink" title="2）创建用户及用户组"></a>2）创建用户及用户组</h2><pre><code class="bash">[root@localhost ~]# groupadd oinstall[root@localhost ~]# groupadd dba[root@localhost ~]# groupadd asmadmin[root@localhost ~]# groupadd asmoper[root@localhost ~]# groupadd asmdba[root@localhost ~]# useradd -g oinstall -G asmdba,asmadmin,asmoper,dba grid[root@localhost ~]# useradd -g oinstall -G dba,asmdba oracle[root@localhost ~]# passwd grid    ##Grid_1Changing password for user grid.New password:BAD PASSWORD: The password contains the user name in some formRetype new password:passwd: all authentication tokens updated successfully.[root@localhost ~]#[root@localhost ~]#[root@localhost ~]# passwd oracle      ##Oracle_1Changing password for user oracle.New password:BAD PASSWORD: The password contains the user name in some formRetype new password:passwd: all authentication tokens updated successfully.[root@localhost ~]# id griduid=1000(grid) gid=1000(oinstall) groups=1000(oinstall),1001(dba),1002(asmadmin),1003(asmdba)[root@localhost ~]# id oracleuid=1001(oracle) gid=1000(oinstall) groups=1000(oinstall),1001(dba),1003(asmdba)[root@localhost ~]#</code></pre><h2 id="3）修改内核参数"><a href="#3）修改内核参数" class="headerlink" title="3）修改内核参数"></a>3）修改内核参数</h2><pre><code class="bash">[root@oracle ~]# vim /etc/sysctl.conffs.aio-max-nr = 1048576fs.file-max = 6815744 kernel.shmall = 2097152 kernel.shmmax = 4294967295 kernel.shmmni = 4096 kernel.sem = 250 32000 100 128 net.ipv4.ip_local_port_range = 9000 65500net.core.rmem_default = 262144 net.core.rmem_max = 4194304net.core.wmem_default = 262144 net.core.wmem_max = 1048576[root@oracle ~]# sysctl -pfs.aio-max-nr = 1048576fs.file-max = 6815744kernel.shmall = 2097152kernel.shmmax = 4294967295kernel.shmmni = 4096kernel.sem = 250 32000 100 128net.ipv4.ip_local_port_range = 9000 65500net.core.rmem_default = 262144net.core.rmem_max = 4194304net.core.wmem_default = 262144net.core.wmem_max = 1048576</code></pre><h2 id="4）设置oracle、grid用户shell限制"><a href="#4）设置oracle、grid用户shell限制" class="headerlink" title="4）设置oracle、grid用户shell限制"></a>4）设置oracle、grid用户shell限制</h2><pre><code class="bash">[root@oracle ~]# vim /etc/security/limits.conforacle soft nofile 1024oracle hard nofile 65536oracle soft nproc 16384oracle hard nproc 16384oracle soft stack 10240oracle hard stack 32768grid soft nofile 1024grid hard nofile 65536grid soft nproc 16384grid hard nproc 16384grid soft stack 10240grid hard stack 32768</code></pre><h2 id="5）修改vim-etc-pam-d-login文件"><a href="#5）修改vim-etc-pam-d-login文件" class="headerlink" title="5）修改vim &#x2F;etc&#x2F;pam.d&#x2F;login文件"></a>5）修改vim &#x2F;etc&#x2F;pam.d&#x2F;login文件</h2><pre><code class="bash">[root@oracle ~]# vim /etc/pam.d/loginsession required  /lib64/security/pam_limits.sosession required pam_limits.so</code></pre><h2 id="6）修改主机名及hosts文件"><a href="#6）修改主机名及hosts文件" class="headerlink" title="6）修改主机名及hosts文件"></a>6）修改主机名及hosts文件</h2><pre><code class="bash">[root@localhost ~]# vim /etc/hostnameoracle[root@oracle ~]# vim /etc/hosts10.10.10.103 oracle##不要有非常规字符，如&quot;-&quot; &quot;~&quot;等，可以有“_”“#”“$”“.”</code></pre><h2 id="7）配置-etc-profile"><a href="#7）配置-etc-profile" class="headerlink" title="7）配置&#x2F;etc&#x2F;profile"></a>7）配置&#x2F;etc&#x2F;profile</h2><pre><code class="bash">[root@oracle ~]# vim /etc/profileif [ $USER = &quot;oracle&quot; ] || [ $USER = &quot;grid&quot; ] ; then    if [ $SHELL = &quot;/bin/ksh&quot; ]; then        ulimit -p 16384        ulimit -n 65536    else        ulimit -u 16384 -n 65536    fiumask 022fi[root@oracle ~]# source /etc/profile</code></pre><h2 id="8）创建安装目录"><a href="#8）创建安装目录" class="headerlink" title="8）创建安装目录"></a>8）创建安装目录</h2><pre><code class="bash">[root@oracle ~]# mkdir -p /oracle/11g[root@oracle ~]# mkdir -p /oracle/11g/oraInventory[root@oracle ~]# chown -R oracle:oinstall /oracle/11g[root@oracle ~]# chmod -R 775 /oracle/11g[root@oracle ~]# mkdir -p /oracle/grid[root@oracle ~]# mkdir -p /oracle/grid/oraInventory[root@oracle ~]# chown -R grid:oinstall /oracle/grid[root@oracle ~]# chmod -R 775 /oracle/grid</code></pre><h2 id="9）配置oracle、grid用户环境变量"><a href="#9）配置oracle、grid用户环境变量" class="headerlink" title="9）配置oracle、grid用户环境变量"></a>9）配置oracle、grid用户环境变量</h2><pre><code class="bash">##oraclevim /home/oracle/.bash_profileORACLE_BASE=/oracle/11g; export ORACLE_BASEORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1; export ORACLE_HOMEORACLE_SID=orcl; export ORACLE_SIDPATH=$ORACLE_HOME/bin:/usr/sbin:$PATH; export PATHCLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib;LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib;export LD_LIBRARY_PATHTMP=/tmp; export TMPTMPDIR=$TMP; export TMPDIRORACLE_TERM=xterm; export ORACLE_TERM.NLS_LANG=&quot;AMERICAN_AMERICA.AL32UTF8&quot;;export NLS_LANGumask 022##gridvim /home/grid/.bash_profileORACLE_BASE=/oracle/grid; export ORACLE_BASEORACLE_HOME=$ORACLE_BASE/product/11.2.0/grid_home; export ORACLE_HOMEORACLE_SID=+ASM; export ORACLE_SIDPATH=$ORACLE_HOME/bin:/usr/sbin:$PATH; export PATHTMP=/tmp; export TMPTMPDIR=$TMP; export TMPDIR</code></pre><h2 id="10）配置ASM磁盘"><a href="#10）配置ASM磁盘" class="headerlink" title="10）配置ASM磁盘"></a>10）配置ASM磁盘</h2><p>ASM一般使用的是共享存储，那么就会有一个问题就是，每次重启，磁盘的盘符就可能会变化，会导致数据混乱，因此我们需要固定设备名，让其每次重启找到的都是正确的磁盘</p><p>查看磁盘，其中sdb、sdc、sdd是新增的，每块5G</p><pre><code class="bash">[root@oracle ~]# fdisk -l |grep dev/sdDisk /dev/sdd: 5368 MB, 5368709120 bytes, 10485760 sectorsDisk /dev/sda: 53.7 GB, 53687091200 bytes, 104857600 sectors/dev/sda1   *        2048     1026047      512000   83  Linux/dev/sda2         1026048   104857599    51915776   8e  Linux LVMDisk /dev/sdc: 5368 MB, 5368709120 bytes, 10485760 sectorsDisk /dev/sdb: 5368 MB, 5368709120 bytes, 10485760 sectors</code></pre><p>查看scsi_id，如果使用的vmware虚拟机，会返回什么都没有，需要再虚拟机配置文件xxxx.vmx里面加上 disk.EnableUUID &#x3D;”TRUE”</p><pre><code class="bash">[root@oracle ~]# /usr/lib/udev/scsi_id --whitelisted --replace-whitespace /dev/sdb36000c291d5874c3016f6b765844b5228[root@oracle ~]# /usr/lib/udev/scsi_id --whitelisted --replace-whitespace /dev/sdc36000c2977ba75cc607a20a729cc7fde3[root@oracle ~]# /usr/lib/udev/scsi_id --whitelisted --replace-whitespace /dev/sdd36000c29c3a13498e34697ea5388c88f7</code></pre><pre><code class="bash">for i in b c d e f g hdoecho &quot;KERNEL==\&quot;sd?\&quot;, SUBSYSTEM==\&quot;block\&quot;,PROGRAM=\&quot;/lib/udev/scsi_id --whitelisted --replace-whitespace /dev/\$name\&quot;, RESULT==\&quot;`/usr/lib/udev/scsi_id --whitelisted --replace-whitespace /dev/sd$i`\&quot;, SYMLINK+=\&quot;asm-disk-sd$i\&quot;,OWNER=\&quot;grid\&quot;,GROUP=\&quot;asmadmin\&quot;,MODE=\&quot;0660\&quot;&quot;done</code></pre><p>配置udev策略</p><pre><code class="bash">[root@oracle ~]# vim /usr/lib/udev/rules.d/99-oracle-asm-disk.rulesKERNEL==&quot;sd?&quot;, SUBSYSTEM==&quot;block&quot;, PROGRAM=&quot;/lib/udev/scsi_id --whitelisted --replace-whitespace /dev/$name&quot;, RESULT==&quot;36000c291d5874c3016f6b765844b5228&quot;, SYMLINK+=&quot;asm-disk-1&quot;, OWNER==&quot;grid&quot;, GROUP==&quot;asmadmin&quot;, MODE=&quot;0660&quot;KERNEL==&quot;sd?&quot;, SUBSYSTEM==&quot;block&quot;, PROGRAM=&quot;/lib/udev/scsi_id --whitelisted --replace-whitespace /dev/$name&quot;, RESULT==&quot;36000c2977ba75cc607a20a729cc7fde3&quot;, SYMLINK+=&quot;asm-disk-2&quot;, OWNER==&quot;grid&quot;, GROUP==&quot;asmadmin&quot;, MODE=&quot;0660&quot;KERNEL==&quot;sd?&quot;, SUBSYSTEM==&quot;block&quot;, PROGRAM=&quot;/lib/udev/scsi_id --whitelisted --replace-whitespace /dev/$name&quot;, RESULT==&quot;36000c29c3a13498e34697ea5388c88f7&quot;, SYMLINK+=&quot;asm-disk-3&quot;, OWNER==&quot;grid&quot;, GROUP==&quot;asmadmin&quot;, MODE=&quot;0660&quot;</code></pre><p>加载udev策略</p><pre><code class="bash">[root@oracle ~]# /sbin/udevadm control --reload[root@oracle ~]# /sbin/udevadm trigger --type=devices --action=change</code></pre><p>查看是否生效及权限是否正确</p><pre><code class="bash">[root@oracle ~]# ll /dev/asm-disk-*lrwxrwxrwx. 1 root root 3 May 25 17:32 /dev/asm-disk-1 -&gt; sdblrwxrwxrwx. 1 root root 3 May 25 17:32 /dev/asm-disk-2 -&gt; sdclrwxrwxrwx. 1 root root 3 May 25 17:32 /dev/asm-disk-3 -&gt; sdd[root@oracle ~]# ll /dev/sd[b,c,d]brw-rw----. 1 grid asmadmin 8, 16 May 25 17:32 /dev/sdbbrw-rw----. 1 grid asmadmin 8, 32 May 25 17:32 /dev/sdcbrw-rw----. 1 grid asmadmin 8, 48 May 25 17:32 /dev/sdd</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-MRO（方法解析顺序）</title>
      <link href="/2018/04/27/Python/Python-MRO%EF%BC%88%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F%EF%BC%89/"/>
      <url>/2018/04/27/Python/Python-MRO%EF%BC%88%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="MRO（方法解析顺序）"><a href="#MRO（方法解析顺序）" class="headerlink" title="MRO（方法解析顺序）"></a>MRO（方法解析顺序）</h1><p>指的是，对一颗类继承树，当调用最底层类对象所对应实例对象的方法时，python解释器在类继承树上搜索方法的顺序。</p><p>对于一颗类继承树，有两种方式获取类继承树的MRO<br>1、使用mro()方法<br>2、使用特殊属性__mro__</p><pre><code class="python">#!/usr/bin/python3class A(object):    def func(self):        print(&#39;A.func&#39;)class B(A):    def func(self):        print(&#39;B.func&#39;)class C(A):    def func(self):        print(&#39;C.func&#39;)class D(B, C):    def func(slef):        print(&#39;D.func&#39;)print(D.mro())print(D.__mro__)print(C.__mro__)print(B.__mro__)print(A.__mro__)</code></pre><pre><code class="python">[root@lyucan ~]# ./16.py[&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;]  #列表(&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)  #元组(&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)(&lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)(&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><p>当向上搜索方法时（无论是重写了的方法还是没有重写的方法），会根据MRO的顺序来进行搜索，例如：如果D没有func()方法， 则会去找B，B没有则会找C，会依次根据MRO去向上寻找，直到找到为止，如果最后object类也没有，则抛出异常。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL备份-mysqldump</title>
      <link href="/2018/04/23/Mysql/MySQL%E5%A4%87%E4%BB%BD-mysqldump/"/>
      <url>/2018/04/23/Mysql/MySQL%E5%A4%87%E4%BB%BD-mysqldump/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql备份-mysqldump"><a href="#Mysql备份-mysqldump" class="headerlink" title="Mysql备份-mysqldump"></a>Mysql备份-mysqldump</h1><p>使用mysqldump对MySQL进行备份，备份少量数据可以使用这种方法，大量数据备份和恢复否会消耗大量的时间；</p><p>mysqldump可以导出存储过程，触发器，事件，数据，但是不能导出视图，如果数据库中有视图，备份完成后还需要导出视图的定义，或者备份视图定义的frm文件，并在恢复时导入；</p><span id="more"></span><h1 id="备份基本语法"><a href="#备份基本语法" class="headerlink" title="备份基本语法"></a>备份基本语法</h1><ul><li>备份单个数据或单个数据中的指定表：</li></ul><pre><code>mysqldump [OPTIONS] database [tb1] [tb2]… &gt; TB_BACKFILE</code></pre><ul><li>备份多个数据库：</li></ul><pre><code>mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...] &gt; DB_BACKFILE</code></pre><ul><li>备份所有数据库：</li></ul><pre><code>mysqldump [OPTIONS] --all-databases [OPTIONS] &gt; ALL_DB_BACKFILE</code></pre><ul><li>例如一个标准的备份语句：</li></ul><pre><code>mysqldump --single-transaction -uroot -p -B -F -R database1 t1 &gt; t1_20180407.sql</code></pre><h1 id="恢复基本语法"><a href="#恢复基本语法" class="headerlink" title="恢复基本语法"></a>恢复基本语法</h1><pre><code>mysql -uxxx -pxxx &lt; BACKFILE       ##注意是mysql 而不是mysqldump</code></pre><p>或者连到mysql数据库里面，source BACKFILE</p><p>恢复表时，需要指定表所在的数据库；</p><pre><code>mysql -uxxx -pxxx DATABASE &lt; TABLE_BACKFILE</code></pre><p><code>--single-transaction</code>（强烈建议加上）</p><p>该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于InnoDB存储引擎。本选项和<code>--lock-tables</code> 选项是互斥的，因为LOCK  TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用<code>--quick</code> 选项。</p><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --single-transaction</code></pre><h1 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h1><ul><li>--default-character-set： 设置字符集</li><li>--single-transaction：将导出设置成事务</li><li>--no-data：导出的SQL脚本中，将只包含创建表的create 语句。</li><li>--add-drop-table：导出的脚本中，包含 drop table if exists</li><li>--routines：导出存储过程及函数</li><li>--events：导出事件</li><li>--triggers：导出触发器</li></ul><h1 id="备份选项-OPTIONS-说明"><a href="#备份选项-OPTIONS-说明" class="headerlink" title="备份选项[OPTIONS]说明"></a>备份选项[OPTIONS]说明</h1><ul><li>--all-databases  , -A<br>导出全部数据库。</li></ul><pre><code>mysqldump  -uroot -p --all-databases</code></pre><ul><li>--all-tablespaces  , -Y<br>导出全部表空间。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --all-tablespaces</code></pre><ul><li>--no-tablespaces  , -y<br>不导出任何表空间信息。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --no-tablespaces</code></pre><ul><li>--add-drop-database<br>每个数据库创建之前添加drop数据库语句。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --add-drop-database</code></pre><ul><li>--add-drop-table<br>每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用<code>--skip-add-drop-table</code>取消选项)</li></ul><pre><code>mysqldump  -uroot -p --all-databases  (默认添加drop语句)mysqldump  -uroot -p --all-databases –skip-add-drop-table  (取消drop语句)</code></pre><ul><li>--add-locks<br>在每个表导出之前增加LOCK TABLES并且之后UNLOCK  TABLE。(默认为打开状态，使用–skip-add-locks取消选项)</li></ul><pre><code>mysqldump  -uroot -p --all-databases  (默认添加LOCK语句)mysqldump  -uroot -p --all-databases –skip-add-locks   (取消LOCK语句)</code></pre><ul><li>--allow-keywords<br>允许创建是关键词的列名字。这由表名前缀于每个列名做到。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --allow-keywords</code></pre><ul><li>--apply-slave-statements<br>在’CHANGE MASTER’前添加’STOP SLAVE’，并且在导出的最后添加’START SLAVE’。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --apply-slave-statements</code></pre><ul><li>--character-sets-dir<br>字符集文件的目录</li></ul><pre><code>mysqldump  -uroot -p --all-databases  --character-sets-dir=/usr/local/mysql/share/mysql/charsets</code></pre><ul><li>--comments<br>附加注释信息。默认为打开，可以用–skip-comments取消</li></ul><pre><code>mysqldump  -uroot -p --all-databases  (默认记录注释)mysqldump  -uroot -p --all-databases --skip-comments   (取消注释)</code></pre><ul><li>--compatible<br>导出的数据将和其它数据库或旧版本的MySQL 相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，<br>要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --compatible=ansi</code></pre><ul><li>--compact<br>导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：<code>--skip-add-drop-table</code>  <code>--skip-add-locks</code> <code>--skip-comments</code> <code>--skip-disable-keys</code></li></ul><pre><code>mysqldump  -uroot -p --all-databases --compact</code></pre><ul><li>--complete-insert,  -c<br>使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到<code>max_allowed_packet</code>参数的影响而导致插入失败。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --complete-insert</code></pre><ul><li>--compress, -C<br>在客户端和服务器之间启用压缩传递所有信息</li></ul><pre><code>mysqldump  -uroot -p --all-databases --compress</code></pre><ul><li>--create-options,  -a<br>在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)</li></ul><pre><code>mysqldump  -uroot -p --all-databases</code></pre><ul><li>--databases,  -B<br>导出几个数据库。参数后面所有名字参量都被看作数据库名。</li></ul><pre><code>mysqldump  -uroot -p --databases test mysql</code></pre><ul><li>--debug<br>输出debug信息，用于调试。默认值为：d:t:o,&#x2F;tmp&#x2F;mysqldump.trace</li></ul><pre><code>mysqldump  -uroot -p --all-databases --debugmysqldump  -uroot -p --all-databases --debug=” d:t:o,/tmp/debug.trace”</code></pre><ul><li>--debug-check<br>检查内存和打开文件使用说明并退出。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --debug-check</code></pre><ul><li>--debug-info<br>输出调试信息并退出</li></ul><pre><code>mysqldump  -uroot -p --all-databases --debug-info</code></pre><ul><li>--default-character-set<br>设置默认字符集，默认值为utf8</li></ul><pre><code>mysqldump  -uroot -p --all-databases --default-character-set=latin1</code></pre><ul><li>--delayed-insert<br>采用延时插入方式（INSERT DELAYED）导出数据</li></ul><pre><code>mysqldump  -uroot -p --all-databases --delayed-insert</code></pre><ul><li>--delete-master-logs<br>master备份后删除日志. 这个参数将自动激活–master-data。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --delete-master-logs</code></pre><ul><li>--disable-keys<br>对于每个表，用<code>ALTER TABLE tbl_name DISABLE KEYS;</code>和<code>ALTER TABLE tbl_name ENABLE KEYS;</code>语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。</li></ul><pre><code>mysqldump  -uroot -p --all-databases</code></pre><ul><li>--dump-slave<br>该选项将导致主的binlog位置和文件名追加到导出数据的文件中。设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，在命令前增加说明信息。该选项将会打开<code>--lock-all-tables</code>，除非<code>--single-transaction</code>被指定。该选项会自动关闭<code>--lock-tables</code>选项。默认值为0。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --dump-slave=1mysqldump  -uroot -p --all-databases --dump-slave=2</code></pre><ul><li>--events, -E<br>导出事件。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --events</code></pre><ul><li>--extended-insert,  -e<br>使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用–skip-extended-insert取消选项。</li></ul><pre><code>mysqldump  -uroot -p --all-databasesmysqldump  -uroot -p --all-databases--skip-extended-insert   (取消选项)</code></pre><ul><li>--fields-terminated-by<br>导出文件中忽略给定字段。与–tab选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项</li></ul><pre><code>mysqldump  -uroot -p test test --tab=”/home/mysql” --fields-terminated-by=”#”</code></pre><ul><li>--fields-enclosed-by<br>输出文件中的各个字段用给定字符包裹。与<code>--tab</code>选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项</li></ul><pre><code>mysqldump  -uroot -p test test --tab=”/home/mysql” --fields-enclosed-by=”#”</code></pre><ul><li>--fields-optionally-enclosed-by<br>输出文件中的各个字段用给定字符选择性包裹。与<code>--tab</code>选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项</li></ul><pre><code>mysqldump  -uroot -p test test --tab=”/home/mysql”  --fields-enclosed-by=”#” --fields-optionally-enclosed-by  =”#”</code></pre><ul><li>--fields-escaped-by<br>输出文件中的各个字段忽略给定字符。与<code>--tab</code>选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项</li></ul><pre><code>mysqldump  -uroot -p mysql user --tab=”/home/mysql” --fields-escaped-by=”#”</code></pre><ul><li>--flush-logs -F<br>开始导出之前刷新日志。<br>请注意：假如一次导出多个数据库(使用选项–databases或者–all-databases)，将会逐个数据库刷新日志。除使用–lock-all-tables或者–master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用–lock-all-tables 或者–master-data 和–flush-logs。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --flush-logs</code></pre><ul><li>--flush-privileges<br>在导出mysql数据库之后，发出一条FLUSH  PRIVILEGES 语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --flush-privileges</code></pre><ul><li>--force<br>在导出过程中忽略出现的SQL错误。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --force</code></pre><ul><li>--help<br>显示帮助信息并退出。</li></ul><pre><code>mysqldump  --help</code></pre><ul><li>--hex-blob<br>使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --hex-blob</code></pre><ul><li>--host, -h<br>需要导出的主机信息</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre><ul><li>--ignore-table<br>不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：<code>--ignore-table=database.table1</code> <code>--ignore-table=database.table2</code> ……</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --ignore-table=mysql.user</code></pre><ul><li>--include-master-host-port<br>在<code>--dump-slave</code>产生的<code>CHANGE  MASTER TO..</code>语句中增加<code>MASTER_HOST=&lt;host&gt;，MASTER_PORT=&lt;port&gt;</code></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --include-master-host-port</code></pre><ul><li>--insert-ignore<br>在插入行时使用INSERT IGNORE语句.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --insert-ignore</code></pre><ul><li>--lines-terminated-by<br>输出文件的每行用给定字符串划分。与–tab选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost test test --tab=”/tmp/mysql”  --lines-terminated-by=”##”</code></pre><ul><li>--lock-all-tables,  -x<br>提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭<code>--single-transaction</code> 和<code>--lock-tables</code> 选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --lock-all-tables</code></pre><ul><li>--lock-tables,  -l<br>开始导出前，锁定所有表。用READ  LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，<code>--single-transaction</code>是一个更好的选择，因为它根本不需要锁定表。<br>请注意当导出多个数据库时，–lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --lock-tables</code></pre><ul><li>--log-error<br>附加警告和错误信息到给定文件</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases  --log-error=/tmp/mysqldump_error_log.err</code></pre><ul><li>--master-data<br>该选项将binlog的位置和文件名追加到输出文件中。如果为1，将会输出CHANGE MASTER 命令；如果为2，输出的CHANGE  MASTER命令前添加注释信息。该选项将打开<code>--lock-all-tables</code> 选项，除非<code>--single-transaction</code>也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的<code>--single-transaction</code>选项）。该选项自动关闭<code>--lock-tables</code>选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --master-data=1;mysqldump  -uroot -p --host=localhost --all-databases --master-data=2;</code></pre><ul><li>--max_allowed_packet<br>服务器发送和接受的最大包长度。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --max_allowed_packet=10240</code></pre><ul><li>--net_buffer_length<br>TCP&#x2F;IP和socket连接的缓存大小。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --net_buffer_length=1024</code></pre><ul><li>--no-autocommit<br>使用autocommit&#x2F;commit 语句包裹表。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-autocommit</code></pre><ul><li>--no-create-db,  -n<br>只导出数据，而不添加CREATE DATABASE 语句。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-create-db</code></pre><ul><li>--no-create-info,  -t<br>只导出数据，而不添加CREATE TABLE 语句。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-create-info</code></pre><ul><li>--no-data, -d<br>不导出任何数据，只导出数据库表结构。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-data</code></pre><ul><li>--no-set-names,  -N<br>等同于<code>--skip-set-charset</code></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-set-names</code></pre><ul><li>--opt<br>等同于<code>--add-drop-table</code>,  <code>--add-locks</code>, <code>--create-options</code>, <code>--quick</code>, <code>--extended-insert</code>, <code>--lock-tables</code>,  <code>--set-charset</code>, <code>--disable-keys</code> 该选项默认开启,  可以用<code>--skip-opt</code>禁用.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --opt</code></pre><ul><li>--order-by-primary<br>如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --order-by-primary</code></pre><ul><li>--password, -p<br>连接数据库密码，使用命名管道连接mysql</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --pipe</code></pre><ul><li><p>--port, -P<br>连接数据库端口号</p></li><li><p>--protocol<br>使用的连接协议，包括：tcp, socket, pipe, memory.</p></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --protocol=tcp</code></pre><ul><li>--quick, -q<br>不缓冲查询，直接导出到标准输出。默认为打开状态，使用<code>--skip-quick</code>取消该选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-quick</code></pre><ul><li>--quote-names,-Q<br>使用（&#96;）引起表和列名。默认为打开状态，使用–skip-quote-names取消该选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-quote-names</code></pre><ul><li>--replace<br>使用REPLACE INTO 取代INSERT INTO.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --replace</code></pre><ul><li>--result-file,  -r<br>直接输出到指定文件中。该选项应该用在使用回车换行对（\r\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --result-file=/tmp/mysqldump_result_file.txt</code></pre><ul><li>--routines, -R<br>导出存储过程以及自定义函数。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --routines</code></pre><ul><li>--set-charset<br>添加<code>SET NAMES  default_character_set</code>到输出文件。默认为打开状态，使用<code>--skip-set-charset</code>关闭选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-set-charset</code></pre><ul><li>--single-transaction（强烈建议加上）<br>该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于InnoDB存储引擎。本选项和<code>--lock-tables</code> 选项是互斥的，因为LOCK  TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用<code>--quick</code> 选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --single-transaction</code></pre><ul><li>--dump-date<br>将导出时间添加到输出文件中。默认为打开状态，使用–skip-dump-date关闭选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-dump-date</code></pre><ul><li>--skip-opt<br>禁用–opt选项.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --skip-opt</code></pre><ul><li>--socket,-S<br>指定连接mysql的socket文件位置，默认路径<code>/tmp/mysql.sock</code></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --socket=/tmp/mysqld.sock</code></pre><ul><li>--tab,-T<br>为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost test test --tab=&quot;/home/mysql&quot;</code></pre><ul><li>--tables<br>覆盖<code>--databases (-B)</code>参数，指定需要导出的表名。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --databases test --tables test</code></pre><ul><li>--triggers<br>导出触发器。该选项默认启用，用–skip-triggers禁用它。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --triggers</code></pre><ul><li>--tz-utc<br>在导出顶部设置时区<code>TIME_ZONE=&#39;+00:00&#39;</code> ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --tz-utc</code></pre><ul><li><p>--user, -u<br>指定连接的用户名。</p></li><li><p>--verbose, –v<br>输出多种平台信息。</p></li><li><p>--version, -V<br>输出mysqldump版本信息并退出</p></li><li><p>--where, -w<br>只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。</p></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --where=&quot;user=&#39;root&#39;&quot;</code></pre><ul><li>--xml, -X<br>导出XML格式.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --xml</code></pre><ul><li>--plugin_dir<br>客户端插件的目录，用于兼容不同的插件版本。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --plugin_dir=”/usr/local/lib/plugin”</code></pre><ul><li>--default_auth<br>客户端插件默认使用权限。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --default-auth=”/usr/local/lib/plugin/&lt;PLUGIN&gt;”</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-列表</title>
      <link href="/2018/04/23/Python/Python-%E5%88%97%E8%A1%A8/"/>
      <url>/2018/04/23/Python/Python-%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表相当于其他编程语言中的数组</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>列表中所有数据是按顺序有序排列的；</li><li>列表中的所有数据都有两个整数类型的索引，通过指定的索引总能映射到唯一的数据；（正向0到n，反向-1到-n）；</li><li>列表中可以存在重复的数据；</li><li>列表中可以保存任何类型的数据，多种类型的数据可以混合存储在一个列表中；</li><li>列表可以根据需要动态伸缩，也就是说，系统会根据需要动态的分配和回收内存，在使用前无需先声明列表的容量；</li></ul><h2 id="列表的创建："><a href="#列表的创建：" class="headerlink" title="列表的创建："></a>列表的创建：</h2><p>1、使用中括号</p><pre><code class="python">&gt;&gt;&gt; L = [&#39;Python&#39;, 19, True, None]&gt;&gt;&gt; L[&#39;Python&#39;, 19, True, None]</code></pre><p>2、调用内置函数list</p><pre><code class="python">&gt;&gt;&gt; L = list(range(6))&gt;&gt;&gt; L[0, 1, 2, 3, 4, 5]</code></pre><p>只能传递一个参数，列表元素需要用<code>[]</code>&#x2F;<code>()</code>&#x2F;<code>&#123;&#125;</code>括起来</p><pre><code class="python">&gt;&gt;&gt; list(1, 2, 3)                                      Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: list expected at most 1 arguments, got 3</code></pre><pre><code class="python">&gt;&gt;&gt; L1 = list([1, 2, 3])&gt;&gt;&gt; L1[1, 2, 3]</code></pre><pre><code class="python">&gt;&gt;&gt; L2 = list((1, 2, 3))&gt;&gt;&gt; L2[1, 2, 3]</code></pre><pre><code class="python">&gt;&gt;&gt; L3 = list(&#123;1, 2, 3&#125;)&gt;&gt;&gt; L3[1, 2, 3]</code></pre><h2 id="获取索引"><a href="#获取索引" class="headerlink" title="获取索引"></a>获取索引</h2><p>查询列表中的元素的索引，如果有重复相同的元素，则返回第一个元素的索引号，通过<code>index()</code>方法查询</p><pre><code class="python">&gt;&gt;&gt; L = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;b&#39;]&gt;&gt;&gt;&gt;&gt;&gt; L.index(&#39;a&#39;)0&gt;&gt;&gt;&gt;&gt;&gt; L.index(&#39;b&#39;)             ##最后还有一个&#39;b&#39;，返回的是第一个&#39;b&#39;1&gt;&gt;&gt; L.index(&#39;c&#39;)2&gt;&gt;&gt; L.index(&#39;c&#39;, -5, -2)2</code></pre><p><code>index()</code>方法还可以指定起始索引和结束索引两个参数，但是如果只传其中一个参数，那么只能传起始索引，不能传结束索引，<code>start</code>、<code>stop</code>同样也是左闭右开</p><pre><code class="python">&gt;&gt;&gt; L[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;b&#39;]&gt;&gt;&gt; L.index(&#39;c&#39;, 1, 2)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: &#39;c&#39; is not in list&gt;&gt;&gt; L.index(&#39;c&#39;, 2, 3)2</code></pre><p>通过索引查询列表中的元素，一次只能获得一个元素</p><pre><code class="python">&gt;&gt;&gt; L = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;b&#39;]&gt;&gt;&gt;&gt;&gt;&gt; L[0]&#39;a&#39;&gt;&gt;&gt; L[5]&#39;b&#39;&gt;&gt;&gt; L[6]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range&gt;&gt;&gt; L[-5]&#39;b&#39;&gt;&gt;&gt; L[-6]&#39;a&#39;&gt;&gt;&gt;&gt;&gt;&gt; L[-7]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range</code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片获取列表中的元素，一次获取多个元素<br>切片语法格式：<code>[start, stop, step]</code><br>切片不包括索引为<code>stop</code>的元素，左闭右开<br>如果不指定<code>step</code>，则默认为<code>1</code>，此时语法可以简化为<code>[start, stop]</code><br>当step为正数时：</p><ul><li>如果不指定start，切片的第一个元素默认是列表的第一个元素。</li><li>如果不指定stop，切片的最后一个元素默认是列表的最后一个元素。</li><li>从索引start开始往后进行切片计算</li></ul><p>当step为负数时：</p><ul><li>如果不指定start，切片的第一个元素默认是列表的最后一个元素。</li><li>如果不指定stop，切片的最后一个元素默认是列表的第一个元素。</li><li>从索引start开始往前进行切片计算</li></ul><p>切片操作十分有用。我们先创建一个0-99的数列：</p><pre><code class="python">&gt;&gt;&gt; L = list(range(100)) &gt;&gt;&gt; L [0, 1, 2, 3, ..., 99]</code></pre><p>可以通过切片轻松取出某一段数列。<br>前10个数：</p><pre><code class="python">&gt;&gt;&gt; L[:10] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>后10个数：</p><pre><code class="python">&gt;&gt;&gt; L[-10:] [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</code></pre><pre><code class="python">&gt;&gt;&gt; L[-10:-1]            [90, 91, 92, 93, 94, 95, 96, 97, 98]</code></pre><blockquote><p>需要注意的是，当想要切出从倒数第一个元素到倒数第2个元素的时候，不能使用[-2 : -1]，因为[-2 : -1]并不包括-1，而是包括-2，如果需要切出倒数第一个到倒数第二个，需要使用[-2 : ]，后面不能跟-1。</p></blockquote><p>前11-20个数：</p><pre><code class="python">&gt;&gt;&gt; L[10:20] [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</code></pre><p>前10个数，每两个取一个：</p><pre><code class="python">&gt;&gt;&gt; L[:10:2] [0, 2, 4, 6, 8]</code></pre><p>所有数，每5个取一个：</p><pre><code class="python">&gt;&gt;&gt; L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</code></pre><p>甚至什么都不写，只写[:]就可以原样复制一个list：</p><pre><code class="python">&gt;&gt;&gt; L[:] [0, 1, 2, 3, ..., 99]&gt;&gt;&gt; L[：:] [0, 1, 2, 3, ..., 99]</code></pre><p><strong>步长为负数的情况</strong></p><pre><code class="python">&gt;&gt;&gt; L[::-1]                         ##可用于反转列表[99, 98, 97, 96, ..., 0]</code></pre><p>从50往前切片，到30</p><pre><code class="python">&gt;&gt;&gt; L[50:30:-2][50, 48, 46, 44, 42, 40, 38, 36, 34, 32]</code></pre><p>因为step为负数，因此只能往前切片，所以stop为100切不到，返回空列表</p><pre><code class="python">&gt;&gt;&gt; L[50:100:-2][]</code></pre><p>切片操作是允许索引越界的，就是说，超出索引的范围，仍可以进行切片操作</p><pre><code class="python">&gt;&gt;&gt; L[:200:2][0, 2, 4, 6, ..., 98]&gt;&gt;&gt; L[:-200:-2][99, 97, 95, 93, ..., 1]</code></pre><p>切片还有一种内置函数可以调用，就是slice()内置函数，其有三种调用方式</p><ol><li>slice(stop)</li><li>slice(start, stop)</li><li>slice(start, stop, step)</li></ol><p>start、stop、step的默认值都是None。<br>slice(start, stop, step)与切片的start, stop, step是等价的。</p><p>slice()返回的是一个切片对象，可以赋值给变量，再使用变量来进行切片，例如：</p><pre><code class="python">&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt;&gt;&gt;&gt; myslice = slice(10, 20, 2)&gt;&gt;&gt;&gt;&gt;&gt; mysliceslice(10, 20, 2)&gt;&gt;&gt;&gt;&gt;&gt; L[myslice]                    ##这里是[]而不是()[10, 12, 14, 16, 18]</code></pre><p>使用in关键字判断列表中是否存在元素，存在返回True，不存在返回False，例如：</p><pre><code class="python">&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; 10 in LTrue&gt;&gt;&gt; 200 in LFalse</code></pre><p><code>tuple</code>也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</p><pre><code class="python">&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2)</code></pre><p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作（但是不能修改，字符串是不可变对象），只是操作结果仍是字符串：</p><pre><code class="python">&gt;&gt;&gt; &#39;ABCDEFG&#39;[:3]&#39;ABC&#39;&gt;&gt;&gt; &#39;ABCDEFG&#39;[::2]&#39;ACEG&#39;</code></pre><h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><p>有两种常用方式：<br>1、为指定元素赋一个新值（一次只能修改一个元素）</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; L[2] = &#39;a&#39;&gt;&gt;&gt; L[1, 2, &#39;a&#39;, 4, 5]</code></pre><p>2、为指定的切片赋一个新值（一次至少修改一个元素），等号左右的元素个数可以不同，赋的值必须也是一个列表</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; L[1:4] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&gt;&gt;&gt; L[1, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 5]&gt;&gt;&gt; L[1:4] = [&#39;OK&#39;]&gt;&gt;&gt; L[1, &#39;OK&#39;, 5]</code></pre><blockquote><p><strong>特殊情况，字符串也可以当作一个列表，因为没有用[]括起来，所以不会修改为’ok’整个字符串</strong></p></blockquote><pre><code class="python">&gt;&gt;&gt; L[:2] = &#39;ok&#39;&gt;&gt;&gt; L[&#39;o&#39;, &#39;k&#39;, 5]</code></pre><h2 id="添加元素（append-、extend-、insert-、给指定的切片赋一个新值）"><a href="#添加元素（append-、extend-、insert-、给指定的切片赋一个新值）" class="headerlink" title="添加元素（append()、extend()、insert()、给指定的切片赋一个新值）"></a>添加元素（append()、extend()、insert()、给指定的切片赋一个新值）</h2><p>1、append方法，在列表末尾添加新的对象</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3]&gt;&gt;&gt; L.append(6)&gt;&gt;&gt; L[1, 2, 3, 6]&gt;&gt;&gt; L.append([7, 8])&gt;&gt;&gt; L[1, 2, 3, 6, [7, 8]]</code></pre><p>2、extend()方法，在列表末尾一次性追加另一个序列的多个值，用新序列扩展原来的列表</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3]&gt;&gt;&gt; L.extend([4, 5, 6])&gt;&gt;&gt; L[1, 2, 3, 4, 5, 6]</code></pre><p>3、insert()方法，在列表的任意位置添加元素，一次只能添加一个元素，原来该位置后的元素依次向后移一个位置</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3]&gt;&gt;&gt; L.insert(1, &#39;a&#39;)&gt;&gt;&gt; L[1, &#39;a&#39;, 2, 3]&gt;&gt;&gt; L.insert(1, &#39;a&#39;, &#39;b&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: insert() takes exactly 2 arguments (3 given)</code></pre><p>4、为指定的切片赋一个新值，在列表的任意位置添加元素，一次可以添加多个元素，原来该位置后的元素依次向后移一个位置，（extend只能在列表末尾添加）</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3]&gt;&gt;&gt; L[1:1] = &#39;a&#39;&gt;&gt;&gt; L[1, &#39;a&#39;, 2, 3]&gt;&gt;&gt; L[2:2] = [&#39;b&#39;, &#39;c&#39;]&gt;&gt;&gt; L[1, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 2, 3]</code></pre><h2 id="删除元素（remove-、pop-、del关键字、给指定的切片赋值一个空列表、clear-）"><a href="#删除元素（remove-、pop-、del关键字、给指定的切片赋值一个空列表、clear-）" class="headerlink" title="删除元素（remove()、pop()、del关键字、给指定的切片赋值一个空列表、clear()）"></a>删除元素（remove()、pop()、del关键字、给指定的切片赋值一个空列表、clear()）</h2><p>1、remove()方法，一次只删除一个元素。删除元素后面的元素依次向前移动一个位置</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; L.remove(2)                      ##参数是元素，而不是元素索引&gt;&gt;&gt; L[1, 3, 4, 5]</code></pre><p>如果列表中存在多个指定元素，只删除第一个指定的元素</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 2, 1]&gt;&gt;&gt; L.remove(2)&gt;&gt;&gt; L[1, 3, 2, 1]</code></pre><p>2、pop()方法，一次只删除一个指定索引的元素，该方法并返回该被删除元素，如果不指定索引，则默认是最后一个元素的索引</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; L.pop(2)                       ##参数是元素的索引3&gt;&gt;&gt; L = [1, 2, 4, 5]&gt;&gt;&gt; L.pop()5&gt;&gt;&gt; L[1, 2, 4]</code></pre><p>3、del关键字，一次至少删除一个元素</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; del L[2]&gt;&gt;&gt; L[1, 2, 4, 5]&gt;&gt;&gt; del L[:2]           ##删除指定切片&gt;&gt;&gt; L[4, 5]</code></pre><p>4、给指定的切片赋值一个空列表</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; L[1:3] = []&gt;&gt;&gt; L[1, 4, 5]</code></pre><h2 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h2><pre><code class="python">&gt;&gt;&gt; L[:] = []          使用这种方法清空列表，该对象是不变的，如果直接使用L = []赋予一个空列表，该对象是不同的&gt;&gt;&gt; L[]&gt;&gt;&gt; L = [1, 2, 3]         &gt;&gt;&gt; id(L)140438784964680&gt;&gt;&gt;&gt;&gt;&gt; L[:] = []                      ##内存地址不变&gt;&gt;&gt; id(L)140438784964680&gt;&gt;&gt; L = [1, 2, 3]&gt;&gt;&gt; id(L)140438784964680&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; L = []                         ##内存地址发生了变化&gt;&gt;&gt; id(L)140438784966152</code></pre><p><code>clear()</code>方法，清空列表，对象也是不变的</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; id(L)140438784966152&gt;&gt;&gt;&gt;&gt;&gt; L.clear()&gt;&gt;&gt;&gt;&gt;&gt; L[]&gt;&gt;&gt; id(L)140438784966152</code></pre><h2 id="列表反转"><a href="#列表反转" class="headerlink" title="列表反转"></a>列表反转</h2><p>1、reverse()方法</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3]&gt;&gt;&gt; L.reverse()&gt;&gt;&gt; L[3, 2, 1]</code></pre><p>2、内置函数reversed()，返回的是一个迭代器对象，原列表不变</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; iter = reversed(L)&gt;&gt;&gt; iter&lt;list_reverseiterator object at 0x7f4488635f98&gt;&gt;&gt;&gt; list(iter)[5, 4, 3, 2, 1]&gt;&gt;&gt; L[1, 2, 3, 4, 5]</code></pre><p>3、使用列表切片反转</p><pre><code class="python">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]&gt;&gt;&gt; L[::-1][5, 4, 3, 2, 1]</code></pre><h2 id="列表统计元素"><a href="#列表统计元素" class="headerlink" title="列表统计元素"></a>列表统计元素</h2><p>1、<code>count()</code>方法，统计元素在列表中出现的次数</p><pre><code class="python">&gt;&gt;&gt; L = [3, 2, 3, 4, 8, 1, 4, 1, 4]&gt;&gt;&gt; L.count(3)2&gt;&gt;&gt; L.count(1)2&gt;&gt;&gt; L.count(4)3</code></pre><h2 id="列表排序元素"><a href="#列表排序元素" class="headerlink" title="列表排序元素"></a>列表排序元素</h2><p>1、<code>sort()</code>方法，默认从小到大排序，指定<code>reverse = True</code>后，从大到小排序</p><pre><code class="python">&gt;&gt;&gt; L = [3, 2, 3, 4, 8, 1]&gt;&gt;&gt; L.sort()&gt;&gt;&gt; L[1, 2, 3, 3, 4, 8]&gt;&gt;&gt; L = [3, 2, 3, 4, 8, 1]&gt;&gt;&gt; L.sort(reverse = True)&gt;&gt;&gt; L[8, 4, 3, 3, 2, 1]</code></pre><p>2、内置函数sorted()，返回值是排序后的新列表，被排序的列表不发生变化，同样可以使用reverse进行逆序排序</p><pre><code class="python">&gt;&gt;&gt; L = [3, 2, 3, 4, 8, 1]&gt;&gt;&gt; sorted(L)[1, 2, 3, 3, 4, 8]&gt;&gt;&gt; L[3, 2, 3, 4, 8, 1]&gt;&gt;&gt; sorted(L, reverse = True)[8, 4, 3, 3, 2, 1]</code></pre><p>3、调用内置函数<code>sorted()</code>时，还可以指定参数<code>key = 函数名</code>，或者<code>key = 类名.方法名</code>，这样会对列表中的所有元素分别调用指定的函数或方法，然后按照函数或方法的返回值进行排序，从而自定义排序规则</p><pre><code class="python">&gt;&gt;&gt; s = [&#39;python&#39;, &#39;java&#39;, &#39;php&#39;]&gt;&gt;&gt; sorted(s, key = len)[&#39;php&#39;, &#39;java&#39;, &#39;python&#39;]</code></pre><p>4、同样的使用方法<code>sort()</code>的时候，也可以按照上述的方法，来自定义排序规则</p><pre><code class="python">&gt;&gt;&gt; s.sort(key = len)&gt;&gt;&gt; s[&#39;php&#39;, &#39;java&#39;, &#39;python&#39;]</code></pre><h2 id="使用运算符加法和乘法操作列表"><a href="#使用运算符加法和乘法操作列表" class="headerlink" title="使用运算符加法和乘法操作列表"></a>使用运算符加法和乘法操作列表</h2><p>1、可以使用加法运算符将两个列表合并后生成一个新的列表，被合并的两个列表不会发生变化。</p><pre><code class="python">&gt;&gt;&gt; L1 = [1, 2, 3]&gt;&gt;&gt; L2 = [4, 5, 6]&gt;&gt;&gt; L3 = L1 + L2&gt;&gt;&gt; L3[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; L1[1, 2, 3]&gt;&gt;&gt; L2[4, 5, 6]&gt;&gt;&gt; L1 = L2 = [1, 2]&gt;&gt;&gt; L1 = L1 + [3, 4]&gt;&gt;&gt; L1[1, 2, 3, 4]&gt;&gt;&gt; L2[1, 2]&gt;&gt;&gt; L1 = L2 = [1, 2]&gt;&gt;&gt; L1 += [3, 4]                ##参数赋值运算符“+=”会对列表对象本身进行修改，但是对字符串或者数字类型的对象不会，因为其仅会改变可变对象&gt;&gt;&gt; L1[1, 2, 3, 4]&gt;&gt;&gt; L2[1, 2, 3, 4]&gt;&gt;&gt; a = b =1                    ##对于不可变对象，就不会对对象本身进行修改&gt;&gt;&gt; a += 1&gt;&gt;&gt; a2&gt;&gt;&gt; b1</code></pre><p>2、使用乘法运算符操作列表，可以将列表中的所有元素重复n次后生成一个新列表，被乘的列表不发生任何变化</p><pre><code class="python">&gt;&gt;&gt; L1 = [1, 2]&gt;&gt;&gt; L2 = L1 * 3&gt;&gt;&gt; L1[1, 2]&gt;&gt;&gt; L2[1, 2, 1, 2, 1, 2]&gt;&gt;&gt; L1 = L2 = [1, 2]            ##参数赋值运算符“+=”会对列表对象本身进行修改，但是对字符串或者数字类型的对象不会，因为其仅会改变可变对象&gt;&gt;&gt; L1 *= 3&gt;&gt;&gt; L1[1, 2, 1, 2, 1, 2]&gt;&gt;&gt; L2[1, 2, 1, 2, 1, 2]</code></pre><p>3、常用于列表的初始化</p><pre><code class="python">&gt;&gt;&gt; L = [0] * 5&gt;&gt;&gt; L[0, 0, 0, 0, 0]</code></pre><h2 id="比较运算符比较列表"><a href="#比较运算符比较列表" class="headerlink" title="比较运算符比较列表"></a>比较运算符比较列表</h2><h1 id="使用如下比较运算符对两个列表进行比较，比较规则为：首先比较两个列表中的第一个元素，如果相等则继续比较下去，直到两个列表中的元素不相等时，其比较结果就是两个列表的比较结果，两个列表中的所有后续元素将不再被比较-bash"><a href="#使用如下比较运算符对两个列表进行比较，比较规则为：首先比较两个列表中的第一个元素，如果相等则继续比较下去，直到两个列表中的元素不相等时，其比较结果就是两个列表的比较结果，两个列表中的所有后续元素将不再被比较-bash" class="headerlink" title="使用如下比较运算符对两个列表进行比较，比较规则为：首先比较两个列表中的第一个元素，如果相等则继续比较下去，直到两个列表中的元素不相等时，其比较结果就是两个列表的比较结果，两个列表中的所有后续元素将不再被比较&#96;&#96;&#96;bash&gt;&gt;&#x3D;&lt;&lt;&#x3D;"></a>使用如下比较运算符对两个列表进行比较，比较规则为：首先比较两个列表中的第一个元素，如果相等则继续比较下去，直到两个列表中的元素不相等时，其比较结果就是两个列表的比较结果，两个列表中的所有后续元素将不再被比较<br>&#96;&#96;&#96;bash<br>&gt;<br>&gt;&#x3D;<br>&lt;<br>&lt;&#x3D;</h1><p>!&#x3D;</p><pre><code> ## 多维列表一维列表的操作也适用于多维列表</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类对象特殊方法__getattr__()、__getitem__()、__setitem__()、__delitem__()</title>
      <link href="/2018/04/23/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__getattr__()%E3%80%81__getitem__()%E3%80%81__setitem__()%E3%80%81__delitem__()/"/>
      <url>/2018/04/23/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__getattr__()%E3%80%81__getitem__()%E3%80%81__setitem__()%E3%80%81__delitem__()/</url>
      
        <content type="html"><![CDATA[<h1 id="类对象特殊方法-getattr-、getitem-、setitem-、delitem"><a href="#类对象特殊方法-getattr-、getitem-、setitem-、delitem" class="headerlink" title="类对象特殊方法__getattr__()、getitem()、setitem()、delitem()"></a>类对象特殊方法__getattr__()、<strong>getitem</strong>()、<strong>setitem</strong>()、<strong>delitem</strong>()</h1><h2 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__()"></a><code>__getattr__()</code></h2><p>当访问实例对象的属性或方法时，如果指定的属性或方法不存在，就会抛出AttributeError，为了避免抛出此异常，可以在实例对象所对应的类对象中实现特殊方法<code>__getattr__()</code>，这样，当指定的属性或方法不存在时，就会自动调用特殊方法<code>__getattr__()</code>。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def do_sth(self):        print(&#39;do_sth()被调用了&#39;)    def __getattr__(self, name):        if name == &#39;data&#39;:                     # 判断的是属性名,            return 20                          # 返回的是属性值        elif name == &#39;do_sth1&#39;:                # 判断的是方法名            return print                       # 返回的是方法名        else:            raise AttributeError(&#39;__getattr__()被调用了&#39;)      # 都不匹配的话，就自定义异常mc = MyClass()mc.do_sth()                     # 这里找到了do_sth方法，直接进行调用# 下面的属性或方法都不存在，因此调用特殊方法__getattr__()，属性名和方法名被当做实参传入，进而进行匹配，当这里都没有的时候，才抛出异常print(mc.data)                  # 这里匹配到了data属性名，返回的就是20mc.do_sth1(&#39;hello&#39;)             # 这里匹配到了do_sth1，返回的是print函数，那么do_sth1就可以被当做print来调用</code></pre><pre><code class="python">[root@lyucan ~]# ./28.pydo_sth()被调用了20hello</code></pre><h2 id="getitem-、-setitem-、-delitem"><a href="#getitem-、-setitem-、-delitem" class="headerlink" title="__getitem__()、__setitem__()、__delitem__()"></a><code>__getitem__()</code>、<code>__setitem__()</code>、<code>__delitem__()</code></h2><p>对于自定义类对象的实例对象，在默认情况下，是不能像列表和字典那样使用中括号语法来操作数据的。</p><p>如果想让自定义类对象的实例对象可以像列表和字典那样使用[]语法操作数据，必须在自定义类对象中实现以下三个特殊方法：<br>1、<code>__getitem__(self, key)</code><br>        当执行操作“obj[key]”时，会自动调用该特殊方法。</p><p>2、<code>__setitem__(self, key, value)</code><br>        当执行操作“obj[key] &#x3D; value”时，会自动调用该特殊方法。</p><p>3、<code>__delitem__(self, key)</code><br>        当执行操作“del obj[key]”时，会自动调用该他特殊方法。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    def __init__(self):        self.data = &#123;&#125;    def __getitem__(self, key):        return self.data[key]    def __setitem__(self, key, value):        self.data[key] = value    def __delitem__(self, key):        del self.data[key]mc = MyClass()mc[&#39;name&#39;] = &#39;Jerry&#39;mc[&#39;age&#39;] = 25print(mc[&#39;name&#39;])print(mc[&#39;age&#39;])del mc[&#39;age&#39;]print(mc[&#39;age&#39;])</code></pre><pre><code class="python">[root@lyucan ~]# ./29.pyJerry25Traceback (most recent call last):  File &quot;./29.py&quot;, line 27, in &lt;module&gt;    print(mc[&#39;age&#39;])  File &quot;./29.py&quot;, line 8, in __getitem__    return self.data[key]KeyError: &#39;age&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-流程控制</title>
      <link href="/2018/04/23/Python/Python-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2018/04/23/Python/Python-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>只有条件判断为True，才会执行执行体里面的代码块，否则跳过往后判断</p><pre><code class="python">if &lt;条件判断1&gt;:     &lt;执行体1&gt; elif &lt;条件判断2&gt;:     &lt;执行体2&gt; elif &lt;条件判断3&gt;:     &lt;执行体3&gt; else:     &lt;执行体4&gt;</code></pre><p><code>if</code>语句执行有个特点，它是从上往下判断，如果在某个判断上是<code>True</code>，把该判断对应的语句执行后，就忽略掉剩下的<code>elif</code>和<code>else</code>，所以，请测试并解释为什么下面的程序打印的是<code>kid</code></p><pre><code class="python">age = 20if age &gt; 3:    print(&#39;kid&#39;)elif age &gt; 14:    print(&#39;teenager&#39;)elif age &gt; 18:    print(&#39;adult&#39;)else:    print(&#39;older&#39;)##kid</code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>专门用于遍历序列，字典和集合等类型的对象，每遍历一个元素，称为一次迭代，可以使用<code>for-in</code>语句遍历的对象又被称为可迭代对象。</p><p>当迭代次数已知时，推荐使用<code>for</code>语句，迭代次数未知时，推荐使用<code>while</code>语句</p><p>当遍历字典时，自定义变量获取的是字典的key，而不是key-value</p><pre><code class="python">d = &#123;...&#125;for key in d.keys()    passfor value in d.vlaues():    passfor key,vlaue in d.items():    pass</code></pre><p>如果循环体内不需要访问自定义的变量，可以将自定义的变量替换为下划线<code>_</code>。</p><pre><code class="python">&gt;&gt;&gt; for _ in range(1,4):...     print(&#39;hello&#39;)...hellohellohello</code></pre><p>在遍历序列的过程中，如果需要对序列进行修改，最好先通过切片操作生成一份序列的拷贝</p><pre><code class="python">&gt;&gt;&gt; words = [&#39;python&#39;, &#39;java&#39;, &#39;php&#39;, &#39;swift&#39;]&gt;&gt;&gt; for word in words[:]:...     if len(word) &lt; 5:...         words.remove(word)...&gt;&gt;&gt; print(words)[&#39;python&#39;, &#39;swift&#39;]</code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code class="python">初始化部分while 循环条件:    &lt;循环体&gt;</code></pre><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>使用break跳出循环</p><pre><code class="python">answer = int(input(&#39;Input a number:&#39;))while True:    if answer == 100:        print(&#39;Right&#39;)        break    else:        answer = int(input(&#39;go on:&#39;))</code></pre><p>使用continue跳出本轮循环，执行下一轮循环，执行循环前首先要进行条件判断。</p><pre><code class="python">&gt;&gt;&gt; for i in range(0,10):...     if i%2 != 0:...         print(i)...         continue...     else:...         i += 2...         print(i)...21436587109</code></pre><pre><code class="python">&gt;&gt;&gt; for i in range(5):...     if i == 3:...         break...     print(&#39;i = &#39;, i)...i =  0i =  1i =  2&gt;&gt;&gt; for i in range(5):...     if i == 3:...         continue...     print(&#39;i = &#39;, i)...i =  0i =  1i =  2i =  4</code></pre><h2 id="while-for-in-else结构"><a href="#while-for-in-else结构" class="headerlink" title="while&#x2F;for-in else结构"></a>while&#x2F;for-in else结构</h2><p>在执行<code>while</code>语句或<code>for-in</code>语句时，如果循环正常结束（没有执行循环体中的<code>break</code>），可能想在循环结束后执行某些操作，即可在<code>while</code>中使用<code>else</code></p><pre><code class="python">lucky_num = 10guess_count = 0while guess_count &lt; 3:    input_num = int(input(&quot;Input the guess num: &quot;))    if input_num &gt; lucky_num:        print(&quot;The real number is smalller!&quot;)    elif input_num &lt; lucky_num:        print(&quot;The real number is bigger...&quot;)    else:        print(&quot;Bjngo!...&quot;)        break    guess_count += 1else:    print(&quot;Too many retrys!&quot;)</code></pre><h2 id="并行遍历"><a href="#并行遍历" class="headerlink" title="并行遍历"></a>并行遍历</h2><pre><code class="python">&gt;&gt;&gt; names = [&#39;Jerry&#39;, &#39;Mark&#39;, &#39;Flank&#39;]&gt;&gt;&gt; ages = [&#39;25&#39;, &#39;40&#39;, &#39;29&#39;]&gt;&gt;&gt; for i in range(len(names)):...     print(names[i], &#39;的年龄是：&#39;, ages[i])...Jerry 的年龄是： 25Mark 的年龄是： 40Flank 的年龄是： 29</code></pre><p>使用zip内置函数</p><pre><code class="python">&gt;&gt;&gt; for name, age in list(zip(names, ages)):...     print(name, age)...Jerry 25Mark 40Flank 29</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx启停脚本</title>
      <link href="/2018/04/18/%E8%BF%90%E7%BB%B4/Nginx%E5%90%AF%E5%81%9C%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/04/18/%E8%BF%90%E7%BB%B4/Nginx%E5%90%AF%E5%81%9C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx启停脚本"><a href="#Nginx启停脚本" class="headerlink" title="Nginx启停脚本"></a>Nginx启停脚本</h1><pre><code class="bash">#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig:   - 85 15# description:  Nginx is an HTTP(S) server, HTTP(S) reverse \#               proxy and IMAP/POP3 proxy server# processname: nginx# config:      /etc/nginx/nginx.conf# config:      /etc/sysconfig/nginx# pidfile:     /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0nginx=&quot;/usr/local/nginx/sbin/nginx&quot;prog=$(basename $nginx)sysconfig=&quot;/etc/sysconfig/$prog&quot;lockfile=&quot;/var/lock/subsys/nginx&quot;pidfile=&quot;/usr/local/nginx/logs/nginx.pid&quot;NGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot;[ -f $sysconfig ] &amp;&amp; . $sysconfigstart() &#123;    [ -x $nginx ] || exit 5    [ -f $NGINX_CONF_FILE ] || exit 6    echo -n $&quot;Starting $prog: &quot;    daemon $nginx -c $NGINX_CONF_FILE    retval=$?    echo    [ $retval -eq 0 ] &amp;&amp; touch $lockfile    return $retval&#125;stop() &#123;    echo -n $&quot;Stopping $prog: &quot;    killproc -p $pidfile $prog    retval=$?    echo    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile    return $retval&#125;restart() &#123;    configtest_q || return 6    stop    start&#125;reload() &#123;    configtest_q || return 6    echo -n $&quot;Reloading $prog: &quot;    killproc -p $pidfile $prog -HUP    echo&#125;configtest() &#123;    $nginx -t -c $NGINX_CONF_FILE&#125;configtest_q() &#123;    $nginx -t -q -c $NGINX_CONF_FILE&#125;rh_status() &#123;    status $prog&#125;rh_status_q() &#123;    rh_status &gt;/dev/null 2&gt;&amp;1&#125;# Upgrade the binary with no downtime.upgrade() &#123;    local oldbin_pidfile=&quot;$&#123;pidfile&#125;.oldbin&quot;    configtest_q || return 6    echo -n $&quot;Upgrading $prog: &quot;    killproc -p $pidfile $prog -USR2    retval=$?    sleep 1    if [[ -f $&#123;oldbin_pidfile&#125; &amp;&amp; -f $&#123;pidfile&#125; ]];  then        killproc -p $oldbin_pidfile $prog -QUIT        success $&quot;$prog online upgrade&quot;        echo        return 0    else        failure $&quot;$prog online upgrade&quot;        echo        return 1    fi&#125;# Tell nginx to reopen logsreopen_logs() &#123;    configtest_q || return 6    echo -n $&quot;Reopening $prog logs: &quot;    killproc -p $pidfile $prog -USR1    retval=$?    echo    return $retval&#125;case &quot;$1&quot; in    start)        rh_status_q &amp;&amp; exit 0        $1        ;;    stop)        rh_status_q || exit 0        $1        ;;    restart|configtest|reopen_logs)        $1        ;;    force-reload|upgrade)        rh_status_q || exit 7        upgrade        ;;    reload)        rh_status_q || exit 7        $1        ;;    status|status_q)        rh_$1        ;;    condrestart|try-restart)        rh_status_q || exit 7        restart        ;;    *)        echo $&quot;Usage: $0 &#123;start|stop|reload|configtest|status|force-reload|upgrade|restart|reopen_logs&#125;&quot;        exit 2esac</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>innodb特性</title>
      <link href="/2018/04/17/Mysql/innodb%E7%89%B9%E6%80%A7/"/>
      <url>/2018/04/17/Mysql/innodb%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="innodb特性"><a href="#innodb特性" class="headerlink" title="innodb特性"></a>innodb特性</h1><h2 id="插入缓存（insert-buffer）"><a href="#插入缓存（insert-buffer）" class="headerlink" title="插入缓存（insert buffer）"></a>插入缓存（insert buffer）</h2><p>对非聚集索引的插入或者update，purge等操作，并非每一次直接插入索引页，而是把若干对于同一页面的更新缓存起来合并为一次操作，随机IO –&gt; 顺序IO，避免随机IO带的性能消耗，提高写性能。</p><ul><li>原理：<br>先判断插入的非聚集索引页是否在缓冲池中<br>如果在，直接插入<br>如果不在，想放到插入缓冲区，欺骗数据库，这个非聚集的索引已经插入到叶子节点了<br>然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作</li><li>条件：<br>索引是辅助索引<br>索引不是唯一的<br>注意：在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认最大可以占用1&#x2F;2的缓冲池内存</li></ul><h2 id="二次写-（double-write）"><a href="#二次写-（double-write）" class="headerlink" title="二次写 （double write）"></a>二次写 （double write）</h2><p>带给innodb存储引擎数据的可靠性</p><ul><li>起因：当数据库宕机时，可能发生数据库写一个页面，而这个页只写了一部分，这就是所谓的部分写失效（partial page write），它会导致数据丢失，这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。</li><li>恢复原理：mysql在恢复的时候是通过检查page的checksum来决定这个页是否需要恢复，checksum就是当前这个页最后一个事务的事务号，如果系统找不到checksum，mysql就无法对该行数据进行写入操作<br><img src="/images/b00db37f-c704-484b-8cc3-d7c915031038-Image.png" alt="b00db37f-c704-484b-8cc3-d7c915031038-Image.png" title="b00db37f-c704-484b-8cc3-d7c915031038-Image.png"></li></ul><p>两次写需要额外添加两个部分：</p><ol><li>内存中的两次写缓冲（doublewrite buffer），大小为2MB</li><li>磁盘上共享表空间中连续的128页，大小也为2MB</li></ol><p>其原理是这样的：</p><ol><li>当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的两次写缓冲区。</li><li>接着从两次写缓冲区分两次写入磁盘共享表空间中，每次写入1MB</li><li>待第2步完成后，再将两次写缓冲区写入数据文件</li></ol><p>这样就可以解决上文提到的部分写失效的问题，因为在磁盘共享表空间中已有数据页副本拷贝，如果数据库在页写入数据文件的过程中宕机，在实例恢复时，可以从共享表空间中找到该页副本，将其拷贝覆盖原有的数据页，再应用重做日志即可。</p><h2 id="自适应哈希索引（adapter-hash-index）"><a href="#自适应哈希索引（adapter-hash-index）" class="headerlink" title="自适应哈希索引（adapter hash index）"></a>自适应哈希索引（adapter hash index）</h2><p>innodb存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引，所以称为自适应的。<br>自适应哈希索引通过缓冲池的B+树构造而来，因为建立的速度很快，而且不需要将整个表都建立哈希索引，innodb会自动根据访问频率和模式来为某些页建立哈希索引。<br>启用自适应哈希索引后，读写速度提高两倍，辅助索引的链接操作，性能提高五倍。<br>数据库自动优化，不需要认为干预。<br>可以通过 show engine innodb status\G来查看自适应哈西索引的使用情况。可以使用innodb_adaptive_hash_index来禁用和启用hash索引，默认开启。</p><h2 id="异步IO（async-IO）"><a href="#异步IO（async-IO）" class="headerlink" title="异步IO（async IO）"></a>异步IO（async IO）</h2><p>为提高性能，采用异步IO来处理磁盘操作，好处是可以进行合并IO；</p><h2 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h2><p>当刷新一个页的时候，innodb存储引擎会检测该页所在区的所有页，如果是脏页，就一起进行刷新。<br>如果使用的是固态硬盘，关掉它可以有效的提高性能。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-上下文管理器with语句</title>
      <link href="/2018/04/17/Python/Python-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8with%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/04/17/Python/Python-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8with%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="上下文管理器with语句"><a href="#上下文管理器with语句" class="headerlink" title="上下文管理器with语句"></a>上下文管理器with语句</h1><p>如果一个类对象实现了特殊方法<code>__enter__()</code>和<code>__exit__()</code>，那么就称这个类对象遵守了上下文管理协议，同时，这个类对象的实例对象被称为上下文管理器。<br><code>with</code>语句会让上下文管理器创建一个运行时上下文，当进入运行时上下文时自动调用特殊方法<code>__enter__()</code>，当离开运行时向下文时自动调用特殊方法<code>__exit__()</code>。</p><p>with语句的语法格式：</p><pre><code class="python">with 上下文表达式 [as 变量]:    with 语句体</code></pre><p>如果<code>with</code>语句体中产生了异常，那么<code>sys.exc_info()</code>的返回值中的三个元素会被自动传递给特殊方法<code>__exit__()</code>的形参<code>exc_type</code>、<code>exc_val</code>、<code>exc_tb</code>，这三个形参分别表示异常的类型、异常的错误信息和异常调用堆栈的跟踪信息。</p><p>与<code>finally</code>类似，特殊方法<code>__exit__()</code>总会被调用，通常在特殊方法<code>__exit__()</code>中释放资源，例如：关闭文件、关闭网路连接等。</p><pre><code class="python">#!/usr/bin/python3class MyContextManager(object):    def __enter__(self):        print(&#39;特殊方法__enter__()被调用&#39;)        return self    def __exit__(self, exc_type, exc_val, exc_tb):        print(&#39;特殊方法__exit__()被调用&#39;)        print(&#39;异常的类型：%s&#39; % exc_type)        print(&#39;异常的错误信息：%s&#39; % exc_val)        print(&#39;异常调用堆栈的跟踪信息：%s&#39; % exc_tb)        # return True    def do_sth(self):        print(&#39;方法do_sth()被调用&#39;)        print(1 / 0)&quot;&quot;&quot;with MyContextManager() as mcm:    mcm.do_sth()&quot;&quot;&quot;try:    with MyContextManager() as mcm:        mcm.do_sth()except ZeroDivisionError as err:    print(err)</code></pre><pre><code class="python">[root@lyucan ~]# ./yc.py特殊方法__enter__()被调用方法do_sth()被调用特殊方法__exit__()被调用异常的类型：&lt;class &#39;ZeroDivisionError&#39;&gt;异常的错误信息：division by zero异常调用堆栈的跟踪信息：&lt;traceback object at 0x7fb5a99c4b88&gt;division by zero</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启动数据库实例与spfile的关系</title>
      <link href="/2018/04/16/Oracle/%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B%E4%B8%8Espfile%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2018/04/16/Oracle/%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B%E4%B8%8Espfile%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="启动数据库实例与spfile的关系"><a href="#启动数据库实例与spfile的关系" class="headerlink" title="启动数据库实例与spfile的关系"></a>启动数据库实例与spfile的关系</h1><p>在数据库启动时需要读取参数文件来分配内存区域并定位控制文件的位置,oracle数据库中的初始化参数传统上是存储在一个文本初始化参数文件中的.为了更好地管理,可以选择使用一个二进制的服务器参数文件来管理初始化参数对它的修改在数据库重启后仍然生效.下面来介绍如何使用这种方法来管理初始化参数.</p><h2 id="什么是服务器参数文件"><a href="#什么是服务器参数文件" class="headerlink" title="什么是服务器参数文件"></a>什么是服务器参数文件</h2><p>服务器参数文件可以被认为是一个初始化参数档案库它被存储在运行oracle数据库服务器的系统中.它被设计为服务端初始化参数文件.存储在服务器参数文件中的初始化参数是永久生效的.当实例运行时对参数的任何改变在数据库重启之后是仍然有效的.这消除了为了使alter system语句的改变永久生效而要手工修改初始化参数的需要.它也提供了对数据库服务器自动调整的基础.</p><p>一个服务器参数文件是通过使用create spfile语句从文本初始化参数文件来初始化创建.(也可以通过DBCA来直接创建).服务器参数文件是一个二进制文件不能使用文本编辑器来修改.oracle数据库提供了其它的接口来查看和修改服务器参数文件中的参数.</p><p>注意:虽然你能使用一个文本编辑器来打开一个二进制服务器参数文件但不能手工修改它.如果修改会损坏文件.你将不能重启实例,如果实例正在运行那么它会终止运行.</p><p>当执行没有pfile子句的startup命令,oracle实例会在操作系统特定的缺省位置来搜索一个服务器参数文件并从文件中读取初始化参数.如果没有找到服务器参数文件,实例将搜索一个文本初始化参数.如果服务器参数文件存在但你想使用一个文本初始化参数来覆盖那么在执行startup命令时指定pfile子句.</p><p>下面来举例说明:<br>1.执行不带pfile子句的startup命令,从下面的输出可以看出启动时自动搜索了服务器参数文件spfilejycs.ora</p><pre><code class="sql">SQL&gt; startupORACLE instance started.Total System Global Area  630501376 bytesFixed Size                  2215984 bytesVariable Size             385880016 bytesDatabase Buffers          234881024 bytesRedo Buffers                7524352 bytesDatabase mounted.Database opened.SQL&gt; show parameter spfileNAME                                 TYPE        VALUE------------------------------------ ----------- ------------------------------spfile                               string      /u01/app/oracle/11.2.0/db/dbs/                                                 spfilejycs.ora</code></pre><p>2.删除服务器参数文件spfilejycs.ora,再执行执行不带pfile子句的startup命令,从下面的输出可以看出在启动时，在搜索不到服务器参数文件时就会搜索文本初始化参数文件initjycs.ora</p><pre><code class="sql">[oracle@jyrac1 dbs]$ mv spfilejycs.ora spfilejycs.ora.bakSQL&gt; startupORACLE instance started.Total System Global Area  630501376 bytesFixed Size                  2215984 bytesVariable Size             385880016 bytesDatabase Buffers          234881024 bytesRedo Buffers                7524352 bytesDatabase mounted.Database opened.SQL&gt; show parameter spfile  NAME                                 TYPE        VALUE------------------------------------ ----------- ------------------------------spfile                               string</code></pre><p>3.删除文本初始化参数文件initjycs.ora,再执行执行不带pfile子句的startup命令,从下面的输出可以看出在启动时，在搜索不到服务器参数文件时就会搜索文本初始化参数文件initjycs.ora,但是因为我们删除了文本初始化参数文件initjycs.ora，所以提示找不到这个文件</p><pre><code class="sql">[oracle@jyrac1 dbs]$ mv initjycs.ora initjycs.ora.bakSQL&gt; startupORA-01078: failure in processing system parametersLRM-00109: could not open parameter file &#39;/u01/app/oracle/11.2.0/db/dbs/initjycs.ora&#39;</code></pre><p>4.执行带pfile子句的startup命令,将使用文本初始化参数文件来替代服务器参数文件,可以看到spfile参数值为空说明是使用文本初始化参数来启动的实例</p><pre><code class="sql">SQL&gt; startup pfile=&#39;/u01/app/oracle/11.2.0/db/dbs/initjycs.ora&#39;ORACLE instance started.Total System Global Area  630501376 bytesFixed Size                  2215984 bytesVariable Size             385880016 bytesDatabase Buffers          234881024 bytesRedo Buffers                7524352 bytesDatabase mounted.Database opened.SQL&gt; show parameter spfileNAME                                 TYPE        VALUE------------------------------------ ----------- ------------------------------spfile                               string</code></pre><h2 id="迁移到服务器参数文件"><a href="#迁移到服务器参数文件" class="headerlink" title="迁移到服务器参数文件"></a>迁移到服务器参数文件</h2><p>如果你当前正使用一个文本初始化参数文件那么使用下面的步骤来迁移到服务器参数文件:</p><p>1.如果初始化参数文件在一个客户端系统中,那么可以使用ftp将这个文件从客户端系统传输到服务器系统.<br>注意:如果你从一个oracle rac环境中迁移一个服务器参数文件,你必须合并所有实例特定的初始化参数文件为一个单独的初始化参数文件.这样做是为了使用oracle rac中的所有实例共同使用一个服务器参数文件.</p><p>2.使用create spfile from pfile命令在缺省位置创建一个服务器参数文件.<br>这个语句将读取一个文本初始化参数来创建一个服务器参数文件.</p><p>3.启动或重启实例<br>这个实例将会在缺省位置查找一个新的spfile文件来启动<br>创建服务器参数文件</p><p>可以使用create spfile语句来创建一个服务器参数文件.必须有sysdba或sysoper系统权限来执行这个语句.<br>注意:当使用dbca创建数据库时它会自动的创建一服务器参数文件</p><p>create spfile语句可以在实例启动之前或之后执行.然而如果实例已经使用一个服务器参数文件启动了，执行这个创建服务器参数文件的语句就会报错.</p><p>可以从一个存在的文本初始化参数文件或从内存来创建一个服务器参数文件(spfile)。从内存来创建服务器参数文件这意味着复制初始化参数的当前值到服务器参数文件中.</p><pre><code class="sql">SQL&gt; create spfile from memory;create spfile from memory*ERROR at line 1:ORA-32002: cannot create SPFILE already being used by the instance##create spfile语句可以在实例启动之前或之后执行，但如果实例已经使用一个服务器参数文件启动了，执行这个创建服务器参数文件的语句就会报错.</code></pre><p>下面的例子从一个文本初始化参数文件&#x2F;u01&#x2F;oracle&#x2F;dbs&#x2F;init.ora来创建服务器参数文件.在这个例子中没有指定spfile文件名所以这个被创建的文件将会使用平台特定的缺省名和位置.</p><pre><code class="sql">SQL&gt;CREATE SPFILE FROM PFILE=&#39;/u01/oracle/dbs/init.ora&#39;;</code></pre><p>下面的例子在创建服务器参数文件时提供了文件名和存储的位置:</p><pre><code class="sql">SQL&gt;CREATE SPFILE=&#39;/u01/oracle/dbs/test_spfile.ora&#39; FROM PFILE=&#39;/u01/oracle/dbs/test_init.ora&#39;;</code></pre><p>下面的例子将在缺省位置将用内存中的初始化参数的当前值来创建服务器参数文件:</p><pre><code class="sql">SQL&gt;CREATE SPFILE FROM MEMORY;SQL&gt; create spfile from memory;create spfile from memory*ERROR at line 1:ORA-32002: cannot create SPFILE already being used by the instanceSQL&gt; create spfile from memory;File created.</code></pre><p>下面将用内存中的初始化参数的当前值来创建文本初始化参数文件，将与用spfile文件创建的文本初始化参数文件进行比较，可以明显看到从内存来创建的文件中多了以_开头的参数</p><pre><code class="sql">SQL&gt; create pfile from memory;File created.[oracle@jyrac1 dbs]$ cat initjycs.orajycs.__db_cache_size=234881024jycs.__java_pool_size=4194304jycs.__large_pool_size=4194304jycs.__oracle_base=&#39;/u01/app/oracle&#39;#ORACLE_BASE set from environmentjycs.__pga_aggregate_target=209715200jycs.__sga_target=633339904jycs.__shared_io_pool_size=0jycs.__shared_pool_size=373293056jycs.__streams_pool_size=4194304*.audit_file_dest=&#39;/u01/app/oracle/admin/jycs/adump&#39;*.audit_trail=&#39;db&#39;*.compatible=&#39;11.2.0.0.0&#39;*.control_files=&#39;/u01/app/oracle/oradata/jycs/control01.ctl&#39;,&#39;/u01/app/oracle/flash_recovery_area/jycs/control02.ctl&#39;*.db_block_size=8192*.db_domain=&#39;&#39;*.db_name=&#39;jycs&#39;*.db_recovery_file_dest=&#39;/u01/app/oracle/flash_recovery_area&#39;*.db_recovery_file_dest_size=4070572032*.diagnostic_dest=&#39;/u01/app/oracle&#39;*.dispatchers=&#39;(PROTOCOL=TCP) (SERVICE=jycsXDB)&#39;*.open_cursors=300*.pga_aggregate_target=209715200*.processes=150*.remote_login_passwordfile=&#39;exclusive&#39;*.sga_target=631242752*.undo_tablespace=&#39;UNDOTBS1&#39;[oracle@jyrac1 dbs]$ cat initjycs.ora# Oracle init.ora parameter file generated by instance jycs on 04/14/2014 10:33:22__db_cache_size=224M__java_pool_size=4M__large_pool_size=4M__oracle_base=&#39;/u01/app/oracle&#39; # ORACLE_BASE set from environment__pga_aggregate_target=200M__sga_target=604M__shared_io_pool_size=0__shared_pool_size=356M__streams_pool_size=4M_aggregation_optimization_settings=0_always_anti_join=&#39;CHOOSE&#39;_always_semi_join=&#39;CHOOSE&#39;_and_pruning_enabled=TRUE_b_tree_bitmap_plans=TRUE_bloom_filter_enabled=TRUE_bloom_folding_enabled=TRUE_bloom_pruning_enabled=TRUE_complex_view_merging=TRUE_compression_compatibility=&#39;11.2.0.0.0&#39;_connect_by_use_union_all=&#39;TRUE&#39;_convert_set_to_join=FALSE_cost_equality_semi_join=TRUE_cpu_to_io=0_dimension_skip_null=TRUE_eliminate_common_subexpr=TRUE_enable_type_dep_selectivity=TRUE_fast_full_scan_enabled=TRUE_first_k_rows_dynamic_proration=TRUE_gby_hash_aggregation_enabled=TRUE_generalized_pruning_enabled=TRUE_globalindex_pnum_filter_enabled=TRUE_gs_anti_semi_join_allowed=TRUE_improved_outerjoin_card=TRUE_improved_row_length_enabled=TRUE_index_join_enabled=TRUE_ksb_restart_policy_times=&#39;0&#39;_ksb_restart_policy_times=&#39;60&#39;_ksb_restart_policy_times=&#39;120&#39;_ksb_restart_policy_times=&#39;240&#39; # internal update to set default_left_nested_loops_random=TRUE_local_communication_costing_enabled=TRUE_minimal_stats_aggregation=TRUE_mmv_query_rewrite_enabled=TRUE_new_initial_join_orders=TRUE_new_sort_cost_estimate=TRUE_nlj_batching_enabled=1_optim_adjust_for_part_skews=TRUE_optim_enhance_nnull_detection=TRUE_optim_new_default_join_sel=TRUE_optim_peek_user_binds=TRUE_optimizer_adaptive_cursor_sharing=TRUE_optimizer_better_inlist_costing=&#39;ALL&#39;_optimizer_cbqt_no_size_restriction=TRUE_optimizer_coalesce_subqueries=TRUE_optimizer_complex_pred_selectivity=TRUE_optimizer_compute_index_stats=TRUE_optimizer_connect_by_combine_sw=TRUE_optimizer_connect_by_cost_based=TRUE_optimizer_connect_by_elim_dups=TRUE_optimizer_correct_sq_selectivity=TRUE_optimizer_cost_based_transformation=&#39;LINEAR&#39;_optimizer_cost_hjsmj_multimatch=TRUE_optimizer_cost_model=&#39;CHOOSE&#39;_optimizer_dim_subq_join_sel=TRUE_optimizer_distinct_agg_transform=TRUE_optimizer_distinct_elimination=TRUE_optimizer_distinct_placement=TRUE_optimizer_eliminate_filtering_join=TRUE_optimizer_enable_density_improvements=TRUE_optimizer_enable_extended_stats=TRUE_optimizer_enhanced_filter_push=TRUE_optimizer_extend_jppd_view_types=TRUE_optimizer_extended_cursor_sharing=&#39;UDO&#39;_optimizer_extended_cursor_sharing_rel=&#39;SIMPLE&#39;_optimizer_extended_stats_usage_control=224_optimizer_fast_access_pred_analysis=TRUE_optimizer_fast_pred_transitivity=TRUE_optimizer_filter_pred_pullup=TRUE_optimizer_fkr_index_cost_bias=10_optimizer_group_by_placement=TRUE_optimizer_improve_selectivity=TRUE_optimizer_join_elimination_enabled=TRUE_optimizer_join_factorization=TRUE_optimizer_join_order_control=3_optimizer_join_sel_sanity_check=TRUE_optimizer_max_permutations=2000_optimizer_mode_force=TRUE_optimizer_multi_level_push_pred=TRUE_optimizer_native_full_outer_join=&#39;FORCE&#39;_optimizer_new_join_card_computation=TRUE_optimizer_null_aware_antijoin=TRUE_optimizer_or_expansion=&#39;DEPTH&#39;_optimizer_order_by_elimination_enabled=TRUE_optimizer_outer_to_anti_enabled=TRUE_optimizer_push_down_distinct=0_optimizer_push_pred_cost_based=TRUE_optimizer_rownum_bind_default=10_optimizer_rownum_pred_based_fkr=TRUE_optimizer_skip_scan_enabled=TRUE_optimizer_sortmerge_join_inequality=TRUE_optimizer_squ_bottomup=TRUE_optimizer_star_tran_in_with_clause=TRUE_optimizer_system_stats_usage=TRUE_optimizer_table_expansion=TRUE_optimizer_transitivity_retain=TRUE_optimizer_try_st_before_jppd=TRUE_optimizer_undo_cost_change=&#39;11.2.0.1&#39;_optimizer_unnest_corr_set_subq=TRUE_optimizer_unnest_disjunctive_subq=TRUE_optimizer_use_cbqt_star_transformation=TRUE_optimizer_use_feedback=TRUE_or_expand_nvl_predicate=TRUE_ordered_nested_loop=TRUE_parallel_broadcast_enabled=TRUE_partition_view_enabled=TRUE_pivot_implementation_method=&#39;CHOOSE&#39;_pre_rewrite_push_pred=TRUE_pred_move_around=TRUE_push_join_predicate=TRUE_push_join_union_view=TRUE_push_join_union_view2=TRUE_px_minus_intersect=TRUE_px_pwg_enabled=TRUE_px_ual_serial_input=TRUE_query_rewrite_setopgrw_enable=TRUE_remove_aggr_subquery=TRUE_replace_virtual_columns=TRUE_right_outer_hash_enable=TRUE_selfjoin_mv_duplicates=TRUE_sql_model_unfold_forloops=&#39;RUN_TIME&#39;_sqltune_category_parsed=&#39;DEFAULT&#39; # parsed sqltune_category_subquery_pruning_enabled=TRUE_subquery_pruning_mv_enabled=FALSE_table_scan_cost_plus_one=TRUE_union_rewrite_for_gs=&#39;YES_GSET_MVS&#39;_unnest_subquery=TRUE_use_column_stats_for_function=TRUEaudit_file_dest=&#39;/u01/app/oracle/admin/jycs/adump&#39;audit_trail=&#39;DB&#39;compatible=&#39;11.2.0.0.0&#39;control_files=&#39;/u01/app/oracle/oradata/jycs/control01.ctl&#39;control_files=&#39;/u01/app/oracle/flash_recovery_area/jycs/control02.ctl&#39;core_dump_dest=&#39;/u01/app/oracle/diag/rdbms/jycs/jycs/cdump&#39;db_block_size=8192db_domain=&#39;&#39;db_name=&#39;jycs&#39;db_recovery_file_dest=&#39;/u01/app/oracle/flash_recovery_area&#39;db_recovery_file_dest_size=3882Mdiagnostic_dest=&#39;/u01/app/oracle&#39;dispatchers=&#39;(PROTOCOL=TCP) (SERVICE=jycsXDB)&#39;log_buffer=7192576 # log buffer updateopen_cursors=300optimizer_dynamic_sampling=2optimizer_mode=&#39;ALL_ROWS&#39;pga_aggregate_target=200Mplsql_warnings=&#39;DISABLE:ALL&#39; # PL/SQL warnings at init.oraprocesses=150query_rewrite_enabled=&#39;TRUE&#39;remote_login_passwordfile=&#39;EXCLUSIVE&#39;result_cache_max_size=3104Ksga_target=604Mskip_unusable_indexes=TRUEundo_tablespace=&#39;UNDOTBS1&#39;</code></pre><p>如果使用缺省的spfile文件名和缺省位置或者指定一个spfile文件名和位置，如果存在一个同名的spfile文件名它将覆盖这个文件而不会有警告信息。</p><p>当从一个文本初始化参数文件创建服务器参数文件spfile时，在初始化参数文件中在相同行的特定注释会作为参数设置在spfile文件中被维护，所有其它的注释会被忽略。</p><p>oracle建议你允许数据库给spfile使用缺省名和缺省存储位置，这简化的数据库的管理，比如使用startup命令就会从缺省位置读取spfile文件。</p><p>下面的表格显示了在UNIX，Linux和Windows平台上的文本初始化参数文件pfile和服务器参数文件spfile的缺省文件名和存储位置。</p><pre><code class="sql">PFILE and SPFILE Default Names and Locations on UNIX, LInux, and Windows-------------------------------------------------------------------------------------------------------------platform      pfile default name    spfile default name     pfile default location   spfile default location-------------------------------------------------------------------------------------------------------------unix,linux    initORACLE_SID.ora    spfileORACLE_SID.ora    ORACLE_HOME/dbs或者       不使用oracle asm:                                                            与数据文件在同一个目录       ORACLE_HOME/dbs或者与                                                                                      数据文件在同一个目录                                                                                      使用oracle asm:与数据文件                                                                                      在同一个磁盘组windows       initORACLE_SID.ora    spfileORACLE_SID.ora    ORACLE_HOME\database      不使用oracle asm:                                                                                      ORACLE_HOME\database                                                                                      使用oracle asm:与数据文件                                                                                      在同一个磁盘组---------------------------------------------------------------------------------------------------------------</code></pre><p>注意:在启动时，实例首先搜索一个名叫spfileORACLE_SID.ora的spfile文件，如果没有找到就会搜索spfile.ora文件；<br>使用spfile.ora能让所有的oracle rac实例使用相同的服务器参数文件；<br>如果spfile没找到，实例将搜索文本初始化参数文件initORACLE_SID.ora；<br>如果你不是在缺省位置创建一个spfile文件那么你必须创建一个缺省的pfile在pfile文件的根部指示这个服务器参数文件；<br>当使用dbca创建数据库且使用oracle asm时，dbca将会把spfile存储在一个oracle asm磁盘组也会在pfile文件的部指示这个服务器参数文件；</p><h2 id="spfile初始化参数"><a href="#spfile初始化参数" class="headerlink" title="spfile初始化参数"></a>spfile初始化参数</h2><p>spfile初始化参数包含了当前服务器参数文件的名字，当数据库使用缺省的服务器参数文件时，也就是执行没有pfile参数的startup命令时，这个spfile的值由服务器内部指定。在<code>SQL*Plus</code>中执行show parameter spfile(或任何其它的方法来查询参数的值)来显示当前使用的服务器参数文件名.<br>改变初始化参数值<br>使用alter system语句来设置，修改或还原初始化参数值。如果你正使用一个文本初始化参数文件，alter system语句就只能对当前实例改变参数的值，因为没有机制可以自动更新磁盘上的文本初始化参数文件，你必须手工更新，使用服务器参数文件可以克服这个问题。<br>有两种类型的初始化参数文件<br>动态初始化参数对于当前oracle实例是可以修改的，这种改变会立即生效。<br>静态初始化参数对于当前实例是不能修改的，必须修改文本初始化参数文件或者服务器参数文件中的参数然后重新启动实例使修改生效。</p><h2 id="设置或修改初始化参数值"><a href="#设置或修改初始化参数值" class="headerlink" title="设置或修改初始化参数值"></a>设置或修改初始化参数值</h2><p>使用有set子句的alter system的语句来设置或修改初始化参数的值.可选scope子句用来指定修改的范围:</p><pre><code class="sql">----------------------------------------------------------------------------------------------------scope clause                       description----------------------------------------------------------------------------------------------------scope=spfile                      这种修改只应用于服务器参数文件.它的效果如下:                                  .对当前实例不会生效                                  .对于动态和静态参数只有在重启实例之后才会生效                                  这是唯一可以修改静态参数的scope范围级别scope=memory                      这种修改只应用于内存.它的效果如下:                                  .这种改变只应用于当前实例且会立即生效                                  .对于动态参数会立即生效.但是不是永久生效因为没有更新spfile文件                                  对于静态参灵数不能在这个范围级别进行修改scope=both                        这种修改应用于服务器参数文件和内存,它的效果如下:                                  .对于当前实例这种改变会立即生效                                  .对于动态参数会永久生效因为修改了服务器参数文件.                                  对于静态参数不能在这个范围级别进行修改----------------------------------------------------------------------------------------------------</code></pre><p>如果使用cope&#x3D;spfile或scope&#x3D;both设置的参数有错误，实例使用服务器参数文件是不能启动的。</p><p>如果实例是使用服务器参数文件启动的，那么缺省的参数修改范围级别为scope&#x3D;both。.如果实例是使用文本初始化参数文件来启动的，那么缺省的参数修改范围级别为scope&#x3D;memory。</p><p>对于动态参数,还可以指定deferred关键字.当指定这个关键字后改变只对以后的会话生效.</p><p>当你设置scope为spfile或both时可以选择comment子句来对参数使用一个文本字符串作为注释，这个注释也会被写入服务器参数文件中.</p><p>下面的语句将修改在连接被删除之前允许的登录失败的最大次数.它包含了一注释且明确地指出了修改只对服务器参数文件生效；</p><pre><code class="sql">SQL&gt;ALTER SYSTEM SET SEC_MAX_FAILED_LOGIN_ATTEMPTS=3 COMMENT=&#39;Reduce from 10 for tighter security.&#39; SCOPE=SPFILE;</code></pre><p>下面的例子介绍了如何对复杂初始化参数进行设置这个参数有一个列表属性.下面的语句可以改变已经存在的设置或者使用一个新的归档目录</p><pre><code class="sql">SQL&gt;ALTER SYSTEM2 SET LOG_ARCHIVE_DEST_4=&#39;LOCATION=/u02/oracle/rbdb1/&#39;,MANDATORY,&#39;REOPEN=2&#39;3 COMMENT=&#39;Add new destination on Nov 29&#39;4 SCOPE=SPFILE;</code></pre><p>当一个参数值是由列表值组成，你不能通过位置或者次序数字来统计单个属性。在每次修改这个参数时必须指定一个完全列表值，新的完全列表可以替换旧的参数列表值。<br>清除初始化参数值</p><p>可以使用alter system reset命令来清除(删除)实例启动时所用的spfile文件中的任何参数设置，scope&#x3D;memory和scope&#x3D;both是不被允许的，scope&#x3D;spfile子句不被要求但可以包含。</p><p>你可能想清除spfile文件中的一个参数使其在下次启动时使用缺省参数值，这样做可能有以下几种原因:</p><p>1、为了诊断列出当前实例的所有参数值，可以使用show parameters命令或者查询v$parameter或v$parameter2视图；</p><p>2、为了修改服务器参数文件首先要将其导出创建成文本初始化参数文件再修改，修改后再使用create spfile命令从文本初始化参数文件来重新创建服务器参数文件；<br>导出的文本初始化参数文件pfile可以使用startup pfile命令来启动实例.</p><p>3、为了执行create pfile语句必须要有sysdba或sysoper系统权限，导出的文件在数据库服务器端生成，它可能包含了参数的注释并一起作为参数被设置；<br>下面的语句用来从spfile文件来创建pfile</p><pre><code class="sql">SQL&gt;create pfile from spfile;</code></pre><p>因为没有指定文件名，数据库将使用一个平台特定的文件名来创建一个文本初始化参数文件pfile，而且它是使用平台特定的缺省的服务器参数文件spfile来创建的</p><p>下面的语句用来从spfile文件来创建pfile,但是指定了文件名:</p><pre><code class="sql">SQL&gt;CREATE PFILE=&#39;/u01/oracle/dbs/test_init.ora&#39; FROM SPFILE=&#39;/u01/oracle/dbs/test_spfile.ora&#39;;</code></pre><p>注意:可以使用内存中的当前参数值来创建一个pfile文件.例如:</p><pre><code class="sql">SQL&gt;CREATE PFILE=&#39;/u01/oracle/dbs/test_init.ora&#39; FROM MEMORY;</code></pre><h2 id="备份服务器参数文件"><a href="#备份服务器参数文件" class="headerlink" title="备份服务器参数文件"></a>备份服务器参数文件</h2><p>可以通过导出的形式来备份服务器参数文件，如果你的数据库使用rman来实例备份和恢复策略，那么可以使用rman来创建一个spfile文件的备份。当使用rman备份数据库时spfile文件会自动备份,但是rman也能让你指定对当前活动的spfile创建一个备份.</p><p>恢复丢失或者损坏的服务器参数文件<br>如果服务器参数文件(spfile)丢失或者损坏了,那么当前实例可能会出现故障或者在下次启动实例时会失败.有下面几种方法来恢复spfile：<br>如果实例正在运行可以使用下面的命令从内存中使用当前参数值来重新创建一个服务器参数文件spfile</p><pre><code class="sql">SQL&gt;create spfile from memory;</code></pre><p>这个命令将在缺省位置使用缺省文件名来创建一个spfile文件，也可以指定新的目录和文件名。</p><p>如果你有一个有效的文本初始化参数文件(pfile),可以使用下面的命令从pfile文件来创建spfile。</p><pre><code class="sql">SQL&gt;create spfile from pfile;</code></pre><p>这个命令将在缺省位置使用缺省文件名来创建一个spfile文件，或者不使用缺省位置的缺省的pfile来创建的语句如下:</p><pre><code class="sql">SQL&gt;CREATE SPFILE=&#39;/u01/oracle/dbs/test_spfile.ora&#39; FROM PFILE=&#39;/u01/oracle/dbs/test_init.ora&#39;;</code></pre><h2 id="从备份中还原spfile"><a href="#从备份中还原spfile" class="headerlink" title="从备份中还原spfile"></a>从备份中还原spfile</h2><p>如果你的情况以上方法都不能使用,那么执行以下步骤来创建:<br>1、从告警日志(alert.log)中所列出的参数值来创建一个文本初始化参数文件(pfile)<br>当实例启动时所使用的初始化参数将会写入告警日志文件中.可以将这些参数信息复制到新的pfile文件中。<br>2、使用pfile文件来创建spfile</p><h2 id="在参数更新时出现读-写错误"><a href="#在参数更新时出现读-写错误" class="headerlink" title="在参数更新时出现读&#x2F;写错误"></a>在参数更新时出现读&#x2F;写错误</h2><h2 id="在参数被更新时如果读取或者写服务器参数文件出错，那么这个错误报告会被写入告警日志文件，且后继的对服务器参数文件的更新将会忽略，这时可以执行下面的操作-1）关闭实例，恢复服务器参数文件后再重新启动实例；2）如果不关心后继的参数修改是不是永久生效，可以继续运行数据库；查看参数设置可以使用以下几种方法来查看参数设置-sql"><a href="#在参数被更新时如果读取或者写服务器参数文件出错，那么这个错误报告会被写入告警日志文件，且后继的对服务器参数文件的更新将会忽略，这时可以执行下面的操作-1）关闭实例，恢复服务器参数文件后再重新启动实例；2）如果不关心后继的参数修改是不是永久生效，可以继续运行数据库；查看参数设置可以使用以下几种方法来查看参数设置-sql" class="headerlink" title="在参数被更新时如果读取或者写服务器参数文件出错，那么这个错误报告会被写入告警日志文件，且后继的对服务器参数文件的更新将会忽略，这时可以执行下面的操作:1）关闭实例，恢复服务器参数文件后再重新启动实例；2）如果不关心后继的参数修改是不是永久生效，可以继续运行数据库；查看参数设置可以使用以下几种方法来查看参数设置&#96;&#96;&#96;sql"></a>在参数被更新时如果读取或者写服务器参数文件出错，那么这个错误报告会被写入告警日志文件，且后继的对服务器参数文件的更新将会忽略，这时可以执行下面的操作:<br>1）关闭实例，恢复服务器参数文件后再重新启动实例；<br>2）如果不关心后继的参数修改是不是永久生效，可以继续运行数据库；<br>查看参数设置<br>可以使用以下几种方法来查看参数设置<br>&#96;&#96;&#96;sql</h2><h2 id="方法-描述"><a href="#方法-描述" class="headerlink" title="方法                                   描述"></a>方法                                   描述</h2><p>show parameters                       这个命令将会显示影响当前会话的初始化参数值</p><p>show spparameters                     这个命令将会显示服务器参数文件中的初始化参数值</p><p>create pfile                          这个命令将使用服务器参数文件或者内存中当前参数的值<br>                                      来创建一个文本初始化参数文件.可以使用任何文本编辑器<br>                                      来查看pfile</p><p>v$parameter                           这个视图将显示影响当前会话的初始化参数.使用视图更容易<br>                                      区分列表参数值因为每一个列表参数值显示为一行</p><p>v$system_parameter                    这个视图显示影响当前实例的初始化参数.一个新的会话会继承<br>                                      实例级别的参数值</p><p>v#system_parameter2                   这个视图显示影响当前实例的初始化参数.一个新的会话会继承<br>                                      实例级别的参数值,使用视图更容易区分列表参数值因为每一个<br>                                      列表参数值显示为一行</p><p>v$spparameter                         这个视图显示了spfile的当前内容.如果实例没有使用spfile启动<br>                                      这个视图在isspecified列返回false.</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-序列类型，range()</title>
      <link href="/2018/04/15/Python/Python-%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%EF%BC%8Crange()/"/>
      <url>/2018/04/15/Python/Python-%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%EF%BC%8Crange()/</url>
      
        <content type="html"><![CDATA[<h1 id="序列类型，range"><a href="#序列类型，range" class="headerlink" title="序列类型，range()"></a>序列类型，range()</h1><p>用于表示不可变的整数序列，内置函数<code>range()</code>创建<code>range</code>类型的对象，有三种调用方式<br>1、range(stop)<br>2、range(start, stop)<br>3、range(start, stop, step)</p><p>其中，整数序列的起始默认值为<code>0</code>，可以使用参数<code>start</code>指定；<br>可以使用参数<code>stop</code>指定整数序列的结束值；创建的<code>range</code>对象不包含<code>stop</code><br>整数㤡的步长默认是<code>1</code>，可以使用参数<code>step</code>指定；<br><code>range</code>对象的优点在于，不管<code>range</code>对象表示的整数序列有多长，所有<code>range</code>对象所占用的内存空间都是相同的，因为仅仅需要存储<code>start</code>、<code>stop</code>、<code>step</code>。只有当用到<code>range</code>对象时，才会去计算序列中的相关元素</p><p>内置函数<code>range</code>的返回值是一个迭代器对象，为了清楚地表示返回的迭代器对象所表示的整数序列，可以加将其转换为列表</p><pre><code class="python">&gt;&gt;&gt; print(list(range(20)))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]&gt;&gt;&gt;&gt;&gt;&gt; print(list(range(-20)))[]&gt;&gt;&gt;&gt;&gt;&gt; print(list(range(5, 20)))[5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]&gt;&gt;&gt; print(list(range(5, 20, 5)))[5, 10, 15]&gt;&gt;&gt; print(list(range(5, -20, -5)))[5, 0, -5, -10, -15]</code></pre><p>可以使用运算符<code>in</code>来检查<code>range</code>对象表示的整数序列中是否存在指定的整数</p><pre><code class="python">&gt;&gt;&gt; 3 in range(5)True&gt;&gt;&gt;&gt;&gt;&gt; 8 not in range(5)True</code></pre><p><code>start</code>参数必须比<code>stop</code>参数小，否则返回一个空列表</p><pre><code class="python">&gt;&gt;&gt; list(range(100, 5))[]&gt;&gt;&gt; list(range(-10, -50))[]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类对象特殊方法__len__、len()</title>
      <link href="/2018/04/15/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__len__%E3%80%81len()/"/>
      <url>/2018/04/15/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__len__%E3%80%81len()/</url>
      
        <content type="html"><![CDATA[<h1 id="类对象特殊方法-len-、len"><a href="#类对象特殊方法-len-、len" class="headerlink" title="类对象特殊方法__len__、len()"></a>类对象特殊方法__len__、len()</h1><p>内置函数len()用于返回对象的长度</p><pre><code class="python">&gt;&gt;&gt; len([1, 2, 3, 4, 5])5&gt;&gt;&gt; len(&#39;abcde&#39;)5&gt;&gt;&gt; len(&#123;&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3&#125;)3</code></pre><p>在上面的例子中，内置函数<code>len()</code>的实参都是内置类对象的实例对象，例如：<br><code>[1, 2, 3, 4, 5]</code>是内置类对象<code>list</code>的一个实例对象<br><code>&#123;&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3&#125;</code>是内置类对象<code>dict</code>的一个实例对象</p><p>内置函数<code>len()</code>的实参在默认情况下，不能是自定义类对象的实例对象，如果我们想要内置函数<code>len()</code>的实参可以是自定义类对象的实例对象，必须在自定义类对象中实现特殊方法<code>__len__()</code>。这样，调用内置函数<code>len()</code>时，在其内部会自动调用实参所对应类对象的特殊方法<code>__len__()</code>。</p><pre><code class="python">&gt;&gt;&gt; class MyClass(object):...     pass...&gt;&gt;&gt;&gt;&gt;&gt; len(MyClass())Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: object of type &#39;MyClass&#39; has no len()&gt;&gt;&gt;&gt;&gt;&gt; class MyClass(object):...     def __len__(self):...         return 20...&gt;&gt;&gt; len(MyClass())20</code></pre><p>之所以内置函数<code>len()</code>的实参可以使上述内置类对象的实例对象，是因为上述的内置独享中都实现了特殊方法<code>__len__()</code>。</p><pre><code class="python">&gt;&gt;&gt; dir(list)[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__delslice__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getslice__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__iadd__&#39;, &#39;__imul__&#39;, &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__reversed__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__setslice__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;append&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39;]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dir(dict)[&#39;__class__&#39;, &#39;__cmp__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;fromkeys&#39;, &#39;get&#39;, &#39;has_key&#39;, &#39;items&#39;, &#39;iteritems&#39;, &#39;iterkeys&#39;, &#39;itervalues&#39;, &#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;setdefault&#39;, &#39;update&#39;, &#39;values&#39;, &#39;viewitems&#39;, &#39;viewkeys&#39;, &#39;viewvalues&#39;]&gt;&gt;&gt;&gt;&gt;&gt; dir(str)[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__getslice__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;_formatter_field_name_split&#39;, &#39;_formatter_parser&#39;, &#39;capitalize&#39;, &#39;center&#39;, &#39;count&#39;, &#39;decode&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isdigit&#39;, &#39;islower&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类对象特殊方法__str__()、__repr__()</title>
      <link href="/2018/04/11/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__str__()%E3%80%81__repr__()/"/>
      <url>/2018/04/11/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__str__()%E3%80%81__repr__()/</url>
      
        <content type="html"><![CDATA[<h1 id="类对象特殊方法-str-和-repr"><a href="#类对象特殊方法-str-和-repr" class="headerlink" title="类对象特殊方法__str__()和__repr__()"></a>类对象特殊方法<code>__str__()</code>和<code>__repr__()</code></h1><p>用于自定义并返回实例对象的字符串表示形式</p><p>内置函数str()和repr()都返回对象的字符串表示，其区别在于：<br>str()的返回值是给用户看的，更加用户友好；<br>repr()的返回值是给程序开发看的，是为调试服务的；</p><p>1、当在交互式命令行中直接打印一个实例对象时</p><ul><li>如果在实例对象对应的类对象中实现了特殊方法<code>__repr__()</code>，会自动调用该方法；</li><li>否则，会打印实例对象对应的类对象在内存中的地址。</li></ul><pre><code class="python">&gt;&gt;&gt; class MyClass(object):...     pass...&gt;&gt;&gt; mc = MyClass()&gt;&gt;&gt; mc&lt;__main__.MyClass object at 0x7f2c301f9470&gt;&gt;&gt;&gt;&gt;&gt;&gt; print(mc)&lt;__main__.MyClass object at 0x7f2c301f9470&gt;&gt;&gt;&gt;&gt;&gt;&gt; str(mc)&#39;&lt;__main__.MyClass object at 0x7f2c301f9470&gt;&#39;&gt;&gt;&gt;&gt;&gt;&gt; repr(mc)&#39;&lt;__main__.MyClass object at 0x7f2c301f9470&gt;&#39;</code></pre><p>2、当调用内置函数print打印一个实例对象时</p><ul><li>如果在实例对象对应的类对象中实现了特殊方法<code>__str__()</code>，会自动调用<code>__str__()</code>方法；</li><li>否则，如果在实例对象对应的类对象实现了特殊方法<code>__repr__()</code>，会自动调用<code>__repr__()</code>方法；</li><li>否则，会打印实例对象对应的类对象在内存中的地址。</li></ul><pre><code class="python">&gt;&gt;&gt; class MyClass2(object):...     def __str__(self):...         return &#39;__str__()被调用了&#39;...&gt;&gt;&gt; mc2 = MyClass2()&gt;&gt;&gt;&gt;&gt;&gt; mc2&lt;__main__.MyClass2 object at 0x7f2c301f95f8&gt;&gt;&gt;&gt;&gt;&gt;&gt; print(mc2)__str__()被调用了&gt;&gt;&gt;&gt;&gt;&gt; str(mc2)&#39;__str__()被调用了&#39;&gt;&gt;&gt;&gt;&gt;&gt; repr(mc2)&#39;&lt;__main__.MyClass2 object at 0x7f2c301f95f8&gt;&#39;</code></pre><p>3、当调用内置函数str创建字符串，并且实参时一个实例对象时</p><ul><li>如果在实例对象的类对象中实现了特殊方法<code>__str__()</code>，在内置函数str的内部会自动调用<code>__str__()</code>方法；</li><li>否则，如果在实例对象对应的类对象中实现了特殊方法<code>__repr__()</code>，在内置函数str的内部会自动调用<code>__repr__()</code>方法；</li><li>否则，会打印实例对象对应的类对象和实例对象在内存中的地址</li></ul><pre><code class="python">&gt;&gt;&gt; class MyClass3(object):...     def __repr__(self):...         return &#39;__repr__()被调用了&#39;...&gt;&gt;&gt; mc3 = MyClass3()&gt;&gt;&gt; mc3__repr__()被调用了&gt;&gt;&gt;&gt;&gt;&gt; print(mc3)__repr__()被调用了&gt;&gt;&gt;&gt;&gt;&gt; str(mc3)&#39;__repr__()被调用了&#39;&gt;&gt;&gt;&gt;&gt;&gt; repr(mc3)&#39;__repr__()被调用了&#39;</code></pre><p>4、当调用内置函数repr创建字符串，并且实参时一个实例对象时</p><ul><li>如果在实例对象的类对象中实现了特殊方法<code>__repr__()</code>，在内置函数str的内部会自动调用<code>__repr__()</code>方法；</li><li>否则，会打印实例对象对应的类对象和实例对象在内存中的地址</li></ul><pre><code class="python">&gt;&gt;&gt; class MyClass4(object):...     def __str__(self):...         return &#39;__str__()被调用了&#39;...     def __repr__(self):...         return &#39;__repr__()被调用了&#39;...&gt;&gt;&gt; mc4 = MyClass4()&gt;&gt;&gt; mc4__repr__()被调用了&gt;&gt;&gt;&gt;&gt;&gt; print(mc4)__str__()被调用了&gt;&gt;&gt;&gt;&gt;&gt; str(mc4)&#39;__str__()被调用了&#39;&gt;&gt;&gt;&gt;&gt;&gt; repr(mc4)&#39;__repr__()被调用了&#39;</code></pre><p><img src="/images/6c896575-d7bd-477a-898d-ebc2846b0b0d-image.png" alt="6c896575-d7bd-477a-898d-ebc2846b0b0d-image.png" title="6c896575-d7bd-477a-898d-ebc2846b0b0d-image.png"></p><p>通常<code>__str__()</code>和<code>__repr__()</code>实现代码是一样的，因此我们可以将定义的其中一个的方法名赋值给另外一个方法名</p><pre><code class="python">#!/usr/bin/python3class MyClass5(object):    def __str__(self):        return &#39;xxx&#39;    __repr__ = __str__</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库startup和shutdown方式</title>
      <link href="/2018/04/11/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93startup%E5%92%8Cshutdown%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/04/11/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93startup%E5%92%8Cshutdown%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle数据库startup和shutdown方式"><a href="#Oracle数据库startup和shutdown方式" class="headerlink" title="Oracle数据库startup和shutdown方式"></a>Oracle数据库startup和shutdown方式</h1><p>要启动和关闭数据库，必须要以具有Oracle 管理员权限用户登陆，通常也就是以具有SYSDBA权限用户登陆。一般我们常用INTERNAL用户来启动和关闭数据库（INTERNAL用户实际上是SYS用户以SYSDBA连接同义词）。Oracle数据库新版本将逐步淘汰INTERNAL这个内部用户，所以我们最还是设置DBA用户具有SYSDBA权限。</p><h2 id="启动一个数据库需要三个步骤"><a href="#启动一个数据库需要三个步骤" class="headerlink" title="启动一个数据库需要三个步骤"></a>启动一个数据库需要三个步骤</h2><p>　　1、 创建一个Oracle实例（非安装阶段）<br>　　2、 由实例安装数据库（安装阶段）<br>    3、 打开数据库（打开阶段）</p><h2 id="Startup（启动数据库命令）"><a href="#Startup（启动数据库命令）" class="headerlink" title="Startup（启动数据库命令）"></a>Startup（启动数据库命令）</h2><p>1、 STARTUP NOMOUNT<br>NONOUNT选项仅仅创建一个Oracle实例。读取init.ora初始化参数文件、启动后台进程、初始化系统全局区（SGA）。Init.ora文件定义了实例配置，包括内存结构大小和启动后台进程数量和类型等。实例名根据Oracle_SID设置，不一定要与打开数据库名称相同。当实例打开后，系统将显示一个SGA内存结构和大小列表，如下所示：</p><pre><code class="sql">SQL&gt; startup nomountORACLE 例程已经启动。Total System Global Area 35431692 bytesFixed Size 70924 bytesVariable Size 18505728 bytesDatabase Buffers 16777216 bytesuRedo Buffers 77824 bytes</code></pre><p>2、STARTUP MOUNT<br>该命令创建实例并且安装数据库，但没有打开数据库。Oracle系统读取控制文件中关于数据文件和重作日志文件内容，但并不打开该文件。这种打开方式常在数据库维护操作中使用，如对数据文件更名、改变重作日志以及打开归档方式等。在这种打开方式下，除了可以看到SGA系统列表以外，系统还会给出”数据库装载完毕”提示。</p><p>3、STARTUP<br>该命令完成创建实例、安装实例和打开数据库所有三个步骤。此时数据库使数据文件和重作日志文件在线，通常还会请求一个或者是多个回滚段。这时系统除了可以看到前面Startup Mount方式下所有提示外，还会给出一个”数据库已经打开”提示。此时，数据库系统处于正常工作状态，可以接受用户请求。</p><p>如果采用STARTUP NOMOUNT或者是STARTUP MOUNT数据库打开命令方式，必须采用ALTER DATABASE命令来执行打开数据库操作。例如，如果你以STARTUP NOMOUNT方式打开数据库，也就是说实例已经创建，但是数据库没有安装和打开。这是必须运行下面两条命令，数据库才能正确启动。</p><pre><code class="sql">ALTER DATABASE MOUNT;ALTER DATABASE OPEN</code></pre><p>4、其他打开方式<br>　　除了前面介绍三种数据库打开方式选项外，还有另外其他一些选项。<br>　　(1) STARTUP RESTRICT<br>　　这种方式下，数据库将被成功打开，但仅仅允许一些特权用户（具有DBA角色用户）才可以使用数据库。这种方式常用来对数据库进行维护，如数据导入&#x2F;导出操作时不希望有其他用户连接到数据库操作数据。<br>　　(2) STARTUP FORCE<br>　　该命令其实是强行关闭数据库（shutdown abort）和启动数据库（startup）两条命令一个综合。该命令仅在关闭数据库遇到问题不能关闭数据库时采用。<br>　　(3) ALTER DATABASE OPEN READ ONLY;<br>　　该命令在创建实例以及安装数据库后，以只读方式打开数据库。对于那些仅仅提供查询功能产品数据库可以采用这种方式打开。</p><h2 id="数据库关闭（SHUTDOWN）"><a href="#数据库关闭（SHUTDOWN）" class="headerlink" title="数据库关闭（SHUTDOWN）"></a>数据库关闭（SHUTDOWN）</h2><p>1、SHUTDOWN NORMAL<br>　　这是数据库关闭SHUTDOWN命令确省选项。也就是说如果你发出SHUTDOWN这样命令，也即是SHUTDOWN NORNAL意思。<br>　　发出该命令后，任何新连接都将再不允许连接到数据库。在数据库关闭之前，Oracle将等待目前连接所有用户都从数据库中退出后才开始关闭数据库。采用这种方式关闭数据库，在下一次启动时不需要进行任何实例恢复。但需要注意一点是，采用这种方式，也许关闭一个数据库需要几天时间，也许更长。</p><p>2、SHUTDOWN IMMEDIATE<br>　　这是我们常用一种关闭数据库方式，想很快地关闭数据库，但又想让数据库干净关闭，常采用这种方式。<br>　　当前正在被Oracle处理SQL语句立即中断，系统中任何没有提交事务全部回滚。如果系统中存在一个很长未提交事务，采用这种方式关闭数据库也需要一段时间（该事务回滚时间）。系统不等待连接到数据库所有用户退出系统，强行回滚当前所有活动事务，然后断开所有连接用户。</p><p>3、SHUTDOWN TRANSACTIONAL<br>　　该选项仅在Oracle 8i后才可以使用。该命令常用来计划关闭数据库，它使当前连接到系统且正在活动事务执行完毕，运行该命令后，任何新连接和事务都是不允许。在所有活动事务完成后，数据库将和SHUTDOWN IMMEDIATE同样方式关闭数据库。</p><p>4、SHUTDOWN ABORT<br>　　这是关闭数据库最后一招，也是在没有任何办法关闭数据库情况下才不得不采用方式，一般不要采用。如果下列情况出现时可以考虑采用这种方式关闭数据库。</p><h2 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h2><pre><code class="sql">SQL&gt; conn /as sysdbaSQL&gt; alter database mount;SQL&gt; alter database open;</code></pre><h2 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h2><pre><code class="sql">SQL&gt; shutdown immediate;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约束类型</title>
      <link href="/2018/04/06/Mysql/%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/04/06/Mysql/%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h1><h2 id="从查询information-schema中查询指定表中的约束"><a href="#从查询information-schema中查询指定表中的约束" class="headerlink" title="从查询information_schema中查询指定表中的约束"></a>从查询information_schema中查询指定表中的约束</h2><pre><code class="sql">mysql&gt; USE INFORMATION_SCHEMA;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; SELECT CONSTRAINT_NAME FROM TABLE_CONSTRAINTS WHERE TABLE_NAME=&#39;t1&#39;;+-----------------+| CONSTRAINT_NAME |+-----------------+| PRIMARY         |+-----------------+1 row in set (0.01 sec)</code></pre><h2 id="主键约束-PRIMARY-KEY"><a href="#主键约束-PRIMARY-KEY" class="headerlink" title="主键约束 PRIMARY KEY"></a>主键约束 PRIMARY KEY</h2><p>添加主键约束</p><ol><li><p>建表时直接添加</p><pre><code class="sql">CREATE TABLE t_user(    user_id INT(10) PRIMARY KEY,    ...);CREATE TABLE t_user(    user_id INT(10),    PRIMARY KEY(user_id));CREATE TABLE t_user(    user_id INT(10),    user_name VARCHAR(30),    CONSTRAINT PK_ID_NAME PRIMARY KEY(user_id,user_name));</code></pre></li><li><p>通过ALTER语句</p><pre><code class="sql">ALTER TABLE t_user ADD PRIMARY KEY(user_id);ALTER TABLE t_user ADD CONSTRAINT PK_ID_NAME PRIMARY KEY(user_id);</code></pre><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10) PRIMARY KEY;</code></pre><blockquote><p>中间的INT(10)不可少，否则报错</p></blockquote><pre><code class="sql">ALTER TABLE t_user CHANGE user_id user_id INT(10) PRIMARY KEY;</code></pre><blockquote><p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。</p></blockquote></li></ol><p>删除主键约束</p><pre><code class="sql">ALTER TABLE t_user DROP PRIMARY KEY;</code></pre><blockquote><p>注：主键约束相当于(唯一约束+非空约束)<br>一张表中最多有一个主键约束,如果设置多个主键,就会出现如下提示：<br>Multiple primary key defined!!!<br>删除主键约束前，如果有自增长需要先删除自增长,如果不删除自增长就无法删除主键约束</p></blockquote><h2 id="唯一约束-UNIQUE"><a href="#唯一约束-UNIQUE" class="headerlink" title="唯一约束 UNIQUE"></a>唯一约束 UNIQUE</h2><p>添加唯一约束</p><ol><li><p>建表时直接添加</p><pre><code class="sql">CREATE TABLE t_user(user_id INT(10) UNIQUE);CREATE TABLE t_user(    user_id INT(10),    UNIQUE KEY(user_id));CREATE TABLE t_user(    user_id INT(10),    user_name VARCHAR(30),    CONSTRAINT UN_PHONE_EMAIL UNIQUE(user_id,user_name));</code></pre></li><li><p>通过ALTER语句</p><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10) UNIQUE;ALTER TABLE t_user CHANGE user_id user_id INT(10) UNIQUE;ALTER TABLE t_user ADD UNIQUE(user_id);ALTER TABLE t_user ADD UNIQUE KEY(user_id);ALTER TABLE t_user ADD CONSTRAINT UN_ID UNIQUE(user_id);ALTER TABLE t_user ADD CONSTRAINT UN_ID UNIQUE KEY(user_id);</code></pre></li></ol><p>删除唯一性约束</p><pre><code class="sql">ALTER TABLE t_user DROP INDEX user_id;</code></pre><blockquote><p>唯一但是可以为空(空和空不相等)</p></blockquote><h2 id="非空约束-NOT-NULL"><a href="#非空约束-NOT-NULL" class="headerlink" title="非空约束 NOT NULL"></a>非空约束 NOT NULL</h2><p>添加非空约束</p><ol><li><p>建表时直接添加</p><pre><code class="sql">CREATE TABLE t_user(user_id INT(10) NOT NULL);</code></pre></li><li><p>通过ALTER 语句</p><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10) NOT NULL;ALTER TABLE t_user CHANGE user_id user_id INT(10) NOT NULL;</code></pre></li></ol><p>删除非空约束</p><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10);ALTER TABLE t_user CHANGE user_id user_id INT(10);</code></pre><h2 id="自增长约束-AUTO-INCREMENT"><a href="#自增长约束-AUTO-INCREMENT" class="headerlink" title="自增长约束 AUTO_INCREMENT"></a>自增长约束 AUTO_INCREMENT</h2><p>添加自增长约束</p><ol><li><p>在创建表的时候添加</p><pre><code class="sql">CREATE TABLE t_user(user_id INT(10) AUTO_INCREMENT PRIMARY KEY);</code></pre></li><li><p>通过ALTER语句</p><pre><code class="sql">   ALTER TABLE t_user MODIFY user_id INT(10) AUTO_INCREMENT;ALTER TABLE t_user CHANGE user_id user_id INT(10) AUTO_INCREMENT;</code></pre></li></ol><p>删除自增长约束</p><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10);ALTER TABLE t_user CHANGE user_id user_id INT(10);</code></pre><blockquote><p>一张表只能有一个自增长列，并且该列必须定义了约束(可以是主键约束,也可以是唯一约束,也可以是外键约束,但是不可以是非空和检查约束)<br>不过自增长一般配合主键使用，并且只能在数字类型中使用</p></blockquote><h2 id="外键约束-FOREIGN-KEY"><a href="#外键约束-FOREIGN-KEY" class="headerlink" title="外键约束 FOREIGN KEY"></a>外键约束 FOREIGN KEY</h2><p>对应的字段只能是主键或者唯一约束修饰的字段<br>创建外键约束<br>主表：</p><pre><code class="sql">CREATE TABLE class(    cla_id INT(6) AUTO_INCREMENT PRIMARY KEY,    cla_name VARCHAR(30) NOT NULL UNIQUE);</code></pre><p>从表：</p><pre><code class="sql">CREATE TABLE students(    stu_id INT(10) AUTO_INCREMENT PRIMARY KEY,    stu_name VARCHAR(30) NOT NULL,    stu_score FLOAT(5,2) DEFAULT 0.0,    cla_id INT(10),    CONSTRAINT FK_CLA_ID FOREIGN KEY(cla_id) REFERENCES class(cla_id) ##添加外键约束);</code></pre><p>也可以这样添加：</p><pre><code class="sql">ALTER TABLE students ADD CONSTRAINT FK_CLA_ID FROEIGN KEY(cla_id) REFERENCES class(cla_id);</code></pre><p>删除外键约束</p><pre><code class="sql">ALTER TABLE students DROP FOREIGN KEY FK_CLA_ID;</code></pre><p>外键中的级联关系有以下几种情况：</p><ul><li>ON DELETE CASCADE 删除主表中的数据时，从表中的数据随之删除</li><li>ON UPDATE CASCADE 更新主表中的数据时，从表中的数据随之更新</li><li>ON DELETE SET NULL 删除主表中的数据时，从表中的数据置为空</li><li>默认 删除主表中的数据前需先删除从表中的数据，否则主表数据不会被删除</li></ul><p><strong>ON DELETE CASCADE</strong></p><pre><code class="sql">CREATE TABLE students(    stu_id INT(10) AUTO_INCREMENT PRIMARY KEY,    stu_name VARCHAR(30) NOT NULL,    stu_score FLOAT(5,2) DEFAULT 0.0,    cla_id INT(10),    CONSTRAINT FK_CLA_ID FOREIGN KEY(cla_id) REFERENCES class(cla_id) ON DELETE CASCADE);</code></pre><p><strong>ON UPDATE CASCADE</strong></p><pre><code class="sql">CREATE TABLE students(    stu_id INT(10) AUTO_INCREMENT PRIMARY KEY,    stu_name VARCHAR(30) NOT NULL,    stu_score FLOAT(5,2) DEFAULT 0.0,    cla_id INT(10),    CONSTRAINT FK_CLA_ID FOREIGN KEY(cla_id) REFERENCES class(cla_id) ON UPDATE CASCADE);</code></pre><p><strong>ON DELETE SET NULL</strong></p><pre><code class="sql">CREATE TABLE students(    stu_id INT(10) AUTO_INCREMENT PRIMARY KEY,    stu_name VARCHAR(30) NOT NULL,    stu_score FLOAT(5,2) DEFAULT 0.0,    cla_id INT(10),    CONSTRAINT FK_CLA_ID FOREIGN KEY(cla_id) REFERENCES class(cla_id) ON DELETE SET NULL);</code></pre><blockquote><p>插入数据时，先插入主表中的数据，再插入从表中的数据。<br>删除数据时，先删除从表中的数据，再删除主表中的数据。</p></blockquote><h2 id="默认约束-DEFAULT"><a href="#默认约束-DEFAULT" class="headerlink" title="默认约束 DEFAULT"></a>默认约束 DEFAULT</h2><p>添加默认约束</p><ol><li><p>在创建表的时候添加</p><pre><code class="sql">CREATE TABLE t_user(user_id INT(10) DEFAULT  3);</code></pre></li><li><p>通过ALTER语句</p><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10) DEFAULT  2;ALTER TABLE t_user CHANGE user_id user_id INT(10) DEFAULT  2;</code></pre></li></ol><p>删除默认约束</p><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10);ALTER TABLE t_user CHANGE user_id user_id INT(10);</code></pre><h2 id="无符号位-UNSIGNED"><a href="#无符号位-UNSIGNED" class="headerlink" title="无符号位 UNSIGNED"></a>无符号位 UNSIGNED</h2><p>添加无符号</p><ol><li>在创建表的时候添加<pre><code class="sql">CREATE TABLE t_user(user_id INT(10) UNSIGNED);</code></pre></li><li>通过ALTER语句<pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10) UNSIGNED;ALTER TABLE t_user CHANGE user_id user_id INT(10) UNSIGNED;</code></pre></li></ol><p>删除无符号</p><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10);ALTER TABLE t_user CHANGE user_id user_id INT(10);</code></pre><h2 id="零填充-ZEROFILL"><a href="#零填充-ZEROFILL" class="headerlink" title="零填充 ZEROFILL"></a>零填充 ZEROFILL</h2><p>添加零填充</p><ol><li><p>在创建表的时候添加</p><pre><code class="sql">CREATE TABLE t_user(user_id INT(10) ZEROFILL);</code></pre></li><li><p>通过ALTER语句</p><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10) ZEROFILL;ALTER TABLE t_user CHANGE user_id user_id INT(10) ZEROFILL;</code></pre></li></ol><p>删除零填充</p><pre><code class="sql">ALTER TABLE t_user MODIFY user_id INT(10);ALTER TABLE t_user CHANGE user_id user_id INT(10);</code></pre><blockquote><p>零填充会将未将有效位以外的位用零来显示,比如某字段数据类型为INT(5),而插入的值为2,那么零填充会显示00002<br>但是，这个效果在Navicat for MySQL中显示不出来,只有在DOS窗口下才能显示</p></blockquote><h2 id="检查约束-CHECK"><a href="#检查约束-CHECK" class="headerlink" title="检查约束 CHECK"></a>检查约束 CHECK</h2><pre><code class="sql">CREATE TABLE class(    cla_id INT(6) AUTO_INCREMENT PRIMARY KEY,    cla_name VARCHAR(30) NOT NULL UNIQUE,    CHECK(cla_id&gt;0));</code></pre><blockquote><p>mysql不支持检查约束，但是写上检查约束不会报错</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-钻石继承树</title>
      <link href="/2018/04/06/Python/Python-%E9%92%BB%E7%9F%B3%E7%BB%A7%E6%89%BF%E6%A0%91/"/>
      <url>/2018/04/06/Python/Python-%E9%92%BB%E7%9F%B3%E7%BB%A7%E6%89%BF%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="钻石继承树"><a href="#钻石继承树" class="headerlink" title="钻石继承树"></a>钻石继承树</h1><p><img src="/images/f1b80e02-b435-4fcb-be7c-8e97049cef91-Image.png" alt="f1b80e02-b435-4fcb-be7c-8e97049cef91-Image.png" title="f1b80e02-b435-4fcb-be7c-8e97049cef91-Image.png"></p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    def __init__(self):        print(&#39;ParentClass的__init__方法被调用了&#39;)class ParentClass1(ParentClass):    def __init__(self):        ParentClass.__init__(self)        print(&#39;ParentClass1的__init__方法被调用了&#39;)class ParentClass2(ParentClass):    def __init__(self):        ParentClass.__init__(self)        print(&#39;ParentClass2的__init__方法被调用了&#39;)class ChildClass(ParentClass1, ParentClass2):    def __init__(self):        ParentClass1.__init__(self)        ParentClass2.__init__(self)        print(&#39;ChildClass的__init__方法被调用了&#39;)print(ChildClass.mro())d = ChildClass()</code></pre><pre><code class="python">[root@lyucan ~]# ./20.py[&lt;class &#39;__main__.ChildClass&#39;&gt;, &lt;class &#39;__main__.ParentClass1&#39;&gt;, &lt;class &#39;__main__.ParentClass2&#39;&gt;, &lt;class &#39;__main__.ParentClass&#39;&gt;, &lt;class &#39;object&#39;&gt;]ParentClass的__init__方法被调用了          # ParentClass被调用了两次ParentClass1的__init__方法被调用了ParentClass的__init__方法被调用了          # ParentClass被调用了两次ParentClass2的__init__方法被调用了ChildClass的__init__方法被调用了</code></pre><p>使用super()方法调用父类中被重写的方法</p><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    def __init__(self):        print(&#39;ParentClass的__init__方法被调用了&#39;)class ParentClass1(ParentClass):    def __init__(self):        super().__init__()        print(&#39;ParentClass1的__init__方法被调用了&#39;)class ParentClass2(ParentClass):    def __init__(self):        super().__init__()        print(&#39;ParentClass2的__init__方法被调用了&#39;)class ChildClass(ParentClass1, ParentClass2):    def __init__(self):        super().__init__()        print(&#39;ChildClass的__init__方法被调用了&#39;)print(ChildClass.mro())d = ChildClass()</code></pre><pre><code class="python">[root@lyucan ~]# ./21.py[&lt;class &#39;__main__.ChildClass&#39;&gt;, &lt;class &#39;__main__.ParentClass1&#39;&gt;, &lt;class &#39;__main__.ParentClass2&#39;&gt;, &lt;class &#39;__main__.ParentClass&#39;&gt;, &lt;class &#39;object&#39;&gt;]ParentClass的__init__方法被调用了        # ParentClass只被调用了一次ParentClass2的__init__方法被调用了ParentClass1的__init__方法被调用了ChildClass的__init__方法被调用了</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyhton-反射</title>
      <link href="/2018/04/02/Python/Pyhton-%E5%8F%8D%E5%B0%84/"/>
      <url>/2018/04/02/Python/Pyhton-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="获取对象信息——反射（hasattr-、getattr-、setattr-、delattr-）"><a href="#获取对象信息——反射（hasattr-、getattr-、setattr-、delattr-）" class="headerlink" title="获取对象信息——反射（hasattr()、getattr()、setattr()、delattr()）"></a>获取对象信息——反射（hasattr()、getattr()、setattr()、delattr()）</h1><p>所谓反射，指的是以字符串的形式来操作（增删改查）对象的属性或方法。<br>只有在不知道对象信息的情况下，才回去获取对象信息，因此若果可以直接写object.name，就不要写为getattr(object, ‘name’)</p><p>用于反射的内置函数有以下四个（参数name都是一个字符串）：</p><h2 id="1、hasattr-object-‘name’"><a href="#1、hasattr-object-‘name’" class="headerlink" title="1、hasattr(object, ‘name’)"></a>1、hasattr(object, ‘name’)</h2><p> 用于判断指定的对象object是否有参数name指定的属性或方法。返回值为布尔值</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    ca = &#39;ca&#39;    def __init__(self):        self.x = 1    def im(self):        print(&#39;im被调用了&#39;)    @classmethod    def cm(cls):        print(&#39;cm被调用了&#39;)    @staticmethod    def sm():        print(&#39;sm被调用了&#39;)print(&#39;# 类对象包含的属性和方法&#39;)print(dir(MyClass))print(&#39;&#39;)print(hasattr(MyClass, &#39;ca&#39;))           # 类对象可以访问类属性，返回Trueprint(hasattr(MyClass, &#39;x&#39;))            # 类对象不能访问实例属性，返回Falseprint(hasattr(MyClass, &#39;__init__&#39;))     # 类对象可以访问实例方法，返回Trueprint(hasattr(MyClass, &#39;im&#39;))           # 类对象可以访问实例方法，返回Trueprint(hasattr(MyClass, &#39;cm&#39;))           # 类对象可以访问类方法，返回Trueprint(hasattr(MyClass, &#39;sm&#39;))           # 类对象可以访问静态方法，返回Trueprint(&#39;&#39;)print(&#39;# 实例对象包含的属性和方法&#39;)print(dir(MyClass()))print(&#39;&#39;)print(hasattr(MyClass(), &#39;ca&#39;))         #实例对象可以访问类属性，返回Trueprint(hasattr(MyClass(), &#39;x&#39;))          #实例对象可以访问实例属性，返回Trueprint(hasattr(MyClass(), &#39;__init__&#39;))   #实例对象可以访问实例方法，返回Trueprint(hasattr(MyClass(), &#39;im&#39;))         #实例对象可以访问实例方法，返回Trueprint(hasattr(MyClass(), &#39;cm&#39;))         #实例对象可以访问类方法，返回Trueprint(hasattr(MyClass(), &#39;sm&#39;))         #实例对象可以访问静态方法，返回True</code></pre><pre><code class="python">[root@lyucan ~]# ./hasattr.py# 类对象包含的属性和方法[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;ca&#39;, &#39;cm&#39;, &#39;im&#39;, &#39;sm&#39;]TrueFalseTrueTrueTrueTrue# 实例对象包含的属性和方法[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;ca&#39;, &#39;cm&#39;, &#39;im&#39;, &#39;sm&#39;, &#39;x&#39;]TrueTrueTrueTrueTrueTrue</code></pre><h2 id="2、getattr-object-‘name’-default"><a href="#2、getattr-object-‘name’-default" class="headerlink" title="2、getattr(object, ‘name’[, default])"></a>2、getattr(object, ‘name’[, default])</h2><p>用于获取指定的对象object中名为name的属性或方法。返回的是对象，可以将其赋值给一个变量，使用变量直接引用。<br>如果不指定参数default，那么当object中不存在名为name的属性或方法时，抛出AttributeError。<br>如果制定了参数default，那么当object中不存在名为name的属性或方法时，就会返回default。<br>getattr(object, name)等价于：object.name。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    ca = &#39;ca&#39;    def __init__(self):        self.x = 1    def im(self):        print(&#39;im被调用了&#39;)    @classmethod    def cm(cls):        print(&#39;cm被调用了&#39;)    @staticmethod    def sm():        print(&#39;sm被调用了&#39;)print(&#39;# 类对象包含的属性和方法&#39;)print(dir(MyClass))print(&#39;&#39;)print(getattr(MyClass, &#39;ca&#39;))#print(getattr(MyClass, &#39;x&#39;))print(getattr(MyClass, &#39;__init__&#39;))print(getattr(MyClass, &#39;im&#39;))print(getattr(MyClass, &#39;cm&#39;))print(getattr(MyClass, &#39;sm&#39;))print(&#39;&#39;)print(&#39;# 实例对象包含的属性和方法&#39;)print(dir(MyClass()))print(&#39;&#39;)print(getattr(MyClass(), &#39;ca&#39;))print(getattr(MyClass(), &#39;x&#39;))print(getattr(MyClass(), &#39;__init__&#39;))print(getattr(MyClass(), &#39;im&#39;))print(getattr(MyClass(), &#39;cm&#39;))print(getattr(MyClass(), &#39;sm&#39;))</code></pre><pre><code class="python">[root@lyucan ~]# ./getattr.py# 类对象包含的属性和方法[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;ca&#39;, &#39;cm&#39;, &#39;im&#39;, &#39;sm&#39;]ca&lt;function MyClass.__init__ at 0x7f69bd143bf8&gt;&lt;function MyClass.im at 0x7f69bd143c80&gt;&lt;bound method MyClass.cm of &lt;class &#39;__main__.MyClass&#39;&gt;&gt;&lt;function MyClass.sm at 0x7f69bd143d90&gt;# 实例对象包含的属性和方法[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;ca&#39;, &#39;cm&#39;, &#39;im&#39;, &#39;sm&#39;, &#39;x&#39;]ca1&lt;bound method MyClass.__init__ of &lt;__main__.MyClass object at 0x7f69bd1dc828&gt;&gt;&lt;bound method MyClass.im of &lt;__main__.MyClass object at 0x7f69bd1dc828&gt;&gt;&lt;bound method MyClass.cm of &lt;class &#39;__main__.MyClass&#39;&gt;&gt;&lt;function MyClass.sm at 0x7f69bd143d90&gt;</code></pre><h2 id="3、setattr-object-‘name’-value"><a href="#3、setattr-object-‘name’-value" class="headerlink" title="3、setattr(object, ‘name’, value)"></a>3、setattr(object, ‘name’, value)</h2><p>用于在指定的对象object中添加或修改名为name的属性或方法，添加或修改后的值为value。<br>setattr(object, name, value)等价于：object.name &#x3D; value。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    ca = &#39;ca&#39;    def __init__(self):        self.x = 1    def im(self):        print(&#39;im被调用了&#39;)    @classmethod    def cm(cls):        print(&#39;cm被调用了&#39;)    @staticmethod    def sm():        print(&#39;sm被调用了&#39;)mc = MyClass()setattr(mc, &#39;new&#39;, 11)print(getattr(mc, &#39;new&#39;))</code></pre><pre><code class="python">[root@lyucan ~]# ./setattr.py11</code></pre><h2 id="4、delattr-object-‘name’"><a href="#4、delattr-object-‘name’" class="headerlink" title="4、delattr(object, ‘name’)"></a>4、delattr(object, ‘name’)</h2><p>用于删除指定的对象object中名为参数name的属性或方法。<br>delattr(object, ‘name’)等价于：del object.name</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    ca = &#39;ca&#39;    def __init__(self):        self.x = 1    def im(self):        print(&#39;im被调用了&#39;)    @classmethod    def cm(cls):        print(&#39;cm被调用了&#39;)    @staticmethod    def sm():        print(&#39;sm被调用了&#39;)mc = MyClass()setattr(mc, &#39;new&#39;, 11)print(getattr(mc, &#39;new&#39;))delattr(mc, &#39;new&#39;)             # 删除了mc实例对象的new属性print(getattr(mc, &#39;new&#39;, &#39;mc实例对象没有new属性&#39;))</code></pre><pre><code class="python">[root@lyucan ~]# ./delattr.py11mc实例对象没有new属性            # 没有属性才会打印这行信息</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle网络之listener.ora、tnsnames.ora、sqlnet.ora</title>
      <link href="/2018/03/24/Oracle/oracle%E7%BD%91%E7%BB%9C%E4%B9%8Blistener.ora%E3%80%81tnsnames.ora%E3%80%81sqlnet.ora/"/>
      <url>/2018/03/24/Oracle/oracle%E7%BD%91%E7%BB%9C%E4%B9%8Blistener.ora%E3%80%81tnsnames.ora%E3%80%81sqlnet.ora/</url>
      
        <content type="html"><![CDATA[<h1 id="oracle网络之listener-ora、tnsnames-ora、sqlnet-ora"><a href="#oracle网络之listener-ora、tnsnames-ora、sqlnet-ora" class="headerlink" title="oracle网络之listener.ora、tnsnames.ora、sqlnet.ora"></a>oracle网络之listener.ora、tnsnames.ora、sqlnet.ora</h1><h2 id="listener-ora"><a href="#listener-ora" class="headerlink" title="listener.ora"></a>listener.ora</h2><p>tnslsnr进程是监听、并接受远程连接数据库请求的监听进程。listener.ora是tnslsnr进程的配置文件，监听的参数都是从该配置文件中读取，该文件位于服务端。<br>如果你只需要在本地连接数据库，不接受远程连接，那么也不需要启动tnslsnr进程，也不需要去维护listener.ora文件。<br>启动监听进程的命令，在命令模式下，执行lsnrctl start命令就启动了监听进程tnslsnr。</p><pre><code class="sql">[oracle@oracle admin]$ cat listener.ora# listener.ora Network Configuration File: /oracle/11g/product/11.2.0/dbhome_1/network/admin/listener.ora# Generated by Oracle configuration tools.LISTENER =  (DESCRIPTION_LIST =    (DESCRIPTION =      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1521))    )  )ADR_BASE_LISTENER = /oracle/11gSID_LIST_LISTENER =    (SID_LIST =        (SID_DESC =            (GLOBAL_DBNAME = orcl1)            (ORACLE_HOME = /oracle/11g/product/11.2.0/dbhome_1)            (SID_NAME =orcl)                       )    )</code></pre><p>LISTENER部分包含协议地址列表，每个实例一个入口。<br>SID_LIST_LISTENER部分标识全局数据库名称、标识监听程序正在服务的每个实例的Oracle软件主目录以及实例或SID。</p><p>当你执行命令sqlplus username&#x2F;password@tnsname时，一般处理过程如下：</p><ol><li>查询sqlnet.ora看看名称的解析方式，发现是TNSNAME，或者hostname。</li><li>则查询tnsnames.ora文件，从里边找tnsname的记录，并且找到主机名，端口和service_name。</li><li>如果listener进程没有问题的话，建立与listener进程的连接。</li><li>根据不同的服务器模式如专用服务器模式或者共享服务器模式，listener采取接下去的动作。默认是专用服务器模式，没有问题的话客户端就连接上了数据库的server process。</li><li>这时候网络连接已经建立，listener进程的历史使命也就完成了。</li></ol><p>几种连接数据库用到的命令形式：</p><ol><li>sqlplus “&#x2F; as sysdba” 这是典型的操作系统认证，不需要listener进程，数据库即使不可用也可以登录。</li><li>sqlplus username&#x2F;password 不需要listener进程，登录本机数据库，数据库实例启动即可。</li><li>sqlplus username&#x2F;password@tnsname需要listener进程，最常见的远程登录模式，需要启动数据库实例和listener进程。</li></ol><h2 id="tnsname-ora"><a href="#tnsname-ora" class="headerlink" title="tnsname.ora"></a>tnsname.ora</h2><p>tnsnames.ora 用在oracle client端，用户配置连接数据库的别名参数,就像系统中的hosts文件一样。提供了客户端连接某个数据库的详细信息，主机地址，端口，数据库实例名等。</p><p>示例</p><pre><code class="sql">[oracle@mysql-master-1003306 admin]$ cat tnsnames.ora# tnsnames.ora Network Configuration File: /oracle/11g/product/11.2.0/dbhome_1/network/admin/tnsnames.ora# Generated by Oracle configuration tools.ORA01 =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = oracle.orcl)    )  )orcl1 =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = orcl1)    )  )</code></pre><ul><li>PROTOCOL参数一般是TCP，可以根据服务器情况选择一种配置方式。</li><li>HOST 一般是ip地址，如果是主机名，则应该在客户端系统的host文件上配好主机名和ip地址的映射关系。</li><li>PORT 标准是1521，根据服务器端的监听端口而定。</li><li>SERVICE_NAME 就是数据库的服务名。对应服务器端listener.ora文件里面的GLOBAL_DBNAME的值，或者lsnrctl status查到的service name；</li></ul><h2 id="sqlnet-ora"><a href="#sqlnet-ora" class="headerlink" title="sqlnet.ora"></a>sqlnet.ora</h2><p>sqlnet.ora 用在oracle client端，用于配置连接服务端oracle的相关参数</p><p>示例</p><pre><code class="sql">[oracle@mysql-master-1003306 admin]$ cat sqlnet.ora# sqlnet.ora Network Configuration File: /oracle/11g/product/11.2.0/dbhome_1/network/admin/sqlnet.ora# Generated by Oracle configuration tools.NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)ADR_BASE = /oracle/11g</code></pre><p>NAMES.DIRECTORY_PATH：定义了在客户端连接数据库时，采用什么样的匹配方式。</p><p>示例：NAMES.DIRECTORY_PATH&#x3D; (TNSNAMES, ONAMES, HOSTNAME)</p><p>那么在客户端执行sqlplus username&#x2F;password@local_dev连接数据库的时，首先采用tnsnames.ora的别名配置连接数据库；如果连接上；再采用ONAMES进行解析，最后采用主机名进行解析。</p><p>ONAMES表示Oracle使用自己的名称服务器（Oracle Name Server）来解析，目前Oracle建议使用轻量目录访问协议LDAP来取代ONAMES;HOSTNAME表示使用host文件，DNS，NIS等来解析；</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库文件</title>
      <link href="/2018/03/18/Mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/"/>
      <url>/2018/03/18/Mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库文件"><a href="#MySQL数据库文件" class="headerlink" title="MySQL数据库文件"></a>MySQL数据库文件</h1><h2 id="1、参数文件"><a href="#1、参数文件" class="headerlink" title="1、参数文件"></a>1、参数文件</h2><p>告诉数据库启动实例的时候在哪里可以找到数据库文件，并指定初始化参数；<br>通过mysql –help | grep my.cnf来寻找即可</p><h2 id="2、日志文件"><a href="#2、日志文件" class="headerlink" title="2、日志文件"></a>2、日志文件</h2><p>记录mysql实例对对某种条件作出响应时写入的文件，如错误日志文件，二进制日志文件，慢查询日志文件，查询日志文件等；<br>注意：redo log 和undo log不在这个范围，因为仅支持事务的存储引擎才有redo log和undo log</p><h3 id="2-1、错误日志文件-（error-log）"><a href="#2-1、错误日志文件-（error-log）" class="headerlink" title="2.1、错误日志文件 （error log）"></a>2.1、错误日志文件 （error log）</h3><p>对mysql的启动、运行、关闭进行了记录；show variables like ‘%log_error%’ 来查看错误日志文件的路径；</p><pre><code class="sql">mysql&gt; show variables like &#39;%log_error%&#39;;+---------------------+-----------------------------+| Variable_name       | Value                       |+---------------------+-----------------------------+| binlog_error_action | ABORT_SERVER                || log_error           | /usr/local/mysql/mysqld.err || log_error_verbosity | 3                           |+---------------------+-----------------------------+3 rows in set (0.00 sec)</code></pre><h3 id="2-2、二进制日志文件-（bin-log）"><a href="#2-2、二进制日志文件-（bin-log）" class="headerlink" title="2.2、二进制日志文件 （bin log）"></a>2.2、二进制日志文件 （bin log）</h3><p><code>bin log</code>记录了对mysql数据库执行更改的所有操作，但不包括select和show操作，因为这两个操作对数据本身并没有修改。<code>bin log</code>有下面几个作用：</p><ul><li>恢复：对数据库全备恢复后，还需要恢复二进制日志来保证数据的完整；</li><li>复制：主从复制，通过bin log来进行数据同步；</li><li>审计：通过对二进制日志中的信息来进行审计，判断是否有sql注入攻击；</li></ul><p><code>bin log</code>默认没有开启。需要手动开启，官方解释开启<code>bin log</code>会使性能下降1%，但是作用巨大，性能损失可以忽略；</p><p><strong>相关参数：</strong></p><ul><li><code>max_binlog_size</code>：指定单个二进制文件最大值，默认1G；</li><li><code>binlog_cache_size</code>：指定二进制缓冲区大小，默认32K，其是针对会话（session）的，就是说，当一个线程开始一个事务的时候，都会自动分配一个大小为binlog_cache_size的内存，因此注意该值不能设置过大；通过binlog_cache_use和binlog_cache_disk_use的状态，可以判断是否设置合适，binlog_cache_use记录了使用缓冲写二进制日志的次数，binlog_cache_disk_use记录了临时文件写二进制的次数，该值如果为0，则表示binlog_cache_size大小够用，否则需要适当的增加大小；</li><li><code>sync_binlog</code> &#x3D; [N] 表示每写缓冲多少次就刷新到磁盘，1是最安全的值，但也是最慢的；<br>  sync_binlog 参数决定bin log刷新机制<br>  1：实时刷新（默认）<br>  0：交由操作系统管理<br>  （2，3，4……n）：n个事务刷新一次</li><li><code>binlog-do-db</code> 哪些库写入二进制文件</li><li><code>binlog-ignore-db</code> 忽略哪些库写入二进制文件</li><li><code>log-slave-update</code> 如果是从库，需要设置该参数来讲主库的二进制文件写入自己的二进制文件中去<br><code>binlog_format</code><ul><li>STATEMENT：记录的是逻辑SQL语句</li><li>ROW：记录表行的更改情况，日志文件会增大，对磁盘空间要求有一定增加；</li><li>MIXED：混合使用，默认还是使用STATEMENT，但是某些情况下会使用ROW，比如<br>1）表的存储引擎为NDB，这时对表的DML语句都是使用ROW；<br>2）使用了UUID()、 USER()、CURRENT_USER()、FOUND_ROWS()、ROW_COUNT()等不确定函数；<br>3）使用了INSERT DELAY语句；<br>4）使用了用户定义函数（UDF）；<br>5）使用了临时表（temporary table）；</li></ul></li></ul><p>二进制文件是二进制的，需要使用mysqlbinlog工具辅助阅读；</p><pre><code class="bash">mysqlbinlog --no-defaults -v -v --base64-output=decode-row /data/binlog &gt; 1.log</code></pre><h3 id="2-3、慢查询日志文件-（slow-query-log）"><a href="#2-3、慢查询日志文件-（slow-query-log）" class="headerlink" title="2.3、慢查询日志文件 （slow query log）"></a>2.3、慢查询日志文件 （slow query log）</h3><p>默认情况下，mysql不启动慢查询日志，需要手动开启；</p><pre><code class="sql">mysql&gt; show variables like &#39;%slow_query_log%&#39;;+---------------------+-----------------------------+| Variable_name       | Value                       |+---------------------+-----------------------------+| slow_query_log      | OFF                         || slow_query_log_file | /data/mysql/lyucan-slow.log |+---------------------+-----------------------------+2 rows in set (0.01 sec)</code></pre><p><strong>相关参数：</strong></p><ul><li><code>long_query_time</code>：设置慢查询阈值，当超过这个阈值的时候，记录到满查询日志，供DBA进行查询优化，默认为10s；</li><li><code>long_query_not_using_indexes</code>：参数控制是否将没有使用索引的sql语句记录到慢查询日志里面；</li><li><code>log_throttle_queries_not_using_indexes</code>：5.6以后引入了一个参数来表示每分钟记录到慢查询日志的且未使用索引的sql语句数量，默认值为0，表示没有限制；</li><li><code>slow_query_type</code>来表示启用slow log的方式，可以为：<br>  0：表示不将sql语句记录到slow log<br>  1：根据运行时间将sql记录到slow log<br>  2：根据逻辑IO次数将sql记录到slow log<br>  3：同事根据运行时间和逻辑IO次数将sql记录到slow log</li></ul><p>可以使用mysqldumpslow命令来辅助分析慢查询日志；</p><h3 id="2-4、查询日志文件-（query-log）"><a href="#2-4、查询日志文件-（query-log）" class="headerlink" title="2.4、查询日志文件 （query log）"></a>2.4、查询日志文件 （query log）</h3><p>对未能正确查询的sql语句，进行了记录</p><h3 id="2-5、中继日志（relay-log）"><a href="#2-5、中继日志（relay-log）" class="headerlink" title="2.5、中继日志（relay log）"></a>2.5、中继日志（relay log）</h3><h2 id="3、socket文件"><a href="#3、socket文件" class="headerlink" title="3、socket文件"></a>3、socket文件</h2><p>使用unix套接字连接时需要的文件；</p><h2 id="4、pid文件"><a href="#4、pid文件" class="headerlink" title="4、pid文件"></a>4、pid文件</h2><p>mysql实例启动的进程文件；</p><h2 id="5、MySQL表结构文件"><a href="#5、MySQL表结构文件" class="headerlink" title="5、MySQL表结构文件"></a>5、MySQL表结构文件</h2><p>存放mysql表结构定义的文件，.frm后缀；<br>每张表都会有一个.frm的文件，存放该表的表结构定义，同时还用来存放视图，如果创建了一个v_a视图，那就会对应产生一个 v_a.frm文件，用来存放视图的定义，该文件可以使用cat查看；</p><h2 id="6、innodb存储引擎文件"><a href="#6、innodb存储引擎文件" class="headerlink" title="6、innodb存储引擎文件"></a>6、innodb存储引擎文件</h2><p>因为mysql存储引擎是基于表的，每个存储引擎都会有自己的文件来保存各种数据；</p><h3 id="6-1、表空间文件"><a href="#6-1、表空间文件" class="headerlink" title="6.1、表空间文件"></a>6.1、表空间文件</h3><p>innodb默认情况下有一个表空间文件，名为ibdata1，用户可以通过参数innodb_data_file_path对其进行设置，格式为：innodb_data_file_path &#x3D; datafile_spec1[;datafile_spec2]…</p><pre><code class="sql">mysql&gt; show variables like &#39;%innodb_data_file%&#39;;+-----------------------+------------------------+| Variable_name         | Value                  |+-----------------------+------------------------+| innodb_data_file_path | ibdata1:12M:autoextend |+-----------------------+------------------------+1 row in set (0.00 sec)</code></pre><p>用户可以通过多个文件组成一个表空间，同事指定文件的属性，例如：</p><pre><code class="sql">[mysqld]innodb_data_file_path = /db/ibdata1:2000M;/db/ivdata2:2000M:autoextend</code></pre><p>若两个文件存放在不同的磁盘上，磁盘的负载可以被均衡，提高数据库的在整体性能；<br>设置innodb_data_file_path参数后，说有基于innodb的存储引擎的表的数据都会存放在该表空间中<br>如果设置了innodb_file_per_table参数，则用户基于每个innodb存储引擎的表都会产生一个独立的表空间，独立表空间的命名规则为：表名.ibd；</p><h3 id="6-2、重做日志文件（redo-log）"><a href="#6-2、重做日志文件（redo-log）" class="headerlink" title="6.2、重做日志文件（redo log）"></a>6.2、重做日志文件（redo log）</h3><pre><code>默认情况下，数据目录下会有两个redo log 文件，ib_logfile0 和 ib_logfile1，每个InnoDB存储引擎至少有1个redo log文件组，每个文件组下至少有2个redo log文件。为了得到更高的可靠性，可以设置多个mirrored log group，将不同的文件组放在不同的磁盘上。日志组中每个redo log文件的大小一致，并以循环方式使用。InnoDB存储引擎先写redo log文件1，当达到文件的最后是，会切换至文件2，当文件2也被写满时，会再切换到文件1中。</code></pre><p>相关参数：</p><ul><li><code>innodb_log_file_size</code>：参数指定了redo log文件的大小；</li><li><code>innodb_log_files_in_group</code>：参数指定了redo log文件组中redo log文件的数量，默认为2；</li><li><code>innodb_mirrored_log_groups</code>：参数指定了日志镜像文件组的数量，默认为1，代表只有一个文件组，没有镜像；</li><li><code>innodb_log_group_home_dir</code>：参数指定了日志文件组所在路径，默认在数据库路径下；</li><li><code>innodb_flush_log_at_trx_commit</code> 参数决定redo log的刷新机制<br>  0：每隔1秒刷新一次<br>  1：实时刷新（默认）建议设置为1<br>  2：交由操作系统管理<br>重做日志不需要二次写，因为重做日志的写入是以扇区为单位的，512字节，扇区是写入的最小单位，因此可以保证每次写都是成功的，所以不需要二次写；</li></ul><h3 id="6-3、回滚日志文件（undo-log）"><a href="#6-3、回滚日志文件（undo-log）" class="headerlink" title="6.3、回滚日志文件（undo log）"></a>6.3、回滚日志文件（undo log）</h3><p>当我们对数据进行操作的时候，就会产生undo记录，Undo记录默认记录在系统表空间（ibdata）中，从MySQL 5.6开始，Undo使用的表空间可以分离为独立的Undo log文件。</p><pre><code class="sql">mysql&gt; show variables like &#39;%undo_table%&#39;;+-------------------------+-------+| Variable_name           | Value |+-------------------------+-------+| innodb_undo_tablespaces | 0     |+-------------------------+-------+1 row in set (0.01 sec)</code></pre><p>0表示使用系统默认的表空间，大于1表示使用独立的undo log文件，等于几就有几个文件；<br><strong>相关参数：</strong></p><pre><code class="sql">mysql&gt; show variables like &#39;%undo%&#39;;+--------------------------+------------+| Variable_name            | Value      |+--------------------------+------------+| innodb_max_undo_log_size | 1073741824 || innodb_undo_directory    | ./         || innodb_undo_log_truncate | OFF        || innodb_undo_logs         | 128        || innodb_undo_tablespaces  | 0          |+--------------------------+------------+5 rows in set (0.00 sec)</code></pre><p>innodb_max_undo_log_size：控制最大undo tablespace 文件的大小<br>其他参数保持默认即可，没必要把表空间文件独立出来；</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-模块的特殊属性__name__</title>
      <link href="/2018/03/13/Python/Python-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7__name__/"/>
      <url>/2018/03/13/Python/Python-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7__name__/</url>
      
        <content type="html"><![CDATA[<h1 id="模块的特殊属性-name"><a href="#模块的特殊属性-name" class="headerlink" title="模块的特殊属性__name__"></a>模块的特殊属性__name__</h1><p>模块的特殊属性__name__在不同情况下的取值<br>1、对于被导入的模块，其特殊属性__name__的值为模块名。<br>2、对于直接运行的模块，其特殊属性__name__的值为__main__。</p><p>例如：</p><pre><code class="python">[root@lyucan ~]# cat mod.py#!/usr/bin/python3print(&#39;模块__name__的值为：&#39;, __name__)[root@lyucan ~]# cat module.py#!/usr/bin/python3import mod# 直接运行[root@lyucan ~]# ./mod.py模块__name__的值为： __main__#被当做模块导入[root@lyucan ~]# ./module.py模块__name__的值为： mod</code></pre><p>可以根据<code>__name__</code>的值判断是否执行模块中的测试代码<br>对于模块中的测试代码，通常当直接运行模块时，才需要运行，而当模块被导入时，则不需要执行。因此，可以根据<code>__name__</code>的值判断是否执行模块中的测试代码</p><pre><code class="python">if __name__ == &#39;__main__&#39;:    ...    ...</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postfix搭建邮件服务器</title>
      <link href="/2018/03/05/%E8%BF%90%E7%BB%B4/postfix%E6%90%AD%E5%BB%BA%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/03/05/%E8%BF%90%E7%BB%B4/postfix%E6%90%AD%E5%BB%BA%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="postfix搭建邮件服务器"><a href="#postfix搭建邮件服务器" class="headerlink" title="postfix搭建邮件服务器"></a>postfix搭建邮件服务器</h1><h2 id="添加下面三条解析记录"><a href="#添加下面三条解析记录" class="headerlink" title="添加下面三条解析记录"></a>添加下面三条解析记录</h2><p><img src="/images/9ddcd803-261f-463d-9d97-743d29f7f0ca-Image.png" alt="9ddcd803-261f-463d-9d97-743d29f7f0ca-Image.png" title="9ddcd803-261f-463d-9d97-743d29f7f0ca-Image.png"></p><h2 id="安装postfix"><a href="#安装postfix" class="headerlink" title="安装postfix"></a>安装postfix</h2><pre><code class="bash">[root@lyucan ~]# yum -y install postfix[root@lyucan ~]# rpm -qa | grep postfixpostfix-2.10.1-6.el7.x86_64</code></pre><h2 id="修改postfix配置文件"><a href="#修改postfix配置文件" class="headerlink" title="修改postfix配置文件"></a>修改postfix配置文件</h2><pre><code class="bash">[root@lyucan ~]# cat -b /etc/postfix/main.cf | grep -v &#39;#&#39; | grep -v ^$    29 queue_directory = /var/spool/postfix    33 command_directory = /usr/sbin    38 daemon_directory = /usr/libexec/postfix    43 data_directory = /var/lib/postfix    53 mail_owner = postfix    69 myhostname = mail.lyucan.com                  ##主机名    76 mydomain = lyucan.com                         ##域名    92 myorigin = $mydomain                          ##设置为域名   107 inet_interfaces = all                         ##定义网络区域   109 inet_protocols = all                          ##定义协议   156 mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain  ##定义可接受主机名或域名列表   208 unknown_local_recipient_reject_code = 550   251 mynetworks = 127.0.0.0/8                      ##允许哪些机器使用这台机器进行发送邮件，定义为本地，避免转发垃圾邮件   361 alias_maps = hash:/etc/aliases   371 alias_database = hash:/etc/aliases   392    499     559 debug_peer_level = 2   575 debugger_command =   576         PATH=/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin   577         ddd $daemon_directory/$process_name $process_id &amp; sleep 5   603 sendmail_path = /usr/sbin/sendmail.postfix   607 newaliases_path = /usr/bin/newaliases.postfix   611 mailq_path = /usr/bin/mailq.postfix   616 setgid_group = postdrop   619 html_directory = no   622 manpage_directory = /usr/share/man   626 sample_directory = /usr/share/doc/postfix-2.10.1/samples   629 readme_directory = /usr/share/doc/postfix-2.10.1/README_FILES</code></pre><h2 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h2><pre><code class="bash">[root@lyucan ~]# firewall-cmd --permanent --add-service=smtpsuccess[root@lyucan ~]# firewall-cmd --reloadsuccess</code></pre><h2 id="启动postfix"><a href="#启动postfix" class="headerlink" title="启动postfix"></a>启动postfix</h2><pre><code class="bash">[root@lyucan ~]# systemctl enable postfix.serviceln -s &#39;/usr/lib/systemd/system/postfix.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/postfix.service&#39;[root@lyucan ~]# systemctl restart postfix.service</code></pre><pre><code class="bash">[root@lyucan ~]# netstat -tlunp | grep 25tcp        0      0 0.0.0.0:25              0.0.0.0:*               LISTEN      7355/master        tcp6       0      0 :::25                   :::*                    LISTEN      7355/master </code></pre><h2 id="测试发送邮件"><a href="#测试发送邮件" class="headerlink" title="测试发送邮件"></a>测试发送邮件</h2><pre><code class="bash">[root@lyucan ~]# yum -y install mailx                 ##安装mail工具的包[root@lyucan ~]# rpm -qa | grep mailxmailx-12.5-16.el7.x86_64[root@lyucan ~]# mail -s test 289211569@qq.com         Hello,this is for test! .EOT[root@lyucan ~]# mailqMail queue is empty                  ##为空表示邮件已经发出</code></pre><h2 id="查看邮件"><a href="#查看邮件" class="headerlink" title="查看邮件"></a>查看邮件</h2><p><img src="/images/daef65dc-589b-4345-888d-824b386a47c3-Image.png" alt="daef65dc-589b-4345-888d-824b386a47c3-Image.png" title="daef65dc-589b-4345-888d-824b386a47c3-Image.png"></p><p>看到是以root发送的，因为如果想要以别的用户发送，需要创建相应用户，以admin用户为例</p><pre><code class="bash">[root@lyucan ~]# useradd admin[root@lyucan ~]# passwd adminChanging password for user admin.New password:Retype new password:passwd: all authentication tokens updated successfully.[root@lyucan ~]# su - adminLast failed login: Fri Apr 13 18:46:55 CST 2018 from 170.254.70.244 on ssh:nottyThere were 658 failed login attempts since the last successful login.[admin@lyucan ~]$ mail -s test 289211569@qq.comtest for admin.EOT[admin@lyucan ~]$ mailq-Queue ID- --Size-- ----Arrival Time---- -Sender/Recipient-------3C4BA35E57*     424 Fri Apr 13 20:24:21  admin@lyucan.com289211569@qq.com-- 0 Kbytes in 1 Request.[admin@lyucan ~]$ mailqMail queue is empty</code></pre><p>查看收件箱<br><img src="/images/4001ac11-aa7c-4618-9027-8881895696cd-Image.png" alt="4001ac11-aa7c-4618-9027-8881895696cd-Image.png" title="4001ac11-aa7c-4618-9027-8881895696cd-Image.png"></p><h2 id="安装dovecot来使其可以用客户端来收发邮件"><a href="#安装dovecot来使其可以用客户端来收发邮件" class="headerlink" title="安装dovecot来使其可以用客户端来收发邮件"></a>安装dovecot来使其可以用客户端来收发邮件</h2><pre><code class="bash">[root@lyucan ~]# yum -y install dovecot[root@lyucan ~]# rpm -qa | grep dovecotdovecot-2.2.10-8.el7.x86_64</code></pre><p>修改dovecot配置文件</p><pre><code class="bash">[root@lyucan ~]# cat -b /etc/dovecot/dovecot.conf | grep -v &#39;#&#39; | grep -v ^$    19 protocols = imap pop3 lmtp    25 listen = *    72 dict &#123;    75 &#125;    79 !include conf.d/*.conf    82 !include_try local.conf</code></pre><pre><code class="bash">[root@lyucan ~]# cat -b /etc/dovecot/conf.d/10-auth.conf | grep -v &#39;#&#39; | grep -v ^$     9 disable_plaintext_auth = no                ##允许明文登陆    82 auth_mechanisms = plain login   100 !include auth-system.conf.ext</code></pre><pre><code class="bash">[root@lyucan ~]# vim /etc/dovecot/conf.d/10-ssl.confssl = no##同时注释掉下面两行配置#ssl_cert = &lt;/etc/pki/dovecot/certs/dovecot.pem#ssl_key = &lt;/etc/pki/dovecot/private/dovecot.pem</code></pre><pre><code class="bash">[root@lyucan ~]# cat -b /etc/dovecot/conf.d/10-mail.conf | grep -v &#39;#&#39; | grep -v ^$    30 mail_location = mbox:~/mail:INBOX=/var/mail/%u    41 namespace inbox &#123;    56   inbox = yes    70 &#125;   142 first_valid_uid = 1000   242 mbox_write_locks = fcntl</code></pre><p>放通防火墙</p><pre><code class="bash">[root@lyucan ~]# firewall-cmd --permanent --add-port=110/tcpsuccess[root@lyucan ~]# firewall-cmd --permanent --add-port=143/tcpsuccess[root@lyucan ~]# firewall-cmd --reloadsuccess</code></pre><p>启动dovecot</p><pre><code class="bash">[root@lyucan ~]# systemctl enable dovecot.serviceln -s &#39;/usr/lib/systemd/system/dovecot.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/dovecot.service&#39;[root@lyucan ~]# systemctl restart dovecot.service[root@lyucan ~]# netstat -tlunp | grep dovecottcp        0      0 0.0.0.0:110             0.0.0.0:*               LISTEN      10963/dovecot      tcp        0      0 0.0.0.0:143             0.0.0.0:*               LISTEN      10963/dovecot    </code></pre><p>测试使用dovecot发送邮件<br>创建admin用户</p><pre><code class="bash">[root@lyucan ~]# useradd admin[root@lyucan ~]# passwd adminChanging password for user admin.New password:Retype new password:passwd: all authentication tokens updated successfully.</code></pre><p>admin发送邮件</p><pre><code class="bash">[root@lyucan ~]# telnet 127.0.0.1 110Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is &#39;^]&#39;.+OK Dovecot ready.user admin+OKpass echo123.-ERR [SYS/PERM] Permission deniedConnection closed by foreign host.</code></pre><p>出现上面错误，查看maillog日志</p><pre><code class="bash">[root@lyucan ~]# tail /var/log/maillogApr 13 21:53:25 MyCloudServer postfix/anvil[13365]: statistics: max connection count 1 for (smtp:119.123.79.43) at Apr 13 21:49:15Apr 13 21:53:25 MyCloudServer postfix/anvil[13365]: statistics: max cache size 2 at Apr 13 21:50:04Apr 13 21:53:29 MyCloudServer dovecot: pop3-login: Login: user=&lt;admin&gt;, method=PLAIN, rip=127.0.0.1, lip=127.0.0.1, mpid=13657, secured, session=&lt;wy5vMrtp1AB/AAAB&gt;Apr 13 21:53:29 MyCloudServer dovecot: pop3(admin): Error: chown(/home/admin/mail/.imap, group=12(mail)) failed: Operation not permitted (egid=1001(admin), group based on /var/mail/admin - see http://wiki2.dovecot.org/Errors/ChgrpNoPerm)Apr 13 21:53:29 MyCloudServer dovecot: pop3(admin): Error: Couldn&#39;t open INBOX: Permission deniedApr 13 21:53:29 MyCloudServer dovecot: pop3(admin): Couldn&#39;t open INBOX top=0/0, retr=0/0, del=0/0, size=0Apr 13 21:54:52 MyCloudServer dovecot: pop3-login: Login: user=&lt;admin&gt;, method=PLAIN, rip=127.0.0.1, lip=127.0.0.1, mpid=13709, secured, session=&lt;MOZgN7tp1QB/AAAB&gt;Apr 13 21:54:52 MyCloudServer dovecot: pop3(admin): Error: chown(/home/admin/mail/.imap, group=12(mail)) failed: Operation not permitted (egid=1001(admin), group based on /var/mail/admin - see http://wiki2.dovecot.org/Errors/ChgrpNoPerm)Apr 13 21:54:52 MyCloudServer dovecot: pop3(admin): Error: Couldn&#39;t open INBOX: Permission deniedApr 13 21:54:52 MyCloudServer dovecot: pop3(admin): Couldn&#39;t open INBOX top=0/0, retr=0/0, del=0/0, size=0</code></pre><p>我们需要在家目录下创建存放邮件的目录</p><pre><code class="bash">[root@lyucan ~]# su - admin[admin@lyucan ~]$ mkdir -p ~/mail/.imap/INBOX </code></pre><p>再次尝试连接</p><pre><code class="bash">[root@lyucan ~]# telnet 127.0.0.1 110Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is &#39;^]&#39;.+OK Dovecot ready.user admin+OKpass echo123.+OK Logged in.              ==》 OK </code></pre><h2 id="使用foxmail连接"><a href="#使用foxmail连接" class="headerlink" title="使用foxmail连接"></a>使用foxmail连接</h2><p><img src="/images/7974a8ed-9c42-4bc5-b302-62762b613eee-Image.png" alt="7974a8ed-9c42-4bc5-b302-62762b613eee-Image.png" title="7974a8ed-9c42-4bc5-b302-62762b613eee-Image.png"></p><p>发送一封邮件，提示如下错误<br><img src="/images/cdeb04ac-7906-4694-ada3-27a4ef1206d7-Image.png" alt="cdeb04ac-7906-4694-ada3-27a4ef1206d7-Image.png" title="cdeb04ac-7906-4694-ada3-27a4ef1206d7-Image.png"></p><p>解决方法找了很多，唯一一个能解决的就是把mynetworks &#x3D; 127.0.0.0&#x2F;8 设置成0.0.0.0&#x2F;0，但是这样做的话，所有的机器多可以通过这台服务器进行转发邮件，很不安全，另外一种解决方法就是通过sasl进行认证，个人也推荐使用这种方法。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang基础</title>
      <link href="/2018/03/02/Golang/Golang%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/03/02/Golang/Golang%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang基础"><a href="#Golang基础" class="headerlink" title="Golang基础"></a>Golang基础</h1><h2 id="第一个go程序"><a href="#第一个go程序" class="headerlink" title="第一个go程序"></a>第一个go程序</h2><p>新建一个文件<code>helloworld.go</code></p><pre><code class="go">package main // 声明包名mainimport &quot;fmt&quot; // 导入fmt标准库包func main() &#123; // 定义main函数    fmt.Println(&quot;hello world&quot;) // 调用fmt包的Println方法打印字符串到控制台&#125;</code></pre><p>使用<code>go run helloworld.go</code> 直接编译运行</p><pre><code>liuyi@DESKTOP-O2GI8R6 MINGW64 /d/工作学习/Go$ go run helloword.gohello world</code></pre><p>或者先编译成二进制文件，再执行二进制文件</p><pre><code>liuyi@DESKTOP-O2GI8R6 MINGW64 /d/工作学习/Go$ go build helloword.go liuyi@DESKTOP-O2GI8R6 MINGW64 /d/工作学习/Go$ ./helloword.exe hello world</code></pre><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>Go 源文件以 package 声明开头，说明源文件所属的包，接着使用 import 导入依赖的包，其<br>次为包级别的变量、常量、类型和函数的声明和赋值。函数中可定义局部的变量、常量等</p><h2 id="基本组成元素"><a href="#基本组成元素" class="headerlink" title="基本组成元素"></a>基本组成元素</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是编程时所使用的名字，用于给变量、常量、函数、类型、接口、包名等进行命名，以建立名称和使用之间的关系，Go语言标识符的命名规则：</p><ul><li>只能由非空字母、数字、下划线组成</li><li>只能以字母或者下划线开头</li><li>不能使用Go关键字</li><li>避免使用Go语言预定标识符</li><li>建议使用驼峰命名，不强制</li><li>标识符区分大小写</li></ul><p>Go语言提供一些预定的标识符来表示内置的常量、类型、函数，在定义标识符时应避免使用</p><ul><li>内置常量：true、false、nil、iota</li><li>内置类型：bool、byte、rune、int、int8、int16、int32、int64、uint、uint8、unit16、unit32、unit64、uintptr、float32、float64、complex64、complex128、string、error</li><li>内置函数：make、len、cap、new、append、copy、close、delete、complex、real、imag、panic、recover</li><li>空白标识符：_</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字用于特性的语法解构，Go语言定义25个关键字：</p><ul><li>声明：import、package</li><li>实体声明和定义：chan、const、func、interface、map、struct、type、var</li><li>流程控制：break、case、continue、default、defer、else、fallthrough、for、go、goto、if、range、return、select、switch</li></ul><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量是值的表示方法，常用与对变量&#x2F;常量进行初始化、主要分为：</p><ul><li>表示基础数据类型值的字面量，例如：0, 1.1, true, 3 + 4i, ‘a’, “我爱中国”</li><li>构造自定义的复合数据类型的类型字面量，例如：type Interval int</li><li>用于表示符合数据类型值的复合字面量，用来构造 array、slice、map、struct 的值，例如：{1, 2, 3}</li></ul><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ul><li>算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>++</code>、<code>--</code></li><li>关系运算符：<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code></li><li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li><li>位运算符：<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&amp;^</code></li><li>赋值运算符：<code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>|=</code>、<code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code></li><li>其他运算符：<code>&amp;</code>(单目)、<code>*</code>(单目)、<code>.</code>(点)、<code>-</code>(单目)、<code>…</code>、<code>&lt;-</code></li></ul><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><p>小括号<code>()</code>, 中括号<code>[]</code>，大括号<code>&#123;&#125;</code>，分号<code>;</code>，逗号<code>,</code></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是指对一块存储空间定义名称，通过名称对存储空间的内容进行访问或修改，使用 var<br>进行变量声明，常用的语法为:</p><ol><li>var 变量名 变量类型 &#x3D; 值<br>定义变量并进行初始化</li></ol><pre><code class="go">var name string = &quot;jerry&quot;</code></pre><ol start="2"><li>var 变量名 变量类型<br>定义变量使用零值进行初始化</li></ol><pre><code class="go">var age int</code></pre><ol start="3"><li>var 变量名 &#x3D; 值<br>定义变量，变量类型通过值类型进行推导</li></ol><pre><code class="go">var isMale = true</code></pre><ol start="4"><li>var 变量名 1, 变量名 2 , …, 变量名 n 变量类型<br>定义多个相同类型的变量并使用零值进行初始化</li></ol><pre><code class="go">var prefix, suffix string</code></pre><ol start="5"><li>var 变量名 1, 变量名 2 , …, 变量名 n 变量类型 &#x3D; 值 1, 值 2, …, 值 n<br>定义多个相同类型的变量并使用对应的值进行初始化</li></ol><pre><code class="go">var prev, next int = 3, 4</code></pre><ol start="6"><li>var 变量名 1, 变量名 2 , …, 变量名 n &#x3D; 值 1, 值 2, …, 值 n<br>定义多个变量并使用对应的值进行初始化，变量的类型使用值类型进行推导，类型可不<br>相同</li></ol><pre><code class="go">var name, age = &quot;tom&quot;, 18</code></pre><ol start="7"><li>批量定义<br>定义多个变量并进行初始化，批量复制中变量类型可省略</li></ol><pre><code class="go">var (    name string = &quot;jerry&quot;    age int = 18)</code></pre><h2 id="变量简短声明"><a href="#变量简短声明" class="headerlink" title="变量简短声明"></a>变量简短声明</h2><p>在函数内可以通过简短声明语句声明并初始化变量，可通过简短声明同时声明和初始化多个<br>变量，需要注意操作符左侧的变量至少有一个未定义过</p><pre><code class="go">gender := &quot;male&quot;</code></pre><blockquote><p>注意，简短声明只能在函数中使用，且变量短声明不能指定类型，类型都是通过推导出来</p></blockquote><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量用于定义不可被修改的的值，需要在编译过程中进行计算，只能为基础的数据类型布尔、<br>数值、字符串，使用 const 进行常量声明，常用语法：</p><ol><li>const 常量名 类型 &#x3D; 值<br>定义常量并进行初始化</li></ol><pre><code class="go">const pi float64 = 3.1415926</code></pre><ol start="2"><li>const 常量名 &#x3D; 值<br>定义常量，类型通过值类型进行推导</li></ol><pre><code class="go">const e = 2.7182818</code></pre><ol start="3"><li>批量定义<br>定义多个变量并进行初始化，批量赋值中变量类型可省略，并且除了第一个常量值外其他常量可同时省略类型和值，表示使用前一个常量的初始化表达式</li></ol><pre><code class="go">const (    name string = &quot;baihuzi&quot;    desc)</code></pre><blockquote><p>常量之间的运算，类型转换，以及对常量调用函数 len、cap、real、imag、complex、<br>unsafe.Sizeof 得到的结果依然为常量</p></blockquote><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域指变量可以使用范围。go 语言使用大括号显示的标识作用域范围，大括号内包含一连串的语句，叫做语句块。语句块可以嵌套，语句块内定义的变量不能在语句块外使用。作用域内定义变量只能被声明一次且变量必须使用，否则编译错误。在不同作用域可定义相同的变量，此时局部将覆盖全局<br>常见隐式语句块：</p><ul><li>全语句块</li><li>包语句块</li><li>文件语句块</li><li>if、switch、for、select、case 语句块</li></ul><h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>布尔类型用于表示真假，类型名为 bool，只有两个值 true 和 false，占用一个字节宽度，零值为 false，常用操作：<br><strong>逻辑运算</strong><br>与（&amp;&amp;），只有左、右表达式结果都为 true，运算结果为 true</p><pre><code class="go">func main() &#123;    isTrue, isFalse := true, false    fmt.Println(isTrue &amp;&amp; isFalse)  // false    fmt.Println(isTrue &amp;&amp; isTrue)   // true    fmt.Println(isFalse &amp;&amp; isTrue)  // false    fmt.Println(isFalse &amp;&amp; isFalse) // false&#125;</code></pre><p>或（||），只要左、右表达式有一个为 true，运算结果为 true</p><pre><code class="go">func main() &#123;    isTrue, isFalse := true, false    fmt.Println(isTrue || isFalse)  // true    fmt.Println(isTrue || isTrue)   // true    fmt.Println(isFalse || isTrue)  // true    fmt.Println(isFalse || isFalse) // false&#125;</code></pre><p>非（!），右表达式为 true，运算结果为 false；右表达式为 false，运算结果为 true</p><pre><code class="go">func main() &#123;    isTrue, isFalse := true, false    fmt.Println(!isTrue)  // false    fmt.Println(!isFalse) // true&#125;</code></pre><p><strong>关系运算</strong><br>等于（&#x3D;&#x3D;），不等于（!&#x3D;）</p><pre><code class="go">func main() &#123; // 定义main函数    isTrue, isFalse := true, false    fmt.Println(isTrue == isFalse) // false    fmt.Println(isTrue != isFalse) // true&#125;</code></pre><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>Go 语言提供了5种有符号、5种无符号、1种指针、1种单字节、1种单个unicode字符（unicode码点），共13种整数类型,零值均为0</p><table><thead><tr><th align="left">类型名</th><th align="left">字节宽度</th><th align="left">说明&amp;取值范围</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">与平台有关，32位系统4字节，64位系统8字节</td><td align="left">有符号整型</td></tr><tr><td align="left">uint</td><td align="left">与平台有关，32位系统4字节，64位系统8字节</td><td align="left">无符号整形</td></tr><tr><td align="left">rune</td><td align="left">4 字节</td><td align="left">Unicode 码点，取值范围同 uint32</td></tr><tr><td align="left">int8</td><td align="left">1 字节</td><td align="left">用 8 位表示的有符号整型，取值范围为:[-128, 127]</td></tr><tr><td align="left">int16</td><td align="left">2 字节</td><td align="left">用 16 位表示的有符号整型，取值范围为：[-32768, 32767]</td></tr><tr><td align="left">int32</td><td align="left">4 字节</td><td align="left">用 32 位表示的有符号整型，取值范围为：[-2147483648, 2147483647]</td></tr><tr><td align="left">int64</td><td align="left">8 字节</td><td align="left">用 64 位表示的有符号整型，取值范围为：[-9223372036854775808, 9223372036854775807]</td></tr><tr><td align="left">uint8</td><td align="left">1 字节</td><td align="left">用 8 位表示的无符号整型，取值范围为：[0, 255]</td></tr><tr><td align="left">uint16</td><td align="left">2 字节</td><td align="left">用 16 位表示的无符号整型，取值范围为：[0, 65535]</td></tr><tr><td align="left">uint32</td><td align="left">4 字节</td><td align="left">用 32 位表示的无符号整型，取值范围为：[0, 4294967295]</td></tr><tr><td align="left">uint64</td><td align="left">8 字节</td><td align="left">用 64 位表示的无符号整型，取值范围为：[0, 18446744073709551615]</td></tr><tr><td align="left">byte</td><td align="left">1 字节</td><td align="left">字节类型，取值范围同 uint8</td></tr><tr><td align="left">uintptr</td><td align="left">与平台有关，32 位系统 4 字节，64 位系统 8 字节</td><td align="left">指针值的无符号整型</td></tr></tbody></table><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><ul><li>十进制<br>以 10 为基数，采用 0-9 十个数字，逢 10 进位，例如：10</li><li>八进制<br>以 8 为基数，采用 0-7 八个数字，逢 8 进位，使用 0 开头表示为八进制表示，例如：010</li><li>十六进制<br>以 16 为基数，采用 0-9 十个数字和 A-F 六个字母，逢 16 进位，使用0X 开头表示为十六进制 ，例如：0X10</li></ul><pre><code class="go">func main() &#123;      fmt.Println(10, 010, 0x10) // 10 8 16&#125;</code></pre><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p><strong>算数运算， +、-、*、&#x2F;、%、++、–</strong></p><blockquote><p>注意：针对<code>/</code>，除数不能为 0，且结果依然为整数</p></blockquote><pre><code class="go">func main() &#123;    n1, n2 := 1, 2    fmt.Println(n1 + n2) // 3    fmt.Println(n1 - n2) // -1    fmt.Println(n1 * n2) // 2    fmt.Println(n1 / n2) // 0    fmt.Println(n1 % n2) // 1    n1++    n2--    fmt.Println(n1, n2) // 2 1&#125;</code></pre><p><strong>关系运算：&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;</strong></p><pre><code class="go">func main() &#123;    n1, n2 := 1, 2    fmt.Println(n1 &gt; n2)  // false    fmt.Println(n1 &lt; n2)  // true    fmt.Println(n1 &gt;= n2) // false    fmt.Println(n1 &lt;= n2) // true    fmt.Println(n1 == n2) // false    fmt.Println(n1 != n2) //true&#125;</code></pre><p><strong>位运算：&amp;、|、^、&amp;^、&lt;&lt;、&gt;&gt;</strong><br>对于负整数在计算机中使用补码进行表示，对应正整数二进制表示取反+1，针对左、右移的右操作数必须为无符号整型</p><ul><li><code>&amp;</code>：按位与，如果两个相应的二进制位都为1，则该位的结果值为1，否则为0</li><li><code>|</code>：按位或，两个相应的二进制位中只要有一个为1，该位的结果值为1</li><li><code>^</code>：按位异或，若参加运算的两个二进制位值相同则为0，否则为1</li><li><code>&amp;^</code>：如果运算符右侧数值的第 i 位为 1，那么计算结果中的第 i 位为 0；如果运算符右侧数值的第 i 位为 0，那么计算结果中的第 i 位为运算符左侧数值的第 i 位的值。</li><li><code>&lt;&lt;</code>：左移，各二进位全部左移若干位，正数高位补0，负数高位补1，低位丢弃</li><li><code>&gt;&gt;</code>：右移，各二进位全部右移若干位，正数高位补0，负数高位补1，低位丢弃</li></ul><pre><code class="go">func main() &#123;    n1, n2 := 1, 2    fmt.Println(n1 &amp; n2)    // n1 = 1   0000 0000 0000 0000 0000 0000 0000 0001    // n2 = 2   0000 0000 0000 0000 0000 0000 0000 0010    // n1 &amp; n2  0000 0000 0000 0000 0000 0000 0000 0000    // 结果：0    fmt.Println(n1 | n2)    // n1 = 1   0000 0000 0000 0000 0000 0000 0000 0001    // n2 = 2   0000 0000 0000 0000 0000 0000 0000 0010    // n1 | n2  0000 0000 0000 0000 0000 0000 0000 0011    // 结果：3    fmt.Println(n1 ^ n2)    // n1 = 1   0000 0000 0000 0000 0000 0000 0000 0001    // n2 = 2   0000 0000 0000 0000 0000 0000 0000 0010    // n1 ^ n2  0000 0000 0000 0000 0000 0000 0000 0011    // 结果：3    fmt.Println(n1 &amp;^ n2)    // n1 = 1   0000 0000 0000 0000 0000 0000 0000 0001    // n2 = 2   0000 0000 0000 0000 0000 0000 0000 0010    // n1 ^ n2  0000 0000 0000 0000 0000 0000 0000 0001    // 结果：1    fmt.Println(n1 &lt;&lt; 2)    // n1 = 1   0000 0000 0000 0000 0000 0000 0000 0001    // n1 &lt;&lt; 2  0000 0000 0000 0000 0000 0000 0000 0100    // 结果：4    fmt.Println(n1 &gt;&gt; 2)    // n1 = 1   0000 0000 0000 0000 0000 0000 0000 0001    // n1 &gt;&gt; 2  0000 0000 0000 0000 0000 0000 0000 0000    // 结果：0&#125;</code></pre><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点数用于表示带小数的数字，Go 提供 float32 和 float64 两种浮点类型<br>字面量：</p><ul><li>十进制表示法：3.1415926</li><li>科学记数法：1e-5</li></ul><h3 id="复数型"><a href="#复数型" class="headerlink" title="复数型"></a>复数型</h3><p>Go 提供 complex64 和 complex128 两种复数类型，针对 complex64 复数的实部和虚部均使用float32，针对 complex128 复数的实部和虚部均使用 float64</p><p>字面量：</p><ul><li>十进制表示法：<code>1 + 2i</code>，<code>i*i = -1</code>, 1 为实部，2 为虚部</li></ul><p>常用函数: </p><ul><li>complex: 工厂函数，通过两个参数创建一个复数</li><li>real：用于获取复数的实部</li><li>imag: 用于获取复数的虚部</li></ul><pre><code class="go">func main() &#123;    var (        c1 complex64 = 1 + 2i        c2 complex64 = complex(3, 4)    )    fmt.Println(c1, c2)             // (1+2i) (3+4i)    fmt.Println(real(c2), imag(c2)) // 3 4&#125;</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go 语言内置了字符串类型，使用 string 表示<br>字面量：</p><ul><li>可解析字符串：通过双引号(“)来创建，不能包含多行，支持特殊字符转义序列</li><li>原生字符串：通过反引号(&#96;)来创建，可包含多行，不支持特殊字符转义序列</li></ul><p>特殊字符：</p><ul><li>\：反斜线</li><li>&#39;：单引号</li><li>&quot;：双引号</li><li>\a：响铃</li><li>\b：退格</li><li>\f：换页</li><li>\n：换行</li><li>\r：回车</li><li>\t：制表符</li><li>\v：垂直制表符</li><li>\ooo：3 个 8 位数字给定的八进制码点的 Unicode 字符（不能超过\377） - \uhhhh：4 个 16 位数字给定的十六进制码点的 Unicode 字符</li><li>\Uhhhhhhhh：8 个 32 位数字给定的十六进制码点的 Unicode 字符</li><li>\xhh：2 个 8 位数字给定的十六进制码点的 Unicode 字符</li></ul><p>常用操作</p><ul><li>字符串连接：+</li><li>关系运算符：&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;</li><li>赋值运算符：+&#x3D;</li><li>索引：s[index]，针对只包含 ascii 字符的字符串</li><li>切片：s[start:end] ，针对只包含 ascii 字符的字符串</li></ul><p>字符串遍历，遍历的结果是码点，且由于中文和英文占的字节数不同，遍历的索引位也不相同，GBK编码，一个汉字占两个字节。 UTF-8编码是变长编码，通常汉字占三个字节，因此遍历的结果如下所示</p><pre><code class="go">func main() &#123;    str := &quot;我不是药神abcde&quot;    for i, v := range str &#123;      fmt.Println(i, v)    &#125;    // 0 25105    // 3 19981    // 6 26159    // 9 33647    // 12 31070    // 15 97    // 16 98    // 17 99    // 18 100    // 19 101&#125;</code></pre><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>go 中并没有枚举类型，但是可以通过 const 来模拟枚举，常使用 iota 生成器用于初始化一系列相同规则的常量，批量声明常量的第一个常量使用iota 进行赋值，此时 iota 被重置为 0，其他常量省略类型和赋值，在每初始化一个常量则加 1</p><pre><code class="go">func main() &#123;    const (        SUNDAY    int = 0        MONDAY    int = 1        TUESDAY   int = 2        WEDNESDAY int = 3        THURSDAY  int = 4        FRIDAY    int = 5        SATURDAY  int = 6    )    fmt.Println(SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY)    // 0 1 2 3 4 5 6&#125;</code></pre><pre><code class="go">func main() &#123;    // 在文件中使用的 const 来模拟枚举，每次都要定义一个数，非常累赘;    // 这里可以引入一个 iota 变量，这个变量有个特点就是在【同一个小括号内】，每调用一次，就会+1，类似一个每次+1的生成器;    const (        SUNDAY = iota        MONDAY        TUESDAY        WEDNESDAY        THURSDAY        FRIDAY        SATURDAY    )    fmt.Println(SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY)    // 0 1 2 3 4 5 6&#125;</code></pre><p>注意iota的特性</p><pre><code class="go">func main() &#123;    const (        n1 = iota        n2        n3        n4 = 100        n5 = iota        n6    )    fmt.Println(n1, n2, n3, n4, n5, n6)    // 0 1 2 100 4 5&#125;</code></pre><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>每个变量在内存中都有对应存储位置（内存地址），可以通过&amp;运算符获取。指针是用来存储变量地址的变量</p><ul><li>声明：指针声明需要指定存储地址中对应数据的类型，并使用*作为类型前缀。指针变量声明后会被初始化为 nil，表示空指针</li><li>初始化：<ol><li>使用&amp;运算符+变量初始化：&amp;运算获取变量的存储位置来初始化指针变量</li><li>使用 new 函数初始化：new 函数根据数据类型申请内存空间并使用零值填充，并返回申请空间地址</li></ol></li><li>操作：可通过*运算符+指针变量名来访问和修改对应存储位置的值</li></ul><pre><code class="go">func main() &#123;    // 对于数字这种数据类型，当使用一个变量接收另一个变量时，会在内存中开辟一块新的内存地址用来保存，从而无法修改原始变量    var num int = 100    var num1 int = num    num1 = 200    fmt.Println(num, num1) // 100 200    num3 := 500    var num4 *int = &amp;num3 // *int 表示指针类型  同理  *string 也是，在类型前加上*即表示指针  &amp;可以拿到一个变量的指针    *num4 = 600    fmt.Println(num3, *num4) // 600 600    // 可以申请一个空指针，用来存储数据    num5 := new(int)         // num5此时是一个指针  *int类型，默认是零值 0    fmt.Println(num5, *num5) // *int 0    *num5 = 999    fmt.Println(num5, *num5) // *int 999    str1 := new(string)    fmt.Println(str1, *str1) // *string   &quot;&quot;&#125;</code></pre><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>Go语言中的流程控制和其他编程语言基本一样，可能就是语法上的差异而已，流程控制的逻辑都是一样的，需要说明的是，在Go语言中，是没有while循环的，需要使用for循环代替。还有switch case语法，和js是不一样的，这些都是根据语言语法规定的。</p><pre><code class="go">func main() &#123;    // if else    condition := true    if condition == true &#123;        fmt.Println(&quot;true&quot;)    &#125; else &#123;          fmt.Println(&quot;false&quot;)    &#125;    // if else if    score := 100    if score == 100 &#123;          fmt.Println(&quot;pretty good&quot;)    &#125; else if score &gt;= 90 &#123;          fmt.Println(&quot;good&quot;)    &#125; else if score &gt;= 60 &#123;          fmt.Println(&quot;ok&quot;)    &#125; else &#123;          fmt.Println(&quot;bad&quot;)    &#125;    // switch case    switch &#123;        case score == 100:        fmt.Println(&quot;pretty good&quot;)        case score &gt;= 90:        fmt.Println(&quot;good&quot;)        case score &gt;= 60:        fmt.Println(&quot;ok&quot;)        default:        fmt.Println(&quot;bad&quot;)    &#125;    // for循环    sum := 0    for index := 1; index &lt;= 100; index++ &#123;          sum += index    &#125;    fmt.Println(sum)    // go 中没有while循环，使用for循环代替    sum1 := 0    index1 := 1    for index1 &lt;= 100 &#123;        sum1 += index1        index1++    &#125;    fmt.Println(sum1)    // 死循环    sum2 := 0    index2 := 1    for &#123;        if index2 &gt; 100 &#123;              break        &#125;        sum2 += index2        index2++    &#125;    fmt.Println(sum2)&#125;</code></pre><h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><ul><li>break：跳出当前循环</li><li>continue：跳出本次循环，开始下一次循环</li><li>break [LABEL]：结合label跳出外层循环</li></ul><pre><code class="go">func main() &#123;    for i := 0; i &lt;= 10; i++ &#123;        if i == 5 &#123;               break // break 跳出循环        &#125;        fmt.Println(i)    &#125;    fmt.Println(&quot;-----------------------&quot;)    for j := 0; j &lt;= 10; j++ &#123;        if j == 5 &#123;            continue // continue 跳出本次循环，开始下一次循环        &#125;        fmt.Println(j)    &#125;    fmt.Println(&quot;-----------------------&quot;)    // 默认 break 只能跳出当前循环，不能跳出外级循环    for k := 0; k &lt;= 10; k++ &#123;        for u := 0; u &lt;= 10; u++ &#123;            if u == 5 &#123;                  break // continue 跳出本次循环，开始下一次循环            &#125;            fmt.Println(k, u)        &#125;    &#125;    fmt.Println(&quot;-----------------------&quot;)    // 如果想要跳出外层循环，需要结合label    LOOP:    for x := 0; x &lt;= 10; x++ &#123;        for y := 0; y &lt;= 10; y++ &#123;            if y == 5 &#123;                  break LOOP // continue 跳出本次循环，开始下一次循环            &#125;            fmt.Println(x, y)        &#125;    &#125;    // 和js里面的一样&#125;</code></pre><h2 id="label和goto"><a href="#label和goto" class="headerlink" title="label和goto"></a>label和goto</h2><p>goto 表示代码运行过程中跳转到哪里，START 和 END 不是固定的，可以自己取值</p><pre><code class="go">func main() &#123;    sum := 0    index := 1    START:    if index &gt; 100 &#123;          goto END    &#125;    sum += index    index++    goto START    END:    fmt.Println(sum)&#125;</code></pre><h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组声明需要指定组成元素的类型以及存储元素的数量（长度）。在数组声明后，其长度不可修改，数组的每个元素会根据对应类型的零值对进行初始化。</p><p>字面量声明数组</p><ul><li>指定数组长度: [length]type{v1, v2, …, vlength}</li><li>使用初始化元素数量推导数组长度: […]type{v1, v2, …, vlength}</li><li>对指定位置元素进行初始化: [length]type{im:vm, …, sin:in}</li></ul><pre><code class="go">func main() &#123;    // go 中数组不可删除和添加  因为长度会影响类型，类型固定后就不能添加和删除了，和js不同    // 长度一旦固定则不可变，一般在go中很少使用，一般使用切片    var arr1 [10]int = [10]int&#123;&#125;    fmt.Printf(&quot;%T, %v \n&quot;, arr1, arr1) // [10]int, [0 0 0 0 0 0 0 0 0 0]    arr2 := [10]int&#123;&#125;    fmt.Printf(&quot;%T, %v \n&quot;, arr2, arr2) // [10]int, [0 0 0 0 0 0 0 0 0 0]    arr3 := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;    fmt.Printf(&quot;%T, %v \n&quot;, arr3, arr3) // [10]int, [1 2 3 4 5 6 7 8 9 10]    arr4 := [10]int&#123;1, 2, 3, 4, 5&#125;    fmt.Printf(&quot;%T, %v \n&quot;, arr4, arr4) // [10]int, [1 2 3 4 5 0 0 0 0 0]    arr5 := [10]int&#123;0: 1, 3: 2, 5: 3&#125;    fmt.Printf(&quot;%T, %v \n&quot;, arr5, arr5) // [10]int, [1 0 0 2 0 3 0 0 0 0]    str1 := [5]string&#123;&#125;    fmt.Printf(&quot;%T, %q \n&quot;, str1, str1) // [5]string, [&quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot;]    str2 := [5]string&#123;&quot;abc&quot;, &quot;def&quot;&#125;    fmt.Printf(&quot;%T, %q \n&quot;, str2, str2) // [5]string, [&quot;abc&quot; &quot;def&quot; &quot;&quot; &quot;&quot; &quot;&quot;]    str3 := [5]string&#123;0: &quot;abc&quot;, 3: &quot;def&quot;&#125;    fmt.Printf(&quot;%T, %q \n&quot;, str3, str3) // [5]string, [&quot;abc&quot; &quot;&quot; &quot;&quot; &quot;def&quot; &quot;&quot;]    // ...推导    var arr6 [10]int    fmt.Printf(&quot;%T, %v \n&quot;, arr6, arr6) // [10]int, [0 0 0 0 0 0 0 0 0 0]    arr6 = [...]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; // ... 会按照后面给定的个数自动推导    fmt.Printf(&quot;%T, %v \n&quot;, arr6, arr6)            // [10]int, [1 2 3 4 5 6 7 8 9 10]    // arr6 = [...]int&#123;1,2,3&#125;// 报错 cannot use [...]int&#123;…&#125; (value of type [3]int) as type [10]int in assignment    for i := 0; i &lt; len(arr6); i++ &#123;          fmt.Println(arr6[i])    &#125;    for index := range arr6 &#123;          fmt.Println(arr6[index])    &#125;    for index, value := range arr6 &#123;          fmt.Println(index, value)    &#125;    for _, value := range arr6 &#123;        fmt.Println(value)    &#125;  &#125;</code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是长度可变的数组（具有相同数据类型的数据项组成的一组长度可变的序列），切片由三部分组成：</p><ul><li>指针：指向切片第一个元素指向的数组元素的地址</li><li>长度：切片元素的数量</li><li>容量：切片开始到结束位置元素的数量</li></ul><pre><code class="go">func main() &#123;    // 切片是相同类型长度可变的元素集合    // nil切片, 不赋值，可以理解威切片的零值是nil    var slice []int    fmt.Println(slice, slice == nil) // [] true    // 空切片    slice1 := []int&#123;&#125;    fmt.Println(slice1, slice1 == nil) // [] false    slice2 := []int&#123;0: 1, 10: 10&#125;    fmt.Println(slice2) // [1 0 0 0 0 0 0 0 0 0 10]    slice2[4] = 4    fmt.Println(slice2) // [1 0 0 0 4 0 0 0 0 0 10]    // 通过make函数来创建切片，类似于js中的 new Array(5).fill(0)    slice3 := make([]int, 5)    fmt.Println(slice3) // [0 0 0 0 0]    slice4 := make([]string, 5)    fmt.Printf(&quot;%q \n&quot;, slice4) // [&quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot;]    // 切片容量    // 通过make函数的第三个参数，可以指定切片的容量    // 切片在底层使用数组进行数据存储，数组是有固定长度的，当切片的长度超过了数组的长度，切片将会申请一个更长的数组，再将原来的数组拷贝过来    slice5 := make([]int, 5, 10)    fmt.Println(slice5, len(slice5), cap(slice5)) // [0 0 0 0 0] 5 10    // 切片可以通过数组进行切片操作来获得，切片的长度既截取出来的长度3，切片的容量既数组的长度减去开始索引位 10 - 2 = 8    arr1 := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;    slice6 := arr1[2:5]    fmt.Println(slice6, len(slice6), cap(slice6)) // [3 4 5] 3 8    // !!!需要注意的是，通过数组切片操作获得的切片，底层共享数组的数据    // 可以看到我们此时将数组的第五个元素修改成为100，切片slice6同样会发生修改，使用时需要特殊注意    arr1[4] = 100    fmt.Println(arr1, slice6) // [1 2 3 4 100 6 7 8 9 10] [3 4 100]    // 遍历，和遍历数组一样，可以通过下标或者range    slice7 := []int&#123;1, 2, 3, 4, 5&#125;    for i := 0; i &lt; len(slice7); i++ &#123;        fmt.Println(slice7[i])    &#125;    for index, value := range slice7 &#123;        fmt.Println(index, value)    &#125;    // 添加 append(slice, item1, item2, item3, ...)，append接收一个添加了切片的返回值，不会直接在原始切片中添加元素    slice8 := append(slice7, 6, 7, 8)    fmt.Println(slice7, slice8) // [1 2 3 4 5] [1 2 3 4 5 6 7 8]    // 删除，在go中没有直接提供删除切片元素的方法，例如js中的pop shift splice    // 可以使用切片操作和解构来进行切片的删除    slice9 := []int&#123;1, 2, 3, 4, 5&#125;    // 删除最后一个元素    slice10 := slice9[0 : len(slice9)-1]    fmt.Println(slice9, slice10) // [1 2 3 4 5] [1 2 3 4]    // 删除第一个元素    slice11 := slice9[1:len(slice9)] // 如果取到末尾，len(slice9)可省略    fmt.Println(slice9, slice11)     // [1 2 3 4 5] [2 3 4 5]    // 删除中间元素, 比如删除3，索引位2的元素    slice12 := append(slice9[0:2], slice9[3:]...) // 这里注意，会修改原始slice9切片, go中的解包操作符...是写在后面，而js中是写在前面    fmt.Println(slice9, slice12)                  // [1 2 4 5 5] [1 2 4 5]    // 切片的切片    slice13 := make([]int, 5, 10)    slice13[0] = 1    slice13[1] = 2    slice13[2] = 3    fmt.Println(slice13, len(slice13), cap(slice13)) // [1 2 3 0 0] 5 10    // 切片的endIndex可以超过长度，但不能超过容量，没有赋值的部分取零值    fmt.Println(slice13[1:10]) // [2 3 0 0 0 0 0 0 0]    // copy函数    // 如果src length 和 dst length 相等，则直接进行覆盖    dst := make([]int, 3)    src := []int&#123;1, 2, 3&#125;    copy(dst, src)    fmt.Println(dst, src) // [1 2 3] [1 2 3]    // 如果src length &gt; dst length，则多出的部分会被舍弃    dst1 := make([]int, 3)    src1 := []int&#123;1, 2, 3, 4&#125;    copy(dst1, src1)    fmt.Println(dst, src) // [1 2 3] [1 2 3]    // 如果src length &lt; dst length，则只会覆盖src存在的部分    dst2 := make([]int, 3)    src2 := []int&#123;1, 2&#125;    copy(dst2, src2)    fmt.Println(dst2, src2) // [1 2 0] [1 2]&#125;</code></pre><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射是存储一系列无序的 key&#x2F;value 对，通过 key 来对 value 进行操作（增、删、改、查）。映射的 key 只能为可使用&#x3D;&#x3D;运算符的值类型（字符串、数字、布尔、数组），value 可以为任意类型 s。</p><p>map 声明需要指定组成元素 key 和 value 的类型，在声明后，会被初始化为 nil，表示暂不存在的映射</p><p>初始化 </p><ul><li>使用字面量初始化:map[ktype]vtype{k1:v1, k2:v2, …, kn:vn}</li><li>使用字面量初始化空映射:map[ktype]vtype{ }</li><li>使用 make 函数初始化<br>make(map[ktype]vtype)，通过 make 函数创建映射</li></ul><pre><code class="go">func main() &#123;    // key value 的无序集合， 遍历时不保证顺序，在go中通过hash table实现    // 定义  map[keyType]valueType，零值是nil    // 字面量定义，零值是nil    var map1 map[string]string    fmt.Printf(&quot;%T %v \n&quot;, map1, map1 == nil) // map[string]string true    // 字面量定义并赋值    map2 := map[string]int&#123;&quot;key1&quot;: 1&#125;    fmt.Printf(&quot;%v %v \n&quot;, map2, map2 == nil) // map[key1:1] false    // 增    // 直接对key进行赋值，map是引用类型    mapNew := map2    map2[&quot;newKey&quot;] = 11    fmt.Println(map2, mapNew) // map[key1:1 newKey:11] map[key1:1 newKey:11]    // 删    // 调用内置函数delete    delete(map2, &quot;newKey&quot;)    fmt.Println(map2) // map[key1:1]    // 改    // 直接对key的value进行修改    map2[&quot;key1&quot;] = 999    fmt.Println(map2) // map[key1:999]    // 查    // 如果key对应的value存在，则直接返回对应的value    value := map2[&quot;key1&quot;]    fmt.Println(value) // 999    // 如果key对应的value不存在，则返回value类型的零值    value2 := map2[&quot;key2&quot;]    fmt.Println(value2) // 0    // 判断对应的value存不存在，可以接受第二个返回值，布尔类型，即对应key的value存不存在，不需要自己取值手动判断    value3, exist3 := map2[&quot;key1&quot;]    fmt.Println(value3, exist3) // 1 true    value4, exist4 := map2[&quot;key2&quot;]    fmt.Println(value4, exist4) // 0 false    // 遍历，不保证顺序，没有index，只能用range遍历    for key := range map2 &#123;        fmt.Println(key, map2[key])    &#125; // key1 999    for key, value := range map2 &#123;        fmt.Println(key, value)    &#125; // key1 999    // 通过make创建map    map3 := make(map[int]string)    map3[0] = &quot;0&quot;    map3[1] = &quot;1&quot;    fmt.Println(map3) // map[0:0 1:1]&#125;</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数用于对代码块的逻辑封装，提供代码复用的最基本方式，函数也可以赋值给变量，存储在数组、切片、映射中，也可作为参数传递给函数或作为函数返回值进行返回。函数的入参是值传递，传递进来的参数会进行一个拷贝，如果在函数内部需要修改传进来的入参，需要传递指针，用来修改传进来的原始入参值</p><pre><code class="go">package mainimport &quot;fmt&quot;func add(a int, b int) int &#123;    return a + b&#125;// 任意多个参数func anyArgs(args ...string) &#123;    fmt.Printf(&quot;%T %v \n&quot;, args, args) // []string [1 2 3]&#125;func sumFunc(n ...int) int &#123;    sum := 0    for _, v := range n &#123;        sum += v    &#125;    return sum&#125;// 多个返回值func calc(a, b int) (int, int, int, int) &#123;    return a + b, a - b, a * b, a / b&#125;// 命名返回值，返回类型中定义的参数，将直接再函数作用域中申明，并使用零值初始化，在函数体内部不需要重复定义// 并可以直接return，无需加上返回参数func sumFunc2(n ...int) (sum int) &#123;    for _, v := range n &#123;        sum += v    &#125;    return&#125;func calc2(a, b int) (jia, jian, cheng, chu int) &#123;    jia = a + b    jian = a - b    cheng = a * b    chu = a / b    return&#125;// 闭包，闭包就是在一个函数中返回另一个函数，在返回函数的内部使用到了外层函数的变量，这个变量在函数执行完的时候并不会被销毁，留着别删func bb() func() string &#123;    name := &quot;123&quot;    return func() string &#123;        return name    &#125;&#125;func main() &#123;    sum := add(1, 2)    fmt.Println(sum) // 3    anyArgs(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)    fmt.Println(sumFunc(1, 2, 3, 4, 5)) // 15    r1, r2, r3, r4 := calc(4, 2)    fmt.Printf(&quot;%v %v %v %v \n&quot;, r1, r2, r3, r4) // 6 2 8 2    fmt.Println(sumFunc2(1, 2, 3, 4)) // 10    rt1, rt2, rt3, rt4 := calc2(6, 2)    fmt.Printf(&quot;%v %v %v %v \n&quot;, rt1, rt2, rt3, rt4) // 8 4 12 3&#125;</code></pre><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go 语言通过 error 接口实现错误处理的标准模式，通过使用函数返回值列表中的最后一个值返回错误信息，将错误的处理交由程序员主动进行处理</p><pre><code class="go">package mainimport (    &quot;errors&quot;    &quot;fmt&quot;)// go标准建议显式的将错误信息返回给开发者，由调用者自行处理// 返回错误一般有两种方法，如fact函数中注释处的用法func fact(n int64) (int64, error) &#123;    if n &lt; 0 &#123;        return 0, fmt.Errorf(&quot;计算错误&quot;) // 和下面的方式一样    &#125;    if n == 0 || n == 1 &#123;        return 1, nil    &#125;    r, err := fact(n - 1)    if err == nil &#123;        return n * r, nil    &#125;    return 0, errors.New(&quot;计算错误&quot;) // 和上面的方式一样&#125;// panic 抛出错误，通过panic抛出的错误，程序将直接终止，如果错误是一个可恢复的，我们需要保持程序运行，还是需要对错误进行手动处理// 此时我们还是需要将其转换成为error的方式，通过defer函数调用和recover恢复函数执行，可以将其转换，是一种常见的方式func fact1(n int64) int64 &#123;    if n &lt; 0 &#123;        panic(&quot;n不能小于0&quot;)    &#125;    if n == 0 || n == 1 &#123;        return 1    &#125;    return n * fact1(n-1)&#125;func main() &#123;    r, err := fact(5)    fmt.Printf(&quot;%v %v\n&quot;, r, err) // 120 nil    r1, err1 := fact(-1)    fmt.Printf(&quot;%v %v\n&quot;, r1, err1) // 0 计算错误    fact1(-1) // 直接调用，此时程序会直接终止&#125;</code></pre><h2 id="panic-与-recover-函数"><a href="#panic-与-recover-函数" class="headerlink" title="panic 与 recover 函数"></a>panic 与 recover 函数</h2><p>go 语言提供 panic 和 recover 函数用于处理运行时错误，当调用 panic 抛出错误，中断原有的控制流程，常用于不可修复性错误。recover 函数用于终止错误处理流程，仅在 defer 语句的函数中有效，用于截取错误处理流程，recover 只能捕获到最后一个错误</p><pre><code class="go">package mainimport (    &quot;fmt&quot;)// panic 抛出错误，通过panic抛出的错误，程序将直接终止，如果错误是一个可恢复的，我们需要保持程序运行，还是需要对错误进行手动处理// 此时我们还是需要将其转换成为error的方式，通过defer函数调用和recover恢复函数执行，可以将其转换，是一种常见的方式// defer执行时机是其所在函数退出的时候执行，并且是一个堆栈解构，defer中的函数会存起来，当所在函数结束后，再取出来执行，由于是堆栈解构，先进后出，会优先执行代码上下文中靠后的defer调用func fact(n int64) int64 &#123;    if n &lt; 0 &#123;        panic(&quot;n不能小于0&quot;)    &#125;    if n == 0 || n == 1 &#123;        return 1    &#125;    return n * fact(n-1)&#125;func warpedErrorFact(n int64) (r int64, err error) &#123;    defer func() &#123;        errMsg := recover()        if errMsg != nil &#123;            err = fmt.Errorf(&quot;%v&quot;, errMsg)        &#125;    &#125;()    r = fact(n)    return&#125;func main() &#123;    r, err := warpedErrorFact(-5)    fmt.Println(r, err) // 0 n不能小于0    r1, err1 := warpedErrorFact(5)    fmt.Println(r1, err1) // 120 &lt;nil&gt;&#125;</code></pre><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer 关键字用户声明函数，不论函数是否发生错误都在函数执行最后执行(return 之前)，若使用 defer 声明多个函数，则按照声明的顺序，先声明后执行（堆）常用来做资源释放，记录日志等工作</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    defer func() &#123;        fmt.Println(&quot;函数延迟执行1&quot;)    &#125;()    defer func() &#123;        fmt.Println(&quot;函数延迟执行2&quot;)    &#125;()    defer func() &#123;        fmt.Println(&quot;函数延迟执行3&quot;)    &#125;()    fmt.Println(&quot;main&quot;)&#125;</code></pre><pre><code class="bash">main函数延迟执行3函数延迟执行2函数延迟执行1</code></pre><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包是函数和数据的集合，将有相关特性的函数和数据放在统一的文件&#x2F;目录进行管理，每个包都可以作为独立的单元维护并提供给其他项目进行使用</p><p>Go 源文件都需要在开头使用 package 声明所在包，包名告知编译器哪些是包的源代码用于编译库文件，其次包名用于限制包内成员对外的可见性，最后包名用于在包外对公开成员的访问</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>包名使用简短的小写字母，常与所在目录名保持一致，一个包中可以由多个 Go 源文件，但必须使用相同包名</p><h2 id="导入-调用"><a href="#导入-调用" class="headerlink" title="导入&amp;调用"></a>导入&amp;调用</h2><p>在使用包时需要使用 import 将包按路径名导入，再通过包名调用成员，可通过 import 每行导入一个包，也可使用括号包含所有包并使用一个 import 导入</p><h2 id="编译-运行"><a href="#编译-运行" class="headerlink" title="编译&amp;运行"></a>编译&amp;运行</h2><p>使用 go build 编译二进制文件<br>命令：go build gpkgmain<br>说明：编译路径 gpkgmain 下的包，main 包，则在当前目录产生以 pkgmain 命名的<br>二进制程序</p><ul><li>使用 go run 运行二进制文件<br>命令：go run gpkgmain</li><li>使用 go install 编译并发布二进制文件<br>命令：go install gpkgmain<br>说明：编译并发布路径 gpkgmain 下的包，main 包，则在将编译后的以 pkgmain 命<br>名的二进制程序拷贝到 bin 目录</li><li>使用 go install 编译发布库文件<br>命令：go install gpkgname&#x2F;pkg01<br>说明：编译并发布路径 gpkgname&#x2F;pkg01 下的包，非 main 包，则在将编译的以包名<br>命名的库文件拷贝到 pkg&#x2F;GOOS_GOARCH 目录下 - 使用 go install 编译发布所有二进制和库文件<br>命令：go install .&#x2F;…</li></ul><h2 id="导入形式"><a href="#导入形式" class="headerlink" title="导入形式"></a>导入形式</h2><ol><li>绝对路径导入<br>在 GOPATH 目录中查找包<br>示例：<br> import “fmt”<br> import “gpkgname&#x2F;pkg01”</li><li>相对路径导入<br>在当前文件所在的目录查找<br>示例：<br>   import “.&#x2F;gpkgname&#x2F;pkg02”</li><li>点导入<br>在调用点导入包中的成员时可以直接使用成员名称进行调用（省略包名）</li></ol><pre><code class="go">package mainimport . &quot;fmt&quot;func main () &#123;      Println(&quot;Hello world&quot;)&#125;</code></pre><ol start="4"><li>别名导入<br>当导入不同路径的相同包名时，可以别名导入为包重命名，避免冲突</li></ol><pre><code class="go">package mainimport f &quot;fmt&quot;func main () &#123;    f.Println(&quot;Hello world&quot;)&#125;</code></pre><ol start="5"><li>下划线导入<br>Go 不允许包导入但未使用，在某些情况下需要初始化包，使用空白符作为别名进行导入，从而使得包中的初始化函数可以执行</li></ol><h2 id="成员可见性"><a href="#成员可见性" class="headerlink" title="成员可见性"></a>成员可见性</h2><p>Go 语言使用名称首字母大小写来判断对象(常量、变量、函数、类型、结构体、方法等)的访问权限，首字母大写标识包外可见(公开的)，否者仅包内可访问(内部的)</p><h2 id="main-包与-main-函数"><a href="#main-包与-main-函数" class="headerlink" title="main 包与 main 函数"></a>main 包与 main 函数</h2><p>main 包用于声明告知编译器将包编译为二进制可执行文件，在 main 包中的 main 函数是程序的入口，无返回值，无参数</p><h2 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h2><p>init 函数是初始化包使用，无返回值，无参数。建议每个包只定义一个。init 函数在 import包时自动被调用（const-&gt;var-&gt;init）</p><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Go1.11 版本提供 Go modules 机制对包进行管理，同时保留 GOPATH 和 vendor 机制，使用临时环境变量 GO111MODULE 进行控制，GO111MODULE 有三个可选值：</p><ul><li>当 GO111MODULE 为 off 时，构建项目始终在 GOPATH 和 vendor 目录搜索目标程序依赖包</li><li>当 GO111MODULE 为 on 时，构建项目则始终使用 Go modules 机制，在 GOPATH&#x2F;pkg&#x2F;mod目录搜索目标程序依赖包</li><li>当 GO111MODULE 为 auto(默认)时,当构建源代码不在 GOPATH&#x2F;src 的子目录且包含go.mod 文件，则使用 Go modules 机制，否则使用 GOPATH 和 vendor 机制</li></ul><h3 id="GOPATH-vendor-机制"><a href="#GOPATH-vendor-机制" class="headerlink" title="GOPATH+vendor 机制"></a>GOPATH+vendor 机制</h3><ul><li><p>vendor<br>将项目依赖包拷贝到项目下的 vendor 目录，在编译时使用项目下 vendor 目录中的包进行编译<br>解决问题：<br>  外部包过多，在使用第三方包时需要使用 go get 进行下载<br>  第三方包在 go get 下载后不能保证开发和编译时版本的兼容性  </p></li><li><p>包搜索顺序<br>1.在当前包下的 vendor 目录查找<br>2.向上级目录查找，直到 GOPATH&#x2F;src&#x2F;vendor 目录<br>3.在 GOPATH 目录查找<br>4.在 GOROOT 目录查找</p></li><li><p>第三方包<br>可以借助 go get 工具下载和安装第三方包及其依赖，需要安装与第三方包匹配的代码管理工具，比如 git、svn 等</p></li></ul><h3 id="Go-modules-机制"><a href="#Go-modules-机制" class="headerlink" title="Go modules 机制"></a>Go modules 机制</h3><p><strong>优势：</strong></p><ul><li>不用设置 GOPATH，代码可任意放置</li><li>自动下载依赖管理</li><li>版本控制</li><li>不允许使用相对导入</li><li>replace 机制</li></ul><p><strong>初始化模块</strong><br>命令：go mod init modname</p><p><strong>当前模块下的包</strong><br>对于当前模块下的包导入时需要使用 modname+packagename</p><p><strong>第三方包</strong><br>在使用 go mod tidy、go build、go test、go list 命令会自动将第三方依赖包写入到go.mod 文件中同时下载第三方依赖包到 GOPATH&#x2F;pkg&#x2F;mod&#x2F;cache 目录，并在当前模块目录生成一个构建状态跟踪文件 go.sum,文件中记录当前 module 所有的顶层和间接依赖，以及这些依赖的校验和</p><p><strong>常用命令</strong></p><ul><li>go mod tidy:整理依赖模块（添加新增的，删除未使用的）</li><li>go mod vendor: 将依赖模块拷贝到模块中的 vendor 目录</li><li>go build: 编译当前模块</li><li>go build .&#x2F;…: 编译当前目录下的所有模块</li><li>go build -mod&#x3D;vendor:使用当前模块下的 vendor 目录中的包进行编译</li><li>go mod download: 仅下载第三方模块</li><li>go mod grapha: 打印所有第三方模块</li><li>go list -m -json all：显示所有模块信息</li><li>go mod edit: 修改 go.mod 文件<br>  require&#x3D;pakcage@version<br>   replace&#x3D;old_package@version&#x3D;new_package@version<br>  可以使用-replace 功能将包替换为本地包，实现相对导入</li></ul><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>自定义类型类似于别名，可以将go的类型自定义为自己的类型，这个类型的特性和原始go的特性一致，也可用于类型转换</p><pre><code class="go">type Counter int</code></pre><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>结构体定义使用 struct 标识，需要指定其包含的属性（名和类型），在定义结构体时可以为结构体指定结构体名（命名结构体），用于后续声明结构体变量使用。</p><pre><code class="go">type User struct &#123;    id    string    name  string    age   int    birth time.Time    tel   string    addr  string&#125;</code></pre><h2 id="声明结构体"><a href="#声明结构体" class="headerlink" title="声明结构体"></a>声明结构体</h2><p>声明结构体变量只需要定义变量类型为结构体名，变量中的每个属性被初始化为对应类型的零值。也可声明结构体指针变量，此时变量被初始化为 nil</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;time&quot;)type User struct &#123;    id    string    name  string    age   int    birth time.Time    tel   string    addr  string&#125;func main() &#123;    var u1 User    fmt.Println(u1) // &#123;  0 &#123;0 0 &lt;nil&gt;&#125;  &#125;    var u2 *User    fmt.Println(u2) // &lt;nil&gt;&#125;</code></pre><h2 id="结构体赋值"><a href="#结构体赋值" class="headerlink" title="结构体赋值"></a>结构体赋值</h2><p>使用结构体创建的变量叫做对应结构体的实例或者对象</p><ol><li>使用结构体零值初始化结构体值对象</li></ol><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;time&quot;)type User struct &#123;    id    string    name  string    age   int    birth time.Time    tel   string    addr  string&#125;func main() &#123;    var u1 User = User&#123;&#125;    fmt.Println(u1) // &#123;  0 &#123;0 0 &lt;nil&gt;&#125;  &#125;&#125;</code></pre><ol start="2"><li>使用结构体字面量初始化结构体值对象</li></ol><ul><li>使用结构体零值初始化结构体值对象</li><li>使用结构体字面量初始化结构体值对象</li><li>使用 new 函数进行初始化结构体指针对象</li><li>使用结构体字面量初始化结构体指针对象</li></ul><pre><code class="go">package mainimport (    &quot;fmt&quot;)type User struct &#123;    id   string    name string    age  int    tel  string    addr string&#125;func main() &#123;    var u1 User = User&#123;&quot;001&quot;, &quot;jerry&quot;, 18, &quot;13299999999&quot;, &quot;湖北&quot;&#125;    var u2 User = User&#123;id: &quot;002&quot;&#125;    var u3 *User = new(User)    u3.id = &quot;003&quot;    u4 := &amp;User&#123;id: &quot;004&quot;&#125;    fmt.Println(u1) // &#123;001 jerry 18 13299999999 湖北&#125;    fmt.Println(u2) // &#123;002  0  &#125;    fmt.Println(u3) // &amp;&#123;003  0  &#125;    fmt.Println(u4) // &amp;&#123;004  0  &#125;&#125;</code></pre><h2 id="属性的访问和修改"><a href="#属性的访问和修改" class="headerlink" title="属性的访问和修改"></a>属性的访问和修改</h2><p>通过结构体对象名&#x2F;结构体指针对象.属性名的方式来访问和修改对象的属性值</p><pre><code class="go">package mainimport &quot;fmt&quot;type User struct &#123;    id   string    name string    age  int    tel  string    addr string&#125;func main() &#123;    var u1 User = User&#123;id: &quot;001&quot;, name: &quot;jerry&quot;&#125;    fmt.Println(u1.id, u1.name) // 001 jerry    u1.id = &quot;1001&quot;    u1.name = &quot;tom&quot;    fmt.Println(u1.id, u1.name) // 1001 tom        var u2 *User = new(User)    fmt.Println(u2)    (*u2).id = &quot;002&quot;    u2.name = &quot;jack&quot;    fmt.Println(u2) // &amp;&#123;002 jack 0  &#125;    u2.id = &quot;003&quot;// 这里不取指针也可以对属性进行赋值    fmt.Println(u2) // &amp;&#123;003 jack 0  &#125;&#125;</code></pre><h2 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h2><p>在定义变量时将类型指定为结构体的结构，此时叫匿名结构体。匿名结构体常用于初始化一次结构体变量的场景，例如项目配置</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var connect = struct &#123;        ip       string        port     string        user     string        password string    &#125;&#123;&quot;127.0.0.1&quot;, &quot;8080&quot;, &quot;root&quot;, &quot;root@password&quot;&#125;    fmt.Println(connect)&#125;</code></pre><h2 id="命名嵌入"><a href="#命名嵌入" class="headerlink" title="命名嵌入"></a>命名嵌入</h2><p>结构体命名嵌入是指结构体中的属性对应的类型也是结构体，使用<code>.</code>链式调用修改或者访问值</p><pre><code class="go">package mainimport &quot;fmt&quot;type Address struct &#123;    country  string    province string&#125;type User struct &#123;    id   string    name string    addr Address // 命名嵌入&#125;func main() &#123;    var u1 User = User&#123;id: &quot;001&quot;, name: &quot;jerry&quot;, addr: Address&#123;country: &quot;china&quot;, province: &quot;hubei&quot;&#125;&#125;    fmt.Println(u1) // &#123;001 jerry &#123;china hubei&#125;&#125;    var u2Addr = Address&#123;&quot;中国&quot;, &quot;湖北&quot;&#125;    var u2 User = User&#123;&quot;002&quot;, &quot;tom&quot;, u2Addr&#125;    fmt.Println(u2) // &#123;002 tom &#123;中国 湖北&#125;&#125;        u1.addr.province = &quot;广东&quot;    fmt.Println(u1) // &#123;001 jerry &#123;china 广东&#125;&#125;&#125;</code></pre><h2 id="匿名嵌入"><a href="#匿名嵌入" class="headerlink" title="匿名嵌入"></a>匿名嵌入</h2><p>结构体匿名嵌入是指将已定义的结构体名直接声明在新的结构体中，从而实现对以后已有类型的扩展和修改</p><pre><code class="go">package mainimport &quot;fmt&quot;type Address struct &#123;    country  string    province string&#125;type User struct &#123;    id   string    name string    Address&#125;func main() &#123;    var u1 User = User&#123;&quot;001&quot;, &quot;jerry&quot;, Address&#123;&quot;china&quot;, &quot;hubei&quot;&#125;&#125;    fmt.Println(u1) // &#123;001 jerry &#123;china hubei&#125;&#125;    var u2 User = User&#123;&quot;002&quot;, &quot;tom&quot;, Address&#123;country: &quot;china&quot;, province: &quot;hubei&quot;&#125;&#125;    fmt.Println(u2) // &#123;002 tom &#123;china hubei&#125;&#125;    var u3 User = User&#123;id: &quot;003&quot;, name: &quot;jack&quot;, Address: Address&#123;country: &quot;china&quot;, province: &quot;hubei&quot;&#125;&#125;    fmt.Println(u3) // &#123;003 jack &#123;china hubei&#125;&#125;    fmt.Println(u1.country)  // china    fmt.Println(u2.province) // hubei    fmt.Println(u3.country)  // china    // 上述访问或修改属性的方法同样可以使用链式调用，只是可以省略其中匿名嵌套的结构体名    fmt.Println(u1.Address.country)  // china    fmt.Println(u2.Address.province) // hubei    fmt.Println(u3.Address.country)  // china&#125;</code></pre><p>下面声明方式是不通过的，通过下面的情况可以得出，匿名结构体嵌套实际上不是扩展，而是使用和结构体相同的名称进行命名，只是省略了名字，类似于下面的方式。注意是类似，因为下面这样声明实际上是命名嵌套了。</p><pre><code class="go">type User struct &#123;    id      string    name    string    Address Address&#125;</code></pre><pre><code class="go">// 不能使用下面方式声明// var u4 User = User&#123;&quot;003&quot;, &quot;jack&quot;, &quot;china&quot;, &quot;hubei&quot;&#125;// var u5 User = User&#123;id: &quot;003&quot;, name: &quot;jack&quot;, country: &quot;china&quot;, province: &quot;hubei&quot;&#125;</code></pre><h2 id="指针类型嵌入"><a href="#指针类型嵌入" class="headerlink" title="指针类型嵌入"></a>指针类型嵌入</h2><p>结构体嵌入(命名&amp;匿名)类型也可以为结构体指针，且由于指针的特性，当指针的值修改了之后，将会影响所有使用此指针的结构体</p><pre><code class="go">package mainimport &quot;fmt&quot;type Address struct &#123;    country  string    province string&#125;type User struct &#123;    id   string    name string    addr *Address&#125;func main() &#123;        addr := &amp;Address&#123;&quot;china&quot;, &quot;hubei&quot;&#125;    var u1 User = User&#123;&quot;001&quot;, &quot;jerry&quot;, addr&#125;    var u2 User = User&#123;&quot;002&quot;, &quot;tom&quot;, addr&#125;        addr.country = &quot;中国&quot;    fmt.Printf(&quot;%#v\n&quot;, u1.addr.country) // &quot;中国&quot;    fmt.Printf(&quot;%#v\n&quot;, u2.addr.country) // &quot;中国&quot;&#125;</code></pre><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>结构体首字母大写则包外可见(公开的)，否者仅包内可访问(内部的)<br>结构体属性名首字母大写包外可见(公开的)，否者仅包内可访问(内部的)<br>组合：</p><ul><li>结构体名首字母大写，属性名大写：结构体可在包外使用，且访问其大写的属性名</li><li>结构体名首字母大写，属性名小写：结构体可在包外使用，且不能访问其小写的属性名</li><li>结构体名首字母小写，属性名大写：结构体只能在包内使用，属性访问在结构体嵌入时<br>由被嵌入结构体(外层)决定，被嵌入结构体名首字母大写时属性名包外可见，否者只能在包内使用</li><li>结构体名首字母小写，属性名小写：结构体只能在包内使用</li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>方法是添加了接收者的函数，接收者必须是自定义的类型</p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>调用方法通过自定义类型的<code>对象.方法名</code>进行调用，在调用过程中对象传递(赋值)给方法的接收者（值类型，拷贝）</p><pre><code class="go">package mainimport &quot;fmt&quot;type Dog struct &#123;    name string&#125;func (d Dog) Run() &#123;    fmt.Printf(&quot;%s running&quot;, d.name)&#125;func (d Dog) RenameOne(name string) &#123;    d.name = name&#125;func (d *Dog) RenameTwo(name string) &#123;    d.name = name&#125;func main() &#123;    var d1 Dog = Dog&#123;&quot;dahuang&quot;&#125;    d1.Run() // dahuang running    // 由于传递给方法的变量时值传递，因此这里rename是不会修改传入的变量的原始值的    d1.RenameOne(&quot;xiaohei&quot;)    d1.Run() // dahuang running    (&amp;d1).RenameTwo(&quot;xiaohei&quot;)    d1.Run() // xiaohei running&#125;</code></pre><h2 id="结构体指针对象调用值接收者方法"><a href="#结构体指针对象调用值接收者方法" class="headerlink" title="结构体指针对象调用值接收者方法"></a>结构体指针对象调用值接收者方法</h2><p>当使用结构体指针对象调用值接收者的方法时，Go 编译器会自动将指针对象”解引用”为值调用方法</p><pre><code class="go">package mainimport &quot;fmt&quot;type Dog struct &#123;    name string&#125;func (d Dog) Run() &#123;    fmt.Printf(&quot;%s running&quot;, d.name)&#125;func (d Dog) Rename(name string) &#123;    d.name = name&#125;func main() &#123;    var d1 *Dog = &amp;Dog&#123;&quot;dahuang&quot;&#125;    (*d1).Rename(&quot;xiaohei&quot;) // 自动会解引用成为值类型    (*d1).Run()// dahuang running&#125;</code></pre><h2 id="结构体对象调用指针接收者方法"><a href="#结构体对象调用指针接收者方法" class="headerlink" title="结构体对象调用指针接收者方法"></a>结构体对象调用指针接收者方法</h2><p>当使用结构体对象调用指针接收者的方法时，Go 编译器会自动将值对象”取引用”为指针调用方法</p><pre><code class="go">package mainimport &quot;fmt&quot;type Dog struct &#123;    name string&#125;func (d Dog) Run() &#123;    fmt.Printf(&quot;%s running&quot;, d.name)&#125;func (d *Dog) Rename(name string) &#123;    d.name = name&#125;func main() &#123;    var d1 Dog = Dog&#123;&quot;dahuang&quot;&#125;    d1.Rename(&quot;xiaohei&quot;) // 自动会取引用成为指针类型    d1.Run()             // xiaohei running&#125;</code></pre><blockquote><p>注：取引用和解引用发生在接收者中，对于函数&#x2F;方法的参数必须保持变量类型一一对<br>应</p></blockquote><h2 id="一般使用规则"><a href="#一般使用规则" class="headerlink" title="一般使用规则"></a>一般使用规则</h2><p>该使用值接收者还是指针接收者，取决于是否现需要修改原始结构体</p><ul><li>若不需要修改则使用值，若需要修改则使用指针</li><li>若存在指针接收者，则所有方法使用指针接收者<blockquote><p>对于接收者为指针类型的方法，需要注意在运行时若接收者为 nil 用会发生错误</p></blockquote></li></ul><h2 id="带方法的结构体命名嵌入"><a href="#带方法的结构体命名嵌入" class="headerlink" title="带方法的结构体命名嵌入"></a>带方法的结构体命名嵌入</h2><p>带方法的结构体命名嵌入，使用链式调用嵌入结构体上的方法</p><pre><code class="go">package mainimport &quot;fmt&quot;type User struct &#123;    name string    addr string&#125;func (u *User) SetAddr(addr string) &#123;    u.addr = addr&#125;type Employee struct &#123;    user   User    salary float64&#125;func (e *Employee) SetSalary(salary float64) &#123;    e.salary = salary&#125;func main() &#123;    var emp1 Employee = Employee&#123;user: User&#123;name: &quot;jerry&quot;, addr: &quot;深圳&quot;&#125;, salary: 3000.00&#125;    fmt.Println(emp1) // </code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-数据类型</title>
      <link href="/2018/03/01/Python/Python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/01/Python/Python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。<br>获取数据类型，<code>type()</code>内置函数</p><pre><code class="python">&gt;&gt;&gt; type(118)&lt;class &#39;int&#39;&gt;&gt;&gt;&gt; type(&#39;118&#39;)&lt;class &#39;str&#39;&gt;</code></pre><p>或者<code>instance()</code>函数判断数据类型</p><pre><code class="python">&gt;&gt;&gt; isinstance(118, int)True&gt;&gt;&gt; isinstance(&#39;118&#39;, str)True</code></pre><p>在Python中，能够直接处理的数据类型有以下几种：</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。<br>10进制：默认进制，0-9组成<br>2进制：0b前缀，0,1组成<br>8进制：0o前缀，0-7组成<br>16进制：0x前缀，0-9，a-f组成</p><pre><code class="python">&gt;&gt;&gt; print(118)118&gt;&gt;&gt; print(0b1110110)118&gt;&gt;&gt; print(0o166)118&gt;&gt;&gt; print(0x76)118</code></pre><p>使用内置函数<code>bin()</code>&#x2F;<code>oct()</code>&#x2F;<code>hex()</code>将十进制数转化为2&#x2F;8&#x2F;16进制数</p><pre><code class="python">&gt;&gt;&gt; bin(118)&#39;0b1110110&#39;&gt;&gt;&gt;&gt;&gt;&gt; oct(118)               ##在python2中，o会被省略，算是个很大的区别&#39;0o166&#39;&gt;&gt;&gt;&gt;&gt;&gt; hex(118)&#39;0x76&#39;</code></pre><p>内置函数<code>int()</code>创建整数，也可以把数字的字符串转化为整型</p><pre><code class="python">&gt;&gt;&gt; int()0&gt;&gt;&gt; int(118)118&gt;&gt;&gt; int(&#39;118&#39;)118&gt;&gt;&gt; int(118.2)118&gt;&gt;&gt; int(&#39;asd&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: &#39;asd&#39;&gt;&gt;&gt; int(&#39;118.2&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: &#39;118.2&#39;&gt;&gt;&gt; int(&#39;0b1110110&#39;, 2)           ##第一个参数必须是字符串类型118 &gt;&gt;&gt; int(&#39;0o166&#39;, 8)118&gt;&gt;&gt; int(&#39;0x76&#39;, 16)118</code></pre><p>在python2中，8进制的前缀0o中的o会被省略，但是在python3中，必须严格写上，否则会报错</p><pre><code class="python">#python2&gt;&gt;&gt; int(066)54#python3&gt;&gt;&gt; int(066)  File &quot;&lt;stdin&gt;&quot;, line 1    int(066)          ^SyntaxError: invalid token&gt;&gt;&gt; int(0o66)54</code></pre><p>负整型就在前面加上“-”号就行了，例如：</p><pre><code class="python">&gt;&gt;&gt; print(-0b1110110)-118&gt;&gt;&gt; bin(-118)&#39;-0b1110110&#39;</code></pre><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><p><code>float()</code>内置函数创建浮点数，不传递参数时，返回浮点数0.0；</p><pre><code class="python">&gt;&gt;&gt; float()0.0&gt;&gt;&gt; float(1)1.0&gt;&gt;&gt; float(1.5)1.5&gt;&gt;&gt; float(&#39;1.5&#39;)1.5&gt;&gt;&gt;</code></pre><blockquote><blockquote><blockquote><p>print(2.3e8)</p></blockquote></blockquote></blockquote><pre><code class="python">230000000.0&gt;&gt;&gt; print(2.3e-4)0.00023</code></pre><p>浮点数存储的不精确性，整数和浮点数在计算机内部存储的方式是不同的，浮点数在计算机中使用二进制存储，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><pre><code class="python">&gt;&gt;&gt; print(1.1 + 2.2 - 3.3)4.440892098500626e-16&gt;&gt;&gt; print(1.1 +2.2)3.3000000000000003</code></pre><p>精确计算浮点数，使用<code>decimal（小数）</code>模块或者<code>fractions（分数）</code>模块，可应用于金额等精确计算的场景</p><pre><code class="python">&gt;&gt;&gt; import decimal&gt;&gt;&gt; print(decimal.Decimal(&#39;1.1&#39;) + decimal.Decimal(&#39;2.2&#39;) - decimal.Decimal(&#39;3.3&#39;))          ##注意传递的参数时字符串类型0.0</code></pre><pre><code class="python">&gt;&gt;&gt; import fractions&gt;&gt;&gt; print(fractions.Decimal(&#39;1.1&#39;) + fractions.Decimal(&#39;2.2&#39;) - fractions.Decimal(&#39;3.3&#39;))    ##注意传递的参数时字符串类型0.0</code></pre><pre><code class="python">&gt;&gt;&gt; print(fractions.Fraction(11, 10) + fractions.Fraction(22, 10) - fractions.Fraction(33, 10))  ##fractions.Fraction(11, 10) == 11/100</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。<br>请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。</p><pre><code class="python">&gt;&gt;&gt; print(&quot;I&#39;m OK&quot;)I&#39;m OK</code></pre><h2 id="原样字符串"><a href="#原样字符串" class="headerlink" title="原样字符串"></a>原样字符串</h2><pre><code class="python">&gt;&gt;&gt; print(r&quot;I&#39;m \t ok&quot;)I&#39;m \t ok&gt;&gt;&gt; print(&quot;I&#39;m \t ok&quot;)I&#39;m     ok</code></pre><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>只有两个取值。True 或者 False （python关键字，首字符大写）；<br>True的值为1<br>False的值为0</p><pre><code class="python">&gt;&gt;&gt; True == 1True&gt;&gt;&gt; False == 0True&gt;&gt;&gt; print(True + 1)2&gt;&gt;&gt; print(False + 1)1</code></pre><p>布尔值可以进行逻辑运算（and、or、not）</p><pre><code class="python">&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt;&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; not TrueFalse</code></pre><p>以下对象的布尔值为False：<br>    False、数值0、None、空字符串、空列表、空元组、空字典、空集合。</p><pre><code class="python">&gt;&gt;&gt; for x in [False, 0, None, &#39;&#39;, [], (), &#123;&#125;, set()]:...     print(&#39;%5s 的布尔值为:%s&#39; %(x, bool(x)))...False 的布尔值为:False    0 的布尔值为:FalseNone 的布尔值为:False      的布尔值为:False                ##这里是空字符串   [] 的布尔值为:False   () 的布尔值为:False   &#123;&#125; 的布尔值为:Falseset() 的布尔值为:False</code></pre><p>除了以上的类型，其他都为True。</p><p>所有对象都可被直接用作布尔值，解释器会自动调用内置函数bool()进行转换</p><h2 id="None"><a href="#None" class="headerlink" title="None"></a>None</h2><p>用于表示数据值的不存在，是实实在在的对象，占用内存空间，并不意味着空或者未定义，None是something而不是nothing</p><pre><code class="python">&gt;&gt;&gt; id(None)139944117241744</code></pre><p>使用场景，对象None经常用于变量的初始化，或者将变量重置为“数据值不存在”的状态</p><pre><code class="python">&gt;&gt;&gt; a = None&gt;&gt;&gt; print(a)None</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB Redo Flush及脏页刷新机制深入分析</title>
      <link href="/2018/02/27/Mysql/InnoDB%20Redo%20Flush%E5%8F%8A%E8%84%8F%E9%A1%B5%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2018/02/27/Mysql/InnoDB%20Redo%20Flush%E5%8F%8A%E8%84%8F%E9%A1%B5%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB-Redo-Flush及脏页刷新机制深入分析"><a href="#InnoDB-Redo-Flush及脏页刷新机制深入分析" class="headerlink" title="InnoDB Redo Flush及脏页刷新机制深入分析"></a>InnoDB Redo Flush及脏页刷新机制深入分析</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>我们知道InnoDB采用Write Ahead Log策略来防止宕机数据丢失，即事务提交时，先写重做日志，再修改内存数据页，这样就产生了脏页。既然有重做日志保证数据持久性，查询时也可以直接从缓冲池页中取数据，那为什么还要刷新脏页到磁盘呢？如果重做日志可以无限增大，同时缓冲池足够大，能够缓存所有数据，那么是不需要将缓冲池中的脏页刷新到磁盘。但是，通常会有以下几个问题：</p><ul><li>服务器内存有限，缓冲池不够用，无法缓存全部数据</li><li>重做日志无限增大成本要求太高</li><li>宕机时如果重做全部日志恢复时间过长</li></ul><p>事实上，当数据库宕机时，数据库不需要重做所有的日志，只需要执行上次刷入点之后的日志。这个点就叫做Checkpoint，它解决了以上的问题：</p><ul><li>缩短数据库恢复时间</li><li>缓冲池不够用时，将脏页刷新到磁盘</li><li>重做日志不可用时，刷新脏页</li></ul><h2 id="重做日志被设计成可循环使用，当日志文件写满时，重做日志中对应数据已经被刷新到磁盘的那部分不再需要的日志可以被覆盖重用。InnoDB引擎通过LSN-Log-Sequence-Number-来标记版本，LSN是日志空间中每条日志的结束点，用字节偏移量来表示。每个page有LSN，redo-log也有LSN，Checkpoint也有LSN。可以通过命令show-engine-innodb-status来观察：-sqlmysql-show-engine-innodb-status-G-LOG"><a href="#重做日志被设计成可循环使用，当日志文件写满时，重做日志中对应数据已经被刷新到磁盘的那部分不再需要的日志可以被覆盖重用。InnoDB引擎通过LSN-Log-Sequence-Number-来标记版本，LSN是日志空间中每条日志的结束点，用字节偏移量来表示。每个page有LSN，redo-log也有LSN，Checkpoint也有LSN。可以通过命令show-engine-innodb-status来观察：-sqlmysql-show-engine-innodb-status-G-LOG" class="headerlink" title="重做日志被设计成可循环使用，当日志文件写满时，重做日志中对应数据已经被刷新到磁盘的那部分不再需要的日志可以被覆盖重用。InnoDB引擎通过LSN(Log Sequence Number)来标记版本，LSN是日志空间中每条日志的结束点，用字节偏移量来表示。每个page有LSN，redo log也有LSN，Checkpoint也有LSN。可以通过命令show engine innodb status来观察：&#96;&#96;&#96;sqlmysql&gt; show engine innodb status\G;LOG"></a>重做日志被设计成可循环使用，当日志文件写满时，重做日志中对应数据已经被刷新到磁盘的那部分不再需要的日志可以被覆盖重用。<br>InnoDB引擎通过LSN(Log Sequence Number)来标记版本，LSN是日志空间中每条日志的结束点，用字节偏移量来表示。每个page有LSN，redo log也有LSN，Checkpoint也有LSN。可以通过命令show engine innodb status来观察：<br>&#96;&#96;&#96;sql<br>mysql&gt; show engine innodb status\G;<br>LOG</h2><p>Log sequence number 2584569<br>Log flushed up to   2584569<br>Pages flushed up to 2584569<br>Last checkpoint at  2584560<br>0 pending log flushes, 0 pending chkp writes<br>67 log i&#x2F;o’s done, 0.00 log i&#x2F;o’s&#x2F;second</p><pre><code>Checkpoint机制每次刷新多少页，从哪里取脏页，什么时间触发刷新？这些都是很复杂的。有两种Checkpoint，分别为：* Sharp Checkpoint* Fuzzy CheckpointSharp Checkpoint发生在关闭数据库时，将所有脏页刷回磁盘。在运行时使用Fuzzy Checkpoint进行部分脏页的刷新。部分脏页刷新有以下几种：* Master Thread Checkpoint    Master Thread以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。这个过程是异步的，不会阻塞查询线程。* FLUSH_LRU_LIST Checkpoint    InnoDB要保证LRU列表中有100左右空闲页可使用。在InnoDB1.1.X版本前，要检查LRU中是否有足够的页用于用户查询操作线程，如果没有，会将LRU列表尾端的页淘汰，如果被淘汰的页中有脏页，会强制执行Checkpoint刷回脏页数据到磁盘，显然这会阻塞用户查询线程。从InnoDB1.2.X版本开始，这个检查放到单独的Page Cleaner Thread中进行，并且用户可以通过innodb_lru_scan_depth控制LRU列表中可用页的数量，默认值为1024。* Async/Sync Flush Checkpoint    是指重做日志文件不可用时，需要强制将脏页列表中的一些页刷新回磁盘。这可以保证重做日志文件可循环使用。在InnoDB1.2.X版本之前，Async Flush Checkpoint会阻塞发现问题的用户查询线程，Sync Flush Checkpoint会阻塞所有查询线程。InnoDB1.2.X之后放到单独的Page Cleaner Thread。* Dirty Page too much Checkpoint    脏页数量太多时，InnoDB引擎会强制进行Checkpoint。目的还是为了保证缓冲池中有足够可用的空闲页。其可以通过参数innodb_max_dirty_pages_pct来设置，默认为75%：    ```sql    mysql&gt; show variables like &#39;innodb_max_dirty_pages_pct&#39;;    +----------------------------+-----------+    | Variable_name              | Value     |    +----------------------------+-----------+    | innodb_max_dirty_pages_pct | 75.000000 |    +----------------------------+-----------+    1 row in set (0.00 sec)    ```以上是脏页刷新的几种触发机制，接下来，细说一下日志机制及其中第3点Async/Sync flush checkpoint原理。## Log及Checkpoint简介Innodb的事务日志是指Redo log，简称Log,保存在日志文件ib_logfile*里面。Innodb还有另外一个日志Undo log，但Undo log是存放在共享表空间里面的（ibdata*文件）。由于Log和Checkpoint紧密相关，因此将这两部分合在一起分析。名词解释：LSN，日志序列号，Innodb的日志序列号是一个64位的整型。### Log写入LSN实际上对应日志文件的偏移量，新的LSN＝旧的LSN + 写入的日志大小。举例如下：LSN＝1G，日志文件大小总共为600M，本次写入512字节，则实际写入操作为：- 求出偏移量：由于LSN数值远大于日志文件大小，因此通过取余方式，得到偏移量为400M；- 写入日志：找到偏移400M的位置，写入512字节日志内容，下一个事务的LSN就是1000000512；### Checkpoint写入Innodb实现了Fuzzy Checkpoint的机制，每次取到最老的脏页，然后确保此脏页对应的LSN之前的LSN都已经写入日志文件，再将此脏页的LSN作为Checkpoint点记录到日志文件，意思就是“此LSN之前的LSN对应的日志和数据都已经写入磁盘文件”。恢复数据文件的时候，Innodb扫描日志文件，当发现LSN小于Checkpoint对应的LSN，就认为恢复已经完成。Checkpoint写入的位置在日志文件开头固定的偏移量处，即每次写Checkpoint都覆盖之前的Checkpoint信息。Flush刷新流程及原理介绍由于Checkpoint和日志紧密相关，将日志和Checkpoint一起说明，详细的实现机制如下：如上图所示，Innodb的一条事务日志共经历4个阶段：1. 创建阶段：事务创建一条日志；2. 日志刷盘：日志写入到磁盘上的日志文件；3. 数据刷盘：日志对应的脏页数据写入到磁盘上的数据文件；4. 写CKP：日志被当作Checkpoint写入日志文件；对应这4个阶段，系统记录了4个日志相关的信息，用于其它各种处理使用：- Log sequence number（LSN1）：当前系统LSN最大值，新的事务日志LSN将在此基础上生成（LSN1+新日志的大小）；- Log flushed up to（LSN2）：当前已经写入日志文件的LSN；- Pages flushed up to（LSN3）：当前最旧的脏页数据对应的LSN，写Checkpoint的时候直接将此LSN写入到日志文件；- Last checkpoint at（LSN4）：当前已经写入Checkpoint的LSN； 对于系统来说，以上4个LSN是递减的，即： LSN1&gt;=LSN2&gt;=LSN3&gt;=LSN4.具体的样例如下（使用show engine innodb status \G命令查看）```sqlmysql&gt; show engine innodb status\G;LOG---Log sequence number 1475999669Log flushed up to   1475999669Pages flushed up to 1475999669Last checkpoint at  14759996600 pending log flushes, 0 pending chkp writes171 log i/o&#39;s done, 0.00 log i/o&#39;s/second----------------------</code></pre><h2 id="Async-Sync-Flush-Checkpoint原理"><a href="#Async-Sync-Flush-Checkpoint原理" class="headerlink" title="Async&#x2F;Sync Flush Checkpoint原理"></a>Async&#x2F;Sync Flush Checkpoint原理</h2><p>Innodb的数据并不是实时写盘的，为了避免宕机时数据丢失，保证数据的ACID属性，Innodb至少要保证数据对应的日志不能丢失。对于不同的情况，Innodb采取不同的对策：</p><ol><li>宕机导致日志丢失<br>Innodb有日志刷盘机制，可以通过innodb_flush_log_at_trx_commit参数进行控制；</li><li>日志覆盖导致日志丢失<br>Innodb日志文件大小是固定的，写入的时候通过取余来计算偏移量，这样存在两个LSN写入到同一位置的可能，后面写的把前面写得就覆盖了，以“写入机制”章节的样例为例，LSN＝100000000和LSN＝1600000000两个日志的偏移量是相同的了。这种情况下，为了保证数据一致性，必须要求LSN&#x3D;1000000000对应的脏页数据都已经刷到磁盘中，也就是要求Last checkpoint对应的LSN一定要大于1000000000，否则覆盖后日志也没有了，数据也没有刷盘，一旦宕机，数据就丢失了。</li></ol><p>为了解决第二种情况导致数据丢失的问题，Innodb实现了一套日志保护机制，详细实现如下：<br><img src="http://tech.uc.cn/wp-content/uploads/2013/01/%E6%97%A5%E5%BF%97%E5%91%A8%E6%9C%9F.gif.png" title="111"></p><p>上图中，直线代表日志空间（Log cap，约等于日志文件总大小*0.8，0.8是一个安全系数)，Ckp age和Buf age是两个浮动的点，Buf async、Buf sync、Ckp async、Ckp sync是几个固定的点。各个概念的含义如下：</p><table><thead><tr><th align="left">概念</th><th align="left">计算</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Ckp age</td><td align="left">LSN1- LSN4</td><td align="left">还没有做Checkpoint的日志范围，若Ckp age超过日志空间，说明被覆盖的日志（LSN1－LSN4－Log cap）对应日志和数据“可能”还没有刷到磁盘上</td></tr><tr><td align="left">Buf age</td><td align="left">LSN1- LSN3</td><td align="left">还没有将脏页刷盘的日志的范围，若Buf age超过日志空间，说明被覆盖的日志（LSN1－LSN3－Log cap）对应数据“肯定”还没有刷到磁盘上</td></tr><tr><td align="left">Buf async</td><td align="left">日志空间大小 * 7&#x2F;8</td><td align="left">强制将Buf age-Buf async的脏页刷盘，此时事务还可以继续执行，所以为async，对事务的执行速度没有直接影响（有间接影响，例如CPU和磁盘更忙了，事务的执行速度可能受到影响）</td></tr><tr><td align="left">Buf sync</td><td align="left">日志空间大小 * 15&#x2F;16</td><td align="left">强制将2*(Buf age-Buf async)的脏页刷盘，此时事务停止执行，所以为sync，由于有大量的脏页刷盘，因此阻塞的时间比Ckp sync要长。</td></tr><tr><td align="left">Ckp async</td><td align="left">日志空间大小 * 31&#x2F;32</td><td align="left">强制写Checkpoint，此时事务还可以继续执行，所以为async，对事务的执行速度没有影响（间接影响也不大，因为写Checkpoint的操作比较简单）</td></tr><tr><td align="left">Ckp sync</td><td align="left">日志空间大小 * 64&#x2F;64</td><td align="left">强制写Checkpoint，此时事务停止执行，所以为sync，但由于写Checkpoint的操作比较简单，即使阻塞，时间也很短</td></tr></tbody></table><p>当事务执行速度大于脏页刷盘速度时，Ckp age和Buf age会逐步增长，当达到async点的时候，强制进行脏页刷盘或者写Checkpoint，如果这样做还是赶不上事务执行的速度，则为了避免数据丢失，到达sync点的时候，会阻塞其它所有的事务，专门进行脏页刷盘或者写Checkpoint。<br>因此从理论上来说,只要事务执行速度大于脏页刷盘速度，最终都会触发日志保护机制，进而将事务阻塞，导致MySQL操作挂起。<br>由于写Checkpoint本身的操作相比写脏页要简单，耗费时间也要少得多，且Ckp sync点在Buf sync点之后，因此绝大部分的阻塞都是阻塞在了Buf sync点，这也是当事务阻塞的时候，IO很高的原因，因为这个时候在不断的刷脏页数据到磁盘。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql体系结构</title>
      <link href="/2018/02/26/Mysql/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2018/02/26/Mysql/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql体系结构"><a href="#Mysql体系结构" class="headerlink" title="Mysql体系结构"></a>Mysql体系结构</h1><p><img src="/images/671063e6-0285-499c-9817-ce5edc8e8f60-Image.png" alt="671063e6-0285-499c-9817-ce5edc8e8f60-Image.png" title="671063e6-0285-499c-9817-ce5edc8e8f60-Image.png"></p><h2 id="server层"><a href="#server层" class="headerlink" title="server层"></a>server层</h2><p>1、连接池组件<br>2、管理服务和工具组件<br>3、SQL借口组件<br>4、查询分析器组件 解析sql语句，解析成树状结构<br>5、优化器组件<br>6、缓冲组件</p><h2 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h2><p>7、插件式存储引擎<br>8、物理文件</p><h2 id="sql语句查询流程"><a href="#sql语句查询流程" class="headerlink" title="sql语句查询流程"></a>sql语句查询流程</h2><p>sql语句 –&gt; query cache –&gt; 解析器 –&gt; 处理器 –&gt; 优化器 –&gt; 执行计划 –&gt; 存储引擎 –&gt; 获取数据、server层 | 存储引擎层<br><img src="/images/bdc7006c-6418-4fb2-99da-ad840cfb9221-Image.png" alt="bdc7006c-6418-4fb2-99da-ad840cfb9221-Image.png" title="bdc7006c-6418-4fb2-99da-ad840cfb9221-Image.png"></p><h2 id="innodb存储引擎架构"><a href="#innodb存储引擎架构" class="headerlink" title="innodb存储引擎架构"></a>innodb存储引擎架构</h2><p><img src="/images/faea03eb-2ffa-4cea-97f9-9b03e38baacc-Image.png" alt="faea03eb-2ffa-4cea-97f9-9b03e38baacc-Image.png" title="faea03eb-2ffa-4cea-97f9-9b03e38baacc-Image.png"></p><h2 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h2><p><img src="/images/9288912e-16b9-4605-a7d4-4ead50c5b4f1-Image.png" alt="9288912e-16b9-4605-a7d4-4ead50c5b4f1-Image.png" title="9288912e-16b9-4605-a7d4-4ead50c5b4f1-Image.png"></p><p>逻辑存储单元</p><ul><li>页：16k （oracle中为8k）<br>页头：存储事务信息，锁信息，指针，checksum值<br>页身：存储实际的行数据，一个页身最多存储7992行数据<br>页尾：checksum值，页尾和页身的值必须一致</li><li>区：64个连续的页组成 64*16k&#x3D;1M</li><li>段：一个大数据段由4个区组成 4M</li><li>表空间</li></ul><p>innodb IO的最小单位是页，读取一行数据的时候，将该行数据的整个页读取到内存中国，以提高内存的命中率（内存读 &#x2F;（内存读+磁盘读））</p><h2 id="innodb内存池组成"><a href="#innodb内存池组成" class="headerlink" title="innodb内存池组成"></a>innodb内存池组成</h2><p><img src="/images/3fe981cc-6ced-4b07-95a9-a78b6470cb79-Image.png" alt="3fe981cc-6ced-4b07-95a9-a78b6470cb79-Image.png" title="3fe981cc-6ced-4b07-95a9-a78b6470cb79-Image.png"></p><h3 id="1、缓冲池"><a href="#1、缓冲池" class="headerlink" title="1、缓冲池"></a>1、缓冲池</h3><p>数据页<br>索引页<br>插入缓冲<br>自适应哈希索引<br>锁信息<br>数据字典</p><p><code>innodb_buffer_pool_size</code> 定义缓冲池大小<br><code>innodb_buffer_pool_instances</code> 定义缓冲池个数<br><code>show engine innodb status</code>; 查看大小和个数</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>一般的数据库缓冲池通过LRU（latest recently used，最近最少使用）算法来进行管理，即最频繁使用的页在LRU列表的前端，最少使用的在LRU的尾端；<br>innodb的缓冲池稍有不同，其在LRU中加入了midpoint位置，新读取的页，放在LRU列表的minpoint位置，minpoint之前的列表称为new列表，之后的称为old列表，可以理解new列表里面的页都是最为活跃的热点数据；</p><p>innodb_old_blocks_pct来控制midpoint的位置，值是百分比<br>nnodb_old_blocks_time用于表示页读到midpoint后，需要等待多久才会被加入到LRU列表的热端，这样做的好处是如果一读到minpoint就放到热端，可能会被其他查询给挤出LRU列表，这种查询一般是作为索引或数据的扫描工作，并不是热点数据，所以需要有个时间来进行控制。</p><h3 id="2、重做日志缓冲区"><a href="#2、重做日志缓冲区" class="headerlink" title="2、重做日志缓冲区"></a>2、重做日志缓冲区</h3><p>innodb存储引擎先将重做日志放在这个缓冲区，然后按照一定频率将其刷新到重做日志文件，重做日主缓冲区一般不需要设置得非常大，因为一般每一秒都会有重做日志缓存刷新到日志文件，只需要保证每秒产生的事务量在这个缓冲区大小内即可。<br>innodb_log_buffer_size控制重做日志缓冲区大小，默认为8M；</p><h3 id="3、额外缓存池"><a href="#3、额外缓存池" class="headerlink" title="3、额外缓存池"></a>3、额外缓存池</h3><p>在对一些数据结构本身进行内存的分配时，需要从额外的内存池中申请内存，当该区域不够的时候，会从缓冲区中进行申请。一般申请了很大的innodb缓冲池时，也应该考虑相应的增加这个值。</p><h2 id="innodb后台线程"><a href="#innodb后台线程" class="headerlink" title="innodb后台线程"></a>innodb后台线程</h2><h3 id="1、Master-Thread"><a href="#1、Master-Thread" class="headerlink" title="1、Master Thread"></a>1、Master Thread</h3><p>核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓存、undo页的回收等；<br>loop 主循环（繁忙）和 background loop 后台循环（空闲）切换操作</p><h3 id="2、IO-Thread"><a href="#2、IO-Thread" class="headerlink" title="2、IO Thread"></a>2、IO Thread</h3><p>IO Thread用AIO（异步IO）来处理IO请求，这样极大的提高了数据库的性能。innodb中分别有4个IO Thread，分别是write thread（4个）、read thread（4个）、insert buffer thread（1个）、log thread（1个）；<br>innodb_read_io_threads、innodb_write_io_threads参数进行设置<br>show variables like ‘innodb_%_io_threads’；</p><h3 id="3、Purge-Thread"><a href="#3、Purge-Thread" class="headerlink" title="3、Purge Thread"></a>3、Purge Thread</h3><p>事务提交后，undo log可能不再需要，因此需要purge thread来回收已经分配使用并分配的undo页<br>innod_purge_threads来控制purge thread的个数；</p><h3 id="4、Page-cleaner-Thread"><a href="#4、Page-cleaner-Thread" class="headerlink" title="4、Page cleaner Thread"></a>4、Page cleaner Thread</h3><p>将脏页的刷新操作放到单独的线程中来完成（innodb1.2x之前的版本，脏页刷新是由master thread来完成的），目的是减小原master thread的工作及对于用户查询线程的阻塞，进一步提高innodb的性能；</p><h2 id="innodb内存刷新机制"><a href="#innodb内存刷新机制" class="headerlink" title="innodb内存刷新机制"></a>innodb内存刷新机制</h2><p>日志先行策略，先写日志，再写文件。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>每个InnoDB存储引擎至少有1个redo log文件组，每个文件组下至少有2个redo log文件。为了得到更高的可靠性，可以设置多个mirrored log group，将不同的文件组放在不同的磁盘上。日志组中每个redo log文件的大小一致，并以循环方式使用。InnoDB存储引擎先写redo log文件1，当达到文件的最后是，会切换至文件2，当文件2也被写满时，会再切换到文件1中。<br><code>innodb_log_file_size</code> 参数指定了redo log文件的大小；<br><code>innodb_log_files_in_group</code> 参数指定了redo log文件组中redo log文件的数量，默认为2；<br><code>innodb_mirrored_log_groups</code> 参数指定了日志镜像文件组的数量，默认为1，代表只有一个文件组，没有镜像；<br><code>innodb_log_group_home_dir</code> 参数指定了日志文件组所在路径，默认在数据库路径下。<br><code>innodb_flush_log_at_trx_commit</code> 参数决定redo log的刷新机制<br>0：每隔1秒刷新一次<br>1：实时刷新（默认）<br>2：交由操作系统管理<br>试想，当文件2写满了，切换到1的时候，覆盖1里面的内容，那之前的redo log不是没有了吗，这时候引入<code>checkpoint</code>概念，当发生日志文件切换的时候，产生<code>checkpoint</code>，将缓冲区里的脏数据刷回磁盘。这是其中一个脏页刷回磁盘的条件。还有一个是通过<code>innodb_max_dirty_pages_pct</code>参数（脏页占缓冲区的比率，默认75%，建议设置成20%-50%）来控制脏页的刷新。</p><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><p><code>sync_binlog</code> 参数决定bin log刷新机制<br>1：实时刷新（默认）<br>0：交由操作系统管理<br>（2，3，4……n）：n个事务刷新一次</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类对象特殊属性__slots__</title>
      <link href="/2018/02/26/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7__slots__/"/>
      <url>/2018/02/26/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7__slots__/</url>
      
        <content type="html"><![CDATA[<h1 id="类对象特殊属性-slots"><a href="#类对象特殊属性-slots" class="headerlink" title="类对象特殊属性__slots__"></a>类对象特殊属性__slots__</h1><p>python是动态语言，所以，在创建对象之后，可以对其动态的绑定属性和方法。</p><p>如果想要对实例对象动态绑定的属性和方法的名称进行限制，可以在其对应的类对象中定义特殊属性<code>__slots__</code>，并给<code>__slots__</code>赋值一个所有元素都为字符串的列表或元组，这样，对实例对象动态绑定的属性和方法的名称就只能来自于<code>__slots__</code>中的元素。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    __slots__ = [&#39;attr&#39;, &#39;func&#39;]mc = MyClass()mc.attr = &#39;attr&#39;#mc.attr1 = &#39;attr1&#39;                            # AttributeError: &#39;MyClass&#39; object has no attribute &#39;attr1&#39; print(mc.attr)#print(mc.attr1)def func():    passdef func1():    passfrom types import MethodTypemc.func = MethodType(func, mc)#mc.func1 = MethodType(func1, mc)              # AttributeError: &#39;MyClass&#39; object has no attribute &#39;func1&#39;</code></pre><pre><code class="python">[root@lyucan ~]# ./31.pyattr</code></pre><p>默认情况下，访问实例对象的属性时通过访问该实例对象的特殊属性<code>__dict__</code>来实现的。例如：访问“obj.x”其实访问的是<code>obj.__dict__[&#39;x&#39;]</code><br>        在类对象中定义了特殊属性<code>__slots__</code>后，其实例对象就不会再创建特殊属性<code>__dict__</code>了，而是为每个属性创建一个描述器，访问属性时就会直接调用这个描述器。调用描述器比访问<code>__dict__</code>要快，因此，在类对象中定义特殊属性<code>__slots__</code>可以提高属性的访问速度。<br>        此外，在类对象中定义了特殊属性<code>__slots__</code>后，由于其实例对象不再创建特殊属性<code>__dict__</code>，同时，特殊属性<code>__dict__</code>是一个字典，字典的本质是哈希表，是一种用空间换时间的数据结构，因此，在类对象中定义特殊属性<code>__slots__</code>可以减少内存消耗。</p><pre><code class="python">#!/usr/bin/python3class MyClass(object):    passclass MyClass1(object):    __slots__ = [&#39;attr&#39;, &#39;func&#39;]print(MyClass().__dict__)print(MyClass1().__dict__)</code></pre><pre><code class="python">[root@lyucan ~]# ./31.py&#123;&#125;                              # 没有__slots__属性Traceback (most recent call last):  File &quot;./31.py&quot;, line 13, in &lt;module&gt;    print(MyClass1().__dict__)AttributeError: &#39;MyClass1&#39; object has no attribute &#39;__dict__&#39;         # 有__slots__属性，就没有__dict__方法了</code></pre><p>特殊属性<code>__slots__</code>只对其所在类对象的实例对象起作用，对其所在子类的实例对象是不起作用的。</p><p>如果父类定义了<code>__slots__</code>，但是子类没有定义<code>__slots__</code>，那么：</p><ul><li>父类的实例对象可以动态绑定的属性和方法的名称只有父类的<code>__slots__</code>；</li><li>子类的实例对象没有限制</li></ul><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    __slots__ = [&#39;attr&#39;]class ChildClass(ParentClass):    passpc = ParentClass()cc = ChildClass()cc.attr1 = &#39;attr1&#39;                   # 父类的__slots__的属性不会影响子类，因此可以绑定属性attr1print(cc.attr1)pc.attr1 = &#39;attr1&#39;                   # 父类不能绑定__slots__之外的属性，因此不能绑定属性attr1print(pc.attr1)</code></pre><pre><code class="python">[root@lyucan ~]# ./31.pyattr1Traceback (most recent call last):  File &quot;./31.py&quot;, line 16, in &lt;module&gt;    pc.attr1 = &#39;attr1&#39;AttributeError: &#39;ParentClass&#39; object has no attribute &#39;attr1&#39;</code></pre><p>如果父类子类都定义了特殊属性<code>__slots__</code>，那么：</p><ul><li>父类的实例对象可以动态绑定的属性和方法的名称只有父类的<code>__slots__</code>；</li><li>子类的实例对象可以动态绑定的属性和方法的名称为父类的<code>__slots__</code>加上子类的<code>__slots__</code>；</li></ul><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    __slots__ = [&#39;attr1&#39;]class ChildClass(ParentClass):    __slots__ = [&#39;attr2&#39;]pc = ParentClass()cc = ChildClass()# 父类pc.attr1 = &#39;attr1&#39;       # 绑定成功pc.attr2 = &#39;attr2&#39;       # 绑定失败pc.attr3 = &#39;attr3&#39;       # 绑定失败# 子类cc.attr1 = &#39;attr1&#39;       # 绑定成功cc.attr2 = &#39;attr2&#39;       # 绑定成功cc.attr3 = &#39;attr3&#39;       # 绑定失败</code></pre><p>如果父类没有定义特殊属性<code>__slots__</code>，但是子类定义了<code>__slots__</code>，那么：</p><ul><li>父类和子类都不会被限制。</li></ul><pre><code class="python">#!/usr/bin/python3class ParentClass(object):    passclass ChildClass(ParentClass):    __slots__ = [&#39;attr2&#39;]pc = ParentClass()cc = ChildClass()pc.attr1 = &#39;attr1&#39;                   # 绑定成功pc.attr2 = &#39;attr2&#39;                   # 绑定成功pc.attr3 = &#39;attr3&#39;                   # 绑定成功print(pc.attr1, pc.attr2, pc.attr3)cc.attr1 = &#39;attr1&#39;                   # 绑定成功cc.attr2 = &#39;attr2&#39;                   # 绑定成功cc.attr3 = &#39;attr3&#39;                   # 绑定成功print(cc.attr1, cc.attr2, cc.attr3)</code></pre><pre><code class="python">[root@lyucan ~]# ./31.pyattr1 attr2 attr3attr1 attr2 attr3</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据类型选择</title>
      <link href="/2018/02/24/Mysql/Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9/"/>
      <url>/2018/02/24/Mysql/Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql数据类型选择"><a href="#Mysql数据类型选择" class="headerlink" title="Mysql数据类型选择"></a>Mysql数据类型选择</h1><h2 id="整形，浮点型"><a href="#整形，浮点型" class="headerlink" title="整形，浮点型"></a>整形，浮点型</h2><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 字节</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 字节</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 字节</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 字节</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 字节</td><td align="left">(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 字节</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度</td></tr><tr><td align="left">浮点数值</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">DOUBLE</td><td align="left">8 字节</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度</td></tr><tr><td align="left">浮点数值</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><table><thead><tr><th align="left">类型</th><th align="left">大小(字节)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01&#x2F;9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’&#x2F;‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901&#x2F;2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">1970-01-01 00:00:00&#x2F;2038<br>结束时间是第 2147483647 秒<br>北京时间 2038-1-19 11:14:07<br>格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYYMMDD HHMMSS</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><p>时间与数字之间的转换</p><pre><code class="sql">mysql&gt; select unix_timestamp(&#39;2018-03-30 22:09:30&#39;);+---------------------------------------+| unix_timestamp(&#39;2018-03-30 22:09:30&#39;) |+---------------------------------------+|                            1522418970 |+---------------------------------------+1 row in set (0.00 sec)mysql&gt; select from_unixtime(1522418970);+---------------------------+| from_unixtime(1522418970) |+---------------------------+| 2018-03-30 22:09:30       |+---------------------------+1 row in set (0.00 sec)</code></pre><h2 id="字符，大数据（text，blob）类型"><a href="#字符，大数据（text，blob）类型" class="headerlink" title="字符，大数据（text，blob）类型"></a>字符，大数据（text，blob）类型</h2><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255字节</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 字节</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255字节</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255字节</td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65 535字节</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65 535字节</td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16 777 215字节</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16 777 215字节</td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294 967 295字节</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294 967 295字节</td><td align="left">极大文本数据</td></tr></tbody></table><blockquote><p>cha和varchar不建议混合使用</p></blockquote><p>ip地址与数字之间的转换，存ip地址使用int类型</p><pre><code class="sql">mysql&gt; SELECT INET_ATON(&#39;255.255.255.255&#39;);+------------------------------+| INET_ATON(&#39;255.255.255.255&#39;) |+------------------------------+|                   4294967295 |+------------------------------+1 row in set (0.00 sec)mysql&gt; SELECT INET_NTOA(4294967295);+-----------------------+| INET_NTOA(4294967295) |+-----------------------+| 255.255.255.255       |+-----------------------+1 row in set (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程</title>
      <link href="/2018/02/24/Python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/02/24/Python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>面向对象编程</p><p>简称OOP（object oriented programming），是一种编程方式，这种编程方式需要使用“对象来实现”。</p><p>对象具有以下特征：<br>1、世间万物皆对象<br>2、每个对象都是唯一的<br>3、对象具有属性和行为<br>4、对象具有状态<br>    某个瞬间对象各个属性的取值<br>5、对象分为类对象和实例对象<br>    类对象是具有相同属性和行为的实例对象的抽象，类对象是实例对象的模板</p><p>面向对象编程的步骤：<br>1、抽象出类对象<br>2、抽象出类对象的属性<br>3、抽象出类对象的行为（方法）<br>4、根据类对象创建实例<br>5、通过实例对象访问属性和方法</p><p>一、定义类对象：</p><pre><code class="python">calss 类名(object):    #属性和方法</code></pre><p>其中<br>1、类名由一个或多个单词组成，每个单词的首字母大写且其余全部字母小写。<br>2、(object)表示该类对象继承自python内置的类对象object，python中，所有的类对象都继承自统一的基类：object。</p><p>二、创建实例对象：<br>为了在创建实例对象后，对其进行初始化（例如：给实例对象绑定一些属性），可以在类对象中定义一个名为<code>__init__</code>的特殊方法（以<code>__</code>开头和结尾的方法），这样，创建实例对象后会自动调用这个特殊方法<code>__init__</code>。</p><p>方法就是定义在类对象中的函数。方法与函数的区别在于：<br>1、定义方法时，方法的第一个形参表示调用该方法的实例对象，第一个形参的名称通常是<code>self</code>，也可以是其他名称（约定<code>self</code>）。<br>2、调用方法时，系统自动将调用该方法的实例对象作为实参传递给第一个形参。第一个实参会传递给第二个形参，第二个实参会传递给第三个形参，以此类推。</p><p>如果没有定义特殊方法<code>__init__</code>，或者定义了特殊方法<code>__init__</code>，但是没有定义除<code>self</code>之外的形参，那么根据类对象创建实例时就不需要传入实参。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组切片</title>
      <link href="/2018/02/20/Golang/%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"/>
      <url>/2018/02/20/Golang/%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h1><pre><code class="go">func main() &#123;    arr := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;    slice1 := arr[2:5]    // 切片从2到5，此时切片没有超过数组的长度，则容量为数组的length - startIndex  =&gt; 10 - 2 = 8    fmt.Println(slice1, len(slice1), cap(slice1)) // [3 4 5] 3 8    // 由于切片是由数组切出来的，因此底层会共享该数组的内存空间，此时如果把切片修改一下，则数组也会随之修改    slice1 = append(slice1, 100)    fmt.Println(slice1, arr) // [3 4 5 100] [1 2 3 4 5 100 7 8 9 10]    // 反之，修改数组也会导致切片随之修改    arr[2] = 100    fmt.Println(slice1, arr) // [100 4 5 100] [1 2 100 4 5 100 7 8 9 10]    //-------------------------------------------------------------    // 详细看下切片的容量是按照什么规则来的    // 1. 直接进行切片，切片的容量即数组的length - startIndex =&gt; 5 - 2 = 3    arr2 := [5]int&#123;1, 2, 3, 4, 5&#125;    slice2 := arr2[2:4]    fmt.Println(slice2, len(slice2), cap(slice2)) // [3 4] 2 3    // 2. 容量为3，切片占了两个，还剩余一个还可以继续存值，此时不会重新申请内存空间，而是直接使用原数组共享的空间，因此此时会像上面说的那样，修改数组或切片，两者会互相影响    slice2 = append(slice2, 100)    arr2[2] = 333    fmt.Println(arr2, slice2, len(slice2), cap(slice2)) // [1 2 333 4 100] [333 4 100] 3 3    // 3. 如果继续向切片中添加元素，此时容量已经不够了，此时会重新申请内存空间，将原数组的元素拷贝过来，容量会在原来的基础上进行翻倍，即 3 * 2 = 6    // 同时，由于重新申请了内存空间，此时修改原数组或者切片，两者不会互相影响了，可以看得到下面我们修改了arr2的 4 =&gt; 444，而切片并没有随之修改    slice2 = append(slice2, 200)    arr2[3] = 444    fmt.Println(arr2, slice2, len(slice2), cap(slice2)) // [1 2 333 444 100] [333 4 100 200] 4 6    // 4. 再继续再切片中新增元素，如果容量不够，又会进行扩容，在原来的基础上进行翻倍    slice2 = append(slice2, 300)    slice2 = append(slice2, 400)    slice2 = append(slice2, 500)    fmt.Println(arr2, slice2, len(slice2), cap(slice2)) // [1 2 333 444 100] [333 4 100 200 300 400 500] 7 12    // !!! 如果数组切片都会互相影响，可能会导致一些异常bug，此时我们可以在切片的时候传入第三个参数，表示容量end， endIndex &lt;= 容量end &lt;= 数组长度    // 即容量最多保留到哪里    arr3 := [5]int&#123;1, 2, 3, 4, 5&#125;    slice3 := arr3[2:4:4] // 此时容量end为4，即不预留容量，添加一个元素的话，会重新申请一个内存空间，此时修改数组或切片，两者是不会互相影响的（但是如果不添加一个元素，就不会重新申请内存，此时直接修改arr或者切片，两者还是会互相影响，这点需要注意）    slice3 = append(slice3, 100)    arr3[2] = 333    fmt.Println(arr3, slice3, len(slice3), cap(slice3)) // [1 2 333 4 5] [3 4 100] 3 4   这里容量是4，因为重新申请了内存，容量在原来基础上翻倍，即 2 * 2 = 4&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-字典</title>
      <link href="/2018/02/20/Python/Python-%E5%AD%97%E5%85%B8/"/>
      <url>/2018/02/20/Python/Python-%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="字典的实现原理："><a href="#字典的实现原理：" class="headerlink" title="字典的实现原理："></a>字典的实现原理：</h2><p>和查字典类似，当我们在字典中查找某个数据时，一种办法是从字典的第一页开始往后翻，直到找我们需要的数据为止。这种方法就是在列表中查找要元素的办法，缺点是字典中的数据越多，其查找速度越低。第二种办法是现在字典的索引表里查找数据对应的位置，然后直接翻到这个位置查找数据，这种方法比第一种方法效率高，查找速度非常快。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ol><li>字典中的所有元素都是key-value对，通过指定的key，总能找到确定的vlaue</li><li>字典中不能存在重复的key，但是可以存在重复的vlaue</li><li>字典中的元素是无序的，顺序不重要，重要的是key-value映射关系</li><li>字典中的key必须是不可变对象，因为要通过key的hash值来计算value的存储位置，必须确保每次计算的hash值是相同的，只有不可变对象才存在hash值</li><li>字典可以根据需要动态伸缩，使用前不需要声明字典的容量</li><li>字典会浪费较大的内存，是以空间换时间</li></ol><h2 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h2><h3 id="1、使用-，不可变类型的数据都可以作为字典的key"><a href="#1、使用-，不可变类型的数据都可以作为字典的key" class="headerlink" title="1、使用{}，不可变类型的数据都可以作为字典的key"></a>1、使用{}，不可变类型的数据都可以作为字典的key</h3><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;:&#39;Jerry&#39;, &#39;age&#39;:18&#125;&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 18&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; dict(&#123;1:2&#125;)&#123;1: 2&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; dict(&#123;(1,):2&#125;)&#123;(1,): 2&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; dict(&#123;frozenset([1]):1&#125;)&#123;frozenset(&#123;1&#125;): 1&#125;</code></pre><h3 id="2、使用内置函数dict"><a href="#2、使用内置函数dict" class="headerlink" title="2、使用内置函数dict()"></a>2、使用内置函数dict()</h3><p>方法1</p><pre><code class="python">&gt;&gt;&gt; d = dict(name = &#39;Jerry&#39;, age = 18)&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 18&#125;</code></pre><p>方法2</p><pre><code class="python">&gt;&gt;&gt; d = dict([(&#39;name&#39;, &#39;Jerry&#39;), (&#39;age&#39;, 18)])&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 18&#125;</code></pre><p>方法3</p><pre><code class="python">&gt;&gt;&gt; d = dict(&#123;&#39;name&#39;:&#39;Jerry&#39;, &#39;age&#39;:18&#125;)&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 18&#125;</code></pre><p>方法4</p><pre><code class="python">&gt;&gt;&gt; d = dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))&gt;&gt;&gt; d&#123;&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3&#125;</code></pre><h3 id="3、dict-fromkeys-方法通过参数指定所有的key，所有value默认都是None"><a href="#3、dict-fromkeys-方法通过参数指定所有的key，所有value默认都是None" class="headerlink" title="3、dict.fromkeys()方法通过参数指定所有的key，所有value默认都是None"></a>3、dict.fromkeys()方法通过参数指定所有的key，所有value默认都是None</h3><pre><code class="python">&gt;&gt;&gt; dict.fromkeys([&#39;name&#39;, &#39;age&#39;])&#123;&#39;name&#39;: None, &#39;age&#39;: None&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; dict.fromkeys((&#39;name&#39;, &#39;age&#39;))&#123;&#39;name&#39;: None, &#39;age&#39;: None&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; dict.fromkeys((&#39;name&#39;, &#39;age&#39;), &#39;N/A&#39;)&#123;&#39;name&#39;: &#39;N/A&#39;, &#39;age&#39;: &#39;N/A&#39;&#125;</code></pre><h2 id="字典的查操作"><a href="#字典的查操作" class="headerlink" title="字典的查操作"></a>字典的查操作</h2><h3 id="1、使用中括号，如果字典中不存在指定的key，抛出KeyError"><a href="#1、使用中括号，如果字典中不存在指定的key，抛出KeyError" class="headerlink" title="1、使用中括号，如果字典中不存在指定的key，抛出KeyError"></a>1、使用中括号，如果字典中不存在指定的key，抛出KeyError</h3><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;:&#39;Jerry&#39;, &#39;age&#39;:18&#125;&gt;&gt;&gt; d[&#39;name&#39;]&#39;Jerry&#39;&gt;&gt;&gt; d[&#39;ad&#39;]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#39;ad&#39;</code></pre><h3 id="2、调用get方法，如果字典中不存在指定的key，不会抛出KeyError，而是返回None"><a href="#2、调用get方法，如果字典中不存在指定的key，不会抛出KeyError，而是返回None" class="headerlink" title="2、调用get方法，如果字典中不存在指定的key，不会抛出KeyError，而是返回None"></a>2、调用get方法，如果字典中不存在指定的key，不会抛出KeyError，而是返回None</h3><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;:&#39;Jerry&#39;, &#39;age&#39;:18&#125;&gt;&gt;&gt; d.get(&#39;name&#39;)&#39;Jerry&#39;&gt;&gt;&gt; print(d.get(&#39;ad&#39;))None</code></pre><p>可以通过参数设置默认的value，以便在字典中不存在指定的key时，将其返回</p><pre><code class="python">&gt;&gt;&gt; print(d.get(&#39;ad&#39;, &#39;Beijing&#39;))Beijing</code></pre><h3 id="3、通过运算符in-（not-in）检查字典中是否存在（不存在）指定的key"><a href="#3、通过运算符in-（not-in）检查字典中是否存在（不存在）指定的key" class="headerlink" title="3、通过运算符in （not in）检查字典中是否存在（不存在）指定的key"></a>3、通过运算符in （not in）检查字典中是否存在（不存在）指定的key</h3><pre><code class="python">&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 18&#125;&gt;&gt;&gt; print(&#39;name&#39; in d)True&gt;&gt;&gt; print(&#39;ad&#39; in d)False&gt;&gt;&gt;&gt;&gt;&gt; print(&#39;ad&#39; not in d)True</code></pre><h2 id="字典的改操作"><a href="#字典的改操作" class="headerlink" title="字典的改操作"></a>字典的改操作</h2><h3 id="1、为已经存在的key赋予一个新的值，一次只能修改一个key对应的value"><a href="#1、为已经存在的key赋予一个新的值，一次只能修改一个key对应的value" class="headerlink" title="1、为已经存在的key赋予一个新的值，一次只能修改一个key对应的value"></a>1、为已经存在的key赋予一个新的值，一次只能修改一个key对应的value</h3><pre><code class="python">&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 18&#125;&gt;&gt;&gt;&gt;&gt;&gt; d[&#39;age&#39;] = 20&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20&#125;</code></pre><h3 id="2、调用方法update-，一次至少修改一个key对应的value"><a href="#2、调用方法update-，一次至少修改一个key对应的value" class="headerlink" title="2、调用方法update()，一次至少修改一个key对应的value"></a>2、调用方法update()，一次至少修改一个key对应的value</h3><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 18, &#39;add&#39;: &#39;Beijing&#39;&#125;</code></pre><p>‘’传入一个字典</p><pre><code class="python">&gt;&gt;&gt; d.update(&#123;&#39;name&#39;:&#39;Jack&#39;, &#39;age&#39;:20&#125;)&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jack&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;&#125;</code></pre><p>传入一个元组的列表</p><pre><code class="python">&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jack&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;&#125;&gt;&gt;&gt;&gt;&gt;&gt; d.update([(&#39;name&#39;, &#39;Mike&#39;), (&#39;age&#39;, 25)])&gt;&gt;&gt;&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Mike&#39;, &#39;age&#39;: 25, &#39;add&#39;: &#39;Beijing&#39;&#125;</code></pre><p>将key当做变量</p><pre><code class="python">&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Mike&#39;, &#39;age&#39;: 25, &#39;add&#39;: &#39;Beijing&#39;&#125;&gt;&gt;&gt;&gt;&gt;&gt; d.update(name = &#39;Tom&#39;, age = 17)&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 17, &#39;add&#39;: &#39;Beijing&#39;&#125;</code></pre><h2 id="字典的增操作"><a href="#字典的增操作" class="headerlink" title="字典的增操作"></a>字典的增操作</h2><p>如果想要向字典中添加key-value对，有两种方法：</p><h2 id="1、为不存在的key赋予一个value值，一次只能添加一个key-value对"><a href="#1、为不存在的key赋予一个value值，一次只能添加一个key-value对" class="headerlink" title="1、为不存在的key赋予一个value值，一次只能添加一个key-value对"></a>1、为不存在的key赋予一个value值，一次只能添加一个key-value对</h2><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20&#125;&gt;&gt;&gt; d[&#39;add&#39;] = &#39;Beijing&#39;&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;&#125;</code></pre><h2 id="2、调用update-方法，同样的，有上述修改中的几种方式，传入的key的值不能重复，否则就是更新，而不是新增了"><a href="#2、调用update-方法，同样的，有上述修改中的几种方式，传入的key的值不能重复，否则就是更新，而不是新增了" class="headerlink" title="2、调用update()方法，同样的，有上述修改中的几种方式，传入的key的值不能重复，否则就是更新，而不是新增了"></a>2、调用update()方法，同样的，有上述修改中的几种方式，传入的key的值不能重复，否则就是更新，而不是新增了</h2><p>传入一个字典</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20&#125;&gt;&gt;&gt; d.update(&#123;&#39;add&#39;:&#39;Beijing&#39;, &#39;gender&#39;:&#39;male&#39;&#125;)&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;</code></pre><p>传入一个元组的列表</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20&#125;&gt;&gt;&gt;&gt;&gt;&gt; d.update([(&#39;add&#39;,&#39;Beijing&#39;), (&#39;gender&#39;,&#39;male&#39;)])&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;</code></pre><p>将key当做变量</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20&#125;&gt;&gt;&gt; d.update(add = &#39;Beijing&#39;, gender = &#39;male&#39;)&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;</code></pre><h2 id="字典的删操作"><a href="#字典的删操作" class="headerlink" title="字典的删操作"></a>字典的删操作</h2><h3 id="1、调用方法pop-，会返回删除key的value值，字典的pop-方法需要传一个参数，传的是字典中的任一的key值"><a href="#1、调用方法pop-，会返回删除key的value值，字典的pop-方法需要传一个参数，传的是字典中的任一的key值" class="headerlink" title="1、调用方法pop()，会返回删除key的value值，字典的pop()方法需要传一个参数，传的是字典中的任一的key值"></a>1、调用方法pop()，会返回删除key的value值，字典的pop()方法需要传一个参数，传的是字典中的任一的key值</h3><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt;&gt;&gt;&gt; d.pop(&#39;age&#39;)20&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;</code></pre><p>如果pop的key不存在，则抛出KeyError</p><pre><code class="python">&gt;&gt;&gt; d.pop(&#39;score&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#39;score&#39;</code></pre><p>为了防止指定的key不存在时抛出KeyError，可以通过参数指定一个默认返回的value</p><pre><code class="python">&gt;&gt;&gt; d.pop(&#39;score&#39;, 90)90</code></pre><h3 id="2、使用del语句，一次只能删除一个key-value对"><a href="#2、使用del语句，一次只能删除一个key-value对" class="headerlink" title="2、使用del语句，一次只能删除一个key-value对"></a>2、使用del语句，一次只能删除一个key-value对</h3><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt; del d[&#39;age&#39;]&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;</code></pre><h3 id="3、调用方法popitem-，会返回删除的key的value值，该方法不能传递参数，一次只删除一个任意的key-value对"><a href="#3、调用方法popitem-，会返回删除的key的value值，该方法不能传递参数，一次只删除一个任意的key-value对" class="headerlink" title="3、调用方法popitem()，会返回删除的key的value值，该方法不能传递参数，一次只删除一个任意的key-value对"></a>3、调用方法popitem()，会返回删除的key的value值，该方法不能传递参数，一次只删除一个任意的key-value对</h3><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt; d.popitem()(&#39;gender&#39;, &#39;male&#39;)&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;&#125;&gt;&gt;&gt; d.popitem()(&#39;add&#39;, &#39;Beijing&#39;)&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20&#125;&gt;&gt;&gt;&gt;&gt;&gt; d.popitem()(&#39;age&#39;, 20)&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;&#125;&gt;&gt;&gt;&gt;&gt;&gt; d.popitem()(&#39;name&#39;, &#39;Jerry&#39;)&gt;&gt;&gt; d&#123;&#125;</code></pre><h3 id="4、调用方法clear-，清空字典"><a href="#4、调用方法clear-，清空字典" class="headerlink" title="4、调用方法clear()，清空字典"></a>4、调用方法clear()，清空字典</h3><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d&#123;&#125;</code></pre><h1 id="为字典中指定的key设置默认的value值"><a href="#为字典中指定的key设置默认的value值" class="headerlink" title="为字典中指定的key设置默认的value值"></a>为字典中指定的key设置默认的value值</h1><p>为了确保字典中指定的key总是存在的，可以调用方法setdefault，这样，<br>1、如果字典中存在指定的key，该方法返回指定的key对应的value，字典不发生变化。</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;&#125;&gt;&gt;&gt; d.setdefault(&#39;name&#39;, &#39;newname&#39;)&#39;Jerry&#39;</code></pre><p>2、如果字典中不存在指定的key，该方法返回指定的默认value值，并会在字典中添加一个对应key-value对</p><pre><code class="python">&gt;&gt;&gt; d.setdefault(&#39;newname&#39;, &#39;newname&#39;)&#39;newname&#39;&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;newname&#39;: &#39;newname&#39;&#125;</code></pre><h2 id="字典的视图"><a href="#字典的视图" class="headerlink" title="字典的视图"></a>字典的视图</h2><p>得到字典相关视图的三个方法：<br>1、keys()方法：返回字典所有key的视图</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt;&gt;&gt;&gt; d.keys()dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;add&#39;, &#39;gender&#39;])</code></pre><p>2、values()方法：返回字典所有value的视图</p><pre><code class="python">&gt;&gt;&gt; d.values()dict_values([&#39;Jerry&#39;, 20, &#39;Beijing&#39;, &#39;male&#39;])</code></pre><p>3、items()方法：返回字典所有key-value对的视图</p><pre><code class="python">&gt;&gt;&gt; d.items()dict_items([(&#39;name&#39;, &#39;Jerry&#39;), (&#39;age&#39;, 20), (&#39;add&#39;, &#39;Beijing&#39;), (&#39;gender&#39;, &#39;male&#39;)])</code></pre><h2 id="视图会随字典的变化而变化"><a href="#视图会随字典的变化而变化" class="headerlink" title="视图会随字典的变化而变化"></a>视图会随字典的变化而变化</h2><p>以keys举例，其他两个同理</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt; k = d.keys()&gt;&gt;&gt; kdict_keys([&#39;name&#39;, &#39;age&#39;, &#39;add&#39;, &#39;gender&#39;])&gt;&gt;&gt;&gt;&gt;&gt; d.pop(&#39;gender&#39;)&#39;male&#39;&gt;&gt;&gt;&gt;&gt;&gt; d&#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;&#125;&gt;&gt;&gt;&gt;&gt;&gt; kdict_keys([&#39;name&#39;, &#39;age&#39;, &#39;add&#39;])</code></pre><h2 id="借助字典创建格式化字符串"><a href="#借助字典创建格式化字符串" class="headerlink" title="借助字典创建格式化字符串"></a>借助字典创建格式化字符串</h2><p>当格式化字符串中的占位符是%，并且占位符对应的实际值来自于某个字典的value时，可以把所有的实际值改写为字典，同时根据字典的value对应的key，在占位符%后添加”(key)”，其中，字典的key会被添加一堆引号，因此，如果字典的key是字符串，需要去掉字典的key自带的引号。</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt; print(&#39;姓名:%s,年龄:%d,住址:%s,性别:%s&#39; %(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;add&#39;], d[&#39;gender&#39;]))姓名:Jerry,年龄:20,住址:Beijing,性别:male</code></pre><p>可以改写为</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt; print(&#39;姓名:%(name)s,年龄:%(age)d,住址:%(add)s,性别:%(gender)s&#39; %(d))姓名:Jerry,年龄:20,住址:Beijing,性别:male</code></pre><p>{}作为占位符</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt; print(&#39;姓名:&#123;&#125;,年龄:&#123;&#125;,住址:&#123;&#125;,性别:&#123;&#125;&#39;.format(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;add&#39;], d[&#39;gender&#39;]))姓名:Jerry,年龄:20,住址:Beijing,性别:male</code></pre><p>可以改写为</p><pre><code class="python">&gt;&gt;&gt; d = &#123;&#39;name&#39;: &#39;Jerry&#39;, &#39;age&#39;: 20, &#39;add&#39;: &#39;Beijing&#39;, &#39;gender&#39;: &#39;male&#39;&#125;&gt;&gt;&gt; print(&#39;姓名:&#123;name&#125;,年龄:&#123;age&#125;,住址:&#123;add&#125;,性别:&#123;gender&#125;&#39;.format_map(d))姓名:Jerry,年龄:20,住址:Beijing,性别:male</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-条件表达式</title>
      <link href="/2018/02/19/Python/Python-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/02/19/Python/Python-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h1><pre><code class="python">x if 判断条件 else y</code></pre><p>如果判断条件为True，则返回x，否则返回y</p><pre><code class="python">&gt;&gt;&gt; score = 70&gt;&gt;&gt; &#39;pass&#39; if score &gt;= 60 else &#39;nopaas&#39;&#39;pass&#39;</code></pre><p>条件表达式可以嵌套条件表达式</p><pre><code class="python">&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; &#39;a大于b&#39; if a &gt; b else (&#39;a小于b&#39; if a &lt; b else &#39;a等于b&#39;)&#39;a小于b&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-模块</title>
      <link href="/2018/02/19/Python/Python-%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/02/19/Python/Python-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块就是python中的一个.py文件<br>可以在模块中定义变量、函数和类，定义在模块中的变量、函数和类统称为模块的属性。</p><h2 id="为什么使用模块"><a href="#为什么使用模块" class="headerlink" title="为什么使用模块"></a>为什么使用模块</h2><p>1、代码重用<br>        在一个模块中可以导入另一个模块，从而重用另一个模块中定义的属性。<br>2、避免属性名冲突<br>        不同的模块中可以存在相同名称的属性。</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>为了更好的组织和管理模块，python引入了包。</p><p>在某个目录下添加模块__init__.py后，这个目录就变成了包、因此包是包含了特定模块的特殊目录。<br>模块__init__.py的作用是初始化其所在的包，如果不需要初始化，其内容可以为空。<br>目录支持嵌套，所以包也支持嵌套，包中还可以有子包</p><p>python官方提供了标准库，其中有非常多的模块可供我们使用，用以完成不同的任务</p><p>如果想要使用标准库中的模块，必须使用import语句进行导入，导入方式有两种：</p><h2 id="1、导入整个模块，语法格式："><a href="#1、导入整个模块，语法格式：" class="headerlink" title="1、导入整个模块，语法格式："></a>1、导入整个模块，语法格式：</h2><pre><code class="python">import  [包名.]模块名</code></pre><p>如果被导入的模块在一个包结构中，那么必须要通过其所有的父包导航到该模块：</p><pre><code class="python">顶层父包名.子包名.....子包名。</code></pre><p>导入整个模块后，就可以访问模块中的属性了（包括：变量、函数和类）。其语法格式为：</p><pre><code class="python">[包名.]模块名.属性名</code></pre><p>导入整个模块时，可以给导入的模块起一个别名，</p><pre><code class="python">import [包名.]模块名 as 模块的别名</code></pre><h2 id="2、导入模块中的属性"><a href="#2、导入模块中的属性" class="headerlink" title="2、导入模块中的属性"></a>2、导入模块中的属性</h2><p>导入模块中某个属性的语法格式为：</p><pre><code class="python">from [包名.]模块名 import 属性名</code></pre><p>同样，如果被导入的模块在一个包结构中，那么必须要通过其所有的父包导航到该模块：</p><pre><code class="python">顶层父包名.子包名.....子包名。</code></pre><p>导入模块中的属性后，就可以直接访问模块中的属性了，而无需添加前缀“[包名.]模块名”,从而使得代码更加简洁，但是与添加前缀相比，代码的可读性差一点</p><p>导入模块中多个属性</p><pre><code class="python">from [包名.]模块名 import 属性名1, 属性名2, ..., 属性名n</code></pre><p>导入模块的属性时，可以给导入的属性起一个别名</p><pre><code class="python">from [包名.]模块名 import 属性名1 as 属性名1的别名,  属性名2 as 属性名2的别名,  ...,  属性名n as 属性名n的别名</code></pre><p>可以将模块中的属性一次性全部导入，其语法格式为：</p><pre><code class="python">from [包名.]模块名 import *</code></pre><blockquote><p>强烈不推荐这种导入方式，因为：<br>1、效率低（将所有的属性全部导入了）<br>2、代码的可读性低（不知道具体导入了哪些属性）<br>3、容易出错（当两个模块中存在相同的属性）</p></blockquote><p>当导入整个模块时，如果模块在一个包结构中，也可以适用类似导入模块中属性的语法格式：</p><pre><code class="python">from 包名 import 模块名</code></pre><p>使用第三方库中的模块<br>    除了官方提供的标准库之外，还有很多第三方库可供使用，以完成不同的任务<br>    如果想要使用第三方库中的模块，必须先使用工具pip下载安装第三方库，然后通过import语句进行导入</p><p>PyPI（Python Package Index）<br>    是Python官方的，基于web的，几种管理的，第三方软件仓库，所有人都可以从PyPI下载安装第三方库，或者将自己开发的库发布到PyPI<br>    网址：<a href="https://pypi.org/">https://pypi.org/</a></p><pre><code>pip（Package Install for Python）</code></pre><p>第三方库的安装路径</p><pre><code>[root@lyucan site-packages]# pwd/usr/local/python3/lib/python3.7/site-packages         # /usr/local/python3是安装路径[root@lyucan site-packages]# lltotal 36drwxr-xr-x. 19 root root 4096 Jul 24 11:21 djangodrwxr-xr-x.  2 root root 4096 Jul 24 11:21 Django-2.0.7.dist-info-rw-r--r--.  1 root root  126 Jul  8 00:26 easy_install.pydrwxr-xr-x.  5 root root   90 Jul 24 11:20 pipdrwxr-xr-x.  2 root root 4096 Jul 24 11:20 pip-18.0.dist-infodrwxr-xr-x.  5 root root   89 Jul  8 00:26 pkg_resourcesdrwxr-xr-x.  2 root root   40 Jul  8 00:26 __pycache__drwxr-xr-x.  4 root root 4096 Jul 24 11:20 pytzdrwxr-xr-x.  2 root root 4096 Jul 24 11:20 pytz-2018.5.dist-info-rw-r--r--.  1 root root  119 Jul  8 00:25 README.txtdrwxr-xr-x.  6 root root 4096 Jul  8 00:26 setuptoolsdrwxr-xr-x.  2 root root 4096 Jul  8 00:26 setuptools-39.0.1.dist-info</code></pre><p>pip3相关命令</p><pre><code>1、查看帮助信息pip32、列出已经安装的所有三方库pip3 list3、模糊搜索某个第三方库pip3 search xxx4、安装指定的第三方库（及其版本号）pip3 install xxxpip3 install xxx==y.y5、升级指定第三方库pip3 install --upgrade xxx6、卸载指定的第三方库（及其版本号）pip3 uninstall xxxpip3 uninstall xxx==y.y7、查看pip3之后某个命令的帮助信息pip3 &lt;cmd&gt; --help</code></pre><p>使用当前项目中的模块<br>如果想要使用当前项目中的模块，必须通过import语句进行导入，有三种导入方式：<br>1、直接导入<br>        直接导入当前目录中的模块名<br>2、绝对导入<br>        导入模块名的绝对路径<br>3、相对导入<br>        导入模块名的相对路径，一个“.”表示当前目录，两个“..”表示当前目录的父目录<br>        当直接运行某个模块时，该模块就变成了主模块，主模块位于最顶层，与同目录下的其他模块无法构成相对关系，因此，当直接运行某个模块时，该模块不能使用相对导入。</p><p>import语句的执行流程<br>例如</p><pre><code class="python">import sys</code></pre><p>当使用import语句导入模块时，解释器会根据sys模块的modules属性值来查找模块是否已经被导入了。<br>1、如果模块已经被导入了，解释器什么都不做。<br>2、如果模块没有被导入<br>    解释器按照某种路径搜索模块；<br>    （可选）将搜索到的模块编译为pyc字节码文件；<br>    执行编译生成的字节码文件从而运行模块；</p><p>解释器搜索模块路径<br>解释器搜索模块路径存放在sys的变量path中</p><pre><code class="python">&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&#39;&#39;, &#39;/usr/local/python3/lib/python37.zip&#39;, &#39;/usr/local/python3/lib/python3.7&#39;, &#39;/usr/local/python3/lib/python3.7/lib-dynload&#39;, &#39;/root/.local/lib/python3.7/site-packages&#39;, &#39;/usr/local/python3/lib/python3.7/site-packages&#39;]</code></pre><p>顺序为：当前目录、标准库目录、第三方库安装目录</p><p>在代码运行过程中可以改变这个值来改变模块搜索路径，但是在代码运行完成后，这个值就会还原</p><p>为了永久的修改这个值，可以设置PYTHONPATH环境变量，PYTHONPATH对应的路径会自动添加到sys.path中。修改后的搜索路径在代码运行后仍然有效。</p><p>当使用import语句导入模块时，如果模块还没有被导入，首先，解释器会按照某种路径搜索模块，其次，搜索到的模块可能会被编译为pyc字节码文件。<br>到搜索到的模块被第一次导入时，他会被便以为pyc字节码文件。pyc字节码问价内存放在与该模块同目录下的目录__pycache__中，其命名格式为：模块名.cpython-版本号.pyc。这样，模块的字节码问价就被缓存起来了，再次加载该模块时，如果改模块没有发生变化，则无需将搜索到的模块编译为pyc字节码文件，而是直接读取缓存中的pyc字节码文件，从而提高加载速度。</p><p>导入包中的模块时，会先导入包中的__init__.py，因此，在运行被导入的模块之前，会从最顶层的父包开始，先依次运行所有父包中的__init__.py</p><p>模块内的数据访问控制</p><p>1、使用模块特殊属性<code>__all__</code></p><p>为了在某种程度上实现模块内的数据访问控制，还可以在模块被定义特殊属性<code>__all__</code>。这样。使用语句<code>from 模块名 import *</code>只能导入特殊属性<code>__all__</code>中定义的属性，但是，使用“import 模块名”语句仍然可以导入所有的属性。</p><p>2、为了在某种程度上实现模块内的数据访问控制，可以在模块内的某些属性前添加单下划线<code>_</code>，这样，就无法使用语句<code>from 模块名 import *</code>导入相应的属性了，但是，使用语句<code>import 模块名</code>仍然可以导入相应的属性。</p><p><img src="/images/3024b2df-788d-4d4a-9923-fd4bf1114d57-image.png" alt="3024b2df-788d-4d4a-9923-fd4bf1114d57-image.png" title="3024b2df-788d-4d4a-9923-fd4bf1114d57-image.png"></p><p>当使用语句<code>from 模块名 import *</code>导入属性时：<br>如果在模块内的某个属性前添加了单下划线<code>_</code>，又将这个属性定义在模块内的特殊属性<code>__all__</code>中，那么<code>__all__</code>比单下划线具有更高的优先级。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DBlink</title>
      <link href="/2018/02/17/Oracle/DBlink/"/>
      <url>/2018/02/17/Oracle/DBlink/</url>
      
        <content type="html"><![CDATA[<h1 id="DBlink"><a href="#DBlink" class="headerlink" title="DBlink"></a>DBlink</h1><p>当用户要跨本地数据库访问另外一个数据库表中的数据时，本地数据库中必须创建了远程数据库的DBLINK，通过DBLINK可以像访问本地数据库一样访问远程数据库表中的数据。创建DBLINK的时候需要知道待读取数据库的IP地址、ORACLE_SID以及数据库用户名和密码。</p><p>在创建DBLINK之前，普通用户必须具有相关的权限才能创建DBLINK，以SYS用户登录到本地数据库可以看到相关的权限（查看其它用户的权限需要登录到该用户使用一下命令查询）：</p><pre><code class="sql">SQL&gt; SELECT * FROM USER_SYS_PRIVS T WHERE T.PRIVILEGE LIKE UPPER(&#39;%LINK%&#39;);USERNAME               PRIVILEGE                           ADM---------------------- ----------------------------------- -------SYS                    DROP PUBLIC DATABASE LINK           NOSYS                    CREATE DATABASE LINK                NOSYS                    CREATE PUBLIC DATABASE LINK         NO</code></pre><p>可以看出，在数据库中DBLINK有3种权限：</p><ul><li>CREATE DATABASE LINK：所创建的DBLINK只能是创建者自己使用，别的用户不能使用；</li><li>CREATE PUBLIC DATABASE LINK：PUBLIC表示所创建的DBLINK所有用户都可以使用；</li><li>DROP PUBLIC DATABASE LINK：删除公共的DBLINK；</li></ul><h2 id="创建dblink"><a href="#创建dblink" class="headerlink" title="创建dblink"></a>创建dblink</h2><p>有两种方式，第一种是在本地的tnsname.ora中添加远程数据库的tns，第二种方式是直接在创建语句中添加远程数据库的信息；</p><h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p>1）在本地tnsname.ora中添加远程数据库的配置</p><pre><code class="bash">orcl_dblink =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1526))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = orcl1)    )  )</code></pre><pre><code class="bash">[oracle@oracle admin]$ tnsping orcl_dblinkTNS Ping Utility for Linux: Version 11.2.0.1.0 - Production on 08-MAY-2018 06:14:28Copyright (c) 1997, 2009, Oracle.  All rights reserved.Used parameter files:/oracle/11g/product/11.2.0/dbhome_1/network/admin/sqlnet.oraUsed TNSNAMES adapter to resolve the aliasAttempting to contact (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1526)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl1)))OK (640 msec)</code></pre><p>2）创建dblink，在sys用户下创建，使用公共dblink；</p><pre><code class="sql">SQL&gt; CREATE PUBLIC DATABASE LINKsystemlink CONNECT TO system IDENTIFIED BY Oracle_1 USING &#39;ORCL_DBLINK&#39;;Database link created.systemlink 为dblink的名字，这个名字将作为查询的名字system/Oracle_1 为连接到远程数据库的用户名密码，然后在本地数据库中可以使用dblink来访问远程数据库</code></pre><h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><p>1）直接在创建语句中写远程数据库的信息，其实就是把tnsname.ora里面的内容放在命令里执行了，在sys用户下创建，使用私有的dblink，所有者将属于sys（谁创建私有dblink，所有者将会是谁）；</p><pre><code class="sql">SQL&gt; CREATE DATABASE LINK systemlink_1CONNECT TO system IDENTIFIED BY Oracle_1USING &#39;(DESCRIPTION =(ADDRESS_LIST =(ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1526)))(CONNECT_DATA =(SERVER = DEDICATED)(SERVICE_NAME = orcl1)))&#39;;</code></pre><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>1）在远程数据库的system用户中创建表t1，在本地查看是否能查到；</p><pre><code class="sql">[oracle@oracle admin]$ sqlplus system/Oracle_1SQL&gt; create table T1 (id int);Table created.SQL&gt; insert into t1 values (1);SQL&gt; commit;</code></pre><p>2）在本地中使用dblink查看，使用sys用户查看；</p><pre><code class="sql">##使用systemlinkSQL&gt; select * from t1@systemlink;     ID----------     1##使用systemlink_1SQL&gt; select *from t1@systemlink_1;     ID----------      1</code></pre><p>3）在本地中使用dblink查看，使用system用户查看；</p><pre><code class="sql">##使用systemlinkSQL&gt; select *from t1@systemlink;     ID----------      1##使用systemlink_1SQL&gt; select *from t1@systemlink_1;select *from t1@systemlink_1                *ERROR at line 1:ORA-02019: connection description for remote database not found</code></pre><p>可以看到，在system用户下，使用ssytemlink_1将不能查询到远程数据库的信息，因为systemlink_1是私有的；</p><h2 id="查看存在的dblink"><a href="#查看存在的dblink" class="headerlink" title="查看存在的dblink"></a>查看存在的dblink</h2><pre><code class="sql">SQL&gt; SELECT * FROM DBA_DB_LINKS;</code></pre><p><img src="/images/51f2b507-62a7-4909-a048-c15c5de3cc21-Image.png" alt="51f2b507-62a7-4909-a048-c15c5de3cc21-Image.png" title="51f2b507-62a7-4909-a048-c15c5de3cc21-Image.png"></p><h2 id="删除dblink"><a href="#删除dblink" class="headerlink" title="删除dblink"></a>删除dblink</h2><p>对于Private类型的dblink，只有其创建者才能删除dblink。如果是Public的dblink，那么只要有“DROP PUBLIC DATABASE LINK”的权限就可以删除dblink：</p><p>使用system用户删除systemlink_1，将会失败；</p><pre><code class="sql">[oracle@oracle admin]$ sqlplus system/Oracle_1SQL&gt; drop database link systemlink_1;drop database link systemlink_1                   *ERROR at line 1:ORA-02024: database link not found</code></pre><p>使用sys则会成功；</p><pre><code class="sql">[oracle@oracle admin]$ sqlplus  / as sysdbaSQL&gt; drop database link systemlink_1;Database link dropped.</code></pre><p>删除systemlink，有’drop public database link’权限就行了。</p><pre><code class="sql">SQL&gt; drop public database link systemlink;     ##注意删除公共dblink的时候，需要加上public，和创建一样；Database link dropped.</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python生成式（列表生成式、集合生成式、字典生成式）、生成器</title>
      <link href="/2018/02/09/Python/Python%E7%94%9F%E6%88%90%E5%BC%8F%EF%BC%88%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E3%80%81%E9%9B%86%E5%90%88%E7%94%9F%E6%88%90%E5%BC%8F%E3%80%81%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%BC%8F%EF%BC%89%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2018/02/09/Python/Python%E7%94%9F%E6%88%90%E5%BC%8F%EF%BC%88%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E3%80%81%E9%9B%86%E5%90%88%E7%94%9F%E6%88%90%E5%BC%8F%E3%80%81%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%BC%8F%EF%BC%89%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="生成式（列表生成式、集合生成式、字典生成式）、生成器"><a href="#生成式（列表生成式、集合生成式、字典生成式）、生成器" class="headerlink" title="生成式（列表生成式、集合生成式、字典生成式）、生成器"></a>生成式（列表生成式、集合生成式、字典生成式）、生成器</h1><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>凡是可以通过<code>for-in</code>循环创建的列表，都可以使用列表生成式来创建</p><pre><code class="python">&gt;&gt;&gt; L = [x **2 for x in range(1, 7)]&gt;&gt;&gt;&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36]</code></pre><p>可以在列表生成式的for-in循环后面添加if语句</p><pre><code class="python">&gt;&gt;&gt; L = [x **2 for x in range(1, 7) if x % 2 == 0]&gt;&gt;&gt; L[4, 16, 36]</code></pre><p>可以在列表生成式中使用双重循环</p><pre><code class="python">&gt;&gt;&gt; L = [(i, j) for i in range(1, 4) for j in range(1, 3)]&gt;&gt;&gt; L[(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2)]</code></pre><p>同样，可以在双重循环后添加if语句</p><pre><code class="python">&gt;&gt;&gt; L = [(i, j) for i in range(1, 4) for j in range(1, 3) if i != j]&gt;&gt;&gt; L[(1, 2), (2, 1), (3, 1), (3, 2)]</code></pre><p>嵌套的列表生成式</p><pre><code class="python">&gt;&gt;&gt; L = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]&gt;&gt;&gt; l1 = [[j[i]  for j in L] for i in range(3)]&gt;&gt;&gt; l1[[1, 4, 7], [2, 5, 8], [3, 6, 9]]</code></pre><h2 id="集合生成式"><a href="#集合生成式" class="headerlink" title="集合生成式"></a>集合生成式</h2><p>和列表生成式类似，通过<code>for-in</code>循环来创建集合生成式</p><pre><code class="python">&gt;&gt;&gt; s = &#123;x **2 for x in range(1, 7)&#125;&gt;&gt;&gt; s&#123;1, 4, 36, 9, 16, 25&#125;            ##集合是没有顺序的</code></pre><pre><code class="python">&gt;&gt;&gt; s = &#123;x **2 for x in range(1, 7) if x % 2 == 0&#125;&gt;&gt;&gt; s&#123;16, 4, 36&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; s = &#123;(i, j) for i in range(1, 4) for j in range(1, 3)&#125;&gt;&gt;&gt; s&#123;(1, 2), (3, 2), (3, 1), (2, 1), (2, 2), (1, 1)&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; s = &#123;[i, j] for i in range(1, 4) for j in range(1, 3)&#125;Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;setcomp&gt;TypeError: unhashable type: &#39;list&#39;          ##集合的元素必须是能hash的</code></pre><pre><code class="python">&gt;&gt;&gt; s = &#123;(i, j) for i in range(1, 4) for j in range(1, 3) if i != j&#125;&gt;&gt;&gt; s&#123;(1, 2), (3, 2), (3, 1), (2, 1)&#125;</code></pre><h1 id="字典生成式"><a href="#字典生成式" class="headerlink" title="字典生成式"></a>字典生成式</h1><pre><code class="python">&gt;&gt;&gt; keys = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&gt;&gt;&gt; values = [1, 2, 3]&gt;&gt;&gt; d = &#123;key:value for key in keys for value in values&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; d = &#123;key.upper():value for key in keys for value in values&#125;&gt;&gt;&gt; d&#123;&#39;A&#39;: 3, &#39;B&#39;: 3, &#39;C&#39;: 3&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; d = &#123;key.upper():value for key, value in zip(keys, values)&#125;&gt;&gt;&gt; d&#123;&#39;A&#39;: 1, &#39;B&#39;: 2, &#39;C&#39;: 3&#125;</code></pre><pre><code class="python">&gt;&gt;&gt; d = &#123;key.upper():value...     for key, value in zip(keys, values)...     if value &gt; 2&#125;&gt;&gt;&gt; d&#123;&#39;C&#39;: 3&#125;</code></pre><blockquote><p>没有元组生成式</p></blockquote><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：<code>generator</code>。</p><p>要创建一个<code>generator</code>，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个<code>generator</code>：</p><pre><code class="python">&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; type(g)&lt;class &#39;generator&#39;&gt;</code></pre><p>可以通过<code>next()</code>函数来获取生成器的值，当生成器的值被调用完了后，会停止迭代，而不会重头开始重新迭代</p><pre><code class="python">&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x7fa073c008b8&gt;&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)25&gt;&gt;&gt; next(g)36&gt;&gt;&gt; next(g)49&gt;&gt;&gt; next(g)64&gt;&gt;&gt; next(g)81&gt;&gt;&gt; next(g)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis配置文件详解</title>
      <link href="/2018/02/07/%E8%BF%90%E7%BB%B4/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%20/"/>
      <url>/2018/02/07/%E8%BF%90%E7%BB%B4/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%20/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis配置文件详解"><a href="#Redis配置文件详解" class="headerlink" title="Redis配置文件详解"></a>Redis配置文件详解</h1><p> Redis是一个高性能的key-value数据库。<br>  Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>  Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>  Redis支持数据的备份，即master-slave模式的数据备份。<br>　为了更好的使用redis,我们需要详细的了解redis配置文件及相关参数作用。</p><pre><code class="bash">include /path/to/local.conf</code></pre><p> 额外载入配置文件，如果有需要的话，可以开启此配置</p><pre><code class="bash">bind 127.0.0.1bind 192.168.1.100</code></pre><p>绑定redis服务器网卡IP，默认为127.0.0.1,即本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。如果bind选项为空的话，那会接受所有来自于可用网络接口的连接。如上配置，绑定一个127.0.0.1的本机地址和192.168.1.100的外网地址。</p><p>protected-mode yes<br>保护模式，默认是开启状态，只允许本地客户端连接， 可以设置密码或添加bind来连接</p><p>port 6379<br>监听端口号，默认为6379，如果设为0，redis将不在socket 上监听任何客户端连接</p><p>tcp-backlog 511<br>TCP监听的最大容纳数量，在高并发的环境下，你需要把这个值调高以避免客户端连接缓慢的问题。Linux 内核会把这个值缩小成 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn对应的值，要提升并发量需要修改这两个值才能达到目的</p><p>unixsocket &#x2F;tmp&#x2F;redis.sock<br>unixsocketperm 700<br>指定redis监听的unix socket路径，默认不启用，unixsocketper指定文件的权限</p><p>timeout 0<br>指定在一个 client 空闲多少秒之后关闭连接（0表示永不关闭）</p><p>tcp-keepalive 300<br>单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0，则不会周期性的检测</p><p>daemonize yes<br>默认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes。当redis作为守护进程运行的时候，它会写一个 pid 到 &#x2F;var&#x2F;run&#x2F;redis.pid 文件里面</p><p>supervised no<br>可以通过upstart和systemd管理Redis守护进程<br>选项：<br>   supervised no - 没有监督互动<br>   supervised upstart - 通过将Redis置于SIGSTOP模式来启动信号<br>   supervised systemd - signal systemd将READY &#x3D; 1写入$ NOTIFY_SOCKET<br>   supervised auto - 检测upstart或systemd方法基于 UPSTART_JOB或NOTIFY_SOCKET环境变量</p><p>pidfile &#x2F;var&#x2F;redis&#x2F;run&#x2F;redis_6379.pid<br>配置PID文件路径，当redis作为守护进程运行的时候，它会把 pid 默认写到 &#x2F;var&#x2F;redis&#x2F;run&#x2F;redis_6379.pid 文件里面</p><p>loglevel notice<br>定义日志级别。<br>  可以是下面的这些值：<br>  debug（记录大量日志信息，适用于开发、测试阶段）<br>  verbose（较多日志信息）<br>  notice（适量日志信息，使用于生产环境）<br>  warning（仅有部分重要、关键信息才会被记录）</p><p>logfile &#x2F;var&#x2F;redis&#x2F;log&#x2F;redis_6379.log<br>日志文件的位置，当指定为空字符串时，为标准输出，如果redis已守护进程模式运行，那么日志将会输出到&#x2F;dev&#x2F;null</p><p>syslog-enabled no<br>要想把日志记录到系统日志，就把它改成 yes，也可以可选择性的更新其他的syslog 参数以达到你的要求</p><p>syslog-ident redis<br>设置系统日志的ID</p><p>syslog-facility local0<br>指定系统日志设置，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值</p><p>databases 16<br>设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select  <dbid> 命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。</p><p>save 900 1<br>save 300 10<br>save 60 10000<br>存 DB 到磁盘：<br>    格式：save &lt;间隔时间（秒）&gt; &lt;写入次数&gt;<br>    根据给定的时间间隔和写入次数将数据保存到磁盘<br>    下面的例子的意思是：<br>    900 秒内如果至少有 1 个 key 的值变化，则保存<br>    300 秒内如果至少有 10 个 key 的值变化，则保存<br>    60 秒内如果至少有 10000 个 key 的值变化，则保存<br> 　　<br>    注意：你可以注释掉所有的 save 行来停用保存功能。<br>    也可以直接一个空字符串来实现停用：<br>    save “”</p><p>stop-writes-on-bgsave-error yes<br>  如果用户开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。<br>  这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。<br>  如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。<br>  如果下一次RDB持久化成功，redis会自动恢复接受写请求。<br>  如果不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，可以关闭这个功能，<br>  以便在快照写入失败时，也能确保redis继续接受新的写请求。</p><p>rdbcompression yes<br>  对于存储到磁盘中的快照，可以设置是否进行压缩存储。<br>  如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，<br>  可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p><p>rdbchecksum yes<br>  在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，<br>  如果希望获取到最大的性能提升，可以关闭此功能。</p><p>dbfilename dump.rdb<br>设置快照的文件名</p><p>dir &#x2F;var&#x2F;redis&#x2F;6379<br>  设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名</p><p>slaveof <masterip> <masterport><br>  主从复制，使用 slaveof 来让一个 redis 实例成为另一个reids 实例的副本，默认关闭<br>  注意这个只需要在 slave 上配置</p><p>masterauth <master-password><br> 如果 master 需要密码认证，就在这里设置，默认不设置</p><p>slave-serve-stale-data yes<br>  当一个 slave 与 master 失去联系，或者复制正在进行的时候，<br>  slave 可能会有两种表现：</p><ol><li>如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，<br>或者数据可能是空的在第一次同步的时候 </li><li>如果为 no ，在你执行除了 info he salveof 之外的其他命令时，<br>slave 都将返回一个 “SYNC with master in progress” 的错误</li></ol><p>slave-read-only yes<br>  你可以配置一个 slave 实体是否接受写入操作。<br>  通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，<br>  因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。<br>  但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。<br>  从 redis 2.6 版起，默认 slaves 都是只读的。</p><p>repl-diskless-sync no<br>  主从数据复制是否使用无硬盘复制功能。<br>  新的从站和重连后不能继续备份的从站，需要做所谓的“完全备份”，即将一个RDB文件从主站传送到从站。<br>  这个传送有以下两种方式：<br>  1）硬盘备份：redis主站创建一个新的进程，用于把RDB文件写到硬盘上。过一会儿，其父进程递增地将文件传送给从站。<br>  2）无硬盘备份：redis主站创建一个新的进程，子进程直接把RDB文件写到从站的套接字，不需要用到硬盘。<br>  在硬盘备份的情况下，主站的子进程生成RDB文件。一旦生成，多个从站可以立即排成队列使用主站的RDB文件。<br>  在无硬盘备份的情况下，一次RDB传送开始，新的从站到达后，需要等待现在的传送结束，才能开启新的传送。<br>  如果使用无硬盘备份，主站会在开始传送之间等待一段时间（可配置，以秒为单位），希望等待多个子站到达后并行传送。<br>  在硬盘低速而网络高速（高带宽）情况下，无硬盘备份更好。</p><p>repl-diskless-sync-delay 5<br>  当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。<br>  这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段<br>  时间以期更多的从站到达。<br>  延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。</p><p>repl-ping-slave-period 10<br>  从redis会周期性的向主redis发出PING包，你可以通过repl_ping_slave_period指令来控制其周期，默认是10秒。</p><p>repl-timeout 60<br>  接下来的选项为以下内容设置备份的超时时间：<br>  1）从从站的角度，同步期间的批量传输的I&#x2F;O<br>  2）从站角度认为的主站超时（数据，ping）<br>  3）主站角度认为的从站超时（REPLCONF ACK pings)<br>  确认这些值比定义的repl-ping-slave-period要大，否则每次主站和从站之间通信低速时都会被检测为超时。</p><p>repl-disable-tcp-nodelay no<br>  同步之后是否禁用从站上的TCP_NODELAY<br>  如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。<br>  Linux内核默认配置情况下最多40毫秒的延时。<br>  如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。<br>  默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。</p><p>repl-backlog-size 1mb<br>  设置备份的工作储备大小。工作储备是一个缓冲区，当从站断开一段时间的情况时，它替从站接收存储数据，<br>  因此当从站重连时，通常不需要完全备份，只需要一个部分同步就可以，即把从站断开时错过的一部分数据接收。<br>  工作储备越大，从站可以断开并稍后执行部分同步的断开时间就越长。<br>  只要有一个从站连接，就会立刻分配一个工作储备。</p><p>repl-backlog-ttl 3600<br>  主站有一段时间没有与从站连接，对应的工作储备就会自动释放。<br>  这个选项用于配置释放前等待的秒数，秒数从断开的那一刻开始计算，值为0表示不释放。</p><p>slave-priority 100<br>  从站优先级是可以从redis的INFO命令输出中查到的一个整数。当主站不能正常工作时<br>  redis sentinel使用它来选择一个从站并将它提升为主站。<br>  低优先级的从站被认为更适合于提升，因此如果有三个从站优先级分别是10，<br>  100，25，sentinel会选择优先级为10的从站，因为它的优先级最低。<br>  然而优先级值为0的从站不能执行主站的角色，因此优先级为0的从站永远不会被redis sentinel提升。<br>  默认优先级是100</p><p>min-slaves-to-write 3<br>min-slaves-max-lag 10<br>  主站可以停止接受写请求，当与它连接的从站少于N个，滞后少于M秒，N个从站必须是在线状态。<br>  延迟的秒数必须&lt;&#x3D;所定义的值，延迟秒数是从最后一次收到的来自从站的ping开始计算。ping通常是每秒一次。<br>  这一选项并不保证N个备份都会接受写请求，但是会限制在指定秒数内由于从站数量不够导致的写操作丢失的情况。<br>  如果想要至少3个从站且延迟少于10秒，如上配置即可</p><p>slave-announce-ip 5.5.5.5<br>slave-announce-port 1234<br> Redis master能够以不同的方式列出所连接slave的地址和端口。<br> 例如，“INFO replication”部分提供此信息，除了其他工具之外，Redis Sentinel还使用该信息来发现slave实例。<br> 此信息可用的另一个地方在masterser的“ROLE”命令的输出中。<br> 通常由slave报告的列出的IP和地址,通过以下方式获得：<br> IP：通过检查slave与master连接使用的套接字的对等体地址自动检测地址。<br> 端口：端口在复制握手期间由slavet通信，并且通常是slave正在使用列出连接的端口。<br> 然而，当使用端口转发或网络地址转换（NAT）时，slave实际上可以通过(不同的IP和端口对)来到达。 slave可以使用以下两个选项，以便向master报告一组特定的IP和端口，<br> 以便INFO和ROLE将报告这些值。<br> 如果你需要仅覆盖端口或IP地址，则没必要使用这两个选项。</p><p>requirepass foobared<br>  设置redis连接密码</p><p>rename-command CONFIG “”<br>  将命令重命名，为了安全考虑，可以将某些重要的、危险的命令重命名。<br>  当你把某个命令重命名成空字符串的时候就等于取消了这个命令。</p><p>maxclients 10000<br>  设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件<br>  描述符数-32（redis server自身会使用一些），如果设置 maxclients为0<br>  表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p><p>maxmemory <bytes><br>  指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key<br>  当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，<br>  会把Key存放内存，Value会存放在swap区，格式：maxmemory <bytes></p><p>maxmemory-policy noeviction<br>  当内存使用达到最大值时，redis使用的清楚策略。有以下几种可以选择：<br>  1）volatile-lru   利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )<br>  2）allkeys-lru   利用LRU算法移除任何key<br>  3）volatile-random 移除设置过过期时间的随机key<br>  4）allkeys-random  移除随机ke<br>  5）volatile-ttl   移除即将过期的key(minor TTL)<br>  6）noeviction  noeviction   不移除任何key，只是返回一个写错误 ，默认选项</p><p>maxmemory-samples 5<br>  LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)<br>  随意你可以选择样本大小进行检，redis默认选择3个样本进行检测，你可以通过maxmemory-samples进行设置样本数</p><p>appendonly no<br>  默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，<br>  会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，<br>  可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入appendonly.aof文件，<br>  每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</p><p>appendfilename “appendonly.aof”<br>  aof文件名</p><p>appendfsync always<br>appendfsync everysec<br>appendfsync no<br>  aof持久化策略的配置<br>  no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。<br>  always表示每次写入都执行fsync，以保证数据同步到磁盘。<br>  everysec表示每秒执行一次fsync，可能会导致丢失这1s数据</p><p>no-appendfsync-on-rewrite no<br>   在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，<br>   执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。<br>   如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。<br>   设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。<br>   Linux的默认fsync策略是30秒。可能丢失30秒数据。</p><p>auto-aof-rewrite-percentage 100<br>  aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，<br>  即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。<br>  当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</p><p>auto-aof-rewrite-min-size 64mb<br>  设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</p><p>aof-load-truncated yes<br>  aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。<br>  重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data&#x3D;ordered选项，出现这种现象<br>  redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。<br>  如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。<br>  如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</p><p>lua-time-limit 5000<br>  如果达到最大时间限制（毫秒），redis会记个log，然后返回error。当一个脚本超过了最大时限。<br>  只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。<br>  要是已经调用了write，只能用第二个命令杀</p><p>cluster-enabled yes<br>  集群开关，默认是不开启集群模式</p><p>cluster-config-file nodes-6379.conf<br> 集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。<br> 这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件<br> 请确保与实例运行的系统中配置文件名称不冲突</p><p>cluster-node-timeout 15000<br> 节点互连超时的阀值，集群节点超时毫秒数</p><p>cluster-slave-validity-factor 10<br>  在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，<br>  导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。<br>  判断方法是：<br>     比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period<br>     如果节点超时时间为三十秒, 并且slave-validity-factor为10,<br>     假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移</p><p>cluster-migration-barrier 1<br>  master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，<br>  那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。</p><p>cluster-require-full-coverage yes<br>  默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。<br>  设置为no，可以在slot没有全部分配的时候提供服务。<br>  不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致</p><p>slowlog-log-slower-than 10000<br> slog log是用来记录redis运行中执行比较慢的命令耗时。<br> 当命令的执行超过了指定时间，就记录在slow log中，slog log保存在内存中，所以没有IO操作。<br> 执行时间比slowlog-log-slower-than大的请求记录到slowlog里面，单位是微秒，所以1000000就是1秒。<br> 注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。</p><p>slowlog-max-len 128<br> 慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉，这个长度没有限制。<br> 只要有足够的内存就行，你可以通过 SLOWLOG RESET 来释放内存</p><p>latency-monitor-threshold 0<br>  延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。<br>  只记录大于等于下边设置的值的操作，0的话，就是关闭监视。<br>  默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置。</p><p>notify-keyspace-events “”<br>键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。<br> notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：<br>  K 键空间通知，所有通知以 <strong>keyspace@</strong> 为前缀<br>  E 键事件通知，所有通知以 <strong>keyevent@</strong> 为前缀<br>  g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知<br>  $ 字符串命令的通知<br>  l 列表命令的通知<br>  s 集合命令的通知<br>  h 哈希命令的通知<br>  z 有序集合命令的通知<br>  x 过期事件：每当有过期键被删除时发送<br>  e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送<br>  A 参数 g$lshzxe 的别名<br> 输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。</p><p>hash-max-ziplist-entries 512<br> hash类型的数据结构在编码上可以使用ziplist和hashtable。<br> ziplist的特点就是文件存储(以及内存存储)所需的空间较小,在内容较小时,性能和hashtable几乎一样。<br> 因此redis对hash类型默认采取ziplist。如果hash中条目的条目个数或者value长度达到阀值,将会被重构为hashtable。<br> 这个参数指的是ziplist中允许存储的最大条目个数，，默认为512，建议为128</p><p>hash-max-ziplist-value 64<br> ziplist中允许条目value值最大字节数，默认为64，建议为1024</p><p>list-max-ziplist-size -2<br>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。<br>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：<br>    -5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb &#x3D;&gt; 1024 bytes）<br>    -4: 每个quicklist节点上的ziplist大小不能超过32 Kb。<br>    -3: 每个quicklist节点上的ziplist大小不能超过16 Kb。<br>    -2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）<br>    -1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</p><p>list-compress-depth 0<br>这个参数表示一个quicklist两端不被压缩的节点个数。<br>注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。<br>实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。<br>参数list-compress-depth的取值含义如下：<br>    0: 是个特殊值，表示都不压缩。这是Redis的默认值。<br>    1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。<br>    2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。<br>    3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。<br>    依此类推…<br>由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p><p>set-max-intset-entries 512<br> 数据量小于等于set-max-intset-entries用intset，大于set-max-intset-entries用set</p><p>zset-max-ziplist-entries 128<br>zset-max-ziplist-value 64<br> 数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset</p><p>hll-sparse-max-bytes 3000<br>  value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse）<br>  大于hll-sparse-max-bytes使用稠密的数据结构（dense），一个比16000大的value是几乎没用的，<br>  建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右</p><p>activerehashing yes<br>  Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。<br>  当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。<br>  如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存</p><p>client-output-buffer-limit normal 0 0 0<br> 对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。<br> 对于normal client，第一个0表示取消hard limit，第二个0和第三个0表示取消soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的</p><p>client-output-buffer-limit slave 256mb 64mb 60<br> 对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。</p><p>client-output-buffer-limit pubsub 32mb 8mb 60<br> 对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。</p><p>hz 10<br>  redis执行任务的频率为1s除以hz</p><p>aof-rewrite-incremental-fsync yes<br>  在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。<br>  这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-浅拷贝、深拷贝</title>
      <link href="/2018/02/02/Python/Python-%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2018/02/02/Python/Python-%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="浅拷贝、深拷贝"><a href="#浅拷贝、深拷贝" class="headerlink" title="浅拷贝、深拷贝"></a>浅拷贝、深拷贝</h1><h2 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h2><p>所谓浅拷贝，指的是：对于某个对象，虽然创建了与该对象具有相同值的另一个对象，但是，这两个对象内部嵌套的对应子对象全都是同一个对象。简单的说，外部进行了拷贝，内部没有拷贝。</p><p>以下几种方式进行的拷贝均是浅拷贝：<br>    1、使用切片操作[:]<br>    2、使用列表、字典、集合的copy()方法<br>    3、使用内置函数list()、dict()、set()<br>    4、调用copy模块的copy()函数</p><pre><code class="python">#!/usr/bin/python3import copyL1 = [[1, 2, 3], 4]L2 = copy.copy(L1)print(&#39;id(L1) =&#123;&#125;&#39;.format(id(L1)))print(&#39;id(L2) =&#123;&#125;&#39;.format(id(L2)))print(&#39;id(L1[0]) =&#123;&#125;&#39;.format(id(L1[0])))print(&#39;id(L2[0]) =&#123;&#125;&#39;.format(id(L2[0])))print(&#39;id(L1[1]) =&#123;&#125;&#39;.format(id(L1[1])))print(&#39;id(L2[1]) =&#123;&#125;&#39;.format(id(L2[1])))</code></pre><pre><code class="python">[root@lyucan ~]# ./5.pyid(L1) =140528250703048id(L2) =140528250250888id(L1[0]) =140528250114568id(L2[0]) =140528250114568id(L1[1]) =140528249476800id(L2[1]) =140528249476800</code></pre><p>当浅拷贝时，对拷贝对象的其中一个元素进行修改，如果该元素是可变对象，那么其他拷贝的对象也会随之被修改。<br>注意！无论是浅拷贝还是深拷贝，对于不可变对象的元素，修改其中一个，另一个都不会随之改变，和深浅拷贝无关。</p><pre><code class="python">&gt;&gt;&gt; L1 = [[1, 2], 3]&gt;&gt;&gt; L2 = L1[:]&gt;&gt;&gt;&gt;&gt;&gt; L1[[1, 2], 3]&gt;&gt;&gt; L2[[1, 2], 3]&gt;&gt;&gt;&gt;&gt;&gt; L1[0].append(3)&gt;&gt;&gt; L1[[1, 2, 3], 3]&gt;&gt;&gt;&gt;&gt;&gt; L2[[1, 2, 3], 3]&gt;&gt;&gt;&gt;&gt;&gt; L1[1] = 5&gt;&gt;&gt; L1[[1, 2, 3], 5]&gt;&gt;&gt; L2[[1, 2, 3], 3]</code></pre><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>可以调用copy模块中的deepcopy()函数实现。</p><p>指的是：对于某个对象，创建与该对象有相同值的另一个对象，同时，这两个对象内部嵌套的对应子对象不是同一个对象。简单地说，外部和内部都进行了拷贝。</p><pre><code class="python">#!/usr/bin/python3import copyL1 = [[1, 2, 3], 4]L2 = copy.deepcopy(L1)print(&#39;id(L1) =&#123;&#125;&#39;.format(id(L1)))print(&#39;id(L2) =&#123;&#125;&#39;.format(id(L2)))print(&#39;id(L1[0]) =&#123;&#125;&#39;.format(id(L1[0])))print(&#39;id(L2[0]) =&#123;&#125;&#39;.format(id(L2[0])))print(&#39;id(L1[1]) =&#123;&#125;&#39;.format(id(L1[1])))print(&#39;id(L2[1]) =&#123;&#125;&#39;.format(id(L2[1])))</code></pre><pre><code class="python">[root@lyucan ~]# ./5.pyid(L1) =140453199916488id(L2) =140453199464200id(L1[0]) =140453199327944id(L2[0]) =140453199464264id(L1[1]) =140453198689984id(L2[1]) =140453198689984</code></pre><p>当深拷贝时，对拷贝的其中一个元素进行修改，不论该元素是不是可变的类型，其他的拷贝对象都不会随之改变。<br>注意！无论是浅拷贝还是深拷贝，对于不可变对象的元素，修改其中一个，另一个都不会随之改变，和深浅拷贝无关。</p><pre><code class="python">&gt;&gt;&gt; L1 = [[1, 2, 3], 4]&gt;&gt;&gt; L2 = copy.deepcopy(L1)&gt;&gt;&gt; L2[0][1] = 999&gt;&gt;&gt; L2[[1, 999, 3], 4]&gt;&gt;&gt; L1[[1, 2, 3], 4]&gt;&gt;&gt; L1 = [[1, 2, 3], 4]&gt;&gt;&gt; L2 = copy.deepcopy(L1)&gt;&gt;&gt; L2[1] = 9999&gt;&gt;&gt; L2[[1, 2, 3], 9999]&gt;&gt;&gt; L1[[1, 2, 3], 4]</code></pre><p>对于没有嵌套子对象的不可变对象，例如：整数对象、字符串对象和元组对象等，不会进行拷贝，也就是说，不会创建另一个对象，不论使用浅拷贝和深拷贝都不会进行拷贝</p><pre><code class="python">&gt;&gt;&gt; i1 = 20&gt;&gt;&gt; i2 = int(i1)&gt;&gt;&gt; id(i1)140090744170688&gt;&gt;&gt; id(i2)140090744170688&gt;&gt;&gt; s1 = &#39;abc&#39;&gt;&gt;&gt; s2 = copy.copy(s1)&gt;&gt;&gt; id(s1)140090745589072&gt;&gt;&gt; id(s2)140090745589072&gt;&gt;&gt; t1 = (1, 2, 3)      &gt;&gt;&gt; t2 = copy.copy(t1)&gt;&gt;&gt;&gt;&gt;&gt; id(t1)140090599826560&gt;&gt;&gt; id(t2)140090599826560</code></pre><p>而对于嵌套了子对象的不可变对象，如果子对象是可变对象，则会进行拷贝</p><pre><code class="python">#!/usr/bin/python3import copyt1 = ([1, 2, 3], 4)t2 = copy.deepcopy(t1)print(&#39;id(t1) =&#123;&#125;&#39;.format(id(t1)))print(&#39;id(t2) =&#123;&#125;&#39;.format(id(t2)))print(&#39;id(t1[0]) =&#123;&#125;&#39;.format(id(t1[0])))print(&#39;id(t2[0]) =&#123;&#125;&#39;.format(id(t2[0])))print(&#39;id(t1[1]) =&#123;&#125;&#39;.format(id(t1[1])))print(&#39;id(t2[1]) =&#123;&#125;&#39;.format(id(t2[1])))</code></pre><pre><code class="python">[root@lyucan ~]# ./5.pyid(t1) =140616493770376id(t2) =140616494039624id(t1[0]) =140616493183624id(t2[0]) =140616493988936id(t1[1]) =140616492545728id(t2[1]) =140616492545728</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle修改默认临时表空间</title>
      <link href="/2018/01/22/Oracle/Oracle%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
      <url>/2018/01/22/Oracle/Oracle%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle修改默认临时表空间"><a href="#Oracle修改默认临时表空间" class="headerlink" title="Oracle修改默认临时表空间"></a>Oracle修改默认临时表空间</h1><p>如果创建数据库时没有设定默认临时表空间，即用户创建数据库时没有temporary tablespace子句，那么系统将默认system表空间为临时表空间对临时数据进行排序。这样服务器将会把此情况写入到报警文件中。</p><p>一个数据库范围内的默认临时表空间可以消除使用系统表空间对临时数据进行排序的现象。从而提高了数据库的效率。默认临时表空间可以使在创建数据库是建立，也可以在创建数据库后单独创建。</p><p>下面的实例是在数据库创建后将XIXI_TEMP临时表空间设定为默认表空间的步骤。<br>1.首先使用database_properties数据字典进行查询</p><pre><code class="sql">SQL&gt; desc database_properties;名称                           是否为空?       类型------------------------------ -------------- ----------------------PROPERTY_NAME                  NOT NULL        VARCHAR2(30)PROPERTY_VALUE                                 VARCHAR2(4000)DESCRIPTION                                    VARCHAR2(4000)SQL&gt; col  PROPERTY_NAME for a25SQL&gt; col  PROPERTY_VALUE for a16SQL&gt; col  DESCRIPTION for a30SQL&gt; select * from database_properties where  PROPERTY_NAME like &#39;DEFAULT%&#39;;PROPERTY_NAME                 PROPERTY_VALUE   DESCRIPTION----------------------------- ---------------- ---------------------------       DEFAULT_TEMP_TABLESPACE       TEMP             Name of default temporary tablespaceDEFAULT_PERMANENT_TABLESPACE  USERS            Name of default permanent tablespaceDEFAULT_TBS_TYPE              SMALLFILE        Default tablespace type</code></pre><p>2.查询临时表空间，选定一个临时表空间设为默认临时表空间。</p><pre><code class="sql">SQL&gt; desc v$tablespace;名称                                      是否为空? 类型----------------------------------------- -------- ----------------------------TS#                                                NUMBERNAME                                               VARCHAR2(30)INCLUDED_IN_DATABASE_BACKUP                        VARCHAR2(3)BIGFILE                                            VARCHAR2(3)FLASHBACK_ON                                       VARCHAR2(3)ENCRYPT_IN_BACKUP                                  VARCHAR2(3)SQL&gt; select name from v$tablespace;NAME                                                                            ------------------------------                                                  SYSTEM                                                                          UNDOTBS1                                                                        SYSAUX                                                                          USERS                                                                           TEMP                                                                            EXAMPLE                                                                         XIXI_TEMP                                                                       FANLU                                                                           LULU                                                                            已选择9行。</code></pre><p>3.将XIXI_TEMP设为默认临时表空间。</p><pre><code class="sql">SQL&gt; alter database default temporary tablespace XIXI_TEMP;数据库已更改。</code></pre><p>4.查询是否已经成功。</p><pre><code class="sql">SQL&gt; select * from database_properties where property_name like &#39;DEFAULT%&#39;;PROPERTY_NAME            PROPERTY_VALUE   DESCRIPTION               ------------------------ ---------------- ------------------------------         DEFAULT_TEMP_TABLESPACE  XIXI_TEMP        Name of default temporary tablespace    DEFAULT_PERMANENT_TABLE  USERSSPACE       Name of default permanent tablespaceDEFAULT_TBS_TYPE         SMALLFILE        Default tablespace type                </code></pre><p>从结果看已经设定XIXI_TEMP为默认临时表空间了。</p><p>默认临时表空间不能被删除，除非有个新的默认临时表空间来代替它。不能将默认临时表空间设为永久表空间，也不能将其进行脱机。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle 密码文件</title>
      <link href="/2018/01/20/Oracle/Oracle%20%E5%AF%86%E7%A0%81%E6%96%87%E4%BB%B6/"/>
      <url>/2018/01/20/Oracle/Oracle%20%E5%AF%86%E7%A0%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle-密码文件"><a href="#Oracle-密码文件" class="headerlink" title="Oracle 密码文件"></a>Oracle 密码文件</h1><h2 id="一、密码文件"><a href="#一、密码文件" class="headerlink" title="一、密码文件"></a>一、密码文件</h2><p> oracle的口令文件的作用是存放所有以sysdba或sysoper权限连接数据库用户的口令，如果想以sysdba或sysoper权限远程连接数据库，必须使用口令文件，否则不能连接，由于sys用户在连接数据库时必须以sysdba or sysoper方式，也就是说sys用户要想远程连接数据库必须使用口令文件，因此可以认为在数据库中存放sys用户的口令其实没有任何意义，因为你本机其实还是可以登陆的！</p><p>使用口令文件的好处是即使数据库不处于open状态，依然可以通过口令文件验证来连接数据库。开始安装完oracle，没有给普通用户授予sysdba或sysoper权限，口令文件中只存放了sys与system的口令，如果之后把sysdba或sysoper权限授予了普通用户，那么此时会把普通用户的口令从数据库中读到口令文件中保存下来，当然这时必须要求数据库处于open状态。</p><h2 id="二、Oracle的两种认证方式；"><a href="#二、Oracle的两种认证方式；" class="headerlink" title="二、Oracle的两种认证方式；"></a>二、Oracle的两种认证方式；</h2><ol><li>使用与操作系统集成的身份验证</li><li>使用Oracle数据库的密码文件进行身份认证</li></ol><h2 id="三、密码文件的位置"><a href="#三、密码文件的位置" class="headerlink" title="三、密码文件的位置"></a>三、密码文件的位置</h2><p>Linux下的存放位置：<br><code>$ORACLE_HOME/dbs/orapw$ORACLE_SID</code><br>即：<code>ORACLE_HOME/dbs/orapw&lt;sid&gt;</code></p><p>Windows下的存放位置:<code>$ORACLE_HOME/database/PW%ORACLE_SID%.ora</code></p><p>密码文件查找的顺序  —&gt;<code>orapw&lt;sid&gt;</code>—&gt;<code>orapw</code>—&gt;<code>Failure</code></p><p>两种认证方式：<br>决定在两个参数中</p><ol><li><p>remote_login_passwordfile &#x3D; none | exclusive |shared  位于$ORACLE_HOME&#x2F;dbs&#x2F;spfile$ORACLE_SID.ora参数文件中，通过show parameter  remote_login_passwordfile查看<br> none : 不使用密码文件认证<br> exclusive :使用密码文件认证，自己独占使用(默认值)<br> shared :使用密码文件认证，不同实例dba用户可以共享密码文件(如集群)</p></li><li><p>$ORACLE_HOME&#x2F;network&#x2F;admin&#x2F;sqlnet.ora文件中<br>SQLNET.AUTHENTICATION_SERVICES &#x3D; none | all | ntf(windows)<br> none : 表示关闭操作系统认证，只能密码文件认证<br> all : 用于linux或unix平台，关闭本机密码文件认证采用操作系统认证，但远程&lt;非本机&gt;可以使用密码文件认证<br> nts : 用于windows平台</p></li></ol><p>如果上面两个参数都选择none，那么sys用户无论是本机还是远程均不可登陆，但是非sys用户可登陆</p><h2 id="四、演示"><a href="#四、演示" class="headerlink" title="四、演示"></a>四、演示</h2><p>查看remote_login_passwordfile参数</p><pre><code class="sql">SQL&gt; show parameter remote_login_passwordfile;NAME                            TYPE        VALUE------------------------------- ----------- -----------------------------remote_login_passwordfile       string      EXCLUSIVE                 ##使用密码文件认证（默认）</code></pre><h3 id="设置sqlnet-ora文件中的SQLNET-AUTHENTICATION-SERVICES参数为none"><a href="#设置sqlnet-ora文件中的SQLNET-AUTHENTICATION-SERVICES参数为none" class="headerlink" title="设置sqlnet.ora文件中的SQLNET.AUTHENTICATION_SERVICES参数为none"></a>设置sqlnet.ora文件中的SQLNET.AUTHENTICATION_SERVICES参数为none</h3><pre><code class="sql">[oracle@oracle admin]$ cat sqlnet.ora | grep -i authSQLNET.AUTHENTICATION_SERVICES = none</code></pre><p>使用本地操作系统认证，失败</p><pre><code class="sql">[oracle@oracle admin]$ sqlplus / as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on Tue May 8 21:49:22 2018Copyright (c) 1982, 2009, Oracle.  All rights reserved.ERROR:ORA-01031: insufficient privilegesEnter user-name:</code></pre><p>使用密码文件认证，成功</p><pre><code class="sql">[oracle@oracle admin]$ sqlplus  sys/Oracle_1@oracle as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on Tue May 8 21:50:39 2018Copyright (c) 1982, 2009, Oracle.  All rights reserved.Connected to:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt;</code></pre><h3 id="设置sqlnet-ora文件中的SQLNET-AUTHENTICATION-SERVICES参数为all"><a href="#设置sqlnet-ora文件中的SQLNET-AUTHENTICATION-SERVICES参数为all" class="headerlink" title="设置sqlnet.ora文件中的SQLNET.AUTHENTICATION_SERVICES参数为all"></a>设置sqlnet.ora文件中的SQLNET.AUTHENTICATION_SERVICES参数为all</h3><pre><code class="sql">[oracle@oracle admin]$ cat sqlnet.ora | grep -i authSQLNET.AUTHENTICATION_SERVICES = all</code></pre><p>使用本地操作系统用户认证，成功</p><pre><code class="sql">[oracle@oracle admin]$ sqlplus / as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on Tue May 8 21:53:01 2018Copyright (c) 1982, 2009, Oracle.  All rights reserved.Connected to:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt;</code></pre><p>使用密码文件认证，失败</p><pre><code class="sql">[oracle@oracle admin]$ sqlplus  sys/Oracle_1@oracle as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on Tue May 8 21:53:28 2018Copyright (c) 1982, 2009, Oracle.  All rights reserved.ERROR:ORA-12641: Authentication service failed to initializeEnter user-name:</code></pre><p>但是远程使用密码文件认证将会成功</p><pre><code class="sql">[oracle@mysql-master-1003306 admin]$ sqlplus  sys/Oracle_1@orcl1 as sysdba              ##此处为远程连接SQL*Plus: Release 11.2.0.1.0 Production on Wed May 9 07:46:40 2018Copyright (c) 1982, 2009, Oracle.  All rights reserved.Connected to:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt;</code></pre><p>使用<code>#</code>符号将新增的SQLNET.AUTHENTICATION_SERVICES行注释掉恢复到缺省值，使用缺省值时系统认证及密码文件认证都可用</p><h2 id="五、密码文件的建立：orapwd"><a href="#五、密码文件的建立：orapwd" class="headerlink" title="五、密码文件的建立：orapwd"></a>五、密码文件的建立：orapwd</h2><pre><code class="sql">[oracle@oracle dbs]$ orapwdUsage: orapwd file=&lt;fname&gt; entries=&lt;users&gt; force=&lt;y/n&gt; ignorecase=&lt;y/n&gt; nosysdba=&lt;y/n&gt;  where    file - name of password file (required),    password - password for SYS will be prompted if not specified at command line,    entries - maximum number of distinct DBA (optional),    force - whether to overwrite existing file (optional),    ignorecase - passwords are case-insensitive (optional),    nosysdba - whether to shut out the SYSDBA logon (optional Database Vault only).     There must be no spaces around the equal-to (=) character.##file：密码文件的名字，默认为orapw&lt;sid&gt;password：sys用户的密码，这里仅仅是sys的密码entries：密码问价那种可存放的最大文件数force：默认为n，y表示允许覆盖ignorecase：忽略大小写nosysdba：是否关闭sysdba登录</code></pre><p>重建或者修改sys密码文件</p><pre><code class="sql">[oracle@oracle dbs]$ orapwd file=&#39;/oracle/11g/product/11.2.0/dbhome_1/dbs/orapworcl&#39; password=&#39;Oracle&#39; entries=5OPW-00005: File with same name exists - please delete or rename[oracle@oracle dbs]$[oracle@oracle dbs]$ orapwd file=&#39;/oracle/11g/product/11.2.0/dbhome_1/dbs/orapworcl&#39; password=&#39;Oracle&#39; entries=5 force=y##将sys用户密码修改为Oracle，也可以用于重建密码文件，密码文件的名字严格按照orapw&lt;sid&gt;来命名</code></pre><p>演示将entries 改为5，然后将多个用户设置为sysdba或sysoper</p><pre><code class="sql">[oracle@oracle dbs]$ orapwd file=&#39;/oracle/11g/product/11.2.0/dbhome_1/dbs/orapworcl&#39; password=&#39;Oracle&#39; entries=5 force=y</code></pre><p>给多个用户赋予sysdba角色</p><pre><code class="sql">SQL&gt; grant sysdba to test6;grant sysdba to test7;grant sysdba to test8;grant sysdba to test9;grant sysdba to test10;Grant succeeded.SQL&gt;Grant succeeded.SQL&gt;Grant succeeded.SQL&gt; grant sysdba to test9*ERROR at line 1:ORA-01996: GRANT failed: password file&#39;/oracle/11g/product/11.2.0/dbhome_1/dbs/orapworcl&#39; is fullSQL&gt;grant sysdba to test10*ERROR at line 1:ORA-01996: GRANT failed: password file&#39;/oracle/11g/product/11.2.0/dbhome_1/dbs/orapworcl&#39; is full</code></pre><p>会出现错误： ORA-01996: GRANT failed: password file ‘’ is full </p><p>再次查看orapworcl发现多出几行，即当设置的时候多出了个用户</p><pre><code class="sql">[oracle@oracle dbs]$ strings orapworcl]\[ZORACLE Remote Password fileINTERNALAB27B53EDC5FEF418A8F025737A9097ATEST122F2E341BF4B8764TEST22E3197EF1322CB1DTEST39728B9C4700744F0TEST4D981A32D021D0F35TEST576489E4C44B14CDFTEST60AE1AAE2C08CD499TEST7BCD14F62F7BE3195TEST8B3F1A240058CED9B</code></pre><blockquote><p>注意不要轻易删掉密码文件，以免将其他账户的信息也删除</p></blockquote><h2 id="六、密码文件内容修改的几种方式"><a href="#六、密码文件内容修改的几种方式" class="headerlink" title="六、密码文件内容修改的几种方式"></a>六、密码文件内容修改的几种方式</h2><p> 1、使用orapwd建立，修改密码文件，不建议使用<br> 2、使用alter user sys identified by &lt;&gt;<br> 3、使用grant sysdba to &lt;&gt; 或grant sysoper to &lt;&gt; 或 revoke sysdba |sysoper from &lt;&gt;</p><h2 id="七、查看密码文件内容"><a href="#七、查看密码文件内容" class="headerlink" title="七、查看密码文件内容"></a>七、查看密码文件内容</h2><pre><code class="sql">[oracle@oracle dbs]$ strings orapworcl]\[ZORACLE Remote Password fileINTERNALAB27B53EDC5FEF418A8F025737A9097A</code></pre><p>当sys密码不记得可以使用OS系统身份认证登陆到sqlplus,再使用alter user修改密码</p><pre><code class="sql">SQL&gt; alter user sys identified by &quot;Oracle_1&quot;;User altered.</code></pre><p>再次查看密码文件与上一次对比，已经发生变化</p><pre><code class="sql">[oracle@oracle dbs]$ strings orapworcl]\[ZORACLE Remote Password fileINTERNALABE3DF9F8DA2D18F72D6FA01DEAD0BB6</code></pre><p>通过授予权限来修改密码，密码文件中多出了scott的信息</p><pre><code class="sql">SQL&gt; grant sysdba to test1;Grant succeeded.SQL&gt; ho strings orapworcl    ]/[Z    ORACLE Remote Password file    INTERNAL    AB27B53EDC5FEF41    8A8F025737A9097A    TEST1    22F2E341BF4B8764</code></pre><p>注意此处使用test1登陆后，显示的账户信息还是sys而不是test1,但此时的test1已经具备了sys权限</p><pre><code class="sql">[oracle@oracle admin]$ sqlplus test1/test1@oracle as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on Tue May 8 22:54:01 2018Copyright (c) 1982, 2009, Oracle.  All rights reserved.Connected to:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; show user;USER is &quot;SYS&quot;</code></pre><h2 id="八、sysdba与sysoper的区别"><a href="#八、sysdba与sysoper的区别" class="headerlink" title="八、sysdba与sysoper的区别"></a>八、sysdba与sysoper的区别</h2><pre><code class="sql">SQL&gt; select * from system_privilege_map where name like &#39;%SYS%&#39;;PRIVILEGE NAME                            PROPERTY---------- ---------------------------------------- ----------     -3 ALTER SYSTEM                           0     -4 AUDIT SYSTEM                           0       -83 SYSDBA                              0       -84 SYSOPER                             0</code></pre><p>两者的schema不同</p><pre><code class="sql">SQL&gt; show user             ##sysdbaUSER is &quot;SYS&quot;SQL&gt; conn / as sysoperConnected.SQL&gt; show user             ##sysoperUSER is &quot;PUBLIC&quot;</code></pre><p>查看密码文件视图，可以得到哪些用户为sysdba,哪些用户为sysoper</p><pre><code class="sql">SQL&gt; select * from v$pwfile_users;USERNAME               SYSDB SYSOP SYSAS------------------------------ ----- ----- -----SYS                    TRUE  TRUE  FALSETEST1                  TRUE  FALSE FALSETEST2                  TRUE  FALSE FALSETEST3                  TRUE  FALSE FALSETEST4                  TRUE  FALSE FALSETEST5                  TRUE  FALSE FALSETEST6                  TRUE  FALSE FALSETEST7                  TRUE  FALSE FALSETEST8                  TRUE  FALSE FALSE9 rows selected.</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2018/01/14/Mysql/MySQL%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/01/14/Mysql/MySQL%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引（Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质：索引是数据结构。可以理解为“排好序的快速查找数据结构”在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据,这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>类似大学图书馆建书目索引，提高数据检索效率，降低数据库的IO成本。通过索引对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</p><h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占空间的。虽然索引大大提高了查询速度，同时确会降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段。都会调整因为更新所带来的键值变化后的索引信息。 </p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>注意：索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引</p><ul><li>MyISAM和InnoDB存储引擎：只支持BTREE索引， 也就是说默认使用BTREE，不能够更换</li><li>MEMORY&#x2F;HEAP存储引擎：支持HASH和BTREE索引</li></ul><p>索引我们分为四类来讲，单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引；</p><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。</p><ul><li>普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</li><li>唯一索引：索引列中的值必须是唯一的，但是允许为空值；</li><li>主键索引：是一种特殊的唯一索引，不允许有空值。</li></ul><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有”你是个大煞笔，二货 …” 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，全文索引很少使用；</p><h3 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h3><p>空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。<br>在创建空间索引时，使用SPATIAL关键字。<br>需要使用引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>创建多列（组合）索引<br>ALTER TABLE t1 ADD INDEX index_c1_c2 (c1,c2);</p><p>查看执行计划可以看到索引是否被使用；</p><pre><code class="sql">mysql&gt; explain select * from t1 where id=1;+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)</code></pre><ul><li>id：SELECT识别符。这是SELECT的查询序列号,也就是一条语句中，该select是第几次出 现。在次语句中，select就只有一个，所以是1.</li><li>select_type：所使用的SELECT查询类型，SIMPLE表示为简单的SELECT，不实用UNION或子查询，就为简单的SELECT。也就是说在该SELECT查询时会使用索引。其他取值，PRIMARY：最外面的SELECT.在拥有子查询时，就会出现两个以上的SELECT。UNION：union(两张表连接)中的第二个或后面的select语句  SUBQUERY：在子查询中，第二SELECT。</li><li>table：数据表的名字。他们按被读取的先后顺序排列，这里因为只查询一张表，所以只显示book</li><li>type：指定本数据表和其他数据表之间的关联关系，该表中所有符合检索值的记录都会被取出来和从上一个表中取出来的记录作联合。ref用于连接程序使用键的最左前缀或者是该键不是 primary key 或 unique索引（换句话说，就是连接程序无法根据键值只取得一条记录）的情况。当根据键值只查询到少数几条匹配的记录时，这就是一个不错的连接类型。(注意，个人这里不是很理解，百度了很多资料，全是大白话，等以后用到了这类信息时，在回过头来补充，这里不懂对后面的影响不大。)可能的取值有 system、const、eq_ref、index和All</li><li>possible_keys：MySQL在搜索数据记录时可以选用的各个索引，该表中就只有一个索引，year_publication</li><li>key：实际选用的索引</li><li>key_len：显示了mysql使用索引的长度(也就是使用的索引个数)，当 key 字段的值为 null时，索引的长度就是 null。注意，key_len的值可以告诉你在联合索引中mysql会真正使用了哪些索引。这里就使用了1个索引，所以为1，</li><li>ref：给出关联关系中另一个数据表中数据列的名字。常量（const），这里使用的是1990，就是常量。</li><li>rows：MySQL在执行这个查询时预计会从这个数据表里读出的数据行的个数。</li><li>extra：提供了与关联操作有关的信息，没有则什么都不写。</li></ul><h2 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h2><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合建立索引，因为每次更新不单单是更新了记录还会更新索引</li><li>WHERE条件里用不到的字段不创建索引</li><li>单键&#x2F;组合索引的选择问题，who?(在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ul><h2 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h2><ul><li>表记录太少</li><li>经常增删改的表<br>提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE、和DELETE。<br>因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。<br>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。</li><li>注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础-字符串</title>
      <link href="/2018/01/12/Python/Python%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/01/12/Python/Python%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是不可变类型，没有改、增、删操作<br>字符串也属于序列类型，可以将字符串看作是字符的列表，因此列表的操作对于字符串也是适用的</p><h2 id="创建字符串的两种方式"><a href="#创建字符串的两种方式" class="headerlink" title="创建字符串的两种方式"></a>创建字符串的两种方式</h2><p>1、 适用引号，既可以适用单引号，也可以适用双引号，通常适用单引号，不能在单引号中使用单引号，也不能在双引号中使用双引号</p><pre><code class="python">&gt;&gt;&gt; s = &#39;abcd&#39;&gt;&gt;&gt; s&#39;abcd&#39;&gt;&gt;&gt; s = &#39;&#39;             ##空字符串&gt;&gt;&gt; s&#39;&#39;</code></pre><p>2、适用内置函数str()</p><pre><code class="python">&gt;&gt;&gt; s = str(&#39;abcd&#39;)&gt;&gt;&gt; s&#39;abcd&#39;&gt;&gt;&gt; str(123)&#39;123&#39;&gt;&gt;&gt; str(123.1)&#39;123.1&#39;&gt;&gt;&gt; a = 123&gt;&gt;&gt; str(a)&#39;123&#39;</code></pre><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><table><thead><tr><th align="left">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">&#39;</td><td align="left">单引号</td></tr><tr><td align="left">&quot;</td><td align="left">双引号</td></tr><tr><td align="left">\a</td><td align="left">发出系统响铃</td></tr><tr><td align="left">\b</td><td align="left">退格符</td></tr><tr><td align="left">\n</td><td align="left">换行符</td></tr><tr><td align="left">\t</td><td align="left">横向制表符（TAB）</td></tr><tr><td align="left">\v</td><td align="left">纵向制表符</td></tr><tr><td align="left">\r</td><td align="left">回车符</td></tr><tr><td align="left">\f</td><td align="left">换页符</td></tr><tr><td align="left">\o</td><td align="left">八进制数代表的字符</td></tr><tr><td align="left">\x</td><td align="left">十六进制代表的字符</td></tr><tr><td align="left">\0</td><td align="left">表示一个空字符</td></tr><tr><td align="left">\</td><td align="left">反斜杠</td></tr></tbody></table><h2 id="原样字符串"><a href="#原样字符串" class="headerlink" title="原样字符串"></a>原样字符串</h2><p>原样字符串的最后一个字符不能是反斜杠（最后两个字符都是反斜杠除外）</p><pre><code class="python">&gt;&gt;&gt; print(r&#39;\t\n&#39;)\t\n&gt;&gt;&gt; print(r&#39;hello world\&#39;)  File &quot;&lt;stdin&gt;&quot;, line 1    print(r&#39;hello world\&#39;)                         ^SyntaxError: EOL while scanning string literal&gt;&gt;&gt;&gt;&gt;&gt; print(r&#39;hello world\\&#39;)hello world\\</code></pre><h2 id="跨越多行的字符串"><a href="#跨越多行的字符串" class="headerlink" title="跨越多行的字符串"></a>跨越多行的字符串</h2><pre><code class="python">&gt;&gt;&gt; print(&#39;&#39;&#39;asdfa... sadfasd... asdfasdf... &#39;&#39;&#39;)asdfasadfasdasdfasdf</code></pre><h2 id="使用加法和乘法操作字符串"><a href="#使用加法和乘法操作字符串" class="headerlink" title="使用加法和乘法操作字符串"></a>使用加法和乘法操作字符串</h2><pre><code class="python">&gt;&gt;&gt; print(&#39;Hello, &#39; + &#39;World!&#39;)Hello, World!&gt;&gt;&gt; print(&#39;haha, &#39; * 3)haha, haha, haha,</code></pre><h2 id="在字符串中查找子串索引"><a href="#在字符串中查找子串索引" class="headerlink" title="在字符串中查找子串索引"></a>在字符串中查找子串索引</h2><p>当获得字符串中指定子串的索引时，除了调用方法index，还可以调用方法find、rfind、rindex，其中，子串的索引指的是子串中第一个字符的索引<br>index和find从左边开始查找，返回的是第一个子串的索引，rindex和rfind从右边开始查找，返回的是最后一个子串的索引</p><pre><code class="python">&gt;&gt;&gt; s = &#39;123456678966789&#39;&gt;&gt;&gt; s.index(&#39;66&#39;)5&gt;&gt;&gt; s.find(&#39;66&#39;)5&gt;&gt;&gt; s.rindex(&#39;66&#39;)10&gt;&gt;&gt; s.rfind(&#39;66&#39;)10</code></pre><p>index和rindex在找不到子串时抛出异常，而find和rfind找不到子串时返回-1</p><pre><code class="python">&gt;&gt;&gt; s.index(&#39;62&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: substring not found&gt;&gt;&gt;&gt;&gt;&gt; s.rindex(&#39;62&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: substring not found&gt;&gt;&gt; s.rfind(&#39;62&#39;)-1&gt;&gt;&gt;&gt;&gt;&gt; s.find(&#39;62&#39;)-1&gt;&gt;&gt;</code></pre><p>该四种查找方法还可以指定查找范围，例如：</p><pre><code class="python">&gt;&gt;&gt; s.find(&#39;66&#39;, 7, 13)10&gt;&gt;&gt; s.rfind(&#39;66&#39;, 7, 13)10&gt;&gt;&gt; s.index(&#39;66&#39;, 7, 13)10&gt;&gt;&gt; s.rindex(&#39;66&#39;, 7, 13)10</code></pre><h2 id="两个字符串进行比较"><a href="#两个字符串进行比较" class="headerlink" title="两个字符串进行比较"></a>两个字符串进行比较</h2><p>和列表比较类似，首先比较两个字符串中的第一个字符，如果相等，则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符，将不再被比较。</p><p>两个字符比较时，比较的是其ordinal value（序数），即ASCII码。调用内置函数ord()可以得到指定字符的ASCII码（十进制）。相反，调用chr()函数可以从ASCII码得到字符</p><pre><code class="python">&gt;&gt;&gt; ord(&#39;a&#39;)97&gt;&gt;&gt; chr(97)&#39;a&#39;</code></pre><pre><code class="python">&gt;&gt;&gt; ord(&#39;a&#39;)97&gt;&gt;&gt; ord(&#39;&#123;&#39;)123&gt;&gt;&gt;&gt;&gt;&gt; &#39;&#123;&#39; &gt; &#39;a&#39;True</code></pre><p>字符串常量会被缓存和重用，和整型不同的是，整型只有较小的整型才会被重用，大的整型并不会被重用</p><pre><code class="python">&gt;&gt;&gt; a = b = &#39;hello&#39;&gt;&gt;&gt; c = &#39;hello&#39;&gt;&gt;&gt; id(a)139932323278384&gt;&gt;&gt; id(b)139932323278384&gt;&gt;&gt; id(c)139932323278384</code></pre><h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><p>与列表不同的是，字符串是不可变类型，因此我们如果想对字符串所有字符进行反转，不存在方法reverse()，只能调用内置函数reversed()。</p><pre><code class="python">&gt;&gt;&gt; s = &#39;abcde&#39;&gt;&gt;&gt; s1 = reversed(s)&gt;&gt;&gt; s1&lt;reversed object at 0x7f44886bee80&gt;&gt;&gt;&gt; print(list(s1))[&#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</code></pre><h2 id="字符串的排序"><a href="#字符串的排序" class="headerlink" title="字符串的排序"></a>字符串的排序</h2><p>与列表不同的是，字符串是不可变类型，因此我们如果想对字符串所有字符进行排序，不存在方法sort()，只能调用内置函数sorted()。</p><pre><code class="python">&gt;&gt;&gt; s = &#39;aEdFcfRjK&#39;&gt;&gt;&gt; sorted(s)[&#39;E&#39;, &#39;F&#39;, &#39;K&#39;, &#39;R&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;f&#39;, &#39;j&#39;]&gt;&gt;&gt; sorted(s, reverse = True)                       ##反向排序[&#39;j&#39;, &#39;f&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;, &#39;R&#39;, &#39;K&#39;, &#39;F&#39;, &#39;E&#39;]&gt;&gt;&gt; s&#39;aEdFcfRjK&#39;</code></pre><p>调用内置函数sorted()时，还可以指定参数key &#x3D; 函数名，或者key &#x3D; 类名.方法名，这样会对字符串中的所有字符分别调用指定的函数或方法，然后按照函数或方法的返回值进行排序，从而自定义排序规则</p><pre><code class="python">&gt;&gt;&gt; sorted(s, key = str.lower)[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;E&#39;, &#39;F&#39;, &#39;f&#39;, &#39;j&#39;, &#39;K&#39;, &#39;R&#39;]&gt;&gt;&gt;&gt;&gt;&gt; sorted(s, key = str.upper)[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;E&#39;, &#39;F&#39;, &#39;f&#39;, &#39;j&#39;, &#39;K&#39;, &#39;R&#39;]</code></pre><h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><h2 id="用百分号作为占位符"><a href="#用百分号作为占位符" class="headerlink" title="用百分号作为占位符"></a>用百分号作为占位符</h2><p>常见的占位符有：</p><table><thead><tr><th align="left">占位符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">%nd</td><td align="left">整数，n表示宽度</td></tr><tr><td align="left">%.nf</td><td align="left">浮点数，.n表示保留几位小数</td></tr><tr><td align="left">%s</td><td align="left">字符串</td></tr><tr><td align="left">%o</td><td align="left">八进制整数</td></tr><tr><td align="left">%x</td><td align="left">十六进制整数</td></tr><tr><td align="left">%X</td><td align="left">大写十六进制整数</td></tr><tr><td align="left">%%</td><td align="left">%转义</td></tr></tbody></table><p>不确定使用哪种占位符，那么%s永远起作用，他会把任何数据类型转换为字符串</p><pre><code class="python">&gt;&gt;&gt; print(&#39;%s先生，你%d月的实时话费%.2f元，可用余额%.2f元。&#39; %(&#39;jerry&#39;, 5, 20, 50))jerry先生，你5月的实时话费20.00元，可用余额50.00元。</code></pre><p>如果定义的格式化字符串中的%是一个普通字符，需要使用%%对其进行转义，注意，这里并不是通过\来进行转义</p><pre><code class="python">&gt;&gt;&gt; print(&#39;我的工作已经完成了%d%%&#39; %(80))我的工作已经完成了80%</code></pre><p>占位符%中可以指定宽度，数字和字符串都是右对齐</p><pre><code class="python">&gt;&gt;&gt; print(&#39;%10d&#39; %(10))        10&gt;&gt;&gt; print(&#39;%10s&#39; %(&#39;ab&#39;))        ab</code></pre><p>占位符%中可以指定精度</p><pre><code class="python">&gt;&gt;&gt; print(&#39;%.3f&#39; %(3.1415926))3.142&gt;&gt;&gt; print(&#39;%.3s&#39; %(&#39;hello&#39;))hel</code></pre><h2 id="用花括号作为占位符"><a href="#用花括号作为占位符" class="headerlink" title="用花括号作为占位符"></a>用花括号作为占位符</h2><p>使用format方法并使用花括号作为占位符，来进行格式化输出</p><p>位置化参数，例如：</p><pre><code class="python">&gt;&gt;&gt; &#39;&#123;0&#125; love &#123;1&#125;!&#39;.format(&#39;I&#39;, &#39;you&#39;)&#39;I love you!&#39;&gt;&gt;&gt; &#39;&#123;0&#125; love &#123;1&#125;! &#123;0&#125; love python&#39;.format(&#39;I&#39;, &#39;you&#39;)&#39;I love you! I love python&#39;</code></pre><p>关键字参数，例如：</p><pre><code class="python">&gt;&gt;&gt; &#39;&#123;a&#125; love &#123;b&#125;!&#39;.format(a=&#39;I&#39;,b=&#39;you&#39;)&#39;I love you!&#39;</code></pre><p><code>&#123;&#125;</code>中不指定参数，方法format的参数会按顺序依次匹配所有占位符{}，但是format()的参数不能少于占位符，否则不够匹配，抛出异常</p><pre><code class="python">&gt;&gt;&gt; &#39;&#123;&#125; love &#123;&#125;! &#123;&#125; love python&#39;.format(&#39;I&#39;, &#39;you&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: tuple index out of range&gt;&gt;&gt; &#39;&#123;&#125; love &#123;&#125;! love python&#39;.format(&#39;I&#39;, &#39;you&#39;)&#39;I love you! love python&#39;&gt;&gt;&gt; &#39;&#123;&#125; love &#123;&#125;! love python&#39;.format(&#39;I&#39;, &#39;you&#39;, &#39;yes&#39;)&#39;I love you! love python&#39;</code></pre><p>占位符<code>&#123;&#125;</code>中可以使用冒号指定整数的表示形式，其中，位置参数或关键字参数的名称放在冒号前面</p><pre><code class="python">##转换为二进制数&gt;&gt;&gt; &#39;&#123;:b&#125;&#39;.format(118)                     &#39;1110110&#39;##指定十六进制a-f是小写&gt;&gt;&gt; &#39;&#123;:x&#125;&#39;.format(111)                     &#39;6f&#39;##指定十六进制A-F是大写&gt;&gt;&gt; &#39;&#123;:X&#125;&#39;.format(111)                     &#39;6F&#39;##指定浮点数保留1位小数&gt;&gt;&gt; &#39;&#123;0:.1f&#125;&#123;1&#125;&#39;.format(35.56,&#39;GB&#39;)&#39;35.6GB&#39;##包括整数位总共3位&gt;&gt;&gt; &#39;&#123;0:.3&#125;&#123;1&#125;&#39;.format(35.56,&#39;GB&#39;)&#39;35.6GB&#39;##使用逗号作为千位分隔符&gt;&gt;&gt; &#39;&#123;:,&#125;&#39;.format(123456789)&#39;123,456,789&#39;##位置参数或关键字参数的名称放在冒号前面&gt;&gt;&gt; &#39;&#123;0:b&#125;&#39;.format(118)&#39;1110110&#39;&gt;&gt;&gt; &#39;&#123;a:b&#125;&#39;.format(a = 118)&#39;1110110&#39;</code></pre><p>占位符<code>&#123;&#125;</code>中还可以使用冒号指定宽度，其中，数字是右对齐，字符串是左对齐</p><pre><code class="python">&gt;&gt;&gt; &#39;&#123;a:10&#125;&#39;.format(a = 118)&#39;       118&#39;&gt;&gt;&gt; &#39;&#123;a:10&#125;&#39;.format(a = &#39;118&#39;)&#39;118       &#39;##同时指定宽度和精度&gt;&gt;&gt; &#39;&#123;0:8.2f&#125;&#123;1&#125;&#39;.format(35.5666,&#39;GB&#39;)&#39;   35.57GB&#39;</code></pre><p><code>&#39;:m&#39;.format(n)</code> 等价于<code>format(n, &#39;m&#39;)</code></p><pre><code class="python">&gt;&gt;&gt; &#39;&#123;:.1f&#125;&#39;.format(35.56)&#39;35.6&#39;&gt;&gt;&gt; format(35.6, &#39;.1f&#39;)&#39;35.6&#39;</code></pre><p>使用美元符作为占位符，导入string模块，使用其Template方法</p><pre><code class="python">&gt;&gt;&gt; import string&gt;&gt;&gt; a = &#39;I&#39;&gt;&gt;&gt; b = &#39;you&#39;&gt;&gt;&gt; tmpl = string.Template(&#39;$x love $y&#39;)   &gt;&gt;&gt; tmpl.substitute(x = a, y = b)&#39;I love you&#39;##使用字典&gt;&gt;&gt; tmpl.substitute(&#123;&#39;x&#39;:a, &#39;y&#39;:b&#125;)&#39;I love you&#39;</code></pre><p><code>safe_substitute()</code>，占位符没有匹配的实际值时，不会抛出异常，而是使用占位符本身作为其实际值</p><pre><code class="python">&gt;&gt;&gt; tmpl.substitute(x = a)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;/usr/local/python3/lib/python3.7/string.py&quot;, line 132, in substitute    return self.pattern.sub(convert, self.template)  File &quot;/usr/local/python3/lib/python3.7/string.py&quot;, line 125, in convert    return str(mapping[named])KeyError: &#39;y&#39;&gt;&gt;&gt;&gt;&gt;&gt; tmpl.safe_substitute(x = a)&#39;I love $y&#39;</code></pre><h1 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h1><p>可以调用字符串的以下方法：</p><ol><li>upper()：把所有字符转化为大写</li><li>lower()：把所有字符转化为小写</li><li>swapcase()：把所有小写转化为大写，大写转化为小写</li><li>capitalize()：把第一个字符转换为大写，把其余字符转化为小写</li><li>title()：把每个单词的第一个字符转化为大写，把每个单词的剩余字符转化为小写</li></ol><pre><code class="python">&gt;&gt;&gt; s = &#39;I love Python&#39;&gt;&gt;&gt; s.upper()&#39;I LOVE PYTHON&#39;&gt;&gt;&gt; s.lower()&#39;i love python&#39;&gt;&gt;&gt; s.swapcase()&#39;i LOVE pYTHON&#39;&gt;&gt;&gt; s.capitalize()&#39;I love python&#39;&gt;&gt;&gt; s.title()&#39;I Love Python&#39;</code></pre><p>判断字符串中某些字符的大小写，可以调用字符串的以下方法：</p><ol><li>isupper()：是否所有字符全为大写</li><li>islower()：是否所有字符全为小写</li><li>istitle()：是否每个单词的第一个字符为大写，并且每个单词的剩余字符为小写</li></ol><pre><code class="python">&gt;&gt;&gt; s&#39;I love Python&#39;&gt;&gt;&gt; s.isupper()False&gt;&gt;&gt; s.islower()False&gt;&gt;&gt; s.istitle()False</code></pre><h1 id="字符串的对齐"><a href="#字符串的对齐" class="headerlink" title="字符串的对齐"></a>字符串的对齐</h1><p>如果想要设置字符串的对齐方式，可以调用字符串的以下方法：</p><ol><li>center()：中心对齐</li><li>ljust()：左对齐</li><li>rjust()：右对齐</li></ol><p>这三个方法都可以接收两个参数，其中<br>第一个参数指定字符串的宽度，如果指定的宽度小于等于字符串的长度，则返回字符串本身<br>第二个参数指定填充字符，且第二个参数时可选的，默认值是空值</p><pre><code class="python">&gt;&gt;&gt; s = &#39;Hello,world!&#39;##center()&gt;&gt;&gt; s.center(21, &#39;-&#39;)&#39;-----Hello,world!----&#39;&gt;&gt;&gt; s.center(21)&#39;     Hello,world!    &#39;&gt;&gt;&gt; s.center(10)&#39;Hello,world!&#39;##ljust()&gt;&gt;&gt; s.ljust(21, &#39;-&#39;)&#39;Hello,world!---------&#39;&gt;&gt;&gt; s.ljust(21)&#39;Hello,world!         &#39;&gt;&gt;&gt; s.ljust(10)&#39;Hello,world!&#39;##rjust&gt;&gt;&gt; s.rjust(21, &#39;-&#39;)&#39;---------Hello,world!&#39;&gt;&gt;&gt; s.rjust(21)&#39;         Hello,world!&#39;&gt;&gt;&gt; s.rjust(10)&#39;Hello,world!&#39;</code></pre><ol start="4"><li>zfill()：右对齐，左边用0填充<br>该方法只接收一个参数，用于指定字符串的宽度，如果指定的宽度小于等于字符串的长度，则返回字符串本身</li></ol><pre><code class="python">&gt;&gt;&gt; s.zfill(21)&#39;000000000Hello,world!&#39;&gt;&gt;&gt; s = &#39;-Hello,world!&#39;             &gt;&gt;&gt; s.zfill(21)&#39;-00000000Hello,world!&#39;          ##注意，这里的负号是在填充的首部，可用于数字的表示&gt;&gt;&gt; s.zfill(10)&#39;-Hello,world!&#39;</code></pre><h1 id="字符串的子串替换"><a href="#字符串的子串替换" class="headerlink" title="字符串的子串替换"></a>字符串的子串替换</h1><p>如果想讲字符串中的子串替换为指定的字符串，可以调用方法<code>replace()</code>，该方法的第一个参数指定被替换的子串，第二个参数指定替换子串的字符串。<br>该方法返回替换后得到的字符串，替换前的字符串不发生变化。</p><pre><code class="python">&gt;&gt;&gt; s = &#39;abc-abc-abc&#39;&gt;&gt;&gt; s.replace(&#39;abc&#39;, &#39;haha&#39;)&#39;haha-haha-haha&#39;&gt;&gt;&gt; s&#39;abc-abc-abc&#39;</code></pre><p>还可以指定第三个参数来指定最大替换个数</p><pre><code class="python">&gt;&gt;&gt; s.replace(&#39;abc&#39;, &#39;haha&#39;, 2)&#39;haha-haha-abc&#39;</code></pre><h1 id="字符串的字符转换"><a href="#字符串的字符转换" class="headerlink" title="字符串的字符转换"></a>字符串的字符转换</h1><p>如果想对字符串中的某些字符进行转换，可以调用方法<code>maketrans</code>和<code>translate</code>，两者结合使用。会将所有字符全都转换。<br>首先调用方法<code>maketrans</code>创建一个转换表，然后把创建的转换表作为参数传给方法<code>translate</code>。</p><pre><code class="python">&gt;&gt;&gt; s = &#39;abcdefg&#39;##创建转换表&gt;&gt;&gt; table = str.maketrans(&#39;abc&#39;, &#39;123&#39;)&gt;&gt;&gt; print(table)&#123;97: 49, 98: 50, 99: 51&#125;                  ##&#123; a :  1,  b : 2,  c: 3&#125;，就是个映射关系，其显示的是ascii码##进行转换&gt;&gt;&gt; s.translate(table)                    ##将转换表作为参数传递，相当于把转换表进行翻译，得出结果&#39;123defg&#39;</code></pre><p>转换表还可以给定第三个参数，用于指定想要删除的字符</p><pre><code class="python">&gt;&gt;&gt; s = &#39;abcdefg&#39;&gt;&gt;&gt;&gt;&gt;&gt; table = str.maketrans(&#39;abc&#39;, &#39;123&#39;, &#39;fg&#39;)&gt;&gt;&gt; print(table)&#123;97: 49, 98: 50, 99: 51, 102: None, 103: None&#125;              ##f和g映射到None，相当于删除&gt;&gt;&gt; s.translate(table)&#39;123de&#39;</code></pre><p>不转换，只指定要删除的字符</p><pre><code class="python">&gt;&gt;&gt; s = &#39;abcdefg&#39;&gt;&gt;&gt; table = str.maketrans(&#39;&#39;, &#39;&#39;, &#39;cde&#39;)&gt;&gt;&gt; print(table)&#123;99: None, 100: None, 101: None&#125;&gt;&gt;&gt; s.translate(table)&#39;abfg&#39;</code></pre><h1 id="字符串的拆分和合并"><a href="#字符串的拆分和合并" class="headerlink" title="字符串的拆分和合并"></a>字符串的拆分和合并</h1><p>1、调用方法<code>split</code>或<code>rsplit</code>拆分字符串，方法<code>split</code>从字符串左边开始拆分，<code>rsplit</code>从字符串右边开始拆分，默认拆分符是空格，这两个方法的返回值都是一个列表。</p><pre><code class="python">&gt;&gt;&gt; s = &#39;I love python&#39;&gt;&gt;&gt; s.split()[&#39;I&#39;, &#39;love&#39;, &#39;python&#39;]&gt;&gt;&gt; s.rsplit()[&#39;I&#39;, &#39;love&#39;, &#39;python&#39;]</code></pre><p>可以通过参数sep指定拆分字符串时的拆分符</p><pre><code class="python">&gt;&gt;&gt; s = &#39;I love python!&#39;&gt;&gt;&gt; s.split(sep = &#39;e&#39;)[&#39;I lov&#39;, &#39; python!&#39;]&gt;&gt;&gt; s.rsplit(sep = &#39;e&#39;)[&#39;I lov&#39;, &#39; python!&#39;]</code></pre><p>可以通过参数<code>maxsplit</code>指定拆分字符串时的最大拆分次数，在经过最大次拆分后，剩余的子串会单独作为一部分，此时，方法<code>split</code>和<code>rsplit</code>就有区别了</p><pre><code class="python">&gt;&gt;&gt; s = &#39;python java php js&#39;&gt;&gt;&gt; s.split(maxsplit = 2)[&#39;python&#39;, &#39;java&#39;, &#39;php js&#39;]&gt;&gt;&gt; s.rsplit(maxsplit = 2)[&#39;python java&#39;, &#39;php&#39;, &#39;js&#39;]</code></pre><p>2、调用方法partition或rpartition拆分字符串，方法partition从字符串左边开始拆分，rpartition从字符串右边开始拆分，与split不同的是，调用partition和rpartition两个方法时，都必须指定拆分符<br>，方法partition在指定的拆分符第一次出现的地方（rpartition在指定拆分符最后一次出现的地方），将字符串拆分为三部分：</p><ol><li>拆分符前面的部分</li><li>拆分符</li><li>拆分符后面的部分</li></ol><p>这两个方法的返回值都是一个元组；</p><pre><code class="python">&gt;&gt;&gt; s = &#39;python-java-php-js&#39;&gt;&gt;&gt; s.partition(&#39;-&#39;)(&#39;python&#39;, &#39;-&#39;, &#39;java-php-js&#39;)&gt;&gt;&gt; s.rpartition(&#39;-&#39;)(&#39;python-java-php&#39;, &#39;-&#39;, &#39;js&#39;)##字符串中不存在拆分符&gt;&gt;&gt; s.partition(&#39;=&#39;)(&#39;python-java-php-js&#39;, &#39;&#39;, &#39;&#39;)&gt;&gt;&gt; s.rpartition(&#39;=&#39;)(&#39;&#39;, &#39;&#39;, &#39;python-java-php-js&#39;)</code></pre><p>3、调用方法join合并多个字符串</p><pre><code class="python">&gt;&gt;&gt; a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&gt;&gt;&gt; &#39;-&#39;.join(a)&#39;a-b-c&#39;&gt;&gt;&gt; b = (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;)&gt;&gt;&gt; &#39;+&#39;.join(b)&#39;1+2+3&#39;&gt;&gt;&gt; &#39;-&#39;.join(&#39;python&#39;)&#39;p-y-t-h-o-n&#39;</code></pre><h1 id="去除字符串的前导字符串或后续字符串"><a href="#去除字符串的前导字符串或后续字符串" class="headerlink" title="去除字符串的前导字符串或后续字符串"></a>去除字符串的前导字符串或后续字符串</h1><p>1、lstrip()方法去除前导字符串<br>2、rstrip()方法去除后续字符串<br>3、strip()方法去除前导和后续字符串<br>其中，默认的前导字符串和后续字符串都是空格字符串</p><pre><code class="python">&gt;&gt;&gt; s = &#39;       python        &#39;&gt;&gt;&gt; s&#39;       python        &#39;&gt;&gt;&gt; s.lstrip()&#39;python        &#39;&gt;&gt;&gt; s.rstrip()&#39;       python&#39;&gt;&gt;&gt; s.strip()&#39;python&#39;</code></pre><p>调用以上三个方法时，可以指定一个字符串，这样的话，<br>前导字符串指的是：从左边第一个字符开始依次往后，直到某个字符不在指定的字符串中<br>后续字符串指的是：从右边最后一个字符开始依次往前，直到某个字符不在指定的字符串中</p><pre><code class="python">&gt;&gt;&gt; s = &#39;www.example.com&#39;&gt;&gt;&gt; s.lstrip(&#39;cmowz.&#39;)&#39;example.com&#39;&gt;&gt;&gt; s.rstrip(&#39;cmowz.&#39;)&#39;www.example&#39;&gt;&gt;&gt; s.strip(&#39;cmowz.&#39;)&#39;example&#39;</code></pre><h1 id="字符串中以is开头的方法"><a href="#字符串中以is开头的方法" class="headerlink" title="字符串中以is开头的方法"></a>字符串中以<code>is</code>开头的方法</h1><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">salnum()：</td><td align="left">如果字符串至少有一个字符，且所有字符都是字母或者数字，则为True，否则为Fals</td></tr><tr><td align="left">sdigit()：</td><td align="left">如果字符串只包含数字（阿拉伯数字），则为True，否则为False</td></tr><tr><td align="left">slower()：</td><td align="left">如果字符串中至少包含一个区分大小写的字符，并且这些字符都是小写，则为True，否则为False</td></tr><tr><td align="left">stitle()：</td><td align="left">如果字符串是标题化（所有单词首字母大写，其余小写）的，则为True，否则为False</td></tr><tr><td align="left">salpha()：</td><td align="left">如果字符串至少有一个字符，且这些字符全部由字母组成，则为True，否则为False</td></tr><tr><td align="left">sdecimal()：</td><td align="left">如果字符串只包含十进制数，则为True，否则为False</td></tr><tr><td align="left">sidentifier()：</td><td align="left">判断指定的字符串是否是合法的标识符</td></tr><tr><td align="left">snumeric()：</td><td align="left">如果字符串中只包含数字（阿拉伯数字、汉语数字、罗马数字），则为True，否则为False</td></tr><tr><td align="left">sspace()：</td><td align="left">如果字符串中只由空白字符（空格、回车、TAB等）组成，则为True，否则为False</td></tr><tr><td align="left">supper()：</td><td align="left">如果字符串中至少包含一个区分大小写的字符，并且这些字符都是大写，则为True，否则为False</td></tr></tbody></table><h1 id="字符串其他方法"><a href="#字符串其他方法" class="headerlink" title="字符串其他方法"></a>字符串其他方法</h1><p><img src="/images/33975c71-2fa0-4941-98c4-c73b67f70fd6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95.jpg" alt="33975c71-2fa0-4941-98c4-c73b67f70fd6-字符串方法.jpg" title="33975c71-2fa0-4941-98c4-c73b67f70fd6-字符串方法.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle移动数据文件的两种方法</title>
      <link href="/2018/01/10/Oracle/oracle%E7%A7%BB%E5%8A%A8%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2018/01/10/Oracle/oracle%E7%A7%BB%E5%8A%A8%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="oracle移动数据文件的两种方法"><a href="#oracle移动数据文件的两种方法" class="headerlink" title="oracle移动数据文件的两种方法"></a>oracle移动数据文件的两种方法</h1><h2 id="alter-database方法"><a href="#alter-database方法" class="headerlink" title="alter database方法"></a>alter database方法</h2><p>该方法，可以移动任何表空间的数据文件。</p><pre><code class="sql">***关闭数据库***SQL&gt; shutdown immediateDatabase closed.Database dismounted.ORACLE instance shut down.***移动数据文件，用oracle用户操作***[oracle@test ~]$ mv /u01/app/oracle/oradata/test/system01.dbf /oracledb/test/system01.dbf[oracle@test ~]$ mv /u01/app/oracle/oradata/test/sysaux01.dbf /oracledb/test/sysaux01.dbf[oracle@test ~]$ mv /u01/app/oracle/oradata/test/undotbs01.dbf /oracledb/test/undotbs01.dbf[oracle@test ~]$ mv /u01/app/oracle/oradata/test/users01.dbf /oracledb/test/users01.dbf[oracle@test ~]$ mv /u01/app/oracle/oradata/test/temp01.dbf /oracledb/test/temp01.dbf[oracle@test ~]$ mv /u01/app/oracle/oradata/test/redo03.log /oracledb/test/redo03.log[oracle@test ~]$ mv /u01/app/oracle/oradata/test/redo02.log /oracledb/test/redo02.log[oracle@test ~]$ mv /u01/app/oracle/oradata/test/redo01.log /oracledb/test/redo01.log***启动到mount状态***SQL&gt; startup mountORACLE instance started.Total System Global Area 1.0122E+10 bytesFixed Size                  2237088 bytesVariable Size            1610616160 bytesDatabase Buffers         8489271296 bytesRedo Buffers               19468288 bytesDatabase mounted.SQL&gt; alter database rename file &#39;/u01/app/oracle/oradata/test/system01.dbf&#39; to &#39;/oracledb/test/system01.dbf&#39;;Database altered.SQL&gt; alter database rename file &#39;/u01/app/oracle/oradata/test/sysaux01.dbf&#39; to &#39;/oracledb/test/sysaux01.dbf&#39;;Database altered.SQL&gt; alter database rename file &#39;/u01/app/oracle/oradata/test/undotbs01.dbf&#39; to &#39;/oracledb/test/undotbs01.dbf&#39;;Database altered.SQL&gt; alter database rename file &#39;/u01/app/oracle/oradata/test/users01.dbf&#39; to &#39;/oracledb/test/users01.dbf&#39;;Database altered.SQL&gt; alter database rename file &#39;/u01/app/oracle/oradata/test/temp01.dbf&#39; to &#39;/oracledb/test/temp01.dbf&#39;;Database altered.SQL&gt; alter database rename file &#39;/u01/app/oracle/oradata/test/redo01.log&#39; to &#39;/oracledb/test/redo01.log&#39;;Database altered.SQL&gt; alter database rename file &#39;/u01/app/oracle/oradata/test/redo02.log&#39; to &#39;/oracledb/test/redo02.log&#39;;Database altered.SQL&gt; alter database rename file &#39;/u01/app/oracle/oradata/test/redo03.log&#39; to &#39;/oracledb/test/redo03.log&#39;;Database altered.SQL&gt; alter database open;Database altered.***重启验证***SQL&gt; shutdown immediate;Database closed.Database dismounted.ORACLE instance shut down.SQL&gt; startupORACLE instance started.Total System Global Area 1.0122E+10 bytesFixed Size                  2237088 bytesVariable Size            1610616160 bytesDatabase Buffers         8489271296 bytesRedo Buffers               19468288 bytesDatabase mounted.Database opened.</code></pre><h2 id="alter-tablespace方法"><a href="#alter-tablespace方法" class="headerlink" title="alter tablespace方法"></a>alter tablespace方法</h2><p>该方法，不能移动system表空间，回滚段表空间和临时段表空间的数据文件。</p><pre><code class="sql">***offline system表空间时报错***SQL&gt; alter tablespace system offline;alter tablespace system offline*ERROR at line 1:ORA-01541: system tablespace cannot be brought offline; shut down if necessary报错：说明system表空间不能offline***由此说明一下system表空间的特性--不能脱机offline--不能置为只读read only--不能重命名--不能删除SQL&gt; alter tablespace sysaux offline;Tablespace altered.[oracle@test ~]$ cp /oracledb/test/sysaux01.dbf /u01/app/oracle/oradata/test/sysaux01.dbfSQL&gt; alter tablespace sysaux rename datafile &#39;/oracledb/test/sysaux01.dbf&#39; to &#39;/u01/app/oracle/oradata/test/sysaux01.dbf&#39;;Tablespace altered.SQL&gt; alter tablespace sysaux online;Tablespace altered.***offline UNDO表空间时报错***SQL&gt; alter tablespace UNDOTBS1 offline;alter tablespace UNDOTBS1 offline*ERROR at line 1:ORA-30042: Cannot offline the undo tablespace***offline TEMP表空间时报错***SQL&gt; alter tablespace TEMP offline;alter tablespace TEMP offline*ERROR at line 1:ORA-03217: invalid option for alter of TEMPORARY TABLESPACE</code></pre><h3 id="分为4个步骤"><a href="#分为4个步骤" class="headerlink" title="分为4个步骤"></a>分为4个步骤</h3><h4 id="1）把需要移动的数据文件对应的表空间offline"><a href="#1）把需要移动的数据文件对应的表空间offline" class="headerlink" title="1）把需要移动的数据文件对应的表空间offline"></a>1）把需要移动的数据文件对应的表空间offline</h4><pre><code class="sql">SQL&gt; alter tablespace USERS offline;Tablespace altered.</code></pre><h4 id="2）移动数据文件至目标位置"><a href="#2）移动数据文件至目标位置" class="headerlink" title="2）移动数据文件至目标位置"></a>2）移动数据文件至目标位置</h4><pre><code class="bash">[oracle@test ~]$ cp /oracledb/test/users01.dbf /u01/app/oracle/oradata/test/users01.dbf</code></pre><h4 id="3）修改表空间中数据文件的位置"><a href="#3）修改表空间中数据文件的位置" class="headerlink" title="3）修改表空间中数据文件的位置"></a>3）修改表空间中数据文件的位置</h4><pre><code class="sql">SQL&gt; alter tablespace USERS rename datafile &#39;/oracledb/test/users01.dbf&#39; to &#39;/u01/app/oracle/oradata/test/users01.dbf&#39;;Tablespace altered.</code></pre><h4 id="4）把表空间online"><a href="#4）把表空间online" class="headerlink" title="4）把表空间online"></a>4）把表空间online</h4><pre><code class="sql">SQL&gt; alter tablespace users online;Tablespace altered.</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>alter database方法可以移动任何表空间的数据文件，但其要求数据库必须处于mount状态，故此种方法更适合做整体数据库的迁移。</p><p>alter tablespace方法需要数据库处于open状态，表空间在offline的状态下才可更改。但其不能移动system表空间，undo表空间和temp表空间的数据文件，故此种方法更适合于做用户数据文件的迁移。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle动态注册与静态注册</title>
      <link href="/2018/01/08/Oracle/Oracle%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E4%B8%8E%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C/"/>
      <url>/2018/01/08/Oracle/Oracle%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E4%B8%8E%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle动态注册与静态注册"><a href="#Oracle动态注册与静态注册" class="headerlink" title="Oracle动态注册与静态注册"></a>Oracle动态注册与静态注册</h1><h2 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h2><p>动态注册是指在instance启动的时候，pmon进程根据init.ora中的instance_name,service_names两个参数将实例和服务动态注册到listener中。</p><p>注册到监听器中的实例名从init.ora文件中的instance_name参数取得。如果该参数没有设定值，那么它将取db_name的值。如果在RAC中配置，您必须将集群中每个实例的instance_name参数设置为一个唯一的值。</p><p>注册到监听器中的服务名从init.ora文件中的参数service_names取得。如果该参数没有设定值，数据库将拼接db_name和db_domain的值来注册自己。如果没有设定，数据库将拼接init.ora中的db_name和db_domain的值来注册自己。</p><pre><code class="bash">[oracle@oracle dbs]$ cat initorcl.oraorcl.__db_cache_size=88080384orcl.__java_pool_size=12582912orcl.__large_pool_size=4194304orcl.__oracle_base=&#39;/oracle/11g&#39;#ORACLE_BASE set from environmentorcl.__pga_aggregate_target=142606336orcl.__sga_target=268435456orcl.__shared_io_pool_size=0orcl.__shared_pool_size=155189248orcl.__streams_pool_size=0*.audit_file_dest=&#39;/oracle/11g/admin/oracle/adump&#39;*.audit_trail=&#39;db&#39;*.compatible=&#39;11.2.0.0.0&#39;*.control_files=&#39;/oracle/11g/oradata/oracle/control01.ctl&#39;,&#39;/oracle/11g/flash_recovery_area/oracle/control02.ctl&#39;*.db_block_size=8192*.db_domain=&#39;orcl&#39;*.db_name=&#39;oracle&#39;*.db_recovery_file_dest=&#39;/oracle/11g/flash_recovery_area&#39;*.db_recovery_file_dest_size=4070572032*.diagnostic_dest=&#39;/oracle/11g&#39;*.dispatchers=&#39;(PROTOCOL=TCP) (SERVICE=orclXDB)&#39;*.memory_target=408944640*.open_cursors=300*.processes=150*.remote_login_passwordfile=&#39;EXCLUSIVE&#39;*.undo_tablespace=&#39;UNDOTBS1&#39;</code></pre><pre><code class="sql">SQL&gt; show parameter db_nameNAME                      TYPE        VALUE------------------------------------ ----------- ------------------------------db_name                   string      oracleSQL&gt; show parameter db_domainNAME                      TYPE        VALUE------------------------------------ ----------- ------------------------------db_domain                 string      orcl</code></pre><p>由于init.ora中没有设置instance_name的值，那么将使用db_name来作为instance_name，我们这里就是oracle<br>由于init.ora中没有设置service_name的值，那么将拼接db_name和db_domain来作为service_name，我们这里就是orcl</p><p>可以使用以下方法查看service_name和instance_name</p><pre><code class="sql">SQL&gt; show parameter service_names;NAME                            TYPE        VALUE------------------------------------ ----------- ------------------------------service_names                   string      oracle.orclSQL&gt; show parameter instance_name;NAME                            TYPE        VALUE------------------------------------ ----------- ------------------------------instance_name                   string      orcl</code></pre><p>动态注册的结果</p><pre><code class="sql">[oracle@oracle admin]$ lsnrctl statusLSNRCTL for Linux: Version 11.2.0.1.0 - Production on 05-MAY-2018 09:27:33Copyright (c) 1991, 2009, Oracle.  All rights reserved.Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1521)))STATUS of the LISTENER------------------------Alias                     LISTENERVersion                   TNSLSNR for Linux: Version 11.2.0.1.0 - ProductionStart Date                05-MAY-2018 09:04:52Uptime                    0 days 0 hr. 22 min. 40 secTrace Level               offSecurity                  ON: Local OS AuthenticationSNMP                      OFFListener Parameter File   /oracle/11g/product/11.2.0/dbhome_1/network/admin/listener.oraListener Log File         /oracle/11g/diag/tnslsnr/oracle/listener/alert/log.xmlListening Endpoints Summary...  (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1521)))  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=10.10.10.101)(PORT=1521)))Services Summary...Service &quot;oracle.orcl&quot; has 1 instance(s).  Instance &quot;orcl&quot;, status READY, has 1 handler(s) for this service...Service &quot;orclXDB.orcl&quot; has 1 instance(s).  Instance &quot;orcl&quot;, status READY, has 1 handler(s) for this service...The command completed successfully</code></pre><p>动态注册的listener.ora配置文件如下，其实LISTENER段和SID段（下面标黄的段）都可以不写，动态注册会自动注册在1521端口，也就是说，listener.ora文件是空的，也会进行动态注册；</p><p>LISTENER段如果要写的话，只能按照下面的方式写，因为动态注册默认只注册到默认的监听器上(名称是LISTENER、端口是1521、协议是TCP)，pmon只会动态注册port等于1521的监听，否则pmon不能动态注册listener</p><pre><code class="bash"># listener.ora Network Configuration File: /oracle/11g/product/11.2.0/dbhome_1/network/admin/listener.ora# Generated by Oracle configuration tools.LISTENER =  (DESCRIPTION_LIST =    (DESCRIPTION =      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1521))    )  )ADR_BASE_LISTENER = /oracle/11gSID_LIST_LISTENER =    (SID_LIST =    (SID_DESC =        (SID_NAME = PLSExtProc)                       ##这里是用来第三方调用的，可以不写，并且有安全隐患，建议不写        (ORACLE_HOME = /oracle/11g/product/11.2.0/dbhome_1)        (PROGRAM = extproc)    )    )</code></pre><h2 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h2><p>静态注册时，listener.ora中的GLOBAL_DBNAME向外提供服务名，GLOBAL_DBNAME可以不写，那么将使用SID_NAME作为服务名，listener.ora中的SID_NAME提供注册的实例名。<br>oracle实例运行后，监听程序启动时，根据listener.ora的配置注册相应的服务。</p><p>静态注册配置文件示例</p><pre><code class="bash">[oracle@oracle admin]$ cat listener.ora# listener.ora Network Configuration File: /oracle/11g/product/11.2.0/dbhome_1/network/admin/listener.ora# Generated by Oracle configuration tools.LISTENER =  (DESCRIPTION_LIST =    (DESCRIPTION =      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.101)(PORT = 1521))    )  )ADR_BASE_LISTENER = /oracle/11gSID_LIST_LISTENER =    (SID_LIST =        (SID_DESC =            (GLOBAL_DBNAME = orcl1)           ##对外的服务名，如果这里不写的话，将使用实例名作为服务名            (ORACLE_HOME = /oracle/11g/product/11.2.0/dbhome_1)            (SID_NAME =orcl)                  ##实例名        )    )</code></pre><p>查看监听状态</p><pre><code class="bash">[oracle@oracle admin]$ lsnrctl statusLSNRCTL for Linux: Version 11.2.0.1.0 - Production on 06-MAY-2018 15:08:35Copyright (c) 1991, 2009, Oracle.  All rights reserved.Connecting to (ADDRESS=(PROTOCOL=tcp)(HOST=)(PORT=1521))STATUS of the LISTENER------------------------Alias                     LISTENERVersion                   TNSLSNR for Linux: Version 11.2.0.1.0 - ProductionStart Date                06-MAY-2018 15:07:08Uptime                    0 days 0 hr. 1 min. 26 secTrace Level               offSecurity                  ON: Local OS AuthenticationSNMP                      OFFListener Parameter File   /oracle/11g/product/11.2.0/dbhome_1/network/admin/listener.oraListener Log File         /oracle/11g/diag/tnslsnr/oracle/listener/alert/log.xmlListening Endpoints Summary...  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=oracle)(PORT=1521)))Services Summary...Service &quot;oracle.orcl&quot; has 1 instance(s).  Instance &quot;orcl&quot;, status READY, has 1 handler(s) for this service...Service &quot;orcl1&quot; has 1 instance(s).                 ##这里的就是静态监听配置，状态为unknown  Instance &quot;orcl&quot;, status UNKNOWN, has 1 handler(s) for this service...Service &quot;orclXDB.orcl&quot; has 1 instance(s).  Instance &quot;orcl&quot;, status READY, has 1 handler(s) for this service...The command completed successfully</code></pre><h2 id="查询某服务是静态注册还是动态注册"><a href="#查询某服务是静态注册还是动态注册" class="headerlink" title="查询某服务是静态注册还是动态注册"></a>查询某服务是静态注册还是动态注册</h2><p>可以使用命令lsnrctl status来查看某服务是静态注册还是动态注册。</p><p>实例状态为UNKNOWN值时表明此服务是静态注册的设置。这时监听器用来表明它不知道关于该实例的任何信息，只有当客户发出连接请求时，它才检查该实例是否存在。</p><p>动态注册的数据库通过状态信息中的状态READY或状态BLOCKED（对于一个备用数据库）来指明。不管关闭何时数据库，动态注册的数据库都会动态地从 监听器注销，而与之相关的信息将从状态列表中消失。这样，不管数据库是在运行还是已经关闭，监听器总是知道它的状态。该信息将被用于连接请求的回退（fallback）和负载平衡。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制概述</title>
      <link href="/2018/01/06/Mysql/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/01/06/Mysql/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL主从复制概述"><a href="#MySQL主从复制概述" class="headerlink" title="MySQL主从复制概述"></a>MySQL主从复制概述</h1><p>复制是mysql数据库提供的一种高可用、高性能的解决方案，一般用来建立大型的应用；<br>mysql支持单向，双向，链式级联，异步复制,半同步制(mysql5.5版本之后)，复制过程中,一台服务器当主master，而一个或者多个服务器slave；<br>复制可以是单向：M–&gt;S,也可以双向M&lt;–&gt;M<br>如设置了链式级联复制，那么从服务器本身除了充当slave之外，还是其下面从服务器的主服务器结构如是：<br>M–&gt;S1–&gt;S2–&gt;S3的复制形式</p><h2 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h2><p>单向主从复制</p><pre><code>master  --&gt;  slave</code></pre><p>一主多从模式</p><pre><code>          -------slave1          |master----|------slave2          |          -------slave3</code></pre><p>线性级联模式</p><pre><code>master --&gt; slave1 --&gt; salve2 --&gt; slave3</code></pre><p>双主模式，互为主从</p><pre><code>master &lt;--&gt; master</code></pre><p>其他，结合起来使用，如</p><pre><code>master &lt;--&gt; master   | slave</code></pre><h2 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="mysql主从复制原理"></a>mysql主从复制原理</h2><p><img src="/images/dfeea023-57b0-44bd-b250-0badaaeb0dbd-191117191651324.png" alt="dfeea023-57b0-44bd-b250-0badaaeb0dbd-191117191651324.png" title="dfeea023-57b0-44bd-b250-0badaaeb0dbd-191117191651324.png"></p><h2 id="复制分为三个步骤"><a href="#复制分为三个步骤" class="headerlink" title="复制分为三个步骤"></a>复制分为三个步骤</h2><ol><li>主服务器将数据更新记录到二进制日志中；</li><li>从服务器把主服务器的二进制日志拷贝到自己的中继日志中；</li><li>从服务器重做中继日志中的时间，把更新应用到自己的数据库上；</li></ol><p>主服务器中的线程：</p><ul><li>I&#x2F;O线程<br>  接收到从库发来的请求后，负责给从库发送二进制日志；</li></ul><p>从库中的线程：</p><ul><li>I&#x2F;O线程<br>  接收主库发来的二进制日志，并将其保存在自己的中继日志中</li></ul><p>sql线程<br>    来复制中继日志中的日志</p><p>主动复制分为异步复制、半同步复制和基于GTID的复制；</p><ul><li><p>异步复制：<br>MySQL复制默认是异步复制，Master将事件写入binlog，但并不知道Slave是否或何时已经接收且已处理。在异步复制的机制的情况下，如果Master宕机，事务在Master上已提交，但很可能这些事务没有传到任何的Slave上。假设有Master-&gt;Salve故障转移的机制，此时Slave也可能会丢失事务。</p></li><li><p>半同步复制：<br>当Slave主机连接到Master时，能够查看其是否处于半同步复制的机制，当Master上开启半同步复制的功能时，至少应该有一个Slave开启其功能。此时，一个线程在Master上提交事务将受到阻塞，直到得知一个已开启半同步复制功能的Slave已收到此事务的所有事件，或等待超时。当一个事务的事件都已写入其relay-log中且已刷新到磁盘上，Slave才会告知已收到，如果等待超时，也就是Master没被告知已收到，此时Master会自动转换为异步复制的机制。当至少一个半同步的Slave赶上了，Master与其Slave自动转换为半同步复制的机制。半同步复制的功能要在Master，Slave都开启，半同步复制才会起作用；否则，只开启一边，它依然为异步复制<br><img src="/images/757359d4-6a2c-4574-8128-ffb59a01c4b2-Image.png" alt="757359d4-6a2c-4574-8128-ffb59a01c4b2-Image.png" title="757359d4-6a2c-4574-8128-ffb59a01c4b2-Image.png"></p></li></ul><h2 id="主从复制应用场景"><a href="#主从复制应用场景" class="headerlink" title="主从复制应用场景"></a>主从复制应用场景</h2><p>主从复制有利于数据库架构的健壮性，提升访问速度，易于管理；</p><h2 id="主从服务器互为备份"><a href="#主从服务器互为备份" class="headerlink" title="主从服务器互为备份"></a>主从服务器互为备份</h2><p>M-S服务器架构的设置，可以大大的加强数据库架构的健壮性，当主库出现问题，可以切换到从库，从而不影响正常生产业务的进行；<br>主从复制读写分离分担网站压力<br>主从服务器架构通过程序(php,java）对客户端的请求实现读写分离，在从服务器上仅仅处理用户的select查询请求，降低用户查询响应时间，以及读写操作同时在主服务器带来的压力；</p><h2 id="GTID主从复制"><a href="#GTID主从复制" class="headerlink" title="GTID主从复制"></a>GTID主从复制</h2><p>一、GTID的概述：</p><ol><li>全局事物标识：global transaction identifieds。</li><li>GTID事物是全局唯一性的，且一个事务对应一个GTID。</li><li>一个GTID在一个服务器上只执行一次，避免重复执行导致数据混乱或者主从不一致。</li><li>GTID用来代替classic的复制方法，不在使用binlog+pos开启复制。而是使用master_auto_postion&#x3D;1的方式自动匹配GTID断点进行复制。</li><li>MySQL-5.6.5开始支持的，MySQL-5.6.10后开始完善。</li><li>在传统的slave端，binlog是不用开启的，但是在GTID中，slave端的binlog是必须开启的，目的是记录执行过的GTID（强制）</li></ol><p>二、GTID的组成部分：</p><ol><li>前面是server_uuid：后面是一个序列号</li><li>例如：server_uuid：sequence number</li><li>7800a22c-95ae-11e4-983d-080027de205a:10</li><li>UUID：每个mysql实例的唯一ID，由于会传递到slave，所以也可以理解为源ID。</li><li>Sequence number：在每台MySQL服务器上都是从1开始自增长的序列，一个数值对应一个事务。</li></ol><p>三、GTID比传统复制的优势：</p><ol><li>更简单的实现failover，不用以前那样在需要找log_file和log_Pos。</li><li>更简单的搭建主从复制。</li><li>比传统复制更加安全。</li><li>GTID是连续没有空洞的，因此主从库出现数据冲突时，可以用添加空事物的方式进行跳过。</li></ol><p>四、GTID的工作原理：</p><ol><li>master更新数据时，会在事务前产生GTID，一同记录到binlog日志中。</li><li>slave端的i&#x2F;o 线程将变更的binlog，写入到本地的relay log中。</li><li>sql线程从relay log中获取GTID，然后对比slave端的binlog是否有记录。</li><li>如果有记录，说明该GTID的事务已经执行，slave会忽略。</li><li>如果没有记录，slave就会从relay log中执行该GTID的事务，并记录到binlog。</li><li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有就用全部扫描。</li></ol><p>五、GTID的限制：</p><ol><li>不支持非事务引擎（从库报错，stopslave; start slave; 忽略）</li><li>不支持create table … select 语句复制（主库直接报错）</li><li>不允许在一个SQL同时更新一个事务引擎和非事务引擎的表</li><li>在一个复制组中，必须要求统一开启CTID或是关闭GTID</li><li>开启DTID需要重启（5.7中可能不需要）</li><li>开启DTID后，就不在使用原来的传统的复制方式</li><li>对于createtemporary table 和drop temporary table语句不支持</li><li>不支持sql_slave_skip_counter</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> GTID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xtrabackup备份实操</title>
      <link href="/2018/01/04/Mysql/xtrabackup%E5%A4%87%E4%BB%BD%E5%AE%9E%E6%93%8D/"/>
      <url>/2018/01/04/Mysql/xtrabackup%E5%A4%87%E4%BB%BD%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="xtrabackup备份实操"><a href="#xtrabackup备份实操" class="headerlink" title="xtrabackup备份实操"></a>xtrabackup备份实操</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>下载安装xtrabackup</p><pre><code class="bash">[root@lyucan ~]# wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.5/binary/tarball/percona-xtrabackup-2.4.5-Linux-x86_64.tar.gz[root@lyucan ~]# tar -xf percona-xtrabackup-2.4.5-Linux-x86_64.tar.gz[root@lyucan ~]# mv percona-xtrabackup-2.4.5-Linux-x86_64 percona-xtrabackup#无需编译，可直接使用</code></pre><p>创建备份用户</p><pre><code class="sql">mysql&gt; create user pxb@&#39;localhost&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt;  grant reload,process,lock tables,replication client on *.* to pxb@localhost;Query OK, 0 rows affected (0.00 sec)</code></pre><p>创建备份存放目录</p><pre><code class="bash">[root@lyucan ~]# mkdir -p /data/xtrabackup</code></pre><h2 id="全量备份与恢复"><a href="#全量备份与恢复" class="headerlink" title="全量备份与恢复"></a>全量备份与恢复</h2><h3 id="全量备份"><a href="#全量备份" class="headerlink" title="全量备份"></a>全量备份</h3><pre><code class="bash">[root@lyucan ~]# cd percona-xtrabackup/[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --no-timestamp /data/xtrabackup/all-20180410-bak......180410 23:11:42 Executing FLUSH NO_WRITE_TO_BINLOG ENGINE LOGS...xtrabackup: The latest check point (for incremental): &#39;1475999660&#39;xtrabackup: Stopping log copying thread..180410 23:11:42 &gt;&gt; log scanned up to (1475999669)180410 23:11:42 Executing UNLOCK TABLES180410 23:11:42 All tables unlocked180410 23:11:42 [00] Copying ib_buffer_pool to /data/xtrabackup/all-20180410-bak/ib_buffer_pool180410 23:11:42 [00]        ...done180410 23:11:42 Backup created in directory &#39;/data/xtrabackup/all-20180410-bak&#39;MySQL binlog position: filename &#39;mysql-bin.000004&#39;, position &#39;8623&#39;180410 23:11:42 [00] Writing backup-my.cnf180410 23:11:42 [00]        ...done180410 23:11:42 [00] Writing xtrabackup_info180410 23:11:42 [00]        ...donextrabackup: Transaction log of lsn (1475999660) to (1475999669) was copied.180410 23:11:42 completed OK!</code></pre><h3 id="查看备份文件"><a href="#查看备份文件" class="headerlink" title="查看备份文件"></a>查看备份文件</h3><pre><code class="bash">[root@lyucan all-20180410-bak]# cd /data/xtrabackup/all-20180410-bak/[root@lyucan all-20180410-bak]# lltotal 77876-rw-r-----. 1 root root      425 Apr 10 23:11 backup-my.cnfdrwxr-x---. 2 root root       49 Apr 10 23:11 dbtest-rw-r-----. 1 root root      503 Apr 10 23:11 ib_buffer_pool-rw-r-----. 1 root root 79691776 Apr 10 23:11 ibdata1drwxr-x---. 2 root root     4096 Apr 10 23:11 mysqldrwxr-x---. 2 root root     8192 Apr 10 23:11 performance_schemadrwxr-x---. 2 root root     8192 Apr 10 23:11 sysdrwxr-x---. 2 root root       45 Apr 10 23:11 test-rw-r-----. 1 root root       22 Apr 10 23:11 xtrabackup_binlog_info-rw-r-----. 1 root root      119 Apr 10 23:11 xtrabackup_checkpoints-rw-r-----. 1 root root      560 Apr 10 23:11 xtrabackup_info-rw-r-----. 1 root root     2560 Apr 10 23:11 xtrabackup_logfile</code></pre><p><code>xtrabackup_binlog_info</code> 文件记录了备份完成时<code>binlog</code>的<code>position</code>；</p><pre><code class="bash">[root@lyucan all-20180410-bak]# cat xtrabackup_binlog_infomysql-bin.000004     8623</code></pre><p><code>xtrabackup_checkpoints</code> 记录了备份的起始<code>lsn</code>号和最后的<code>lsn</code>号</p><pre><code class="bash">[root@lyucan all-20180410-bak]# cat xtrabackup_checkpointsbackup_type = full-backuped             ##full-backuped表示全备from_lsn = 0                            ##全备lsn号一定是从0开始to_lsn = 1475999660last_lsn = 1475999669compact = 0recover_binlog_info = 0</code></pre><p><code>xtrabackup_info</code> 记录了备份的信息，时间，命令，版本等；</p><pre><code class="bash">[root@lyucan all-20180410-bak]# cat xtrabackup_infouuid = 79f03ea9-3cd1-11e8-bf94-da8255dea6c5name =tool_name = innobackupextool_command = --defaults-file=/etc/my.cnf --user=pxb --password=... --socket=/tmp/mysql.sock --no-timestamp /data/xtrabackup/all-20180410-baktool_version = 2.4.5ibbackup_version = 2.4.5server_version = 5.7.21-logstart_time = 2018-04-10 23:11:39end_time = 2018-04-10 23:11:42lock_time = 0binlog_pos = filename &#39;mysql-bin.000004&#39;, position &#39;8623&#39;innodb_from_lsn = 0innodb_to_lsn = 1475999660partial = Nincremental = Nformat = filecompact = Ncompressed = Nencrypted = N</code></pre><h3 id="全量恢复"><a href="#全量恢复" class="headerlink" title="全量恢复"></a>全量恢复</h3><pre><code class="bash">[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log  /data/xtrabackup/all-20180410-bak......InnoDB: Starting crash recovery.InnoDB: xtrabackup: Last MySQL binlog file position 8129, file name mysql-bin.000004InnoDB: Removed temporary tablespace data file: &quot;ibtmp1&quot;InnoDB: Creating shared tablespace for temporary tablesInnoDB: Setting file &#39;./ibtmp1&#39; size to 12 MB. Physically writing the file full; Please wait ...InnoDB: File &#39;./ibtmp1&#39; size is now 12 MB.InnoDB: 96 redo rollback segment(s) found. 1 redo rollback segment(s) are active.InnoDB: 32 non-redo rollback segment(s) are active.InnoDB: 5.7.13 started; log sequence number 1475999765xtrabackup: starting shutdown with innodb_fast_shutdown = 1InnoDB: FTS optimize thread exiting.InnoDB: Starting shutdown...InnoDB: Shutdown completed; log sequence number 1475999793180410 23:36:27 completed OK!</code></pre><p>这一步的<code>--apply-log</code>的作用是将备份的事务进行前滚（redo）或回滚（undo），将已提交的前滚，未提交的回滚，达到数据的一致性；这个一致性的时间点就是备份过程中FTWRL锁表的时间点。</p><h3 id="应用备份库"><a href="#应用备份库" class="headerlink" title="应用备份库"></a>应用备份库</h3><pre><code class="bash">#停掉当前库[root@lyucan xtrabackup]# service mysqld stopShutting down MySQL.... SUCCESS!#将当前库重命名[root@lyucan data]# mv /data/mysql/  /data/mysql_bak_20180410#将备份库重命名为mysql[root@lyucan data]# mv /data/xtrabackup/all-20180410-bak/  /data/mysql#修改权限[root@lyucan data]# chown mysql:mysql -R /data/mysql/#启动数据库[root@lyucan data]# service mysqld startStarting MySQL.. SUCCESS!</code></pre><p><strong>要完全恢复数据库，还要结合二进制日志进行恢复；</strong></p><h2 id="增量备份与恢复"><a href="#增量备份与恢复" class="headerlink" title="增量备份与恢复"></a>增量备份与恢复</h2><h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><pre><code class="bash">#首先进行一次全备[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --no-timestamp /data/xtrabackup/all-20180410-bak#进行一次增备，基于第一次的全备[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --no-timestamp --user=pxb --password=echo123. --socket=/tmp/mysql.sock --incremental --incremental-basedir=/data/xtrabackup/all-20180410-bak  /data/xtrabackup/incremental-20180411-bak--incremental：表示是增备--incremental-basedir：基于哪个备份进行增备#再进行一次增备，基于第二次的增备[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --no-timestamp --user=pxb --password=echo123. --socket=/tmp/mysql.sock --incremental --incremental-basedir=/data/xtrabackup/incremental-20180411-bak  /data/xtrabackup/incremental-20180412-bak</code></pre><h3 id="查看三次的备份文件"><a href="#查看三次的备份文件" class="headerlink" title="查看三次的备份文件"></a>查看三次的备份文件</h3><pre><code class="bash"># checkpoint[root@lyucan xtrabackup]# cat /data/xtrabackup/all-20180410-bak/xtrabackup_checkpointsbackup_type = full-backuped             ##全备from_lsn = 0to_lsn = 1476007364last_lsn = 1476007373compact = 0recover_binlog_info = 0[root@lyucan xtrabackup]# cat /data/xtrabackup/incremental-20180411-bak/xtrabackup_checkpointsbackup_type = incremental               ##增备from_lsn = 1476007364to_lsn = 1476011232last_lsn = 1476011241compact = 0recover_binlog_info = 0[root@lyucan xtrabackup]# cat /data/xtrabackup/incremental-20180412-bak/xtrabackup_checkpointsbackup_type = incremental              ##增备from_lsn = 1476011232to_lsn = 1476015084last_lsn = 1476015093compact = 0recover_binlog_info = 0##可以看到lsn号都是连续的# binlog_info[root@lyucan xtrabackup]# cat /data/xtrabackup/all-20180410-bak/xtrabackup_binlog_infomysql-bin.000005     479[root@lyucan xtrabackup]# cat /data/xtrabackup/incremental-20180411-bak/xtrabackup_binlog_infomysql-bin.000005     645[root@lyucan xtrabackup]# cat /data/xtrabackup/incremental-20180412-bak/xtrabackup_binlog_infomysql-bin.000005     811</code></pre><h3 id="增备恢复"><a href="#增备恢复" class="headerlink" title="增备恢复"></a>增备恢复</h3><pre><code class="bash">##恢复第一个全备，加上--redo-only，表示只进行前滚[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log --redo-only  /data/xtrabackup/all-20180410-bak##将20180411增量备份加到全量备份上，使用--incremental-dir= 来指定增量备份[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log --redo-only  /data/xtrabackup/all-20180410-bak  --incremental-dir=/data/xtrabackup/incremental-20180411-bak##将20180412增量备份加到全量备份上，使用--incremental-dir= 来指定增量备份[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log --redo-only  /data/xtrabackup/all-20180410-bak  --incremental-dir=/data/xtrabackup/incremental-20180412-bak##将所有增量备份加到全备上后，再进行全备的恢复，回归到全量备份，此时没有--redo-only；[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log  /data/xtrabackup/all-20180410-bak</code></pre><h3 id="应用备份库-1"><a href="#应用备份库-1" class="headerlink" title="应用备份库"></a>应用备份库</h3><pre><code class="bash">#停掉当前库[root@lyucan xtrabackup]# service mysqld stopShutting down MySQL.... SUCCESS!#将当前库重命名[root@lyucan data]# mv /data/mysql/  /data/mysql_bak_20180410#将备份库重命名为mysql[root@lyucan data]# mv /data/xtrabackup/all-20180410-bak/  /data/mysql#修改权限[root@lyucan data]# chown mysql:mysql -R /data/mysql/#启动数据库[root@lyucan data]# service mysqld startStarting MySQL.. SUCCESS!</code></pre><p><strong>还是那句话，如果要进行完全数据恢复，还需要结合二进制日志进行数据恢复；<br>很简单，根据备份里面记录的xtrabackup_binlog_info，进行原库二进制日志的恢复；</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类对象特殊方法__new__()</title>
      <link href="/2018/01/04/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__new__()/"/>
      <url>/2018/01/04/Python/Python-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95__new__()/</url>
      
        <content type="html"><![CDATA[<h1 id="类对象特殊方法-new"><a href="#类对象特殊方法-new" class="headerlink" title="类对象特殊方法__new__()"></a>类对象特殊方法<code>__new__()</code></h1><p>当使用“类名([实参])”创建实例对象时，python解释器的主要处理过程包括两大步：<br>1、调用特殊方法<code>__new__()</code>创建实例对象</p><p>首先会查找该类对象是否实现了特殊方法<code>__new__()</code>，如果没有实现，则去其父类中一次查找，直到类对象object。<br>特殊方法<code>__new__()</code>会返回创建的实例对象。</p><p>2、调用特殊方法<code>__init__()</code>对创建的实例对象进行初始化<br><code>__new__()</code>返回的实例对象会作为实参被自动传递给<code>__init__()</code>的第一个形参self。</p><p><img src="/images/502585d7-962c-497d-a955-5361ea4a7a04-Image.png" alt="502585d7-962c-497d-a955-5361ea4a7a04-Image.png" title="502585d7-962c-497d-a955-5361ea4a7a04-Image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-元组</title>
      <link href="/2018/01/03/Python/Python-%E5%85%83%E7%BB%84/"/>
      <url>/2018/01/03/Python/Python-%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组和列表的主要区别：</p><ol><li>元组用小括号表示，列表用中括号表示</li><li>元组是不可变类型，列表是可变类型</li><li>元组里面的元素是不能重复的</li></ol><p>另一种有序列表叫元组：<code>tuple</code>。<code>tuple</code>和<code>list</code>非常类似，但是<code>tuple</code>一旦初始化就不能修改，比如同样是列出同学的名字：</p><pre><code class="python">&gt;&gt;&gt; classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)# 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。# 其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</code></pre><p>不可变的<code>tuple</code>有什么意义？因为<code>tuple</code>不可变，所以代码更安全。如果可能，能用<code>tuple</code>代替<code>list</code>就尽量用<code>tuple</code>。<br><code>tuple</code>的陷阱：当你定义一个<code>tuple</code>时，在定义的时候，<code>tuple</code>的元素就必须被确定下来，比如：</p><pre><code class="python">&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2)</code></pre><p>如果要定义一个空的tuple，可以写成()：</p><pre><code class="python">&gt;&gt;&gt; t = ()&gt;&gt;&gt; t()</code></pre><p>但是，要定义一个只有1个元素的tuple，如果你这么定义：</p><pre><code class="python">&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1</code></pre><p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p><p>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</p><pre><code class="python">&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,)</code></pre><p>Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH互信</title>
      <link href="/2018/01/02/%E8%BF%90%E7%BB%B4/SSH%E4%BA%92%E4%BF%A1/"/>
      <url>/2018/01/02/%E8%BF%90%E7%BB%B4/SSH%E4%BA%92%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH互信"><a href="#SSH互信" class="headerlink" title="SSH互信"></a>SSH互信</h1><p>在母机上</p><pre><code class="bash">[root@lyucan ~]# ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsaGenerating public/private rsa key pair./root/.ssh/id_rsa already exists.Overwrite (y/n)? yYour identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:f1:02:d9:85:de:39:ab:19:45:5c:b7:f2:92:0e:6d:4e root@lyucan.comThe key&#39;s randomart image is:+--[ RSA 2048]----+|         o... .  ||       o..o  . . ||      o.oo .. .  ||       ..o=. +   ||        S.ooE .  ||        ...* .   ||         +  o    ||        o        ||                 |+-----------------+</code></pre><p>这样就不需要一步步敲了，这里-P指的是私钥的密码，不同于登录密码，这里空着。</p><p>然后将~&#x2F;.ssh&#x2F;id_rsa.pub复制到目标服务器上去</p><pre><code class="bash">[root@noblank ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@103.214.143.94root@103.214.143.94&#39;s password: #输入目标服务器密码Now try logging into the machine, with &quot;ssh &#39;root@103.214.143.94&#39;&quot;, and check in:.ssh/authorized_keysto make sure we haven&#39;t added extra keys that you weren&#39;t expecting.</code></pre><p>然后再登录就不需要输入密码了</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在vue中替换使用默认的svg loader</title>
      <link href="/2017/07/13/Vue/%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E6%9B%BF%E6%8D%A2%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84svg-loader/"/>
      <url>/2017/07/13/Vue/%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E6%9B%BF%E6%8D%A2%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84svg-loader/</url>
      
        <content type="html"><![CDATA[<h1 id="1、要知道如何修改，首先要知道如何查看"><a href="#1、要知道如何修改，首先要知道如何查看" class="headerlink" title="1、要知道如何修改，首先要知道如何查看"></a>1、要知道如何修改，首先要知道如何查看</h1><p><code>vue-cli3</code> 默认是不暴露webpack的配置在项目目录中的，在项目根目录使用<code>vue inspect</code>可以查看所有的webpack配置（如果实在是想看，可以使用<code>vue eject</code> 把所以配置暴露出来，但是该操作不可逆，拿出来了就藏不回去了，慎重使用）</p><p>由于<code>vue inspect</code>命令的输出太太太长了，这里就不贴出来了，但是vue想到了这一点，我们可以指定命令选项来查看我们需要的信息</p><p><code>vue inspect --rule svg </code></p><pre><code class="js">/* config.module.rule(&#39;svg&#39;) */&#123;  test: /\.(svg)(\?.*)?$/,  use: [    /* config.module.rule(&#39;svg&#39;).use(&#39;file-loader&#39;) */    &#123;      loader: &#39;D:\\Microsoft VS Code\\Repositories\\myrepo\\z-knowledge\\Vue\\project\\study\\node_modules\\file-loader\\dist\\cjs.js&#39;,      options: &#123;        name: &#39;img/[name].[hash:8].[ext]&#39;      &#125;    &#125;  ]&#125;</code></pre><p>我们想要把默认的处理svg的file-loader修改成为<code>svg-sprite-loader</code></p><h1 id="2、安装-svg-sprite-loader"><a href="#2、安装-svg-sprite-loader" class="headerlink" title="2、安装 svg-sprite-loader"></a>2、安装 svg-sprite-loader</h1><pre><code class="js">npm i svg-sprite-loader -D </code></pre><h1 id="3、修改vue-config-js"><a href="#3、修改vue-config-js" class="headerlink" title="3、修改vue.config.js"></a>3、修改vue.config.js</h1><pre><code class="js">const path = require(&#39;path&#39;) // 下面的处理目录只能使用绝对路径，因此使用nodejs的path方法module.exports = &#123;    chainWebpack: config =&gt; &#123;        config.module.rule(&#39;svg&#39;)            .exclude.add(path.resolve(__dirname, &#39;./src/icons/svgs&#39;)); // svg规则不再处理&#39;./src/icons/svgs&#39;目录下的文件        config.module.rule(&#39;icons&#39;) // 新增一个icons规则，处理.svg后缀的文件            .test(/\.svg$/)            .include.add(path.resolve(__dirname, &#39;./src/icons/svgs&#39;))                .end()            .use(&#39;svg-sprite-loader&#39;)                .loader(&#39;svg-sprite-loader&#39;)                .options(&#123; symbolId: &#39;icon-[name]&#39; &#125;) // 定义使用svg的方式                .end()    &#125;&#125;</code></pre><p>修改后会新增一个规则<code>icons</code>,该配置如下</p><p><code>vue inspect --rule icons</code></p><pre><code class="js">/* config.module.rule(&#39;icons&#39;) */&#123;  test: /\.svg$/,  include: [    &#39;./src/icons/svgs&#39;  ],  use: [    /* config.module.rule(&#39;icons&#39;).use(&#39;svg-sprite-loader&#39;) */    &#123;      loader: &#39;svg-sprite-loader&#39;,      options: &#123;        symbolId: &#39;icon-[name]&#39;      &#125;    &#125;  ]&#125;</code></pre><h1 id="4、使用svg图标"><a href="#4、使用svg图标" class="headerlink" title="4、使用svg图标"></a>4、使用svg图标</h1><h2 id="4-1-在阿里图标库下载svg格式的图标，保存在src-icons目录下"><a href="#4-1-在阿里图标库下载svg格式的图标，保存在src-icons目录下" class="headerlink" title="4.1 在阿里图标库下载svg格式的图标，保存在src/icons目录下"></a>4.1 在阿里图标库下载svg格式的图标，保存在<code>src/icons</code>目录下</h2><pre><code>|--icons   |--svgs      wx.svg      qq.xvg</code></pre><h2 id="4-2-然后在组件-页面中进行导入"><a href="#4-2-然后在组件-页面中进行导入" class="headerlink" title="4.2 然后在组件&#x2F;页面中进行导入"></a>4.2 然后在组件&#x2F;页面中进行导入</h2><pre><code class="js">import &#39;@/icons/svgs/wx.svg&#39;import &#39;@/icons/svgs/qq.svg&#39;</code></pre><h2 id="4-3-在标签中进行使用"><a href="#4-3-在标签中进行使用" class="headerlink" title="4.3 在标签中进行使用"></a>4.3 在标签中进行使用</h2><pre><code class="html">&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-wx&quot;&gt;&lt;/use&gt;&lt;/svg&gt;&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-qq&quot;&gt;&lt;/use&gt;&lt;/svg&gt;</code></pre><h1 id="5、每次都按需导入十分麻烦，可以一次性导入所有svg图标"><a href="#5、每次都按需导入十分麻烦，可以一次性导入所有svg图标" class="headerlink" title="5、每次都按需导入十分麻烦，可以一次性导入所有svg图标"></a>5、每次都按需导入十分麻烦，可以一次性导入所有svg图标</h1><p>新建文件<code>src/icons/index.js</code>，添加以下代码</p><pre><code class="js">const requireAll = requireContext =&gt; requireContext.keys().map(requireContext);const req = require.context(&quot;./svgs&quot;, false, /.svg$/);requireAll(req);</code></pre><p>在<code>main.js</code>中引入该<code>index.js</code>文件</p><pre><code class="js">import &#39;@/icons/index&#39;</code></pre><p>此时就不用了每次使用都单独导入了，因此上面4.2步骤中的导入可以不写了</p><h1 id="6、封装svg组件"><a href="#6、封装svg组件" class="headerlink" title="6、封装svg组件"></a>6、封装svg组件</h1><blockquote><p><code>&#39;@/components/icons/SvgIcon&#39;</code></p></blockquote><pre><code class="js">&lt;template&gt;  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;    &lt;use :xlink:href=&quot;iconName&quot; /&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;svg-icon&#39;,    props: &#123;        iconClass: &#123;            type: String,            required: true        &#125;,        className: &#123;            type: String,            default: &#39;&#39;        &#125;    &#125;,    computed: &#123;        iconName() &#123;            return `#icon-$&#123;this.iconClass&#125;`        &#125;,        svgClass() &#123;            if (this.className) &#123;                return &#39;svg-icon&#39; + this.className            &#125; else &#123;                return &#39;svg-icon&#39;            &#125;        &#125;    &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123;    width: 1em;    height: 1em;    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;&#125;&lt;/style&gt;</code></pre><p>使用</p><pre><code class="html">&lt;SvgIcon icon-class=&quot;wx&quot;&gt;&lt;/SvgIcon&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端几种常见的布局方式</title>
      <link href="/2017/07/04/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2017/07/04/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h1><p>两栏布局是前端常见的几种布局方式之一，一般是左侧固定宽度，右侧自适应，或者右侧固定宽度，左侧自适应，利用定位进行布局</p><!-- tab Html --><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--自适应两栏布局        需要将上面的块设置成定位，让下面的块挤上去    --&gt;    &lt;div class=&quot;one-left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;one-right&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two-left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two-right&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><!-- endtab --><!-- tab CSS --><pre><code class="css">* &#123;    margin: 0;    padding: 0;&#125;.one-left &#123;    width: 200px;    height: 200px;    background-color: red;    position: absolute;    right: 0;    opacity: 0.1;&#125;.one-right &#123;    height: 200px;    background-color: green;    margin-right: 300px;&#125;/*---------------------------------------*/.two-left &#123;    width: 200px;    height: 200px;    background-color: palevioletred;    position: absolute;&#125;.two-right &#123;    height: 200px;    background-color: #3665ee;    margin-left: 300px;&#125;</code></pre><!-- endtab --><p>效果图：<br><img src="/images/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80.gif"></p><hr><h1 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h1><p>两侧宽度固定，中间宽度自适应的三栏布局</p><p>中间部分在DOM结构上优先，以便优先渲染，只需要使用一个额外的div标签</p><p>实现步骤：</p><ul><li>写下如下HTML代码</li><li>使三个区域都处于做悬浮状态，并使main的宽度成父容器的<code>100%</code></li><li>为两侧侧边栏添加<strong>负margin</strong>，用来调整位置，其中摆在左边的left的<code>margin-left</code>为<code>-100%</code>，</li><li>而右边<code>right</code>的<code>margin-right</code>为负的其自身宽度。（利用了浮动元素的<strong>负margin</strong>到一定值后会使其自身往上一行移动的原理）</li><li>为<code>class=&#39;container&#39;</code>的主容器设置<strong>左右padding</strong>值，使其为以后的侧边栏空出位置，padding的值为侧边栏的宽度</li><li>对left和right添加<code>position: relative</code>，然后对他们进行定位移动到两侧，圣杯布局就完成了</li></ul><!-- tab Html --><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;    &lt;meta name=&quot;description&quot; content=&quot;&quot;/&gt;    &lt;title&gt;圣杯布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;main&quot;&gt;中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中&lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><!-- endtab --><!-- tab CSS --><pre><code class="css">* &#123;    margin: 0;    padding: 0;&#125;.container &#123;    min-width: 600px;    height: 500px;    background-color: #f5f5f5;    padding: 0 200px;&#125;.left, .right &#123;    width: 200px;    height: 500px;    background-color: red;    float: left;&#125;.left &#123;    margin-left: -100%;    position: relative;    left: -200px;&#125;.right &#123;    margin-left: -200px;    position: relative;    right: -200px;&#125;.main &#123;    width: 100%;    height: 500px;    background-color: green;    float: left;&#125;</code></pre><!-- endtab --><p><img src="/images/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.gif"></p><hr><h1 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h1><p>双飞翼布局最初是淘宝试用的一种布局方式，不同于圣杯布局的是， 双飞翼布局多嵌套了一层div</p><!-- tab Html --><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;    &lt;meta name=&quot;description&quot; content=&quot;&quot;/&gt;    &lt;title&gt;双飞翼布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div class=&quot;main_content&quot;&gt;中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><!-- endtab --><!-- tab CSS --><pre><code class="css">* &#123;    margin: 0;    padding: 0;&#125;.container &#123;    min-width: 600px;    background-color: #f5f5f5;    height: 500px;&#125;.left, .right &#123;    width: 200px;    height: 500px;    background-color: red;    float: left;&#125;.main &#123;    width: 100%;    height: 500px;    background-color: blue;    float: left;&#125;.left &#123;    margin-left: -100%;&#125;.right &#123;    margin-left: -200px;&#125;.main_content &#123;    margin: 0 200px;&#125;</code></pre><!-- endtab --><p><img src="/images/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.gif"></p><hr><p>以上实现方式都是通过浮动和定位来做的，我们也可以用html5的flex布局进行布局，相比于传统方式，flex布局实现方式更加简单。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
