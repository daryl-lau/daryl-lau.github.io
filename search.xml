<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redux 异步操作redux-thunk和redux-saga</title>
      <link href="/2021/08/14/Redux-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9Credux-thunk%E5%92%8Credux-saga/"/>
      <url>/2021/08/14/Redux-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9Credux-thunk%E5%92%8Credux-saga/</url>
      
        <content type="html"><![CDATA[<p>在<code>Redux</code>中的<code>action</code>仅支持原始对象（<code>plain object</code>），处理有副作用的<code>action</code>，需要使用中间件。中间件可以在发出<code>action</code>，到<code>reducer</code>函数接受<code>action</code>之间，执行具有副作用的操作，例如网络请求，读取浏览器缓存等。</p><p>下面的示例基于<a href="https://www.baihuzi.com/2021/08/13/React-react-redux%E7%9A%84%E4%BD%BF%E7%94%A8/#%E7%94%A8%E4%BE%8B%E6%BA%90%E7%A0%81">【react-redux的使用】学习源码</a></p><h1 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h1><p><code>redux-thunk</code>是<code>redux</code>的作者提供的一个处理副作用的方案，我们都知道，<code>dispatch</code>必须接收一个原始对象，在里面无法实现副作用逻辑，但是我们可以使用<code>action creator</code>函数，在内部处理副作用，然后返回一个<code>action</code>原始对象。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>yarn add redux-thunk</code></pre><h2 id="应用redux-thunk中间件"><a href="#应用redux-thunk中间件" class="headerlink" title="应用redux-thunk中间件"></a>应用redux-thunk中间件</h2><pre><code class="javascript">import thunk from &#39;redux-thunk&#39;// ...let store = createStore(reducers, applyMiddleware(thunk))</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>此时我们不能直接派发<code>action</code>，而是先要创建一个函数，例如下面的<code>changeName</code>，函数签名<code>dispatch</code>和<code>getState</code>，都是<code>store</code>上的两个方法，然后可以在里面进行异步请求操作</p><pre><code class="javascript">const ConnectedUser = connect(mapStateToProps, &#123;    ageIncrement(payload) &#123;        return &#123;type: &#39;increment&#39;, payload&#125;    &#125;,    ageDecrement(payload) &#123;        return &#123;type: &#39;decrement&#39;, payload&#125;    &#125;,    changeName(payload) &#123;        return (dispatch, getState) =&gt; &#123;           fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;)            .then(res =&gt; res.json())            .then(data =&gt; dispatch(&#123;type: &#39;changeName&#39;, payload&#125; ))        &#125;    &#125;&#125;)(User)</code></pre><h1 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h1><p><code>redux-saga</code>是<code>redux</code>处理副作用的另一种方式，相较于<code>redux-thunk</code>，能更好的的组织代码，功能也更加丰富</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><pre><code>yarn add redux-saga</code></pre><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h2 id="应用中间件"><a href="#应用中间件" class="headerlink" title="应用中间件"></a>应用中间件</h2><pre><code class="javascript">import createSagaMidware from &#39;redux-saga&#39;const saga = createSagaMidware()const store = createStore(reducers, applyMiddleware(saga))</code></pre><p><code>redux-saga</code>采用的方案更接近于<code>redux</code>的全局思想，使用方式和<code>thunk</code>有很大不同，<br><code>saga</code>需要一个全局监听器（<code>watcher saga</code>），用于监听组件发出的<code>action</code>，将监听到的<code>action</code>转发给对应的接收器（<code>worker saga</code>），再由接收器执行具体任务，副作用执行完后，再发出另一个<code>action</code>交由<code>reducer</code>修改<code>state</code>，所以这里必须注意：**<code>watcher saga</code>监听的<code>action</code>和对应<code>worker saga</code>中发出的<code>action</code>不能同名**，否则造成死循环</p><h2 id="watcher-saga"><a href="#watcher-saga" class="headerlink" title="watcher saga"></a>watcher saga</h2><p>我们先定义一个<code>watcher saga</code></p><pre><code class="javascript">import &#123; takeEvery &#125; from &#39;redux-saga/effects&#39;// watcher sagafunction* watchIncrementSaga() &#123;  yield takeEvery(&#39;increment&#39;, workIncrementSaga)&#125;</code></pre><p><code>watcher saga</code> 很简单，就是监听用户派发的<code>action</code>（只用于监听，具体操作交由<code>worker saga</code>），这里使用<code>takeEvery</code>辅助方法，表示每次派发都会被监听到，第一个参数就是用户派发<code>action</code>的类型，第二个参数就是指定交由哪个<code>worker saga</code>进行处理</p><h2 id="worker-saga"><a href="#worker-saga" class="headerlink" title="worker saga"></a>worker saga</h2><p>因此我们需要再定义一个名为<code>workIncrementSaga</code>的<code>worker saga</code>，我们在里面执行副作用操作，然后使用<code>yield put(...)</code>派发<code>action</code>，让<code>reducer</code>去更新<code>state</code></p><pre><code class="javascript">import &#123; call, put, takeEvery &#125; from &#39;redux-saga/effects&#39;// watcher sagafunction* watchIncrementSaga() &#123;  yield takeEvery(&#39;increment&#39;, workIncrementSaga)&#125;// worker sagafunction* workIncrementSaga() &#123;  function f () &#123;    return fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;).then(res =&gt; res.json()).then(data =&gt; data)  &#125;  const res = yield call(f)  console.log(res)  yield put(&#123;type: &#39;INCREMENT&#39;&#125;)&#125;</code></pre><p>基本使用就是这样。</p><p>上面的代码可能有些难以理解，为什么要用<code>generator</code>函数，<code>call</code>，<code>put</code>又是什么方法，下面我们来看看<code>redux-saga</code>里面一些非常重要的概念和API</p><p>在 <code>redux-saga</code> 的世界里，<code>Sagas</code> 都用 <code>Generator</code> 函数实现。我们从 <code>Generator</code> 里 <code>yield</code> 纯 <code>JavaScript</code> 对象以表达 <code>Saga</code> 逻辑。 我们称呼那些对象为 <code>Effect</code>。<code>Effect</code> 是一个简单的对象，这个对象包含了一些给 <code>middleware</code> 解释执行的信息。 你可以把 <code>Effect</code> 看作是发送给 <code>middleware</code> 的指令以执行某些操作（调用某些异步函数，发起一个 <code>action</code> 到 <code>store</code>，等等）。你可以使用 <code>redux-saga/effects</code> 包里提供的函数来创建 <code>Effect</code>。</p><h2 id="辅助方法（监听类型）"><a href="#辅助方法（监听类型）" class="headerlink" title="辅助方法（监听类型）"></a>辅助方法（监听类型）</h2><ul><li><code>takeEvery</code>：     监听类型，同一时间允许多个处理函数同时进行，并发处理</li><li><code>takeLatest</code>：    监听类型，同一时间只能有一个处理函数在执行，后面开启的任务会执行，前面的会取消执行</li><li><code>takeLeading</code>：   如果当前有一个处理函数正在执行，那么后面开启的任务都不会被执行，直到该任务执行完毕</li></ul><h2 id="effect创建器"><a href="#effect创建器" class="headerlink" title="effect创建器"></a>effect创建器</h2><ul><li><p><code>take(pattern)</code></p><p>在<code>watcher saga</code>中使用，用来拦截<code>action</code>，当<code>action</code>匹配到这个<code>take</code>的时候，在发起与 <code>pattern</code> 匹配的 <code>action</code> <code>之前，Generator</code> 将暂停。实际上就是上面辅助方法的底层实现，例如：</p><pre><code class="javascript">function* watchDecrementSaga() &#123;  while(true) &#123;    yield take(&#39;decrement&#39;)    const state = yield select()    console.log(state, &#39;state&#39;)    yield put(&#123;type: &#39;DECREMENT&#39;&#125;)  &#125;&#125;</code></pre><p>此时用户派发一个<code>&#123;type: &#39;decrement&#39;, payload&#125;</code>的<code>action</code>，就会被上面的<code>take</code>拦截到，执行相应的代码，然后再去派发一个<code>action</code>，通知<code>reducer</code>修改<code>state</code>，如果没有<code>put</code>，则不会通知<code>reducer</code>修改<code>state</code>，注意需要使用<code>while true</code>一直监听，否则只有第一次派发<code>decrement</code>的action会被拦截，后面的都不会被拦截到。</p></li></ul><p> <code> pattern</code>就是匹配规则，基本有以下几种形式</p><ol><li>如果以空参数或 <code>*</code> 调用 <code>take</code>，那么将匹配所有发起的 <code>action</code>。（例如，<code>take()</code> 将匹配所有 <code>action</code>）</li><li>如果它是一个函数，那么将匹配 <code>pattern(action)</code> 为 <code>true</code> 的 <code>action</code>。（例如，<code>take(action =&gt; action.entities)</code> 将匹配哪些 <code>entities</code> 字段为真的 <code>action</code>）</li><li>如果它是一个字符串，那么将匹配 <code>action.type === pattern</code> 的 <code>action</code>。（例如，<code>take(INCREMENT_ASYNC)</code>）</li><li>如果它是一个数组，那么数组中的每一项都适用于上述规则 —— 因此它是支持字符串与函数混用的。不过，最常见的用例还属纯字符串数组，其结果是用 <code>action.type</code> 与数组中的每一项相对比。（例如，<code>take([INCREMENT, DECREMENT]</code>) 将匹配 <code>INCREMENT</code> 或 <code>DECREMENT</code> 类型的 <code>action</code>）</li></ol><p>  有了这个规则，我们就可以进行更细粒度的控制拦截到的<code>action</code>，再去做相应的修改。</p><ul><li><p><code>call(fn, ...args)</code></p><p>创建一个 <code>Effect</code> 描述信息，用来命令 <code>middleware</code> 以参数 <code>args</code> 调用函数 <code>fn</code> 。</p><ol><li><code>fn</code>: <code>Function</code> - 一个 <code>Generator</code> 函数, 也可以是一个返回 <code>Promise</code> 或任意其它值的普通函数。</li><li><code>args</code>: <code>Array&lt;any&gt;</code> - 传递给 fn 的参数数组。</li></ol></li><li><p><code>put(action)</code></p><p>创建一个 <code>Effect</code> 描述信息，用来命令 <code>middleware</code> 向 <code>Store</code> 发起一个 <code>action</code>。 这个 <code>effect</code> 是非阻塞型的，并且所有向下游抛出的错误（例如在 <code>reducer</code> 中），都不会冒泡回到 <code>saga</code> 当中。</p></li><li><p><code>fork(fn, ...args)</code></p><p><code>fork</code>和<code>call</code>用法一样，唯一的区别就是<code>fork</code>是非阻塞的，而<code>call</code>是阻塞的</p><p>创建一个 <code>Effect</code> 描述信息，用来命令 <code>middleware</code> 以 非阻塞调用 的形式执行 <code>fn</code>，返回一个 <code>Task</code> 对象。<code>Task</code>对象上有一些实用的方法及属性，比如取消某个网络请求什么的。</p><ol><li><code>fn</code>: <code>Function</code> - 一个 Generator 函数，或返回 Promise 的普通函数</li><li><code>args</code>: <code>Array&lt;any&gt;</code> - 传递给 fn 的参数数组。</li></ol></li><li><p><code>select(selector, ...args)</code></p><p>创建一个 <code>Effect</code>，用来命令 <code>middleware</code> 在当前 <code>Store</code> 的 <code>state</code> 上调用指定的选择器（即返回 <code>selector(getState(), ...args)</code> 的结果）。</p><p>获取当前<code>state</code>中的部分数据，第一个参数是一个函数，函数的参数是<code>state</code>，即当前状态，后面的参数依次传递给第一个函数，作为该函数的参数</p><pre><code class="javascript">function selector (state, index) &#123;  return state[index]&#125;let state2 = yield select(selector, 0)console.log(state2, &#39;select2&#39;);</code></pre><p><code>select</code> 也可以不传任何参数，返回值就直接是当前的所有状态</p></li><li><p><code>cancel(task)</code></p><p>创建一个 <code>Effect</code> 描述信息，用来命令 <code>middleware</code> 取消之前的一个分叉任务。</p><ol><li><code>task</code>: <code>Task</code> - 由之前 <code>fork</code> 指令返回的 <code>Task</code> 对象</li></ol><p><code>cancel</code> 是一个非阻塞的 <code>Effect</code>。也就是说，执行 <code>cancel</code> 的 <code>Saga</code> 会在发起取消动作后立即恢复执行。</p><p>对于返回 Promise 结果的函数，你可以通过给 promise 附加一个 [CANCEL] 来插入自己的取消逻辑。</p><p>举个使用cancel取消请求的例子，</p><ol><li>首先需要从<code>redux-saga</code>库里引入<code>CANCEL</code>（注意不是<code>redux-saga/effects</code>中的）</li><li>然后在异步操作上面自定义一个取消异步操作的函数，需要根据不同的异步操作形式自定义不同的取消函数，下面的例子我们是用<code>fetch</code>进行网络请求的，因此要使用<code>fetch</code>对应的取消请求的方法，如果你用的<code>axios</code>，则需要使用<code>axios</code>取消请求的方法</li><li>把这个取消函数绑定到异步请求上，如下<code>promise[CANCEL] = () =&gt; &#123; controller.abort() &#125;</code></li><li>使用<code>fork</code>去执行异步操作（不会阻塞下面代码执行），返回这个异步操作的<code>task</code></li><li>如果想要取消这个异步操作，则直接使用<code>redux-saga/effects</code>中的<code>cancel</code>方法取消这个<code>task</code></li></ol><pre><code class="javascript">import &#123; call, cancel, put, select, take, takeEvery, fork &#125; from &#39;redux-saga/effects&#39;import &#123;CANCEL&#125; from &#39;redux-saga&#39;function* watchChangeName() &#123;  yield takeEvery(&#39;changeName&#39;, workerChangeName)&#125;function* workerChangeName(&#123; payload &#125;) &#123;  function f () &#123;    const controller = new AbortController();    const &#123; signal &#125; = controller;    const promise = fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;, &#123; signal &#125;).then(res =&gt; res.json()).then(data =&gt; console.log(data))    promise[CANCEL] = () =&gt; &#123; controller.abort() &#125;    console.log(promise)    return promise  &#125;  const fetchTask = yield fork(f)  yield cancel(fetchTask) // 这里直接调用cancel取消请求  yield put(&#123;type: &#39;CHANGE_NAME&#39;, payload&#125;)&#125;</code></pre><p><img src="/images/redux16.gif"></p></li></ul><p>上面就是我们常用到的一些方法，具体的其他一些用法，参考<a href="https://redux-saga-in-chinese.js.org/">redux-saga官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> react-thunk </tag>
            
            <tag> react-sage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React react-redux的使用</title>
      <link href="/2021/08/13/React-react-redux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/08/13/React-react-redux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>由于redux是一个独立的库，我们如果需要想在react中更方便的使用redux，推荐使用<code>react-redux</code>这个库，当然不使用这个库也是可以的，那么你需要自己维护全局<code>state</code>，并且订阅state的更新，去修改视图，而react-redux已经帮我们做好了这些东西，并且提供了一些api可以使用。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先我们需要安装<code>redux</code>和<code>react-redux</code></p><pre><code>yarn add redux react-redux</code></pre><h1 id="定义store"><a href="#定义store" class="headerlink" title="定义store"></a>定义store</h1><p>然后我们需要定义<code>store</code>，我们在这里创建一个姓名和年龄的<code>store</code>，并<code>combineReducers</code>，一般存放在单独的文件中，我们放在<code>store.js</code>中</p><pre><code class="javascript">import &#123; createStore, combineReducers &#125; from &#39;redux&#39;const ageReducer = (state = &#123;age: 18&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      return &#123;...state, age: state.age + 1&#125;    case &#39;decrement&#39;:      return &#123;...state, age: state.age - 1&#125;    default:      return state  &#125;&#125;const nameReducer = (state = &#123;name: &#39;jerry&#39;&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;changeName&#39;:      return &#123;...state, name: action.payload.name&#125;        default:      return state  &#125;&#125;const reducers = combineReducers(&#123;ageReducer, nameReducer&#125;);const store = createStore(reducers)export default store</code></pre><h1 id="在react中使用"><a href="#在react中使用" class="headerlink" title="在react中使用"></a>在react中使用</h1><p>如何将<code>store</code>和<code>react app</code>之间关联起来呢？这就是<code>react-redux</code>的作用，<code>react-redux</code>提供一个<code>Provider</code>组件，将<code>store</code>绑定到组件，一般我们直接绑定到根组件<code>app</code>上，那么子组件中也可以使用<code>store</code>了</p><pre><code class="javascript">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import App from &#39;./App&#39;;import &#123; Provider &#125; from &#39;react-redux&#39;import store from &#39;./store&#39;ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#39;root&#39;));</code></pre><h1 id="在组件中使用"><a href="#在组件中使用" class="headerlink" title="在组件中使用"></a>在组件中使用</h1><p><code>store</code>已经可用，但是在组件中要怎么使用，怎么拿到<code>state</code>，又怎么派发<code>action</code>呢？此时需要使用到<code>react-redux</code>提供的<code>connect</code>高阶组件了，这个是可选的，如果你的组件不需要访问<code>store</code>，就可以不使用<code>connect</code>。</p><p>来看看具体用法，假设我们有一个组件<code>User.js</code>，渲染姓名和年龄，注意我们使用的时候不提供<code>name</code>和<code>age`` props</code></p><pre><code class="javascript">import React from &#39;react&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        return &lt;div&gt;            姓名： &#123;this.props.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.age&#125;        &lt;/div&gt;    &#125;&#125;export default User</code></pre><p>此时肯定是渲染不出来的，因为我们还没有使用<code>connect</code>连接<code>store</code>，<code>&lt;User /&gt;</code>上也没有提供相应的<code>props</code>。</p><p>现在我们来连接<code>store</code>，就使用到了<code>connect</code>高阶组件，<code>connect</code>接收两个函数作为参数，我们习惯性的称之为<code>mapStateToProps</code>和<code>mapDispatchToProps</code>，顾名思义，就是把<code>state</code>和<code>dispatc</code>h映射到<code>props</code>上，使我们的组件可以通过<code>props</code>属性访问<code>state</code>和<code>dispatch</code>，通过<code>dispatch</code>，就可以派发<code>action</code>了。<strong>第二个函数是可选的，如果不传，会直接把<code>dispatch</code>映射到组件的<code>props</code>上</strong></p><h2 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h2><p>我们先来看看<code>mapStateToProps</code>怎么用，我们打印一下<code>state</code>，看看是什么东西</p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        return &lt;div&gt;            姓名： &#123;this.props.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.age&#125;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state) =&gt; &#123;    console.log(state)&#125;const ConnectedUser = connect(mapStateToProps)(User)export default ConnectedUser</code></pre><p><img src="/images/redux11.png"></p><p>可以看到，就是<code>state</code>对象，注意我们是使用<code>combineReducers</code>过的，是有<code>key</code>的，具体可以查看<a href="https://www.baihuzi.com/2021/08/13/Redux%E7%9A%84%E4%BD%BF%E7%94%A8/#Redux-combineReducers">Redux combineReducers</a></p><p>从上图报错也可以看出来，<code>mapStateToProps</code>需要返回一个纯对象，因此我们可以拿到所有的<code>state</code>后，只挑选出对自己有用的，如果都需要或者图方便，直接返回<code>&#123;...state&#125;</code>即可</p><pre><code class="javascript">// ...const mapStateToProps = (state) =&gt; &#123;    return &#123;...state&#125;&#125;// ...</code></pre><p>此时我们就可以在组件的<code>props</code>属性上获取到<code>state</code>了，渲染的时候要根据<code>state</code>的结构进行渲染，因此上面的<code>this.props.name</code>和<code>this.props.age</code>需要修改一下</p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state) =&gt; &#123;    console.log(state)    return &#123;...state&#125;&#125;const ConnectedUser = connect(mapStateToProps)(User)export default ConnectedUser</code></pre><p><img src="/images/redux12.png"></p><p>实际上，如果我们的组件有自己的<code>props</code>，例如有一个性别属性<code>&lt;User gender=&quot;male&quot; /&gt;</code>，<code>mapStateToProp</code>函数还接受第二个参数，可以获取到组件自己的属性，如果只传了<code>state</code>参数，会自动进行合并，<strong>不幸的是，如果组件自身的props和state的属性有重名的，组件自身的属性将会丢失</strong>，因此对于这种情况，<code>mapStateToProp</code>函数让你接受第二个参数，就是组件自身的<code>props</code>，具体保留哪个，我们可以自行指定。</p><p>例如我们是组件以自身的属性优先，就可以直接<code>return &#123; ...state, ...props &#125;</code>，此时组件自身的值总是会覆盖<code>state</code>的值<br>例如这样使用组件<code>&lt;User ageReducer=&quot;male&quot; /&gt;</code></p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state, props) =&gt; &#123;    console.log(state)    return &#123;...state, ...props&#125;&#125;const ConnectedUser = connect(mapStateToProps)(User)export default ConnectedUser</code></pre><p><img src="/images/redux13.png"></p><blockquote><p>看完记得记得把<code>&lt;User ageReducer=&quot;male&quot; /&gt;</code>还原</p></blockquote><h2 id="仅在需要时返回新的对象引用"><a href="#仅在需要时返回新的对象引用" class="headerlink" title="仅在需要时返回新的对象引用"></a>仅在需要时返回新的对象引用</h2><p>我们从<code>store</code>中取出的<code>state</code>还可以结合组件自身<code>props</code>进行一些计算操作，例如排序，复杂计算等，但是如果非常耗时，可能会影响性能.</p><p><code>react-redux</code> 内部实现了<code>shouldComponentUpdate</code>方法以便在组件用到的数据发生变化后能够精确地重新渲染。默认地，<code>react-redux</code>使用<code>===</code>对<code>mapStateToProps</code>返回的对象的每一个字段逐一对比，以判断内容是否发生了改变。</p><p><code>react-redux</code>进行浅比较来检查<code>mapStateToProps</code>的结果是否改变了。返回一个新对象或数组引用十分容易操作，但会造成你的组件在数据没变的情况下也重新渲染。</p><p>我们建议将所有复杂的查找和计算数据的方法封装到<code>selector</code>中。此外，你今后可以通过使用<a href="https://github.com/reduxjs/reselect">Reselect</a>编写“<code>memoized</code>” <code>selectors</code>来跳过不必要的工作从而优化性能。还可以将复杂计算放到组件内部去做计算，使用<code>useMeme</code>或<code>useCallback</code>进行优化</p><h1 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h1><p>在来看看如何<code>dispatch</code>一个<code>action</code>，上面看到，<code>dispatch</code>函数已经是默认被传递到组件的<code>props</code>属性上了，如果不做操作，可以直接使用<code>this.props.dispatch</code>派发一个<code>action</code></p><p>例如:</p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    handleIncrementClick = () =&gt; &#123;        this.props.dispatch(&#123;type: &#39;increment&#39;&#125;)    &#125;    handleDecrementClick = () =&gt; &#123;        this.props.dispatch(&#123;type: &#39;decrement&#39;&#125;)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;            &lt;br /&gt;            &lt;button onClick=&#123;this.handleIncrementClick&#125;&gt;+&lt;/button&gt;            &lt;button onClick=&#123;this.handleDecrementClick&#125;&gt;-&lt;/button&gt;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state, props) =&gt; &#123;    console.log(state)    return &#123;...state, ...props&#125;&#125;const ConnectedUser = connect(mapStateToProps)(User)export default ConnectedUser</code></pre><p><img src="/images/redux14.gif"></p><p>这样做没问题，但是直接在组件内部派发<code>action</code>，组件里面可能很多地方都需要<code>dispatch</code>，分散在组件的各个地方，代码维护起来就会十分困难，如果在组件内部还要继续向子组件里面传递<code>dispatch</code>，再在子组件内部派发<code>action</code>，就非常混乱了，并且暴露了父层的<code>dispatch</code>给子组件了，子组件如果内部还有自己的<code>connect</code>，就会非常混乱。</p><p>此时借助<code>connect</code>的第二个参数，我们可以在<code>mapDispatchToProps</code>里面集中定义组件的需要的<code>dispatch</code>方法，再传给组件，这样集中管理起来代码维护起来成本就降低很多了。</p><p>怎么用呢？<code>mapDispatchToProps</code>接收<code>dispatch</code>作为参数，返回一个派发<code>action</code>的函数对象，一旦定义了这个函数，<code>dispatch</code>就不会默认传给组件了，需要自己定义。</p><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    handleIncrementClick = () =&gt; &#123;        this.props.ageIncrement()    &#125;    handleDecrementClick = () =&gt; &#123;        this.props.ageDecrement()    &#125;    handleNameChange = () =&gt; &#123;        this.props.changeName(&#123;name: &#39;tom&#39;&#125;)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;            &lt;br /&gt;            &lt;button onClick=&#123;this.handleIncrementClick&#125;&gt;+&lt;/button&gt;            &lt;button onClick=&#123;this.handleDecrementClick&#125;&gt;-&lt;/button&gt;            &lt;button onClick=&#123;this.handleNameChange&#125;&gt;改变名字&lt;/button&gt;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state, props) =&gt; &#123;    console.log(state)    return &#123;...state, ...props&#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123;    return &#123;        ageIncrement: payload =&gt; dispatch(&#123;type: &#39;increment&#39;, payload&#125;),        ageDecrement: payload =&gt; dispatch(&#123;type: &#39;decrement&#39;, payload&#125;),        changeName: payload =&gt; dispatch(&#123;type: &#39;changeName&#39;, payload&#125;),    &#125;&#125;const ConnectedUser = connect(mapStateToProps, mapDispatchToProps)(User)export default ConnectedUser</code></pre><p>这样的话，我们自己定义的派发<code>action</code>函数<code>ageIncrement</code>、<code>ageDecrement</code>、<code>changeName</code>就会放到组件的<code>props</code>属性上了<br><img src="/images/redux15.gif"></p><h2 id="mapDispatchToProps简写形式"><a href="#mapDispatchToProps简写形式" class="headerlink" title="mapDispatchToProps简写形式"></a>mapDispatchToProps简写形式</h2><p>使用上述方式定义<code>mapDispatchToProps</code>看起来有点累赘，<code>react-redux</code>也帮我们想到了，在<code>connect</code>函数的第二个参数上，可以直接传递一个<code>action creator</code>函数的数组，然后使用<code>bindActionCreators</code> API来帮我们进行处理，<code>bindActionCreators</code>的使用具体请看<a href="https://www.baihuzi.com/2021/08/13/Redux%E7%9A%84%E4%BD%BF%E7%94%A8/#Redux-bindActionCreators">Redux bindActionCreators</a></p><p>我们对<code>mapDispatchToProps</code>进行改写，这样看起来好多了，功能也没有受到影响。</p><pre><code class="javascript">// ...// const mapDispatchToProps = (dispatch) =&gt; &#123;//     return &#123;//         ageIncrement: payload =&gt; dispatch(&#123;type: &#39;increment&#39;, payload&#125;),//         ageDecrement: payload =&gt; dispatch(&#123;type: &#39;decrement&#39;, payload&#125;),//         changeName: payload =&gt; dispatch(&#123;type: &#39;changeName&#39;, payload&#125;),//     &#125;// &#125;const ConnectedUser = connect(mapStateToProps, &#123;    ageIncrement(payload) &#123;        return &#123;type: &#39;increment&#39;, payload&#125;    &#125;,    ageDecrement(payload) &#123;        return &#123;type: &#39;decrement&#39;, payload&#125;    &#125;,    changeName(payload) &#123;        return &#123;type: &#39;changeName&#39;, payload&#125;    &#125;&#125;)(User)export default ConnectedUser</code></pre><p><code>react-redux</code>的基本使用就这些了，如果想要继续深入学习，可以看一下它的<a href="https://github.com/reduxjs/react-redux">源码</a>，和<a href="https://www.yuque.com/marckon/react-redux.cn/usage#osumaf">中文文档</a></p><p>现在都流行<code>hooks</code>，<code>react-redux</code>也实现了<code>hooks</code>，留坑，有时间再更新吧。</p><h1 id="用例源码"><a href="#用例源码" class="headerlink" title="用例源码"></a>用例源码</h1><pre><code class="javascript">import &#123; createStore, combineReducers &#125; from &#39;redux&#39;const ageReducer = (state = &#123;age: 18&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      return &#123;...state, age: state.age + 1&#125;    case &#39;decrement&#39;:      return &#123;...state, age: state.age - 1&#125;    default:      return state  &#125;&#125;const nameReducer = (state = &#123;name: &#39;jerry&#39;&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;changeName&#39;:      return &#123;...state, name: action.payload.name&#125;        default:      return state  &#125;&#125;const reducers = combineReducers(&#123;ageReducer, nameReducer&#125;);const store = createStore(reducers)export default store</code></pre><pre><code class="javascript">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import App from &#39;./App&#39;;import &#123; Provider &#125; from &#39;react-redux&#39;import store from &#39;./store&#39;ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#39;root&#39;));</code></pre><pre><code class="javascript">import React, &#123; Profiler &#125; from &#39;react&#39;;import SagaTest from &#39;./components/redux/storeTest&#39;function App () &#123;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;SagaTest gender=&quot;male&quot;&gt;&lt;/SagaTest&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;class User extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    handleIncrementClick = () =&gt; &#123;        this.props.ageIncrement()    &#125;    handleDecrementClick = () =&gt; &#123;        this.props.ageDecrement()    &#125;    handleNameChange = () =&gt; &#123;        this.props.changeName(&#123;name: &#39;tom&#39;&#125;)    &#125;    render() &#123;        console.log(this.props)        return &lt;div&gt;            姓名： &#123;this.props.nameReducer.name&#125;            &lt;br /&gt;            年龄： &#123;this.props.ageReducer.age&#125;            &lt;br /&gt;            &lt;button onClick=&#123;this.handleIncrementClick&#125;&gt;+&lt;/button&gt;            &lt;button onClick=&#123;this.handleDecrementClick&#125;&gt;-&lt;/button&gt;            &lt;button onClick=&#123;this.handleNameChange&#125;&gt;改变名字&lt;/button&gt;        &lt;/div&gt;    &#125;&#125;const mapStateToProps = (state, props) =&gt; &#123;    console.log(state)    return &#123;...state, ...props&#125;&#125;// const mapDispatchToProps = (dispatch) =&gt; &#123;//     return &#123;//         ageIncrement: payload =&gt; dispatch(&#123;type: &#39;increment&#39;, payload&#125;),//         ageDecrement: payload =&gt; dispatch(&#123;type: &#39;decrement&#39;, payload&#125;),//         changeName: payload =&gt; dispatch(&#123;type: &#39;changeName&#39;, payload&#125;),//     &#125;// &#125;const ConnectedUser = connect(mapStateToProps, &#123;    ageIncrement(payload) &#123;        return &#123;type: &#39;increment&#39;, payload&#125;    &#125;,    ageDecrement(payload) &#123;        return &#123;type: &#39;decrement&#39;, payload&#125;    &#125;,    changeName(payload) &#123;        return &#123;type: &#39;changeName&#39;, payload&#125;    &#125;&#125;)(User)export default ConnectedUser</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> react redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux的使用</title>
      <link href="/2021/08/13/Redux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/08/13/Redux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Redux</code> 是一个使用叫做“<code>action</code>”的事件来管理和更新应用状态的模式和工具库 它以集中式<code>Store</code>（<code>centralized store</code>）的方式对整个应用中使用的状态进行集中管理，其规则确保状态只能以可预测的方式更新。</p><p>为什么要使用 <code>Redux</code>？<br><code>Redux</code> 帮你管理“全局”状态 - 哪些应用程序的许多部分都需要的状态。</p><p><code>Redux</code> 提供的模式和工具使您更容易理解应用程序中的状态何时、何地、为什么以及如何更新，以及当这些更改发生时您的应用程序逻辑将如何表现。 <code>Redux</code> 指导您编写可预测和可测试的代码，这有助于让您确信您的应用程序将按预期工作。</p><p>不像<code>Vuex</code>，<code>Redux</code>是一个独立的工具库，不仅可以在<code>React</code>中使用，还可以在其他框架中使用，甚至可以直接用<code>script</code>标签的形式在页面中直接使用</p><h1 id="Redux使用"><a href="#Redux使用" class="headerlink" title="Redux使用"></a>Redux使用</h1><p>我们就通过一个简单的计数器页面来了解<code>Redux</code>该怎么使用，我们先不在<code>react</code>项目中使用，先看看最原始的<code>redux</code>要怎么用。后面再看看怎么在<code>react</code>中使用。</p><p>基础的<code>html</code>页面如下，需要引用<code>redux</code>的<code>umd</code>包（使用<code>jquery</code>来方便我们操作<code>dom</code>）</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;https://cdn.bootcss.com/redux/4.0.0/redux.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;p&gt;&lt;span id=&quot;count&quot;&gt;&lt;/span&gt;&lt;/p&gt;    &lt;button&gt;+&lt;/button&gt;    &lt;button&gt;-&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>引用了<code>redux</code>，会在<code>Window</code>上挂载一个<code>Redux</code>全局对象，我们首先需要定义一个<code>reducer</code>，<code>reducer</code> 是一个函数，接收当前的 <code>state</code> 和一个 <code>action</code> 对象，必要时决定如何更新状态，并返回新状态。函数签名是：<code>(state, action) =&gt; newState</code>。 你可以将 <code>reducer</code> 视为一个事件监听器，它根据接收到的 <code>action</code>（事件）类型处理事件。</p><pre><code class="javascript">$(document).ready(function() &#123;  const reducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;    switch (action.type) &#123;      case &#39;INCREMENT&#39;:        return &#123;...state, count: state.count + 1&#125;      case &#39;DECREMENT&#39;:        return &#123;...state, count: state.count - 1&#125;        default:        return state     &#125;  &#125;&#125;)</code></pre><p><code>action</code> 是一个具有 <code>type</code> 字段的普通 <code>JavaScript</code> 对象。你可以将 <code>action</code> 视为描述应用程序中发生了什么的事件。<code>type</code> 字段是一个字符串，给这个 <code>action</code> 一个描述性的名字，比如<code>&quot;todos/todoAdded&quot;</code>。我们通常把那个类型的字符串写成“域&#x2F;事件名称”，其中第一部分是这个 <code>action</code> 所属的特征或类别，第二部分是发生的具体事情。</p><p><code>action</code> 对象可以有其他字段，其中包含有关发生的事情的附加信息。按照惯例，我们将该信息放在名为 <code>payload</code> 的字段中。</p><p>在定义<code>reducer</code>的时候，注意返回的状态必须是一个全新的状态，不能直接使用和之前相同的引用，例如使用<code>obj.a</code>直接修改<code>a</code>的值，或者<code>array.push</code>一个新的值</p><p>此时有了<code>reducer</code>，我们就可以使用全局的<code>Redux</code>创建一个<code>store</code>，</p><pre><code class="javascript">$(document).ready(function() &#123;  const reducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;    switch (action.type) &#123;      case &#39;INCREMENT&#39;:        return &#123;...state, count: state.count + 1&#125;      case &#39;DECREMENT&#39;:        return &#123;...state, count: state.count - 1&#125;        default:        return state     &#125;  &#125;  const store = Redux.createStore(reducer)  console.log(store)&#125;)</code></pre><p>我们可以看看store上有哪些API<br><img src="/images/redux1.png"></p><p>发现上面有<code>dispatch</code>、<code>getState</code>、<code>replaceReducer</code>、<code>subscribe</code>这四个<code>API</code>，下面我们都会用到。</p><h1 id="store-getState"><a href="#store-getState" class="headerlink" title="store.getState()"></a>store.getState()</h1><p>通过上图可以发现，我们的页面<code>count</code>字段是没值的，那我们要怎么获取到<code>store</code>中的<code>state</code>呢？此时就可以使用<code>store.getState()</code>来获取<code>store</code>中的状态了，我们获取到<code>state</code>然后渲染到页面中</p><pre><code class="javascript">$(document).ready(function() &#123;  const reducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;    switch (action.type) &#123;      case &#39;INCREMENT&#39;:        return &#123;...state, count: state.count + 1&#125;      case &#39;DECREMENT&#39;:        return &#123;...state, count: state.count - 1&#125;        default:        return state     &#125;  &#125;  const store = Redux.createStore(reducer)  console.log(store.getState()) // &#123;count: 0&#125;  $(&#39;#count&#39;).text(store.getState().count)&#125;)</code></pre><h1 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch"></a>store.dispatch</h1><p>此时页面就已经有了<code>count</code>的值了，那怎么修改<code>state</code>呢？此时我们就可以使用<code>dispatch</code>来派发一个<code>action</code>，然后在<code>reducer</code>中根据<code>action</code>的<code>type</code>值，来判断需要怎么处理<code>state</code></p><pre><code class="javascript">$(document).ready(function() &#123;  // ...  $(&#39;button&#39;).eq(0).click(function() &#123;    store.dispatch(&#123;type: &#39;INCREMENT&#39;&#125;)    console.log(store.getState())  &#125;)  $(&#39;button&#39;).eq(1).click(function() &#123;    store.dispatch(&#123;type: &#39;DECREMENT&#39;&#125;)    console.log(store.getState())  &#125;)&#125;)</code></pre><p>我们点击按钮<code>+</code>，通过<code>store</code> <code>dispatch</code> 一个<code>action</code> <code>&#123;type: &#39;INCREMENT&#39;&#125;</code>，然后<code>reducer</code>中就会按照<code>action</code>的<code>type</code>类型，去更新<code>state</code>，点击按钮<code>-</code>也是一样</p><p>我们看看效果<br><img src="/images/redux3.gif"></p><h1 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe"></a>store.subscribe</h1><p>此时<code>state</code>是确实被更新了，但是页面为什么没有改变呢？这是因为<code>state</code>确实是改变了，但是<code>redux</code>并没有告诉我<code>state</code>改变了啊，所以我们需要知道<code>state</code>变化了，再执行一些动作。此时就可以使用<code>store</code>的<code>subscribe</code>来订阅一个监听器，一旦<code>state</code>改变了，<code>redux</code>就去执行那个监听器，做相应的更改。</p><p><code>subscribe</code>接收一个函数作为参数，我们将我们需要做的操作传进去，一旦<code>redux</code>检测到<code>state</code>发生了变化，就会去调用这个函数</p><pre><code class="javascript">$(document).ready(function() &#123;  // ...  store.subscribe(function() &#123;    $(&#39;#count&#39;).text(store.getState().count)  &#125;)&#125;)</code></pre><p><img src="/images/redux4.gif"></p><p><code>subscribe</code>还接收一个返回值，用来取消订阅，这个返回值是一个方法，我们直接调用这个方法就可以取消订阅了，后续<code>state</code>的修改不会去触发监听器函数，但是<code>redux</code>内部<code>state</code>的状态还是会持续更新</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;!-- ... --&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;p&gt;&lt;span id=&quot;count&quot;&gt;&lt;/span&gt;&lt;/p&gt;    &lt;button&gt;+&lt;/button&gt;    &lt;button&gt;-&lt;/button&gt;    &lt;button&gt;取消订阅&lt;/button&gt;  &lt;/div&gt;  &lt;script&gt;        $(document).ready(function() &#123;      // ...      const cancelSub = store.subscribe(function() &#123;        $(&#39;#count&#39;).text(store.getState().count)      &#125;)      $(&#39;button&#39;).eq(2).click(function() &#123;        cancelSub()      &#125;)    &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/redux5.gif"></p><p>最主要的几个<code>API</code>我们已经用到了，剩下的几个<code>api</code>我们分别来说说</p><h1 id="Redux-combineReducers"><a href="#Redux-combineReducers" class="headerlink" title="Redux.combineReducers"></a>Redux.combineReducers</h1><p>由于不建议创建多个<code>store</code>，因此如果有多个<code>reducer</code>，需要利用这个<code>API</code>来组合<code>reducer</code>，</p><p><code>combineReducers</code> 辅助函数的作用是，把一个由多个不同 <code>reducer</code> 函数作为 <code>value</code> 的 <code>object</code>，合并成一个最终的 <code>reducer</code> 函数，然后就可以对这个 <code>reducer</code> 调用 <code>createStore</code> 方法。</p><p>合并后的 <code>reducer</code> 可以调用各个子 <code>reducer</code>，并把它们返回的结果合并成一个 <code>state</code> 对象。 由 <code>combineReducers()</code> 返回的 <code>state</code> 对象，会将传入的每个 <code>reducer</code> 返回的 <code>state</code> 按其传递给 <code>combineReducers()</code> 时对应的 <code>key</code> 进行命名。</p><pre><code class="javascript">const countReducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;INCREMENT&#39;:      return &#123;...state, count: state.count + 1&#125;    case &#39;DECREMENT&#39;:      return &#123;...state, count: state.count - 1&#125;      default:      return state   &#125;&#125;const priceReducer = (state = &#123;price : 10&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;INCREMENT&#39;:      return &#123;...state, price: state.price + 1&#125;    case &#39;DECREMENT&#39;:      return &#123;...state, price: state.price - 1&#125;      default:      return state   &#125;&#125;const combinedReducers = Redux.combineReducers(&#123;countReducer: countReducer, priceReducer: priceReducer&#125;)const store = Redux.createStore(combinedReducers)console.log(store.getState())</code></pre><p><img src="/images/redux6.png"><br>可以看到我们组合了<code>countReducer</code>和<code>priceReducer</code>，最终会按照传入<code>combineReducers</code>对象的<code>key</code>进行命名区分，因此我们之前的代码需要改为</p><pre><code class="javascript">$(&#39;#count&#39;).text(store.getState().countReducer.count)const cancelSub = store.subscribe(function() &#123;  $(&#39;#count&#39;).text(store.getState().countReducer.count)&#125;)</code></pre><p><img src="/images/redux7.png"></p><p>我们发现一个问题，为什么我派发了一个<code>action</code>，两个<code>state</code>都会发生变化？其实是因为我们的<code>action</code>都是<code>INCREMENT</code>，由于两个<code>reducer</code>中的<code>type</code>设置的是一样的，这样的话就会导致这个问题，一般为了解决这个问题，我们都是把那个类型的字符串写成“域&#x2F;事件名称”，例如<code>COUNT/INCREMENT</code>，用于区分不同的<code>reducer</code>。</p><p>再修改一下代码</p><pre><code class="javascript">// ...const countReducer = (state = &#123;count : 0&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;COUNT/INCREMENT&#39;:      return &#123;...state, count: state.count + 1&#125;    case &#39;COUNT/DECREMENT&#39;:      return &#123;...state, count: state.count - 1&#125;      default:      return state   &#125;&#125;const priceReducer = (state = &#123;price : 10&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;PRICE/INCREMENT&#39;:      return &#123;...state, price: state.price + 1&#125;    case &#39;PRICE/DECREMENT&#39;:      return &#123;...state, price: state.price - 1&#125;      default:      return state   &#125;&#125;// ...$(&#39;button&#39;).eq(0).click(function() &#123;  store.dispatch(&#123;type: &#39;COUNT/INCREMENT&#39;&#125;)  console.log(store.getState())&#125;)$(&#39;button&#39;).eq(1).click(function() &#123;  store.dispatch(&#123;type: &#39;COUNT/INCREMENT&#39;&#125;)  console.log(store.getState())&#125;)</code></pre><p>现在就正常了<br><img src="/images/redux8.png"></p><h1 id="Redux-applyMiddleware"><a href="#Redux-applyMiddleware" class="headerlink" title="Redux.applyMiddleware"></a>Redux.applyMiddleware</h1><p>我们可以在<code>Redux</code>中使用各种插件，以增强我们的功能，比如我在每次修改<code>state</code>的时候，不用自己手动打印，而是自动打印，此时我们可以使用<code>redux-logger</code>插件</p><pre><code class="html">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/redux-logger/4.0.0/redux-logger.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // ...  const logger = reduxLogger.createLogger()  const store = Redux.createStore(combinedReducers, Redux.applyMiddleware(logger))&lt;/script&gt;</code></pre><p><img src="/images/redux9.png"></p><h1 id="Redux-bindActionCreators"><a href="#Redux-bindActionCreators" class="headerlink" title="Redux.bindActionCreators"></a>Redux.bindActionCreators</h1><p>一般情况下你可以直接在 <code>Store</code> 实例上调用 <code>dispatch</code>。如果你在 <code>React</code> 中使用 <code>Redux</code>，<code>react-redux</code> 会提供 <code>dispatch</code> 函数让你直接调用它 。</p><p>把一个 <code>value</code> 为不同 <code>action creator</code> 的对象，转成拥有同名 <code>key</code> 的对象。同时使用 <code>dispatch</code> 对每个 <code>action creator</code> 进行包装，以便可以直接调用它们。</p><p>惟一会使用到 <code>bindActionCreators</code> 的场景是当你需要把 <code>action creator</code> 往下传到一个组件上，却不想让这个组件觉察到 <code>Redux</code> 的存在，而且不希望把 <code>dispatch</code> 或 <code>Redux store</code> 传给它。</p><p>为方便起见，你也可以传入一个函数作为第一个参数，它会返回一个函数。</p><p>上面的解释理解起来可能有些难以理解，下面我们用例子说明：</p><p>什么是<code>action creator</code>，就是返回<code>action</code>的函数，例如：</p><pre><code class="javascript">const incrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/INCREMENT&#39; &#125;&#125;</code></pre><p>定义了如上<code>action creator</code>，然而我们派发<code>action</code>的时候仍然需要使用<code>store.dispatch</code>进行派发，例如<code>store.dispatch(incrementActionCreator())</code>，这样写未免有些累赘了，此时我们就可以使用<code>bindActionCreators</code>方法，将<code>action creator</code>和<code>store.diapatch</code>传进去，返回一个函数，可以直接派发 <code>action</code>，例如:</p><pre><code class="javascript">const incrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/INCREMENT&#39; &#125;&#125;const increment = Redux.bindActionCreators(incrementActionCreator, store.diapatch)increment() // 这里直接会派发action</code></pre><p>同时，<code>Redux.bindActionCreators</code>的第一个参数还可以接受一个由<code>action creator</code>组成的对象，对象的<code>key</code>随便指定，此时会返回和<code>key</code>相同的一组对象，对象的值就是可以直接派发<code>action</code>的函数，例如:</p><pre><code class="javascript">const incrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/INCREMENT&#39; &#125;&#125;const decrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/DECREMENT&#39; &#125;&#125;let actions = Redux.bindActionCreators(&#123; increment: incrementActionCreator, decrement: decrementActionCreator &#125;, store.dispatch)// 此时使用这种方式直接派发actions.increment()actions.decrement()</code></pre><p>我们将之前的例子改写成这种形式，注意下面使用了两种形式，可以更好地看出区别</p><pre><code class="javascript">// ...const incrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/INCREMENT&#39; &#125;&#125;const decrementActionCreator = () =&gt; &#123;  return &#123; type: &#39;COUNT/DECREMENT&#39; &#125;&#125;let increment = Redux.bindActionCreators(incrementActionCreator, store.dispatch)let actions = Redux.bindActionCreators(&#123; increment: incrementActionCreator, decrement: decrementActionCreator &#125;, store.dispatch)$(&#39;button&#39;).eq(0).click(function() &#123;  increment()&#125;)$(&#39;button&#39;).eq(1).click(function() &#123;  actions.decrement()&#125;)</code></pre><p><img src="/images/redux10.png"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 合成事件</title>
      <link href="/2021/08/12/React-%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/"/>
      <url>/2021/08/12/React-%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="react合成事件"><a href="#react合成事件" class="headerlink" title="react合成事件"></a>react合成事件</h1><p>如果<code>DOM</code>上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。<code>React</code>为了避免这类<code>DOM</code>事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——<code>SyntheticEvent</code>。</p><p>当用户在为<code>onClick</code>添加函数时，<code>React</code>并没有将<code>Click</code>事件绑定在对应的元素上面，而是在<code>document</code>处监听所有支持的事件，当事件发生并冒泡至<code>document</code>处时，<code>React</code>将事件内容封装交给中间层<code>SyntheticEvent</code>（负责所有事件合成）</p><p>所有的react合成事件都存放在一个事件池里面，当调用的时候给合成事件的事件对象赋值，执行完之后把事件对象设置为null，放回事件池，而不用每次都创建一个新的合成事件</p><p>当事件触发的时候，对使用统一的分发函数<code>ReactEventListener.dispatchEvent</code>将指定函数执行。</p><h1 id="合成事件和原生事件的执行顺序是什么？可以混用吗？"><a href="#合成事件和原生事件的执行顺序是什么？可以混用吗？" class="headerlink" title="合成事件和原生事件的执行顺序是什么？可以混用吗？"></a>合成事件和原生事件的执行顺序是什么？可以混用吗？</h1><ol><li><code>React</code>的所有事件都通过 <code>document</code>进行统一分发。当真实 <code>Dom</code>触发事件后冒泡到 <code>document</code>后才会对 <code>React</code>事件进行处理。</li><li>原生的事件会先执行，然后执行 <code>React</code>合成事件，最后执行真正在 <code>document</code>上挂载的事件</li><li><code>React</code>事件和原生事件最好不要混用。原生事件中如果执行了 <code>stopPropagation</code>方法，则会导致其他 <code>React</code>事件失效。因为所有元素的事件将无法冒泡到 <code>document</code>上，导致所有的 <code>React</code>事件都将无法被触发。</li></ol><p>在 <code>React</code> 中 <code>event</code> 是一个 <code>SyntheticEvent</code>，如果和它的交互被延迟了（例如：通过 <code>setTimeout</code>），事件会被清除并且 <code>e.target</code> 引用不会再有效，事件对象上的所有属性都为<code>null</code></p><pre><code class="javascript">import React from &#39;react&#39;class SyntheticEvent extends React.Component &#123;  constructor(...props) &#123;    super(...props)  &#125;  clickHandler = (e) =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&#39;React 事件触发了&#39;, e);    &#125;, 2000)  &#125;  render () &#123;    return (      &lt;&gt;        &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击&lt;/button&gt;      &lt;/&gt;    )  &#125;&#125;export default SyntheticEvent</code></pre><p><img src="/images/SyntheticEvent.gif"></p><p>如果你需要在事件处理函数运行之后获取事件对象的属性，你需要调用 <code>e.persist()</code>：</p><pre><code class="javascript">// ...clickHandler = (e) =&gt; &#123;    e.persist()    setTimeout(() =&gt; &#123;      console.log(&#39;React 事件触发了&#39;, e);    &#125;, 2000)  &#125;</code></pre><p><img src="/images/SyntheticEvent1.gif"></p><p>如果原生事件和React事件混用，则优先调用原生事件，再调用React事件，如果document上也绑定了原生事件，则最后执行；</p><pre><code class="javascript">import React from &#39;react&#39;class SyntheticEvent extends React.Component &#123;  constructor(...props) &#123;    super(...props)    this.btnRef = React.createRef()  &#125;  clickHandler = (e) =&gt; &#123;      console.log(&#39;React 事件触发了&#39;, e);  &#125;  componentDidMount() &#123;    this.btnRef.current.addEventListener(&#39;click&#39;, (e) =&gt; &#123;      console.log(&#39;原生事件&#39;, e)    &#125;)    document.addEventListener(&#39;click&#39;, (e) =&gt; &#123;      console.log(&#39;原生事件 document&#39;, e)    &#125;)  &#125;  render () &#123;    return (      &lt;&gt;        &lt;button ref=&#123;this.btnRef&#125; onClick=&#123;this.clickHandler&#125;&gt;点击&lt;/button&gt;      &lt;/&gt;    )  &#125;&#125;export default SyntheticEvent</code></pre><p><img src="/images/SyntheticEvent2.gif"></p><p>如果原生事件中阻止冒泡了，则React事件不会触发</p><pre><code class="javascript">// ...componentDidMount() &#123;    this.btnRef.current.addEventListener(&#39;click&#39;, (e) =&gt; &#123;      console.log(&#39;原生事件&#39;, e)      e.stopPropagation()    &#125;)    document.addEventListener(&#39;click&#39;, (e) =&gt; &#123;      console.log(&#39;原生事件 document&#39;, e)    &#125;)  &#125;</code></pre><p><img src="/images/SyntheticEvent3.gif"></p><p><code>React v17</code> 中，<code>React</code> 不会再将事件处理添加到 <code>document</code> 上，而是将事件处理添加到渲染 <code>React</code> 树的根 <code>DOM</code> 容器中：移除了 “<code>event pooling</code>（事件池）”</p><pre><code class="javascript">const rootNode = document.getElementById(&#39;root&#39;);ReactDOM.render(&lt;App /&gt;, rootNode);</code></pre><p>在 <code>React 16</code> 及之前版本中，<code>React</code> 会对大多数事件进行 <code>document.addEventListener()</code> 操作。React v17 开始会通过调用 <code>rootNode.addEventListener()</code> 来代替。<br><img src="/images/react_17_delegation.png"></p><p><img src="/images/SyntheticEvent3.png"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React ReactDOM顶层API</title>
      <link href="/2021/08/12/React-ReactDOM%E9%A1%B6%E5%B1%82API/"/>
      <url>/2021/08/12/React-ReactDOM%E9%A1%B6%E5%B1%82API/</url>
      
        <content type="html"><![CDATA[<h1 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h1><p>在提供的 <code>container</code> 里渲染一个 <code>React</code> 元素，并返回对该组件的引用（或者针对无状态组件返回 <code>null</code>）。</p><p>如果 <code>React</code> 元素之前已经在 <code>container</code> 里渲染过，这将会对其执行更新操作，并仅会在必要时改变 <code>DOM</code> 以映射最新的 <code>React</code> 元素。</p><p>如果提供了可选的回调函数，该回调将在组件被渲染或更新之后被执行。</p><h1 id="hydrate"><a href="#hydrate" class="headerlink" title="hydrate()"></a>hydrate()</h1><p>与 <code>render()</code> 相同，但它用于在<code> ReactDOMServer</code> 渲染的容器中对 <code>HTML</code> 的内容进行 <code>hydrate</code> 操作。</p><h1 id="unmountComponentAtNode"><a href="#unmountComponentAtNode" class="headerlink" title="unmountComponentAtNode()"></a>unmountComponentAtNode()</h1><pre><code class="javascript">ReactDOM.unmountComponentAtNode(container)</code></pre><p>从 <code>DOM</code> 中卸载组件，会将其事件处理器（<code>event handlers</code>）和 <code>state</code> 一并清除。如果指定容器上没有对应已挂载的组件，这个函数什么也不会做。如果组件被移除将会返回 <code>true</code>，如果没有组件可被移除将会返回 <code>false</code>。</p><p>只能销毁<code>ReactDOM.render(element, container)</code>调用生成的的容器节点，通过<code>react</code>产生的节点使用此方法回报错：</p><pre><code>Warning: unmountComponentAtNode(): The node you&#39;re attempting to unmount was rendered by React and is not a top-level container. Instead, have the parent component update its state and rerender in order to remove this component.</code></pre><h1 id="findDOMNode"><a href="#findDOMNode" class="headerlink" title="findDOMNode()"></a>findDOMNode()</h1><p>当<code>ref</code>作用于组件时，只能拿到组件的实例，但是如何拿到组件的<code>DOM</code>呢？一种方法是通过<code>ref</code>转发，将<code>ref</code>转发到组件内部，绑定到具体<code>DOM</code>上<br>另一种方法就是通过<code>ReactDOM.findDOMNode()</code>API，通过组件实例去查找<code>DOM</code>，</p><p>使用这个API是有条件的</p><ul><li><code>findDOMNode</code> 只在已挂载的组件上可用（即，已经放置在 <code>DOM</code> 中的组件）。如果你尝试调用未挂载的组件（例如在一个还未创建的组件上调用 <code>render()</code> 中的 <code>findDOMNode()</code>）将会引发异常。</li><li><code>findDOMNode</code> 不能用于函数组件。</li></ul><p>大多数情况下，你可以绑定一个 <code>ref</code> 到 <code>DOM</code> 节点上，可以完全避免使用 <code>findDOMNode</code>。</p><p><strong>严格模式下该方法已弃用。</strong></p><p>示例代码</p><pre><code class="javascript">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;class Child extends React.Component &#123;    constructor(props)&#123;        super(props)        this.state = &#123;            count: 0        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;div&gt;                &lt;p&gt;Child&lt;/p&gt;                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;                &lt;input&gt;&lt;/input&gt;            &lt;/div&gt;        &lt;/&gt;    &#125;&#125; class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = React.createRef()    &#125;    componentDidMount() &#123;        console.log(this.childRef.current)        console.log(ReactDOM.findDOMNode(this.childRef.current))    &#125;    render() &#123;        return &lt;&gt;            &lt;p &gt;Parent&lt;/p&gt;            &lt;Child ref=&#123;this.childRef&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><p><img src="/images/findNodeDom.png"></p><h1 id="createPortal"><a href="#createPortal" class="headerlink" title="createPortal()"></a>createPortal()</h1><p><a href="https://www.baihuzi.com/2021/08/11/React-Protals/">React Protals</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> ReactDOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 组件生命周期</title>
      <link href="/2021/08/11/React-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2021/08/11/React-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>分三个阶段来看<code>React</code>组件的<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期</a></p><ul><li><p>挂载阶段</p><p>当组件初次挂载，会有以下几个动作</p><ol><li>执行<code>constructor</code>构造函数，如果组件内部没有使用到<code>state</code>或者不需要对事件处理函数绑定<code>this</code>，则这个构造函数可以不写</li><li>执行 <code>static getDerivedStateFromProps</code>，这个方法接收两个参数，<code>nextprops</code>和<code>nextState</code>，可以获取到最新的属性和状态，在挂载阶段这两个值都是初始绑定的值，该方法有个返回值，它可以返回一个对象来更新 <code>state</code>，如果返回 <code>null</code>，则不对<code>state</code>进行修改，否则会修改<code>state</code>（浅合并）</li><li>执行<code>render</code>，更新属性和状态</li><li>渲染组件，更新<code>DOM</code></li><li>执行<code>componentDidMount</code>，组件已经挂在，通常在这个方法里做数据请求操作，或者订阅事件等</li></ol></li><li><p>更新阶段</p><p>当组件的<code>props</code>或者<code>state</code>有更新的时候，就会触发组件的更新</p><ol><li>执行 <code>static getDerivedStateFromProps</code>，和挂载阶段一样。</li><li>执行<code>shouldComponentUpdate</code>，同样这个方法接收两个参数，<code>nextprops</code>和<code>nextState</code>，可以获取到最新的属性和状态，有一个返回值为<code>true</code>或者<code>false</code>，如果为<code>false</code>，组件将不进行更新，后面的几个个动作都不会执行，这个函数通常用作性能优化。</li><li>执行<code>render</code>，更新属性和状态</li><li>执行<code>getSnapshotBeforeUpdate</code>，这个方法在最近一次渲染输出（提交到 <code>DOM</code> 节点）之前调用，此生命周期方法的任何返回值将作为参数传递给<code>componentDidUpdate</code>作为第三个参数（如果不返回值，<code>componentDidUpdate</code>第三个参数将会接收到undefined，开发工具里面此时会报错，但不影响代码运行）。需要特别注意这个方法的入参，由于属性和状态已经更改了，因此这个方法的接收两个入参<code>prevProps</code>和<code>prevState</code>，分别是修改前的<code>props</code>和<code>state</code>。</li><li>渲染组件，更新<code>DOM</code></li><li>执行<code>componentDidUpdate</code>，这个方法在更新完成后调用，接收两个入参<code>prevProps</code>和<code>prevState</code>，也分别是修改前的<code>props</code>和<code>state</code>。如果<code>getSnapshotBeforeUpdate</code>方法有返回值，将作为第三个参数传入给<code>componentDidUpdate</code>。</li></ol><p>我们可以总结出，可以以<code>rener</code>函数分界，<code>render</code>函数执行之前，属性和状态还没有发生变更， 在它之前的两个方法<code>getDerivedStateFromProps</code>和<code>shouldComponentUpdate</code>的参数获取的是将要发生变更的属性和方法，而在<code>render</code>函数执行之后，属性和状态已经变更了，在它之后的两个方法<code>getSnapshotBeforeUpdate</code>和<code>componentDidUpdate</code>的参数获取的是修改之前的属性和方法。</p><p>这样的好处是我们可以在这个数据更改前后做一些自定义的操作，比如在<code>shouldComponentUpdate</code>方法中对当前状态和修改的状态做深度比较，完全相等才不去更新组件，否则更新。又比如在<code>componentDidUpdate</code>中，可以对比修改前的状态和修改后的状态，例如<code>this.props.userID !== prevProps.userID</code>，如果两者不相等，就去调用数据更新接口，可以在<code>componentDidUpdate</code>中直接调用<code>setState</code>更新组件，但请注意它<strong>必须被包裹在一个条件语句里</strong>，例如上面这种，否则会导致死循环。</p></li><li><p>卸载阶段</p><ol><li>执行<code>componentWillUnmount</code>，会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除定时器，取消网络请求或清除在 <code>componentDidMount</code>中创建的订阅等。<code>componentWillUnmount</code>中不应调用 <code>setState</code>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</li></ol></li></ul><h1 id="父子组件生命周期执行顺序"><a href="#父子组件生命周期执行顺序" class="headerlink" title="父子组件生命周期执行顺序"></a>父子组件生命周期执行顺序</h1><p>通过以下代码来进行观察</p><pre><code class="javascript">import React from &#39;react&#39;class LifeCycleChild extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;&#125;    console.log(&#39;child constructor&#39;);  &#125;  static getDerivedStateFromProps (nextProps, nextState) &#123;    console.log(&#39;child getDerivedStateFromProps&#39;);    return null  &#125;  componentDidMount () &#123;    console.log(&#39;child componentDidMount&#39;);  &#125;  shouldComponentUpdate (nextProps, nextState) &#123;    console.log(&#39;child shouldComponentUpdate&#39;);    return true  &#125;  getSnapshotBeforeUpdate (prevProps, prevState) &#123;    console.log(&#39;child getSnapshotBeforeUpdate&#39;);  &#125;  componentDidUpdate (prevProps, prevState, snapshot) &#123;    console.log(&#39;child componentDidUpdate&#39;);  &#125;  componentWillUnmount() &#123;    console.log(&#39;child componentWillUnmount&#39;)  &#125;  render () &#123;    console.log(&#39;child render&#39;);    return (      &lt;div&gt;        &lt;p&gt;&#123;this.props.text&#125;&lt;/p&gt;      &lt;/div&gt;    )  &#125;&#125;class LifeCycleFather extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      text: &#39;hello&#39;    &#125;    console.log(&#39;father constructor&#39;)  &#125;  componentDidMount () &#123;     console.log(&#39;father componentDidMount&#39;);  &#125;    static getDerivedStateFromProps () &#123;     console.log(&#39;father getDerivedStateFromProps&#39;);    return null  &#125;  shouldComponentUpdate () &#123;     console.log(&#39;father shouldComponentUpdate&#39;);    return true  &#125;  getSnapshotBeforeUpdate () &#123;     console.log(&#39;father getSnapshotBeforeUpdate&#39;);    return &#39;father&#39;  &#125;  componentDidUpdate () &#123;     console.log(&#39;father componentDidUpdate&#39;);  &#125;  componentWillUnmount() &#123;    console.log(&#39;father componentWillUnmount&#39;)  &#125;  render () &#123;    console.log(&#39;father render&#39;);    return &lt;&gt;      &lt;p&gt;father&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; this.setState(&#123;text: &#39;new text&#39;&#125;)&#125;&gt;修改text&lt;/button&gt;      &lt;LifeCycleChild text=&#123;this.state.text&#125; /&gt;    &lt;/&gt;  &#125;&#125;class WrappedComp extends React.Component &#123;  constructor(props)&#123;    super(props)    this.state = &#123;      isShow: true    &#125;  &#125;  render() &#123;    return &lt;&gt;      &lt;button onClick=&#123;()=&gt;&#123;this.setState(&#123;isShow: !this.state.isShow&#125;)&#125;&#125;&gt;卸载组件&lt;/button&gt;      &#123; this.state.isShow ? &lt;LifeCycleFather /&gt; : null &#125;    &lt;/&gt;  &#125;&#125;export default WrappedComp</code></pre><ul><li><p>挂载阶段</p><pre><code>father constructorfather getDerivedStateFromPropsfather renderchild constructorchild getDerivedStateFromPropschild renderchild componentDidMountfather componentDidMount</code></pre></li><li><p>更新阶段</p><pre><code>father getDerivedStateFromPropsfather shouldComponentUpdatefather renderchild getDerivedStateFromPropschild shouldComponentUpdatechild renderchild getSnapshotBeforeUpdatefather getSnapshotBeforeUpdatechild componentDidUpdatefather componentDidUpdate</code></pre></li><li><p>卸载阶段</p><pre><code>father componentWillUnmountchild componentWillUnmount</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React React顶层API</title>
      <link href="/2021/08/11/React-React%E9%A1%B6%E5%B1%82API/"/>
      <url>/2021/08/11/React-React%E9%A1%B6%E5%B1%82API/</url>
      
        <content type="html"><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React.Component"></a>React.Component</h2><p><code>React.Component</code> 是使用 <code>ES6 classes</code> 方式定义 <code>React</code> 组件的基类：</p><pre><code class="javascript">class Greeting extends React.Component &#123;  render() &#123;    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;  &#125;&#125;</code></pre><h2 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h2><p><code>React.PureComponent</code> 与 <code>React.Component</code> 很相似。两者的区别在于 <code>React.Component</code> 并未实现 <code>shouldComponentUpdate()</code>，而 <code>React.PureComponent</code> 中以浅层对比 <code>prop</code> 和 <code>state</code> 的方式来实现了该函数。</p><p>如果赋予<code> React</code> 组件相同的 <code>props</code> 和 <code>state</code>，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。</p><p><code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 <code>props</code> 和 <code>state</code> 较为简单时，才使用 <code>React.PureComponent</code>，或者在深层数据结构发生变化时调用 <code>forceUpdate()</code> 来确保组件被正确地更新。你也可以考虑使用 <code>immutable</code> 对象加速嵌套数据的比较。</p><p>此外，<code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 将跳过所有子组件树的 <code>prop</code> 更新。因此，请确保所有子组件也都是“纯”的组件。</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><p><a href="https://www.baihuzi.com/2021/08/11/React-React-memo/">React.memo</a></p><h1 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h1><h2 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h2><p><code>JSX</code>实际上是<code>React.createElement</code>的语法糖，最终都会转换为<code>React.createElement</code>函数<br>参考<a href="https://zhuanlan.zhihu.com/p/140962830">通过源码学习React.createElement</a></p><h1 id="转换元素"><a href="#转换元素" class="headerlink" title="转换元素"></a>转换元素</h1><h2 id="React-Children"><a href="#React-Children" class="headerlink" title="React.Children"></a>React.Children</h2><p><code>React.Children</code> 提供了用于处理 <code>this.props.children</code> 不透明数据结构的实用方法。</p><p>我们先来看看<code>children</code>上有哪些东西</p><pre><code class="javascript">import React from &#39;react&#39;class ReactChildren extends React.Component &#123;  render () &#123;    // children还可以是一个函数，如果内部不调用，则会报错，所以内部需要使用this.props.children()来调用    console.log(this.props.children, &#39;ReactChildren&#39;);    return (      &lt;div&gt;        &#123; this.props.children &#125;      &lt;/div&gt;    )  &#125;&#125;export default class Wrapper extends React.Component &#123;  constructor(props) &#123;    super(props)    this.titleRef = React.createRef();  &#125;  handleClick = () =&gt; &#123;    console.log(&#39;clicked!&#39;)  &#125;  render () &#123;    return (      &lt;ReactChildren&gt;        &#123;/* 在children里传入一个函数，内部需要进行调用，否则报错，同样可以进行传参，和render props一样，只不过是写在了children里面 */&#125;        &#123;/* &#123;(msg) =&gt; &#123; return &lt;h1&gt;&#123;msg&#125;&lt;/h1&gt; &#125;&#125; */&#125;        &lt;h1 name=&quot;name&quot; ref=&#123;this.titleRef&#125;&gt;Title&lt;/h1&gt;        &lt;ul&gt;          &lt;li key=&quot;a&quot;&gt;aaa&lt;/li&gt;          &lt;li key=&quot;b&quot;&gt;bbb&lt;/li&gt;          &lt;li key=&quot;c&quot;&gt;ccc&lt;/li&gt;        &lt;/ul&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/button&gt;      &lt;/ReactChildren&gt;    )  &#125;&#125;</code></pre><p><img src="/images/react_children.png"></p><h3 id="React-Children-map"><a href="#React-Children-map" class="headerlink" title="React.Children.map"></a>React.Children.map</h3><p><code>React.Children.map</code>的实现比数组的<code>map</code>实现要多，因为<code>children</code>的值可能是<code>null</code>，或者其他，直接使用<code>this.props.children.map</code>可能会报错</p><pre><code class="javascript">React.Children.map(this.props.children, (child, index) =&gt; &#123;console.log(child, index)&#125;)</code></pre><h3 id="React-Children-forEach"><a href="#React-Children-forEach" class="headerlink" title="React.Children.forEach"></a>React.Children.forEach</h3><p>与 <code>React.Children.map()</code> 类似，但它不会返回一个数组。</p><pre><code class="javascript">React.Children.forEach(this.props.children, (child, index) =&gt; &#123;console.log(child, index)&#125;)</code></pre><h3 id="React-Children-count"><a href="#React-Children-count" class="headerlink" title="React.Children.count"></a>React.Children.count</h3><p>输出<code>children</code>的长度</p><pre><code class="javascript">React.Children.count(this.props.children)</code></pre><h3 id="React-Children-only"><a href="#React-Children-only" class="headerlink" title="React.Children.only"></a>React.Children.only</h3><p>验证 <code>children</code> 是否只有一个子节点（一个 <code>React</code> 元素），如果有则返回它，否则此方法会抛出错误</p><blockquote><p>注意：<code>React.Children.only()</code> 不接受 <code>React.Children.map()</code> 的返回值，因为它是一个数组而并不是 <code>React</code> 元素。</p></blockquote><pre><code class="javascript">try &#123;  console.log(React.Children.only(this.props.children))&#125; catch (error) &#123;  console.log(error)&#125;</code></pre><h3 id="React-Children-toArray"><a href="#React-Children-toArray" class="headerlink" title="React.Children.toArray"></a>React.Children.toArray</h3><p>将 <code>children</code> 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 <code>key</code>。当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 <code>this.props.children</code> 之前对内容重新排序或获取子集时。</p><pre><code class="javascript">React.Children.toArray(this.props.children)</code></pre><p><img src="/images/react_children2.png"></p><p><strong>以上所有的方法都不涉及子元素的情况，只能操作当前层级的元素</strong>，如果需要操作整个树，需要自己递归。</p><h2 id="cloneElement"><a href="#cloneElement" class="headerlink" title="cloneElement()"></a>cloneElement()</h2><p><code>cloneElement()</code>是<code>createFactory()</code>的替代品，<code>createFactory()</code>已被废弃</p><p><code>cloneElement()</code>以 <code>element</code> 元素为样板克隆并返回新的 <code>React</code> 元素。返回元素的 <code>props</code> 是将新的 <code>props</code> 与原始元素的 <code>props</code> 浅层合并后的结果。新的子元素将取代现有的子元素（如果子元素里有children，要记得同时传入），而<strong>来自原始元素的 key 和 ref 将被保留</strong>。</p><p><code>children</code>是<strong>只读</strong>的，我们不能直接对<code>children</code>进行修改，就可以借助此<code>api</code>进行修改；</p><pre><code class="javascript">&#123; React.Children.map(this.props.children, (child, index) =&gt; &#123;  console.log(child);  return React.cloneElement(child, &#123; style: &#123; color: &#39;red&#39; &#125;, aaa: &#39;title&#39; &#125;, [...child.props.children, &lt;span key=&#123;null&#125;&gt;新添加的内容&lt;/span&gt;])&#125;) &#125;</code></pre><p>类似<code>createElement</code>，第一个参数是具体<code>React</code>元素，第二个参数是扩展的属性，第三个参数是子元素</p><p>扩展的属性会进行一个浅合并，相同的属性名将直接覆盖，不相同的则逐个添加到props</p><p>子元素是个数组，</p><ul><li>如果不传，则里面的元素不会发生变化，有多少克隆多少</li><li>如果传了，则里面的元素会整体替换为传入的元素，因此如果当前元素里面仍存在<code>children</code>不想丢失，也需要进行扩展</li></ul><h2 id="isValidElement"><a href="#isValidElement" class="headerlink" title="isValidElement()"></a>isValidElement()</h2><p>验证对象是否为 <code>React</code> 元素，返回值为 <code>true</code> 或 <code>false</code></p><pre><code class="javascript">React.isValidElement(this.props.children)</code></pre><p>有一点需要注意的是，判断的元素<strong>必须有单一根元素（Fragment也算）</strong>，像上面例子那种没有单一根元素的，其实是一个数组，都会被判定为<code>false</code></p><h1 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h1><p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p><p>例如在特定标签中（例如<code>table</code> <code>th</code> <code>td</code>），限定标签类型，此时如果有多个标签，给定额外的根标签会使HTML无效，Fragments就解决了此问题</p><p>可以使用<code>&lt;React.Fragment&gt;</code>组件，或者短语发<code>&lt;&gt;&lt;/&gt;</code></p><p>使用显式 <code>&lt;React.Fragment&gt;</code> 语法声明的片段可能具有 <code>key</code>，<code>key</code> 是唯一可以传递给 <code>Fragment</code> 的属性。未来可能会添加对其他属性的支持，例如事件。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p>refs相关操作，查阅<a href="https://www.baihuzi.com/2021/08/11/React-ref%E7%9A%84%E4%BD%BF%E7%94%A8/">React ref的使用</a>，或官方文档<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">Refs &amp; DOM</a>&#x2F;<a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html">Refs 转发</a></p><h1 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h1><p><code>Suspense</code>用于懒加载组件时进行，<code>React.Suspense</code> 可以指定加载指示器（<code>loading indicator</code>），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 <code>&lt;React.Suspense&gt;</code> 支持的唯一用例</p><pre><code class="javascript">import React, &#123; Suspense &#125; from &#39;react&#39;const List = React.lazy(() =&gt; import(&#39;./列表渲染&#39;))class LazyLoadTest extends React.Component &#123;    render () &#123;        return (            &lt;Suspense fallback=&#123;&lt;div&gt;Loading&lt;/div&gt;&#125;&gt;                &lt;List&gt;&lt;/List&gt;            &lt;/Suspense&gt;        )    &#125;&#125;export default LazyLoadTest</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React React.memo</title>
      <link href="/2021/08/11/React-React-memo/"/>
      <url>/2021/08/11/React-React-memo/</url>
      
        <content type="html"><![CDATA[<p>如果你的组件在相同 <code>props</code> 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，<code>React</code> 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p><code>React.memo</code> 仅检查 <code>props</code> 变更</p><p>例如我们渲染一个斐波那契数列的第40位的值，这是一个很耗时的递归操作，在父组件中修改<code>state</code>，我们知道<code>state</code>变了，会导致组件重新渲染，此时<code>Fib</code>组件也会重新渲染，会去重新计算斐波那契数列的值，由于计算非常耗时，此时页面会夯住；</p><pre><code class="javascript">import React from &#39;react&#39;class Fib extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    fib = (n) =&gt; &#123;        if (n == 1 || n == 2) return 1        return this.fib(n - 1) + this.fib(n - 2)    &#125;    componentDidUpdate() &#123;        console.log(&#39;重新渲染了&#39;)    &#125;    render() &#123;        return &lt;div&gt;            &lt;div&gt;&#123;this.fib(this.props.n)&#125;&lt;/div&gt;        &lt;/div&gt;    &#125;&#125;class Comp extends React.Component &#123;    constructor(props)&#123;        super(props)        this.state = &#123;            count: 0        &#125;    &#125;    render()&#123;        return &lt;div&gt;            &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;            &lt;button onClick=&#123;()=&gt;&#123;this.setState(&#123;count: this.state.count + 1&#125;)&#125;&#125;&gt;+1&lt;/button&gt;            &lt;Fib n=&#123;40&#125;&gt;&lt;/Fib&gt;        &lt;/div&gt;    &#125;&#125;export default Comp</code></pre><p><img src="/images/react_memo2.gif"></p><p>查看结果发现，每当我们点击按钮，<code>Fib</code>组件都会重新渲染并计算值，性能很差;</p><p>而如果我们使用<code>React.memo</code>高阶组件包装一下<code>Fib</code>，此时页面检测到实际上<code>Fib</code>组件的<code>props</code>属性<code>n</code> 并没有发生改变，则跳过渲染组件的操作并直接复用最近一次渲染的结果</p><p>只需要这么包一下</p><pre><code class="javascript">// ...const FibMemo = React.memo(Fib)class Comp extends React.Component &#123;    constructor(props)&#123;        super(props)        this.state = &#123;            count: 0        &#125;    &#125;    render()&#123;        return &lt;div&gt;            &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;            &lt;button onClick=&#123;()=&gt;&#123;this.setState(&#123;count: this.state.count + 1&#125;)&#125;&#125;&gt;+1&lt;/button&gt;            &lt;FibMemo n=&#123;40&#125;&gt;&lt;/FibMemo&gt;        &lt;/div&gt;    &#125;&#125;</code></pre><p><img src="/images/react_memo.gif"></p><p>通过结果可以看到，使用<code>React.memo</code>包装了之后，组件没有重复渲染，父组件的行为也正常</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Protals</title>
      <link href="/2021/08/11/React-Protals/"/>
      <url>/2021/08/11/React-Protals/</url>
      
        <content type="html"><![CDATA[<p><code>Portal</code> 提供了一种将子节点渲染到存在于父组件以外的 <code>DOM</code> 节点的优秀的方案。</p><pre><code class="javascript">ReactDOM.createPortal(child, container)</code></pre><p>注意<code>createPortal</code>是<code>ReactDOM</code>的api，需要引入<code>react-dom</code>包</p><p>第一个参数（<code>child</code>）是任何可渲染的 <code>React</code> 子元素，例如一个元素，字符串或 <code>fragment</code>。第二个参数（<code>container</code>）是一个 <code>DOM</code> 元素。</p><p>通常来讲，当你从组件的 <code>render</code> 方法返回一个元素时，该元素将被挂载到 <code>DOM</code> 节点中离其最近的父节点：</p><p>然而，有时候将子元素插入到 <code>DOM</code> 节点中的不同位置也是有好处的，一个 <code>portal</code> 的典型用例是当父组件有 <code>overflow: hidden</code> 或<code> z-index</code> 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：</p><p>下面是一个demo：</p><pre><code class="javascript">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;// Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。// antd中的Dialog就是用的这个方案class Modal extends React.Component &#123;  constructor(props) &#123;    super(props)    this.$el = document.createElement(&#39;div&#39;)  &#125;  componentDidMount() &#123;    document.body.appendChild(this.$el)  &#125;  componentWillUnmount() &#123;    console.log(this.$el)    document.body.removeChild(this.$el)  &#125;  render () &#123;    return &lt;div&gt;      &#123;ReactDOM.createPortal(this.props.children, this.$el)&#125;    &lt;/div&gt;  &#125;&#125;class Comp extends React.Component &#123;  constructor(props)&#123;    super(props)    this.state = &#123;      showModal: false    &#125;  &#125;  handleClick = () =&gt; &#123;    this.setState(&#123;      showModal: !this.state.showModal    &#125;)  &#125;  render() &#123;    return &lt;div&gt;      &lt;button onClick=&#123;this.handleClick&#125;&gt;show&lt;/button&gt;      &#123;this.state.showModal ? &lt;Modal&gt;        &lt;div style=&#123;&#123;width: '100px', height: '100px', backgroundColor: 'gray'&#125;&#125;&gt;          &lt;button onClick=&#123;this.handleClick&#125;&gt;hide&lt;/button&gt;        &lt;/div&gt;      &lt;/Modal&gt; : null&#125;    &lt;/div&gt;  &#125;&#125;export default Comp</code></pre><p>尽管 <code>portal</code> 可以被放置在 <code>DOM</code> 树中的任何地方，但在任何其他方面，其行为和普通的 <code>React</code> 子节点行为一致。由于 <code>portal</code> 仍存在于 <code>React</code> 树， 且与 <code>DOM</code> 树中的位置无关，那么无论其子节点是否是 <code>portal</code>，像 <code>context</code> 这样的功能特性都是不变的。</p><p>这包含事件冒泡。一个从 <code>portal</code> 内部触发的事件会一直冒泡至包含 <code>React</code> 树的祖先，即便这些元素并不是 <code>DOM</code> 树中的祖先。</p><p>假设我们在<code>Modal</code>父元素上绑定一个点击事件，则<code>Modal</code>内部的点击会一直冒泡到其<code>React</code> 树的父元素上</p><pre><code class="javascript">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;class Modal extends React.Component &#123;  constructor(props) &#123;    super(props)    this.$el = document.createElement(&#39;div&#39;)  &#125;  componentDidMount() &#123;    document.body.appendChild(this.$el)  &#125;  componentWillUnmount() &#123;    console.log(this.$el)    document.body.removeChild(this.$el)  &#125;  render () &#123;    return ReactDOM.createPortal(this.props.children, this.$el)  &#125;&#125;class Comp extends React.Component &#123;  constructor(props)&#123;    super(props)    this.state = &#123;      showModal: false,      count: 0    &#125;  &#125;  handleClick = (e) =&gt; &#123;    this.setState(&#123;      showModal: !this.state.showModal    &#125;)    e.stopPropagation()  &#125;  handlePopClick = () =&gt; &#123;    this.setState(&#123;      count: this.state.count + 1    &#125;)  &#125;  render() &#123;    // 在这里绑定事件，每次都会使count +1,    return &lt;div onClick=&#123;this.handlePopClick&#125;&gt;      &lt;button onClick=&#123;this.handleClick&#125;&gt;show&lt;/button&gt;      count: &#123;this.state.count&#125;      &#123;this.state.showModal ? &lt;Modal&gt;        &lt;div style=&#123;&#123;width: '100px', height: '100px', backgroundColor: 'gray'&#125;&#125;&gt;          &lt;button onClick=&#123;this.handleClick&#125;&gt;hide&lt;/button&gt;        &lt;/div&gt;      &lt;/Modal&gt; : null&#125;    &lt;/div&gt;  &#125;&#125;export default Comp</code></pre><p><img src="/images/portals1.gif"></p><p>可以看到虽然<code>Modal</code>被渲染到了<code>body</code>上，但是父元素上还是能捕获到冒泡上来的事件。</p><p>可以理解为<code>Portals</code>只是把<code>dom</code>渲染到了其他地方，但是从代码结构上来看，还是处在当前父子组件的上下文中</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React ref的使用</title>
      <link href="/2021/08/11/React-ref%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/08/11/React-ref%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>ref</code>可以作用于普通元素，也可以作用于<code>class</code>组件上，<strong>不能作用于函数式组件</strong>，因为函数式组件没有<code>this</code>实例对象，在函数式组件中可以使用<code>useRef</code>和<code>useImperativeHandle</code></p><p>如果作用于组件上，可以直接访问组件的<code>state</code>，还可以调用组件的方法（自定义方法以及<code>setState</code>等内置方法）</p><p>父组件设置的<code>ref</code>还可以转发给子组件，以获取子组件内部的元素或者组件</p><h1 id="设置ref的3种方法"><a href="#设置ref的3种方法" class="headerlink" title="设置ref的3种方法"></a>设置ref的3种方法</h1><h2 id="设置为字符串（已废弃）"><a href="#设置为字符串（已废弃）" class="headerlink" title="设置为字符串（已废弃）"></a>设置为字符串（已废弃）</h2><pre><code class="jsx">  &lt;Child ref=&quot;child&quot;&gt;&lt;/Child&gt;</code></pre><h2 id="使用React-createRef"><a href="#使用React-createRef" class="headerlink" title="使用React.createRef()"></a>使用<code>React.createRef()</code></h2><pre><code class="jsx">class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = React.createRef()    &#125;    handleClick = () =&gt; &#123;        console.log(this.childRef.current) // Child组件实例，可以访问Child上的state和方法    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child ref=&#123;this.childRef&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;</code></pre><h2 id="使用回调函数"><a href="#使用回调函数" class="headerlink" title="使用回调函数"></a>使用回调函数</h2><p><code>React</code> 也支持另一种设置 <code>refs</code> 的方式，称为“回调 <code>refs</code>”。它能助你更精细地控制何时 <code>refs</code> 被设置和解除。</p><p>不同于传递 <code>createRef()</code> 创建的 <code>ref</code> 属性，你会传递一个函数。这个函数中接受 <code>React</code> 组件实例或 <code>HTML DOM</code> 元素作为参数，以使它们能在其他地方被存储和访问。</p><pre><code class="jsx">class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childInput = null;    &#125;    handleClick = () =&gt; &#123;        console.log(this.childInput)    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child ref=&#123;el =&gt; this.childInput = el&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;</code></pre><p>如果 <code>ref</code> 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数绑定的<code>DOM</code>元素或者组件。这是因为在每次渲染时会创建一个新的函数实例，所以 <code>React</code> 清空旧的 <code>ref</code> 并且设置新的。通过将 <code>ref</code> 的回调函数定义成 <code>class</code> 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p><pre><code class="javascript">import React from &#39;react&#39;import Child from &#39;./Child&#39;class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = null;        this.state = &#123;            count: 0        &#125;    &#125;    handleClick = () =&gt; &#123;        this.setState(&#123;            count: this.state.count + 1        &#125;)    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child ref=&#123;el =&gt; &#123;console.log(el); this.childRef = el&#125;&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><h1 id="ref转发"><a href="#ref转发" class="headerlink" title="ref转发"></a>ref转发</h1><p>为什么需要转发？如果我们给一个组件设置<code>ref</code>，那么这个<code>ref</code>是该组件实例，那如果我们需要封装一个组件，在外部调用它的时候，给他设置<code>ref</code>，则直接抛出组件内部的<code>DOM</code>元素，这就需要用到转发了；</p><p>转发的方式有两种，一个是使用<code>React.forwardRef</code> api，另一个是作为<strong>额外属性</strong>传递；</p><p>注意，不管是以何种方式定义的<code>ref</code>，转发都会转发到对应的<code>DOM</code>元素或者组件；</p><h2 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef"></a>React.forwardRef</h2><p><code>forwardRef</code>接收一个函数作为参数，该函数有两个入参，一个是<code>props</code>，另一个就是需要传递的<code>ref</code>，由于<code>React</code>内部把<code>ref</code>属性<strong>从props中过滤掉了</strong>，因此我们需要单独的接受<code>ref</code>，我们可以指定这个从父组件传过来的<code>ref</code>具体绑定到哪个元素上；</p><pre><code class="jsx">import React from &#39;react&#39;import Child from &#39;./Child&#39;class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = React.createRef()    &#125;    handleClick = () =&gt; &#123;        console.log(this.childRef.current) // Child组件的input元素    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child ref=&#123;this.childRef&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><pre><code class="jsx">import React from &#39;react&#39;const Child = React.forwardRef((props, ref) =&gt; &#123;    return         &lt;div&gt;            &lt;p&gt;Child&lt;/p&gt;            &lt;input ref=&#123;ref&#125;&gt;&lt;/input&gt;        &lt;/div&gt;&#125;)export default Child</code></pre><p>可以看到，像上面的写法我们只能返回一个函数式组件，那么要返回一个<code>class</code>组件，要怎么写呢，此时我们需要额外的包装一层，有点类似高阶组件，实际上高阶组件中传递<code>ref</code>也是通过下面这种方式的，由于<code>ref</code>不会通过<code>props</code>传递给子组件，因此需要一个额外的属性来传递<code>ref</code></p><pre><code class="jsx">import React from &#39;react&#39;class Child extends React.Component &#123;    constructor(props)&#123;        super(props)    &#125;    render() &#123;        return &lt;&gt;            &lt;div&gt;                &lt;p&gt;Child&lt;/p&gt;                &lt;input ref=&#123;this.props.forwardRef&#125;&gt;&lt;/input&gt;            &lt;/div&gt;        &lt;/&gt;    &#125;&#125;const wrappedChild = React.forwardRef((props, ref) =&gt; &#123;    // 注意透传props    return &lt;Child &#123;...props&#125; forwardRef=&#123;ref&#125; /&gt;&#125;)export default wrappedChild</code></pre><h2 id="作为属性传递"><a href="#作为属性传递" class="headerlink" title="作为属性传递"></a>作为属性传递</h2><p>其实上述的例子中已经用到了作为属性传递<code>ref</code>的特性，由于<code>ref</code>不会存在于<code>props</code>中，因此需要额外的通过一个属性进行传递，这里就不举例子了。</p><p>额外的属性除了可以传递<code>createRef</code>的值之外，还可以传递一个回调<code>refs</code>，作用和<code>createRef</code>一样，两者并没有什么明显区别</p><pre><code class="javascript">class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.childRef = null;        this.state = &#123;            count: 0        &#125;    &#125;    handleClick = () =&gt; &#123;        this.setState(&#123;            count: this.state.count + 1        &#125;)    &#125;    render() &#123;        return &lt;&gt;            &lt;p&gt;Parent&lt;/p&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;            &lt;Child forwardRef=&#123;el =&gt; &#123;console.log(el); this.childRef = el&#125;&#125;&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><pre><code class="javascript">class Child extends React.Component &#123;    constructor(props)&#123;        super(props)        this.state = &#123;            count: 0        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;div&gt;                &lt;p&gt;Child&lt;/p&gt;                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;                &lt;input ref=&#123;this.props.forwardRef&#125;&gt;&lt;/input&gt;            &lt;/div&gt;        &lt;/&gt;    &#125;&#125;   export default Child</code></pre><h1 id="displayName"><a href="#displayName" class="headerlink" title="displayName"></a>displayName</h1><p>在 <code>DevTools</code> 中显示自定义名称，例如下面的子组件，在<code>DevTools</code>中会显示为<code>Child ForwardRef</code>，否则会显示<code>Anonymous ForwardRef</code></p><pre><code class="javascript">const Child = React.forwardRef((props, ref) =&gt; &#123;    return &lt;div&gt;                &lt;p&gt;Child&lt;/p&gt;                &lt;input ref=&#123;ref&#125;&gt;&lt;/input&gt;            &lt;/div&gt;&#125;)Child.displayName = &#39;Child&#39;export default Child</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 跨层组件树传值-context上下文</title>
      <link href="/2021/08/10/React-%E8%B7%A8%E5%B1%82%E7%BB%84%E4%BB%B6%E6%A0%91%E4%BC%A0%E5%80%BC-context%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2021/08/10/React-%E8%B7%A8%E5%B1%82%E7%BB%84%E4%BB%B6%E6%A0%91%E4%BC%A0%E5%80%BC-context%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>跨层组件树传值，可以使用<code>context</code>上下文来处理，先要定义一个上下文，然后在子孙组件中进行消费</p><p>详细文档查看<a href="https://zh-hans.reactjs.org/docs/context.html">React官网</a></p><h1 id="创建context"><a href="#创建context" class="headerlink" title="创建context"></a>创建context</h1><p>首先需要创建一个<code>context</code>，可以给定一个默认值，当消费组件上没有<code>Provider</code>的时候，使用默认值。</p><p>然后通过上面的Provider指定想要传递的数据</p><p><code>colorCtx.js</code></p><pre><code class="javascript">import &#123; createContext &#125; from &#39;react&#39;export const ColorCtx = createContext(&quot;red&quot;)    </code></pre><p>然后通过<code>CTX.Provider</code> 组件，绑定一个<code>value</code>，用来传递给子孙组件，这里我我们绑定一个<code>&#123;color: &#39;green&#39;&#125;</code>状态</p><pre><code class="jsx">import React from &#39;react&#39;import Child from &#39;./Child&#39;import &#123; ColorCtx &#125; from &#39;./context&#39;class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.state = &#123;            color: &#39;green&#39;        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Provider value=&#123;this.state.color&#125;&gt;                &lt;p&gt;Parent&lt;/p&gt;                &lt;Child&gt;&lt;/Child&gt;            &lt;/ColorCtx.Provider&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><h1 id="消费context"><a href="#消费context" class="headerlink" title="消费context"></a>消费<code>context</code></h1><p>下面我们就可以在子孙组件里面消费绑定的value了，有以下几种方式可以消费</p><ul><li><p>使用<code>consumer</code>消费</p><p>在使用<code>consumer</code>的时候，不能在生命周期中获取到上下文的信息，只能在<code>consumer</code>里面获取到，同时如果需要同时消费多个<code>Provider</code>，也只能使用<code>consumer</code>消费</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; ColorCtx &#125; from &#39;./context&#39;class Child extends React.Component &#123;    constructor(...props) &#123;        super(...props)    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Consumer&gt;                &#123;value =&gt; &lt;div&gt;                    &lt;p style=&#123;&#123;color: value&#125;&#125;&gt;Child&lt;/p&gt;                &lt;/div&gt;&#125;            &lt;/ColorCtx.Consumer&gt;        &lt;/&gt;    &#125;&#125;export default Child</code></pre></li><li><p>使用静态方法<code>contentType</code>消费</p><p>通过指定<code>contentType</code>，来消费<code>Provider</code>，取值的时候就可以使用<code>this.context</code>取值</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; ColorCtx &#125; from &#39;./context&#39;class Child extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.state = &#123;            color: &#39;green&#39;        &#125;    &#125;    // 定义了这个，会把this.context 映射到 vlue    static contextType = ColorCtx    render() &#123;        return &lt;&gt;            &lt;div&gt;                &lt;p style=&#123;&#123;color: this.context&#125;&#125;&gt;Child&lt;/p&gt;            &lt;/div&gt;        &lt;/&gt;    &#125;&#125;//上面的 static contextType = ColorCtx 也可以使用这种方法指定// Child.contextType = ColorCtxexport default Child</code></pre></li><li><p>消费多个<code>Provider</code></p><ol><li>创建多个context</li></ol><pre><code class="javascript">import &#123;createContext&#125; from &#39;react&#39;export const ColorCtx = createContext(&#39;red&#39;)export const BackColorCtx = createContext(&#39;white&#39;)</code></pre><ol start="2"><li>在父组件中提供多个<code>Provider</code></li></ol><pre><code class="jsx">import React from &#39;react&#39;import Child from &#39;./Child&#39;import &#123; ColorCtx, BackColorCtx &#125; from &#39;./context&#39;class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.state = &#123;            color: &#39;green&#39;,            backColor: &#39;black&#39;        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Provider value=&#123;this.state.color&#125;&gt;                &lt;BackColorCtx.Provider value=&#123;this.state.backColor&#125;&gt;                    &lt;p&gt;Parent&lt;/p&gt;                    &lt;Child&gt;&lt;/Child&gt;                &lt;/BackColorCtx.Provider&gt;            &lt;/ColorCtx.Provider&gt;        &lt;/&gt;    &#125;&#125;export default Parent</code></pre><ol start="3"><li>在子孙组件中进行消费</li></ol><pre><code class="jsx">import React from &#39;react&#39;import &#123; ColorCtx, BackColorCtx &#125; from &#39;./context&#39;class Child extends React.Component &#123;    constructor(...props) &#123;        super(...props)    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Consumer&gt;                &#123; color =&gt;                     &lt;BackColorCtx.Consumer&gt;                        &#123; backColor =&gt;                             &lt;div&gt;                                &lt;p style=&#123;&#123;color: color, backgroundColor: backColor&#125;&#125;&gt;Child&lt;/p&gt;                            &lt;/div&gt;                        &#125;                    &lt;/BackColorCtx.Consumer&gt;                &#125;            &lt;/ColorCtx.Consumer&gt;        &lt;/&gt;    &#125;&#125;export default Child</code></pre></li></ul><h1 id="default默认值"><a href="#default默认值" class="headerlink" title="default默认值"></a><code>default</code>默认值</h1><p>如果说子孙组件没有提供<code>Provider</code>，则子组件的消费者的value会被赋予默认值。</p><p>例如第二个子组件<code>Child</code>没有提供<code>Provider</code>，则<code>Child</code>会被渲染成红色，就是上面<code>export const ColorCtx = createContext(&#39;red&#39;)</code>指定的</p><pre><code class="jsx">class Parent extends React.Component &#123;    constructor(...props) &#123;        super(...props)        this.state = &#123;            color: &#39;green&#39;,            backColor: &#39;black&#39;        &#125;    &#125;    render() &#123;        return &lt;&gt;            &lt;ColorCtx.Provider value=&#123;this.state.color&#125;&gt;                &lt;p&gt;Parent&lt;/p&gt;                &lt;Child&gt;&lt;/Child&gt;            &lt;/ColorCtx.Provider&gt;            &lt;Child&gt;&lt;/Child&gt;        &lt;/&gt;    &#125;&#125;</code></pre><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>当<code>context</code>的<code>value</code>发生变化的时候，会引发子组件的更新，在<code>React</code>内部，很暴力，直接使用<code>===</code>进行对比新旧值，那如果我们使用类似<code>&lt;ColorCtx.Provider value=&#123;&#123;someValue: 'value'&#125;&#125;&gt;</code>的方式传递<code>value</code>，内部比较直接<code>&#123;someValue: &#39;value&#39;&#125; === &#123;someValue: &#39;value&#39;&#125;</code>，此时永远都是<code>false</code>，子组件就会更新，造成性能问题，我们的解决方法是把<code>value</code>放到<code>state</code>中，传递的是<code>state</code>里的值，就像上述例子里那样，这样的话，值没变子组件就不会更新了。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 受控组件和非受控组件</title>
      <link href="/2021/08/10/React-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
      <url>/2021/08/10/React-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>什么是受控组件和非受控组件，这两个东西都是基于表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）来讨论的，其他类型的标签不存在受控和非受控的说法，那么，受控和非受控，控制的是什么呢，实际上就是控制表单元素的<code>value</code>，原生的表单元素<code>value</code>是元素自身维护的，我们不需要关心<code>value</code>的改变具体要怎么做，最后提交的时候拿到<code>value</code>就行了，而受控组件就是把表单元素的<code>value</code>拿来自己维护，不使用其自身的特性，非受控组件就需要依赖元素自身的<code>value</code>管理来实现</p><p>以<code>&lt;input&gt;</code>元素为例，我们原生的使用方式是这样的</p><pre><code class="html">&lt;form action=&quot;&quot; id=&quot;form&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;script&gt;    document.querySelector(&#39;#form&#39;).addEventListener(&#39;submit&#39;, (e) =&gt; &#123;        let textInput = document.querySelector(&#39;#text&#39;)        console.log(textInput.value)        e.preventDefault()    &#125;)&lt;/script&gt;</code></pre><p>我们只是在提交的时候拿到表单的<code>value</code>，其中是如何修改<code>value</code>的我们并不关心</p><p>那我们在<code>React</code>中使用表单元素的时候，受控组件怎么做，非受控组件怎么做，下面来看看。</p><h1 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h1><p>我们上面说了，受控组件控制的是表单元素的<code>value</code>值，因此我们需要在组件内部自己维护<code>value</code>，然后赋值给表单，自己也需要定义方法来更新<code>value</code></p><p>通过下面代码，我们就定义了一个受控组件，我们自己组件内部维护了一个<code>value</code>值，绑定给了<code>&lt;input&gt;</code>元素，并且<code>value</code>的更新都是我们自己控制。</p><pre><code class="jsx">import React from &#39;react&#39;class ControlledComp extends React.Component &#123;    constructor(props) &#123;        super(props)        this.state = &#123;            value: &#39;&#39;        &#125;    &#125;    handleChange = (e) =&gt; &#123;        this.setState(&#123;            value: e.target.value        &#125;)    &#125;    submit = () =&gt; &#123;      console.log(this.state.value)    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;input name=&quot;text&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.value&#125; /&gt;                &lt;button onClick=&#123;this.submit&#125;&gt;提交&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default ControlledComp</code></pre><h1 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h1><p>非受控组件我们组件内部不需要维护一个<code>value</code>值，也不用我们自己定义函数去更新<code>value</code>，而是交由表单元素自己去做，我们只需要拿到表单元素获取<code>value</code>就可以了</p><pre><code class="jsx">import React, &#123;createRef&#125; from &#39;react&#39;class UnControlledComp extends React.Component &#123;    constructor(props) &#123;        super(props)        this.inputRef = createRef()    &#125;    submit = () =&gt; &#123;      console.log(this.inputRef.current.value)    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;input name=&quot;text&quot; ref=&#123;this.inputRef&#125; /&gt;                &lt;button onClick=&#123;this.submit&#125;&gt;提交&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default UnControlledComp</code></pre><p>我们表单元素不止有<code>&lt;input&gt;</code>，还有<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等，在<code>&lt;select&gt;</code>上我们绑定的值并不是<code>value</code>，而是<code>checked</code>，这就需要我们做进一步处理，下面是一个更复杂的例子</p><pre><code class="jsx">class Reservation extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      isGoing: true,      numberOfGuests: 2    &#125;;    this.handleInputChange = this.handleInputChange.bind(this);  &#125;  handleInputChange(event) &#123;    const target = event.target;    const value = target.type === &#39;checkbox&#39; ? target.checked : target.value;    const name = target.name;    this.setState(&#123;      [name]: value    &#125;);  &#125;  render() &#123;    return (      &lt;form&gt;        &lt;label&gt;          参与:          &lt;input            name=&quot;isGoing&quot;            type=&quot;checkbox&quot;            checked=&#123;this.state.isGoing&#125;            onChange=&#123;this.handleInputChange&#125; /&gt;        &lt;/label&gt;        &lt;br /&gt;        &lt;label&gt;          来宾人数:          &lt;input            name=&quot;numberOfGuests&quot;            type=&quot;number&quot;            value=&#123;this.state.numberOfGuests&#125;            onChange=&#123;this.handleInputChange&#125; /&gt;        &lt;/label&gt;      &lt;/form&gt;    );  &#125;&#125;</code></pre><blockquote><p>上述例子来自<a href="https://zh-hans.reactjs.org/docs/forms.html#handling-multiple-inputs">React官网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 事件处理函数以及传参</title>
      <link href="/2021/08/10/React-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%BC%A0%E5%8F%82/"/>
      <url>/2021/08/10/React-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%BC%A0%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<p>在React class组件中，给事件绑定处理函数需要注意一下this的指向，还有获取事件对象以及函数的传参，我们将分几种情况看看到底该怎么做</p><h1 id="普通函数形式"><a href="#普通函数形式" class="headerlink" title="普通函数形式"></a>普通函数形式</h1><p>如果使用function函数声明一个事件处理函数，我们需要特别注意this的指向，在constructor中修改this的指向或者直接在绑定的时候修改，并且事件对象会默认追加到入参<strong>尾部</strong>。</p><p>如果给处理函数传参了，事件对象是追加到所有入参的尾部的</p><pre><code class="javascript">import React from &#39;react&#39;;class Com1 extends React.Component &#123;  constructor(...props) &#123;    super(...props)    this.handler1 = this.handler.bind(this)  &#125;  handler1(e) &#123;    console.log(e)  // Event  &#125;  handler2(e) &#123;    console.log(e)  // Event  &#125;  handler3(arg1, arg2, e) &#123;    console.log(arg1)   // 123    console.log(arg2)   // 456    console.log(e)      // Event  &#125;  render () &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handler1&#125;&gt;点击&lt;/button&gt;        &lt;button onClick=&#123;this.handler2.bind(this)&#125;&gt;点击&lt;/button&gt;        &lt;button onClick=&#123;this.handler3.bind(this, 123, 456)&#125;&gt;点击&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;export default Com1</code></pre><h1 id="箭头函数形式"><a href="#箭头函数形式" class="headerlink" title="箭头函数形式"></a>箭头函数形式</h1><p>箭头函数和普通函数不一样，不用特别处理this的指向问题，</p><ul><li>如果不需要传参，则事件对象默认传入</li><li>如果需要传参，则必须重新声明一个函数</li><li>如果需要同时传参和事件对象，则新声明函数需要手动传入事件对象</li></ul><pre><code class="javascript">import React from &#39;react&#39;;class Com1 extends React.Component &#123;  constructor(...props) &#123;    super(...props)  &#125;  handler1 = (e) =&gt; &#123;    console.log(e)  // Event  &#125;  handler2 = (arg1, arg2, e) =&gt; &#123;    console.log(arg1)  // 123    console.log(arg2)  // 456    console.log(e)  // undefined  &#125;  handler3(e, arg1, arg2) &#123;    console.log(e)      // Event    console.log(arg1)   // 123    console.log(arg2)   // 456  &#125;  render () &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handler1&#125;&gt;点击&lt;/button&gt;        &lt;button onClick=&#123;() =&gt; this.handler2(123, 456)&#125;&gt;点击&lt;/button&gt;        &lt;button onClick=&#123;(e) =&gt; this.handler3(e, 123, 456)&#125;&gt;点击&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;export default Com1</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React render props模式</title>
      <link href="/2021/08/10/React-render-props%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/08/10/React-render-props%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>render props</code>模式是封装组件的其中一种方式，由外部指定需要渲染的元素，组件内部把状态传递给它，外部声明一个函数式的<code>props</code>，函数参数接收内部状态，返回需要渲染的元素</p><pre><code class="jsx">import React from &#39;react&#39;class Mouse extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      x: 0,      y: 0    &#125;  &#125;  moveHandle = e =&gt; &#123;    this.setState(&#123;      x: e.clientX,      y: e.clientY    &#125;)  &#125;  componentDidMount () &#123;    window.addEventListener(&#39;mousemove&#39;, this.moveHandle)  &#125;  componentWillUnmount() &#123;    window.removeEventListener(&#39;mousemove&#39;, this.moveHandle)  &#125;  render () &#123;    // render props模式，这里渲染的是外面调用的时候传过来的函数的返回值，同时把组件内部的状态传递给外面的函数    // 外面的传递过来的函数不一定要叫render，任何名字都行，同时还可以把函数放在props.children里面    // 这种使用方式被称之为render props模式，实现组件的复用    return this.props.render(this.state)  &#125;&#125;export default Mouse</code></pre><p>使用</p><pre><code class="jsx">&lt;Mouse render=&#123;mouse =&gt; &lt;h1&gt;rendre props-鼠标位置：&#123;mouse.x&#125;,&#123;mouse.y&#125;&lt;/h1&gt;&#125;&gt;&lt;/Mouse&gt;</code></pre><p>上面是一个简单的<code>render props</code>例子，注意，我们并不是只能使用<code>render</code>作为属性，随便叫什么属性都行，组件内部用法协商好就行</p><p>除了在属性上给定函数，还可以直接在<code>children</code>中使用，例如</p><pre><code class="javascript">&lt;Mouse&gt;  &#123;mouse =&gt; &lt;h1&gt;rendre props-鼠标位置：&#123;mouse.x&#125;,&#123;mouse.y&#125;&lt;/h1&gt;&#125;&lt;/Mouse&gt;</code></pre><p>此时组件内部就需要使用<code>children</code>获取渲染函数</p><pre><code class="javascript">render () &#123;    return this.props.children(this.state)  &#125;</code></pre><p>由于这一技术的特殊性，当你在设计一个类似的 <code>API</code> 时，你或许会要直接地在你的 <code>propTypes</code> 里声明 <code>children</code> 的类型应为一个函数。</p><pre><code class="javascript">Mouse.propTypes = &#123;  children: PropTypes.func.isRequired&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React setState需要注意的地方</title>
      <link href="/2021/08/10/React-setState%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/2021/08/10/React-setState%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<p>函数内部多次调用<code>setState</code>，会将所有的<code>setState</code>操作进行合并，如果有修改到相同的属性，谁在最后执行谁，例如下面调用3次<code>setState</code>，<code>count</code>初始值是<code>0</code>，依次修改<code>count</code>的值，分别加1，加2，加3，最终<code>count</code>的值会被修改为3，而不是6</p><pre><code class="jsx">import React from &#39;react&#39;class Counter extends React.Component &#123;    constructor(props) &#123;        super(props)        this.state = &#123;            count: 0,        &#125;    &#125;    clickHandle = () =&gt; &#123;        this.setState(&#123;            count: this.state.count + 1        &#125;)        this.setState(&#123;            count: this.state.count + 2        &#125;)        this.setState(&#123;            count: this.state.count + 3        &#125;)    &#125;    render () &#123;        console.log(&#39;render&#39;);        return (            &lt;div&gt;                &lt;h1 id=&quot;title&quot;&gt;计数器：&#123;this.state.count&#125;&lt;/h1&gt;                &lt;button onClick=&#123;this.clickHandle&#125;&gt;+1&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default Counter</code></pre><p>如果我们想要结果为6，就是都执行的话，需要给<code>setState</code>传入一个函数，函数的入参分别是最新的<code>state</code>和最新的<code>props</code>，可以进行解构，得到自己想要的值，下面的<code>setState</code>执行了3次，每次都拿到了最新的<code>state</code>，因此<code>count</code>最终会被修改为6</p><pre><code class="javascript">// ...clickHandle = () =&gt; &#123;    this.setState((state, props) =&gt; &#123;        console.log(state);          // &#123;count: 0&#125;        return &#123;            count: state.count + 1        &#125;    &#125;)    this.setState((state, props) =&gt; &#123;        console.log(state);          // &#123;count: 1&#125;        return &#123;            count: state.count + 2        &#125;    &#125;)    this.setState((&#123;count&#125;, props) =&gt; &#123;        console.log(count);          // 3        return &#123;            count: state.count + 2        &#125;    &#125;)&#125;</code></pre><p>我们设置了<code>setState</code>，怎么拿到最新的值呢？直接在<code>setState</code>后面获取行不行？答案是不行，因为<code>setState</code>是<strong>异步</strong>的，因此每次拿到的都是初始值，也就是<code>0</code></p><pre><code class="javascript">// ...clickHandle = () =&gt; &#123;    this.setState((state, props) =&gt; &#123;        console.log(state);          // &#123;count: 0&#125;        return &#123;            count: state.count + 1        &#125;    &#125;)    // 这里获取到的值是0，因为setState是异步的    console.log(this.state.count) // 0&#125;</code></pre><p>那有什么方法可以拿到修改后的值呢？我们可以给<code>setState</code>传入第二个参数，是一个函数，可以拿到<code>setState</code>修改后的值，但是请注意，是<strong>所有setState合并执行后的值</strong>！</p><pre><code class="javascript">// ...clickHandle = () =&gt; &#123;    this.setState((state, props) =&gt; &#123;        return &#123;            count: state.count + 1        &#125;    &#125;, () =&gt; &#123;        console.log(&#39;更新后的状态：&#39;, this.state.count);  // 2    &#125;)    this.setState((state, props) =&gt; &#123;        return &#123;            count: state.count + 1        &#125;    &#125;, () =&gt; &#123;        console.log(&#39;更新后的状态：&#39;, this.state.count);  // 2    &#125;)&#125;</code></pre><p>除了上面的方式使得我们可以同步设置<code>state</code>，还有其他一些方法，但是我们只推荐使用上面的方法，下面的方法都<strong>不建议</strong>使用</p><ul><li><p>定时器</p><pre><code class="javascript">// ...  clickHandle = () =&gt; &#123;  setTimeout(() =&gt; &#123;    this.setState(&#123; count: this.state.count + 1 &#125;)    console.log(this.state.count);  // 这里获取到的就是修改后的count 1  &#125;, 0)  setTimeout(() =&gt; &#123;    this.setState(&#123; count: this.state.count + 1 &#125;)    console.log(this.state.count);  // 这里获取到的就是修改后的count 2  &#125;, 0)&#125;</code></pre></li><li><p>原生事件中修改状态</p><pre><code class="javascript">// ...clickHandle = () =&gt; &#123;  this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count);    // 这里获取到的就是修改后的count 1  this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count);    // 这里获取到的就是修改后的count 2&#125;  componentDidMount() &#123;  this.btnRef.addEventListener(&#39;click&#39;, this.clickHandle, false)&#125;</code></pre></li><li><p>使用<code>async</code>&#x2F;<code>await</code> (不规范，不建议使用)</p><pre><code class="javascript">clickHandle = async () =&gt; &#123;  await this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count);  // 这里获取到的就是修改后的count 1  await this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count);  // 这里获取到的就是修改后的count 2&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React hooks知识点整理</title>
      <link href="/2021/08/10/React-hooks%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2021/08/10/React-hooks%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Hook-使用规则"><a href="#Hook-使用规则" class="headerlink" title="Hook 使用规则"></a>Hook 使用规则</h1><p><code>Hook</code> 就是 <code>JavaScript</code> 函数，但是使用它们会有两个额外的规则：</p><ul><li>只能在函数最外层调用 <code>Hook</code>。不要在循环、条件判断或者子函数中调用。</li><li>只能在 <code>React</code> 的函数组件中调用 <code>Hook</code>。不要在其他 <code>JavaScript</code> 函数中调用，还可以在自定义<code>Hook</code>中调用其他<code>Hook</code></li></ul><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><pre><code class="javascript">const [state, setState] = useState(initialState);</code></pre><p>返回一个 <code>state</code>，以及更新 <code>state</code> 的函数。</p><p>在初始渲染期间，返回的状态 (<code>state</code>) 与传入的第一个参数 (<code>initialState</code>) 值相同。</p><p><code>setState</code> 函数用于更新 <code>state</code>。它接收一个新的 <code>state</code> 值并将组件的一次重新渲染加入队列。</p><p>在后续的重新渲染中，<code>useState</code> 返回的第一个值将始终是更新后最新的 <code>state</code>。</p><p>在<code>class</code>中<code>state</code>只能作为对象，但在<code>useState</code> hook中不仅仅可以使用对象，还可以使用数组，数字，字符串等;</p><pre><code class="javascript">export default function CountHooks () &#123;  const [count, setCount] = useState(0)  // setState会合并，取最后一次更新的值，因此调用这个函数，每次只会加1，而不是4  function changeCount () &#123;    setCount(count + 3)    setCount(count + 1)  &#125;  return (    &lt;div&gt;      &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;+1&lt;/button&gt;      &lt;button onClick=&#123;changeCount&#125;&gt;changeCount&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>注意！和<code>class</code>组件的<code>setState</code>一样，会合并调用，谁在最后执行谁，因此上面代码中每次调用<code>changeCount</code>函数，每次<code>count</code>还是加1，不是加4也不是加3</p><h2 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h2><p>如果新的 <code>state</code> 需要通过使用先前的 <code>state</code> 计算得出，那么可以将函数传递给 <code>setState</code>。该函数将接收先前的 <code>state</code>，并返回一个更新后的值。</p><pre><code class="javascript">export default function CountHooks () &#123;  const [count, setCount] = useState(0)  function changeCount () &#123;    setCount(count =&gt; &#123;      return count + 1    &#125;)    setCount(count =&gt; &#123;      return count + 1    &#125;)  &#125;  return (    &lt;div&gt;      &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count =&gt; count + 1) &#125;&#125;&gt;+1&lt;/button&gt;      &lt;button onClick=&#123;changeCount&#125;&gt;+2&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; setCount(0)&#125;&gt;reset&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h2 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h2><p>惰性初始化，<code>useState</code>中传入一个函数即可，这个函数只会在初始化的时候调用一次，后面组件重新渲染的时候并不会再次调用，提高性能</p><p>如果下面不使用函数，而是直接<code>fib(40)</code>，这是函数的调用，这会在每次渲染的时候都执行一遍该函数，每当点击按钮一次，就会重新计算一次，此时页面会夯住。即使后续的重新渲染不会用到，但也会执行。</p><pre><code class="javascript">import React, &#123; useState &#125; from &#39;react&#39;function fib (n) &#123;  if (n == 1 || n == 2) return 1  return fib(n - 1) + fib(n - 2)&#125;export default function Comp () &#123;  const [result] = useState(() =&gt; fib(40))  const [count, setCount] = useState(0)  function handleClick () &#123;    setCount(c =&gt; c + 1)  &#125;  return (    &lt;div&gt;      &lt;p&gt;&#123;result&#125;&lt;/p&gt;      &lt;p&gt;&#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;handleClick&#125;&gt;+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>如果<code>useState</code>初始值是一个对象或数组，<code>setState</code>并不会进行对象的合并，需要自己使用扩展语法进行扩展，如果下面的代码不对<code>count</code>进行扩展，则<code>label</code>属性会丢失</p><pre><code class="javascript">export default function CountHooks () &#123;  const [count, setCount] = useState(&#123;sum: 0, label: &#39;个数&#39;&#125;)  function changeCount () &#123;    setCount(count =&gt; &#123;      return &#123;...count, sum: count.sum + 1&#125;    &#125;)  &#125;  return (    &lt;div&gt;      &lt;p&gt;&#123;count.label&#125;: &#123;count.sum&#125;&lt;/p&gt;      &lt;button onClick=&#123;changeCount&#125;&gt;+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><p><code>useEffect</code>的用法查看官网<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect">React 官网-useEffect</a></p><p>下面通过一个例子解释下其运行机制</p><pre><code class="javascript">import React, &#123; useState, useEffect &#125; from &#39;react&#39;export default function TimerHooks () &#123;  console.log(&#39;function start run &#39; + Date.now())  const [date, setDate] = useState(new Date())  useEffect(() =&gt; &#123;    console.log(&#39;timer hooks 的effect执行了&#39;, date);    let timerId = setInterval(() =&gt; &#123;      setDate(new Date())    &#125;, 1000)  &#125;);  console.log(&#39;function end run &#39; + Date.now())  return (    &lt;div&gt;      &lt;p&gt;时间: &#123;date.toLocaleTimeString()&#125;&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><ul><li>组件初次挂载，会开启一个定时器，每隔1s更新一下当前时间</li><li>我们什么也不做，此时副作用内部又更新了state，会导致组件更新，又开启定时器，无限循环，性能极差<br><img src="/images/hooks1.gif"></li></ul><p>此时我们给定一个清除副作用的函数</p><pre><code class="javascript">useEffect(() =&gt; &#123;  console.log(&#39;timer hooks 的effect执行了&#39;, date);  let timerId = setInterval(() =&gt; &#123;    setDate(new Date())  &#125;, 1000)  return () =&gt; &#123;    console.log(&#39;取消副作用&#39;);    clearInterval(timerId)  &#125;&#125;);</code></pre><ul><li>组件初次挂载，会开启一个定时器，每隔1s更新一下当前时间</li><li>组件更新前，先取消副作用，清除了定时器，然后再重新设置一个定时器</li></ul><p>这样做看似没什么问题，但是如果我们有其他状态也变化了呢，此时也会取消定时器，导致异常</p><p>我们加一个按钮，修改一下count</p><pre><code class="javascript">import React, &#123; useState, useEffect &#125; from &#39;react&#39;export default function TimerHooks () &#123;  console.log(&#39;function start run &#39; + Date.now())  const [date, setDate] = useState(new Date())  const [count, setCount] = useState(0)  useEffect(() =&gt; &#123;    console.log(&#39;timer hooks 的effect执行了&#39;, date);    let timerId = setInterval(() =&gt; &#123;      setDate(new Date())    &#125;, 1000)    return () =&gt; &#123;      console.log(&#39;取消副作用&#39;);      clearInterval(timerId)    &#125;  &#125;);  console.log(&#39;function end run &#39; + Date.now())  return (    &lt;div&gt;      &lt;p&gt;时间: &#123;date.toLocaleTimeString()&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>疯狂点击按钮，此时页面上的事件会停住，因为我们点击按钮，也会导致组件更新，此时先清除定时器，再设置，由于我们点得非常快，定时器一直在被清除，因此页面时间显示会卡住，观察下图时间显示<br><img src="/images/hooks2.gif"></p><p>那此时要怎么做，这时我们可以给useEffect传入第二个参数，是一个依赖数组，我们直接传入一个空数组，此时这个effect只在挂载的时候执行一次，卸载的时候清除副作用，组件再怎么更新就与这个effect无关了</p><pre><code class="javascript">  // ...  useEffect(() =&gt; &#123;    console.log(&#39;timer hooks 的effect执行了&#39;, date);    let timerId = setInterval(() =&gt; &#123;      setDate(new Date())    &#125;, 1000)    return () =&gt; &#123;      console.log(&#39;取消副作用&#39;);      clearInterval(timerId)    &#125;  &#125;, []); // 这里传入一个空数组</code></pre><p>此时所有问题就都被解决了<br><img src="/images/hooks3.gif"></p><h1 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h1><p><code>useContext</code>接收一个 <code>context</code> 对象（<code>React.createContext</code> 的返回值）并返回该 <code>context</code> 的当前值。当前的 <code>context</code> 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> <code>prop</code> 决定。</p><p>使用<code>useContext</code>只是让我们允许在函数组件中能接收到<code>context</code>的值，但仍然需要在上层组件中使用<code>Provider</code>来提供<code>value</code></p><pre><code class="javascript">import React, &#123; useContext &#125; from &#39;react&#39;const myContext = React.createContext()const Provider = myContext.Providerexport default function ContextHooks () &#123;  const store = &#123;    user: &#123;      name: &#39;jerry&#39;,      age: 18    &#125;  &#125;  return (    &lt;Provider value=&#123;store&#125;&gt;      &lt;Child&gt;&lt;/Child&gt;    &lt;/Provider&gt;  )&#125;const Child = props =&gt; &#123;  console.log(useContext(myContext));  const &#123; user &#125; = useContext(myContext)  return &lt;div&gt;    &lt;h1&gt;user: &#123;user.name&#125;&lt;/h1&gt;  &lt;/div&gt;&#125;</code></pre><h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><p><code>useReducer</code>就像一个小型的<code>redux</code>，对于比较复杂的<code>state</code>，我们建议通过使用<code>useReducer</code>来声明状态，而不是<code>useState</code></p><p>我们还可以把<code>dispatch</code>函数向子组件传递，用来修改父组件的状态，不用父组件内部再定义一个回调函数了。</p><p><code>useReducer</code>和<code>useState</code>一样，不仅可以使用对象作为初始值，还可以使用数组，数字，字符串等，和<code>redux</code>的区别是，<code>redux</code>可以将初始状态通过默认参数直接传递给<code>state</code>，但是在<code>useReducer</code>中，初始状态只能通过<code>userReducer</code>的第二个参数传入</p><p><code>useReducer</code>接收两个参数，第一个参数是<code>reducer</code>，第二个是初始值，返回最新的<code>state</code>，和<code>dispatch</code>派发<code>reducer</code>的函数</p><pre><code class="javascript">import React, &#123; useReducer &#125; from &#39;react&#39;const initCount = &#123; count: 0 &#125;function reducer (state, action) &#123;  switch (action.type) &#123;    case &#39;decrement&#39;:      return &#123; count: state.count - 1 &#125;    case &#39;increment&#39;:      return &#123; count: state.count + 1 &#125;    default:      throw new Error(&#39;unknow action type&#39;);  &#125;&#125;function ReducerCounter (props) &#123;  const [state, dispatch] = useReducer(reducer, initCount)  return (    &lt;div&gt;      &lt;h1&gt;&#123;state.count&#125;&lt;/h1&gt;      &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: &#39;decrement&#39; &#125;) &#125;&#125;&gt;-1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: &#39;increment&#39; &#125;) &#125;&#125;&gt;+1&lt;/button&gt;    &lt;/div&gt;  )&#125;export default ReducerCounter</code></pre><p><code>useReducer</code>还可以接受第三个参数，就是初始化函数，这个初始化函数将<code>userReducer</code>的第二个初始值入参作为参数，返回一个新的<code>state</code></p><pre><code class="javascript">import React, &#123; useReducer &#125; from &#39;react&#39;function init (initialCount) &#123;  return &#123; count: initialCount &#125;;&#125;function reducer (state, action) &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      return &#123; count: state.count + 1 &#125;;    case &#39;decrement&#39;:      return &#123; count: state.count - 1 &#125;;    case &#39;reset&#39;:      return init(action.payload);    default:      throw new Error();  &#125;&#125;function Counter (&#123; initialCount &#125;) &#123;  // 这里的初始值是通过props传过来的  // 这里使用init初始化函数，作用是如果需要根据传过来的数据做处理，然后再设置状态，这样就可以把数据处理方法组件外面来执行  // reducer第三个参数就是初始化数据的函数，会自动把第二个参数的值传递给该函数，再由该函数返回初始的状态值，  // 这对于复杂的处理很方便，比如需要对传入的参数进行筛选或者改造，但对于简单的，直接使用第二个参数就行了  // 而对于有重置功能的组件来说，使用第三个参数也是非常方便的  const [state, dispatch] = useReducer(reducer, initialCount, init);  return (    &lt;&gt;      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;      &lt;button        onClick=&#123;() =&gt; dispatch(&#123; type: &#39;reset&#39;, payload: initialCount &#125;)&#125;&gt;        Reset      &lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;decrement&#39; &#125;)&#125;&gt;-&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;+&lt;/button&gt;    &lt;/&gt;  );&#125;export default Counter</code></pre><pre><code class="javascript">&lt;Counter initialCount=&#123;0&#125;&gt;&lt;/Counter&gt;</code></pre><h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><p><code>useCallback</code> 第一个参数是函数，第二个参数是依赖状态的数组，返回值是函数，因此下面使用的时候要带上<code>()</code></p><p>它将返回该回调函数的 <code>memoized</code> 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p>当组件更新的时候，返回的缓存函数依然会执行，只不过执行的函数是缓存起来的函数，因此值不会发生改变</p><blockquote><p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)。但useMemo的实际用法不是这样，只是说useCallback可以使用useMemo的这种方式代替<br>useMemo缓存的是返回值，useCallback缓存的是回调函数 </p></blockquote><pre><code class="javascript">import React, &#123; useCallback, useState &#125; from &#39;react&#39;export default function HooksCallBack (props) &#123;  const [count, setCount] = useState(0)  const [price, setPrice] = useState(10)  const [any, setAny] = useState(1)  const getTotalCallback = useCallback(() =&gt; &#123;    console.log(&#39;函数执行了&#39;);    console.log(any);    return price * count    // 如果这里为空数组，那么count和price无论怎么改变，getTotalCallback函数都是缓存下来的函数，下面的总计调用永远都是那个函数，就不会更新    // 若只有一个，则只有该状态变化的时候，才会执行回调函数  &#125;, [count, price])  return (    &lt;div&gt;      &lt;p&gt;单价：&#123;price&#125;，数量：&#123;count&#125;，总计：&#123;getTotalCallback()&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setPrice(price + 1) &#125;&#125;&gt;单价+1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;数量+1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; setAny(any + 1) &#125;&#125;&gt;测试+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p><img src="/images/hooks4.gif"><br>可以看到，每次点击函数都会执行，并且只有当【单价】和【数量】有变化的时候，函数才变了，因为我们多次点击测试按钮，每次返回的都是上一次的值，而当点击单价或数量后，这个值才是最新的值。</p><h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><p><code>useMemo</code>和<code>useCallback</code>的用法类似，只不过<code>useMemo</code>缓存的是值，而<code>useCallback</code>缓存的是函数，<code>useMemo</code>返回的是缓存的具体值；</p><p>我们依然可以使用上面相同的例子，转换成<code>useMemo</code></p><pre><code class="javascript">import React, &#123; useState, useMemo &#125; from &#39;react&#39;export default function HooksCallBack (props) &#123;  const [count, setCount] = useState(0)  const [price, setPrice] = useState(10)  const [any, setAny] = useState(1)  // useMemo返回值即函数的返回值，下面使用的时候直接使用  const total = useMemo(() =&gt; &#123;    console.log(&#39;函数执行了&#39;);    console.log(any);    return price * count    // 当不在依赖状态数组里面的状态发生了变化，不会执行fn函数，返回的是上一次执行后的缓存的值  &#125;, [count, price])  return (    &lt;div&gt;      &lt;p&gt;单价：&#123;price&#125;，数量：&#123;count&#125;，总计：&#123;total&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; &#123; setPrice(price + 1) &#125;&#125;&gt;单价+1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;数量+1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; &#123; setAny(any + 1) &#125;&#125;&gt;测试+1&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p><img src="/images/hooks5.gif"></p><h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><pre><code class="javascript">const refContainer = useRef(initialValue);</code></pre><p><code>useRef</code> 返回一个<strong>可变的</strong> <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 <code>ref</code> 对象在组件的整个生命周期内持续存在。</p><p>普通用法和createRef一样，都是通过绑定ref属性来获取DOM元素或者组件实例，区别在于，在class组件中，我们在constructor中创建ref，而constructor仅在组件挂载的时候执行一次，更新阶段是不会执行的，因此在class组件中更新不会重新创建ref，在函数组件中，函数更新每次都会重新执行，因此createRef在函数组件中每次都会重新创建，导致每次都是得到的结果都是初始值，而useRef在函数组件中具有“缓存”的特点，多次执行函数并不会“重置”ref的值。</p><p>我们通过下面的例子来看看两者的区别：</p><pre><code class="javascript">export default const UseRefCreateRef = () =&gt; &#123;  const [count, setCount] = useState(0)  const varUseRef = useRef()  const varCreateRef = createRef()  console.log(varUseRef, varCreateRef);  // 从这里的打印值就可以看出来，每次打印，varUseRef返回的是同一个引用，而createRef每次都会创建一个新的引用  varUseRef.current = count  varCreateRef.current = count  return (    &lt;&gt;      &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;      &lt;p&gt;varUseRef: &#123;varUseRef.current&#125;&lt;/p&gt;      &lt;p&gt;varCreateRef: &#123;varCreateRef.current&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;    &lt;/&gt;  )&#125;</code></pre><p><img src="/images/hooks6.png"><br>解释下，每次更新<code>count</code>，都会使组件重新渲染，我们在函数组件里面重新设置<code>varUseRef</code>和<code>varCreateRef</code>的值，但是从结果可以看出来，<code>varCreateRef</code>每次都被重新创建了，而<code>varUseRef</code>每次都保持了相同的引用。</p><p>有了这一特性，我们就可以把一些在组件全生命周期中需要保留的东西放在<code>useRef</code>上面，比如一个可修改的“全局变量”，又或是<code>debounce</code>时候定义的定时器也可以使用<code>useRef</code>保存。</p><h1 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h1><p>我们在使用<code>forwardRef</code>进行转发时，接收到父组件的<code>ref</code>，然后直接将其绑定到子组件的<code>DOM</code>上，这样做并没有什么问题，但是这会带来一些问题，将子组件的<code>DOM</code>直接暴露给父组件，父组件的行为子组件并不可控，可能做一些破坏性的动作。此时我们可以仅暴露操作子组件DOM的方法，而不将整个DOM暴露给父组件，例如我只希望父组件可以操作子组件内部input元素的focus，就可以将其封装成一个函数，暴露给父组件。借助<code>useImperativeHandle</code>，我们就可以进行这种操作。</p><pre><code class="javascript">useImperativeHandle(ref, createHandle, [deps])</code></pre><ul><li><code>ref</code>：父组件绑定的<code>ref</code></li><li><code>createHandle</code>：一个函数，返回值是一个对象，这个对象将绑定到传过来的<code>ref</code>的<code>.current</code>属性上</li><li><code>[deps]</code>：依赖列表，当监听的依赖发生变化，<code>useImperativeHandle</code> 才会重新将子组件的实例属性输出到父组件</li></ul><p><code>useImperativeHandle</code>应该总是配合<code>React.forwardRef</code>一起使用，</p><p>例如以下代码：</p><pre><code class="javascript">import React, &#123; useRef, useImperativeHandle &#125; from &#39;react&#39;function FancyInput (props, ref) &#123;  const inputRef = useRef();  const btnRef = useRef();  useImperativeHandle(ref, () =&gt; (&#123;    inputFocus: () =&gt; &#123;      inputRef.current.focus();    &#125;,    getBtnWidth: () =&gt; &#123;      return btnRef.current.offsetWidth;    &#125;  &#125;));  return (    &lt;&gt;      &lt;input ref=&#123;inputRef&#125;&gt;&lt;/input&gt;      &lt;button ref=&#123;btnRef&#125;&gt;按钮按钮按钮按钮按钮&lt;/button&gt;    &lt;/&gt;  )&#125;FancyInput = React.forwardRef(FancyInput);export default function HooksRef () &#123;  const fancyInputRef = useRef()  return (    &lt;div&gt;      &lt;p&gt;useRef&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; fancyInputRef.current.inputFocus()&#125;&gt;聚焦&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; alert(fancyInputRef.current.getBtnWidth())&#125;&gt;获取子组件按钮宽度&lt;/button&gt;      &lt;div&gt;        &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt;      &lt;/div&gt;    &lt;/div&gt;  )&#125;</code></pre><p><img src="/images/hooks6.gif"></p><h1 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h1><p>其函数签名与 <code>useEffect</code> 相同，但它会在所有的 <code>DOM</code> 变更之后同步调用 <code>effect</code>。可以使用它来读取 <code>DOM</code> 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。</p><p><code>useEffect</code>在浏览器渲染完成后执行，算是异步执行，这样就不会阻塞浏览器渲染，影响用户体验。应该尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p><pre><code class="javascript">import React, &#123; useLayoutEffect, useEffect &#125; from &#39;react&#39;const LayoutEffectComp = () =&gt; &#123;  const ref = React.createRef()  // 使用useLayoutEffect的时候，在副作用里面操作dom会在浏览器渲染前变化，不会看到页面有闪屏  useEffect(() =&gt; &#123;    ref.current.style.transform = &#39;translateX(100px)&#39;  &#125;)  return (    &lt;div style=&#123;&#123; width: 100, height: 100, backgroundColor: 'red' &#125;&#125; ref=&#123;ref&#125;&gt;&lt;/div&gt;  )&#125;export default LayoutEffectComp</code></pre><p><img src="/images/hooks7.gif"></p><p>将<code>useEffect</code>换成<code>useLayoutEffect</code>就不会有这种闪动了</p><h1 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h1><pre><code class="javascript">useDebugValue(value)</code></pre><p><code>useDebugValue</code> 可用于在 <code>React</code> 开发者工具中显示自定义 <code>hook</code> 的标签。</p><p>例如一个简易的useDebounce</p><pre><code class="javascript">import &#123; useRef, useDebugValue &#125; from &#39;react&#39;const useDebounce = (func, time) =&gt; &#123;  useDebugValue(&#39;someDebounceName&#39;)  let timer = useRef()  return function (...args) &#123;    if (timer.current) clearTimeout(timer.current)    timer.current = setTimeout(() =&gt; &#123;      func(...args)    &#125;, time)  &#125;&#125;export default useDebounce</code></pre><p><img src="/images/hooks7.png"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> React Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 函数柯里化</title>
      <link href="/2021/08/09/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2021/08/09/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是函数柯里化"><a href="#什么是函数柯里化" class="headerlink" title="什么是函数柯里化"></a>什么是函数柯里化</h1><p>维基百科上说道：柯里化，英语：<code>Currying</code>(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><p>通过一个简单的例子解释下，比如有一个函数：</p><pre><code class="javascript">function addFn (x, y, z) &#123;  return x + y + z&#125;</code></pre><p>正常函数的调用是：</p><pre><code class="javascript">addFn(1, 2, 3)</code></pre><p>而柯里化后的函数调用应该像这样：</p><pre><code class="javascript">addFn(1)(2)(3)// 或者addFn(1, 2)(3)// 又或者addFn(1)(2, 3)</code></pre><p>这样怎么实现呢，通过简单的2个参数的加法函数演示一下，当然这是最简单的，调用的方式也只能传单个参数；</p><pre><code class="javascript">function curryAdd (x) &#123;  return function (y) &#123;    return x + y  &#125;&#125;curryAdd(1)(2)    // 3    </code></pre><p>那么我们怎么怎么把一个普通的函数转换成形如上述<code>curryAdd</code>函数的样子呢，这就需要我们进行函数的柯里化，将一个多参数的函数转变称为能够像链式调用那样的函数；</p><p>抽象上面的<code>curryAdd</code>高阶函数，先假设只调用两层（<code>fn(1)(2)</code>），也可以理解为被柯里化的函数只有两个参数，我们最多只能返回两层，<code>args1</code>是<code>currying</code>函数本身的参数，<code>args2</code>是第一层的参数<code>1</code>，<code>args3</code>是第二层的参数<code>2</code></p><pre><code class="javascript">function addFn (x, y) &#123;  return x + y&#125;function currying (fn, ...args1) &#123;  console.log(args1, &#39;args1&#39;)   // 由于没有传参这里是[]  return function (...args2) &#123;    console.log(args2, &#39;args2&#39;) // 这里是[1]    return function(...args3) &#123;      console.log(args3, &#39;args3&#39;) // 这里是 [2]      // 然后把接收到的所有参数，交由fn函数处理，然后返回      return  fn(...args1, ...args2, ...args3)    &#125;  &#125;&#125;let fn = curry(addFn)console.log(fn(1)(2))  // 3</code></pre><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>问题来了，我们不可能有多少个参数就写多少层吧，我们需要定义一个柯里化函数，来进行函数的柯里化，具备通用性，无论多少参数都能进行转化；</p><p>我们可以利用函数上的特殊属性<code>length</code>来进行处理，这个是函数参数的个数，比如我们定义一个函数<code>foo(a, b, c)</code>，<code>foo.length</code> 就是函数入参的个数<code>3</code></p><p>由于我们不知道具体有多少个参数，因此需要递归来进行处理，如果传入的参数没有超过函数入参的个数，就再次调用自己，进行下一轮的柯里化，直到传入的参数等于函数入参的个数</p><p>代码如下：</p><pre><code class="javascript">function simpleCurrying(fn, ...args) &#123;  // 如果传入的参数已经大于函数可以处理的长度，则直接抛出错误  if (args.length &gt; fn.length) &#123;    throw new Error(&#39;参数超出可处理范围&#39;)  &#125;  // 一旦传入的参数等于了函数可以处理的长度，则调用fn进行处理  if (args.length === fn.length) &#123;    return fn(...args)  &#125;  // 否则继续调用自己，注意需要在外层接收下一次调用的入参，并合并到上一次的参数中，否则参数会丢失  return function(...args2) &#123;    return simpleCurrying(fn, ...args, ...args2)  &#125;&#125;</code></pre><p>让我们来测试一下：</p><pre><code class="javascript">function add (a, b, c, d) &#123;  return a + b + c + d&#125;let sc = simpleCurry(add);sc(1, 2, 3, 4)  // 10sc(1, 2)(3)(4)  // 10sc(1, 2, 3)(4)  // 10sc(1, 2)(3, 4)  // 10sc(1, 2, 3, 4, 5) // ERROR 参数超出可处理范围</code></pre><p>当然我们的例子还有许多需要优化的地方，而<a href="https://www.lodashjs.com/docs/lodash.curry">lodash.curry</a>也提供了柯里化函数的方法，可以直接使用；</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 相关【持续更新...】</title>
      <link href="/2021/08/08/Webpack-%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/08/08/Webpack-%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="三种hash策略"><a href="#三种hash策略" class="headerlink" title="三种hash策略"></a>三种hash策略</h1><ul><li><p>hash</p><p><code>hash</code> 和每次 build有关，没有任何改变的情况下，每次编译出来的 <code>hash</code>都是一样的，但当你改变了任何一点东西，它的<code>hash</code>就会发生改变。</p><p>简单理解，你改了任何东西，hash 就会和上次不一样了。</p></li><li><p>chunkhash</p><p><code>chunkhash</code>根据不同的入口文件(<code>Entry</code>)进行依赖文件解析、构建对应的代码块（<code>chunk</code>），生成对应的哈希值，某文件变化时只有该文件对应代码块（<code>chunk</code>）的<code>hash</code>会变化</p></li><li><p>contenthash</p><p>它的出现主要是为了解决，让<code>css</code>文件不受<code>js</code>文件的影响。比如<code>foo.css</code>被<code>foo.js</code>引用了，所以它们共用相同的<code>chunkhash</code>值。但这样子是有问题的，如果<code>foo.js</code>修改了代码，<code>css</code>文件就算内容没有任何改变，由于是该模块的 <code>hash</code> 发生了改变，其<code>css</code>文件的<code>hash</code>也会随之改变。</p><p>这个时候我们就可以使用<code>contenthash</code>了，保证即使<code>css</code>文件所处的模块里有任何内容的改变，只要 <code>css</code> 文件内容不变，那么它的<code>hash</code>就不会发生变化。</p><p><code>contenthash</code> 你可以简单理解为是 <code>moduleId + content</code> 所生成的 <code>hash</code>。</p></li></ul><h1 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h1><h2 id="优化loader查找范围"><a href="#优化loader查找范围" class="headerlink" title="优化loader查找范围"></a>优化loader查找范围</h2><p>在<code>loader</code>中结合<code>test</code> <code>include</code> <code>exclude</code>三个配置项来缩⼩loader的处理范围，推荐<code>include</code></p><pre><code class="javascript">// ...rules: [    &#123; test: /\.js$/, use: &#39;babel-loader&#39;, exclude: &#39;/node_modules/&#39; &#125;,]// ...</code></pre><blockquote><p><code>exclude</code> 优先级要优于 <code>include</code> 和 <code>test</code> ，所以当三者配置有冲突时， <code>exclude</code> 会优先于其他两个配置。</p></blockquote><h2 id="优化resolve-modules配置"><a href="#优化resolve-modules配置" class="headerlink" title="优化resolve.modules配置"></a>优化resolve.modules配置</h2><p><code>resolve.modules</code>⽤于配置<code>webpack</code>去哪些⽬录下寻找第三⽅模块，默认是[‘node_modules’]</p><p>寻找第三⽅模块，默认是在当前项⽬⽬录下的<code>node_modules</code>⾥⾯去找，如果没有找到，就会去上⼀级⽬录<code>../node_modules</code>找，再没有会去<code>../../node_modules</code>中找，以此类推，和<code>Node.js</code>的模块寻找机制很类似。</p><p>如果我们的第三⽅模块都安装在了项⽬根⽬录下，就可以直接指明这个路径。</p><pre><code class="javascript">module.exports=&#123; resolve:&#123; modules: [path.resolve(__dirname, &quot;./node_modules&quot;)] &#125;&#125;</code></pre><h2 id="优化resolve-alias配置"><a href="#优化resolve-alias配置" class="headerlink" title="优化resolve.alias配置"></a>优化resolve.alias配置</h2><p><code>resolve.alias</code>配置通过别名来将原导⼊路径映射成⼀个新的导⼊路径，拿<code>react</code>为例，我们引⼊的<code>react</code>库，⼀般存在两套代码</p><ul><li><p>cjs</p><p>采⽤commonJS规范的模块化代码</p></li><li><p>umd</p><p>已经打包好的完整代码，没有采⽤模块化，可以直接执⾏</p></li></ul><p>默认情况下，<code>webpack</code>会从⼊⼝⽂件<code>./node_modules/bin/react/index</code>开始递归解析和处理依赖的⽂件。我们可以直接指定⽂件，避免这处的耗时。</p><pre><code class="javascript">resolve: &#123;  alias: &#123;    &quot;@assets&quot;: path.resolve(__dirname, &quot;../src/assets&quot;),    &quot;@src&quot;: path.join(__dirname, &quot;./src&quot;),    &quot;react&quot;: path.resolve(__dirname, &quot;./node_modules/react/umd/react.production.min.js&quot;),    &quot;react-dom&quot;: path.resolve(__dirname, &quot;./node_modules/react-dom/umd/react-dom.production.min.js&quot;)  &#125;,&#125;,</code></pre><h2 id="优化resolve-extensions配置"><a href="#优化resolve-extensions配置" class="headerlink" title="优化resolve.extensions配置"></a>优化resolve.extensions配置</h2><p><code>resolve.extensions</code>在导⼊语句没带⽂件后缀时，<code>webpack</code>会⾃动带上后缀后，去尝试查找⽂件是否存在</p><p>默认值：</p><pre><code class="javascript">extensions:[&#39;.js&#39;,&#39;.json&#39;,&#39;.jsx&#39;,&#39;.ts&#39;]</code></pre><ul><li>后缀尝试列表尽量的⼩</li><li>导⼊语句尽量的带上后缀</li></ul><h2 id="利⽤多线程提升构建速度"><a href="#利⽤多线程提升构建速度" class="headerlink" title="利⽤多线程提升构建速度"></a>利⽤多线程提升构建速度</h2><p>由于运⾏在 <code>Node.js</code> 之上的 <code>Webpack</code> 是单线程模型的，所以 <code>Webpack</code> 需要处理的事情需要⼀件⼀件的做，不能多件事⼀起做。我们需要 <code>Webpack</code> 能同⼀时间处理多个任务，发挥多核 <code>CPU</code> 电脑的威⼒。</p><p><strong>thread-loader</strong>是针对 <code>loader</code> 进⾏优化的，它会将 <code>loader</code> 放置在⼀个 <code>worker</code> 池⾥⾯运⾏，以达到多线程构建。<code>thread-loader</code> 在使⽤的时候，需要将其放置在其他 <code>loader</code> 之前，如下⾯实例:</p><pre><code class="javascript">module.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\.js$/,        use: [          &#39;thread-loader&#39;          // 你的⾼开销的loader放置在这后面 (e.g babel-loader)        ]      &#125;    ]  &#125;&#125;;</code></pre><h2 id="缓存cache相关"><a href="#缓存cache相关" class="headerlink" title="缓存cache相关"></a>缓存cache相关</h2><p><code>Webpack</code> 中打包的核⼼是 <code>JavaScript</code> <code>⽂件的打包，JavaScript</code> 使⽤的是 <code>babel-loader</code>，其实打包时间⻓很多时候是<code>babel-loader</code> 执⾏慢导致的。这时候我们不仅要使⽤ <code>exclude</code> 和 <code>include</code> 来尽可能准确的指定要转换内容的范畴，还需要关注 <code>babel-loader</code> 在执⾏的时候，可能会产⽣⼀些运⾏期间重复的公共⽂件，造成代码体积⼤冗余，同时也会减慢编译的速度。</p><p><code>babel-loader</code>提供了 <code>cacheDirectory</code> 配置给 <code>Babel</code> 编译时给定的⽬录，并且将⽤于缓存加载器的结果，但是这个设置默认是 <code>false</code> 关闭的状态，我们需要设置为 <code>true</code> ，这样 <code>babel-loader</code> 将使⽤默认的缓存⽬录 。<code>node_modules/.cache/babel-loader</code> ，如果在任何根⽬录下都没有找到 <code>node_modules</code> ⽬录，将会降级回退到操作系统默认的临时⽂件⽬录。</p><pre><code class="javascript">rules: [  &#123;    test: /\.js$/,    loader: &#39;babel-loader&#39;,    options: &#123;      cacheDirectory: true    &#125;,  &#125;];</code></pre><h2 id="压缩速度优化"><a href="#压缩速度优化" class="headerlink" title="压缩速度优化"></a>压缩速度优化</h2><p>相对于构建过程⽽⾔，压缩相对我们来说只有⽣产环境打包才会做，⽽且压缩我们除了添加 <code>cache</code> 和多线程⽀持之外，可以优化的空间较⼩。我们在使⽤ <code>terser-webpack-plugin</code> 的时候可以通过下⾯的配置开启多线程和缓存：</p><pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);module.exports = &#123;  optimization: &#123;    minimizer: [      new TerserPlugin(&#123;        cache: true, // 开启缓存        parallel: true // 多线程      &#125;)    ]  &#125;&#125;;</code></pre><h2 id="使⽤externals优化cdn静态资源"><a href="#使⽤externals优化cdn静态资源" class="headerlink" title="使⽤externals优化cdn静态资源"></a>使⽤externals优化cdn静态资源</h2><p>公司有<code>cdn</code>，静态资源有部署到<code>cdn</code>有链接了，我们使⽤<code>cdn</code>，我们的<code>bundle</code>⽂件⾥，就不⽤打包进去这个依赖了，体积会⼩很多，我们可以将⼀些<code>JS</code>⽂件存储在 <code>CDN</code> 上(减少 <code>Webpack</code> 打包出来的 <code>js</code> 体积)，在<code>index.html</code>中通过标签引⼊，如:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;root&lt;/div&gt;    &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>我们希望在使⽤时，仍然可以通过 <code>import</code> 的⽅式去引⽤(如 <code>import $ from &#39;jquery&#39;</code> )，并且希望<code>webpack</code> 不会对其进⾏打包，此时就可以配置 <code>externals</code> 。</p><pre><code class="javascript">module.exports = &#123; //...  externals: &#123;    //jquery通过script引⼊之后，全局中即有了 jQuery 变量    &#39;jquery&#39;: &#39;jQuery&#39;  &#125;&#125;</code></pre><h2 id="使⽤静态资源路径publicPath-CDN"><a href="#使⽤静态资源路径publicPath-CDN" class="headerlink" title="使⽤静态资源路径publicPath(CDN)"></a>使⽤静态资源路径publicPath(CDN)</h2><p><code>CDN</code>通过将资源部署到世界各地，使得⽤户可以就近访问资源，加快访问速度。要接⼊<code>CDN</code>，需要把⽹⻚的静态资源上传到<code>CDN</code>服务上，在访问这些资源时，使⽤<code>CDN</code>服务提供的<code>URL</code>。</p><pre><code class="javascript">// webpack.config.jsoutput:&#123;  publicPath: &#39;//cdnURL.com&#39;, //指定存放JS⽂件的CDN地址&#125;</code></pre><h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h2><p>借助<code>postcss</code>和<code>cssnano</code>，实现<code>css</code>代码的压缩，借助<code>terser-webpack-plugin</code>，实现<code>js</code>的压缩，借助<code>html-webpack-plugin</code>，实现<code>html</code>的压缩</p><ul><li><p>压缩html</p><pre><code class="javascript">plugin: [  new htmlWebpackPlugin(&#123;    title: &quot;京东商城&quot;,    template: &quot;./index.html&quot;,    filename: &quot;index.html&quot;,    minify: &#123;      // 压缩HTML⽂件      removeComments: true, // 移除HTML中的注释      collapseWhitespace: true, // 删除空⽩符与换⾏符      minifyCSS: true // 压缩内联css    &#125;  &#125;),]</code></pre></li><li><p>压缩css</p><p><code>webpack.config.js</code></p><pre><code class="javascript">&#123;  test: /\.css$/,  use: [    &#39;style-loader&#39;,    &#39;css-loader&#39;,    &#39;postcss-loader&#39;  ]&#125;,</code></pre><p><code>postcss.config.js</code></p><pre><code class="javascript">module.exports = &#123;  plugins: [    require(&#39;autoprefixer&#39;),    require(&#39;cssnano&#39;)  ]&#125;;</code></pre></li><li><p>压缩js</p><p>在 <code>mode=production</code> 下，<code>Webpack</code> 会⾃动压缩代码，我们可以⾃定义⾃⼰的压缩⼯具，这⾥推荐<code>terser-webpack-plugin</code>，它是 <code>Webpack</code> 官⽅维护的插件，使⽤<code>terser</code>来压缩 <code>JavaScript</code> 代码。<code>UglifyJS</code>在压缩 <code>ES5</code> ⽅⾯做的很优秀，但是随着 <code>ES6</code> 语法的普及，<code>UglifyJS</code> 在 <code>ES6</code> 代码压缩上做的不够好，所以有了 <code>uglify-es</code> 项⽬，但是之后 <code>uglify-es</code> 项⽬不在维护了，<code>terser</code> 是从 <code>uglify-es</code> 项⽬拉的⼀个分⽀，来继续维护。</p><pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);module.exports = &#123;  optimization: &#123;    minimizer: [      new TerserPlugin()    ]  &#125;&#125;;</code></pre><p>在实际开发中，我们可以通过移除⼀些不⽤的代码从⽽达到优化代码体积的作⽤，<code>Tree-Shaking</code> 也是依赖这个插件的</p><pre><code class="javascript">new TerserPlugin(&#123;  // 使⽤ cache，加快⼆次构建速度  cache: true,  terserOptions: &#123;    comments: false,    compress: &#123;      // 删除⽆⽤的代码      unused: true,      // 删掉 debugger      drop_debugger: true, // eslint-disable-line      // 移除 console      drop_console: true, // eslint-disable-line      // 移除⽆⽤的代码      dead_code: true // eslint-disable-line    &#125;  &#125;&#125;);</code></pre><p>压缩是发布前处理最耗时间的⼀个步骤，在 <code>Webpack</code> 配置中可以通过开启 <code>terser-webpack-plugin</code> 的多线程压缩来加速我们的构建压缩速度：</p><pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);module.exports = &#123;  optimization: &#123;    minimizer: [new TerserPlugin(      parallel: true // 多线程    )],  &#125;,&#125;;</code></pre></li></ul><h2 id="tree-Shaking：擦除⽆⽤的JS-CSS"><a href="#tree-Shaking：擦除⽆⽤的JS-CSS" class="headerlink" title="tree Shaking：擦除⽆⽤的JS,CSS"></a>tree Shaking：擦除⽆⽤的JS,CSS</h2><p><code>webpack4.x</code>开始⽀持 <code>tree shaking</code>概念，顾名思义，”摇树”，清除⽆⽤ <code>css</code>,<code>js</code>(<code>Dead Code</code>)<br><code>Dead Code</code> ⼀般具有以下⼏个特征</p><ul><li><p>代码不会被执⾏，不可到达</p></li><li><p>代码执⾏的结果不会被⽤到</p></li><li><p>代码只会影响死变量（只写不读）</p></li><li><p>Js tree shaking只⽀持ES module的引⼊⽅式！！！！</p></li><li><p>Css tree shaking</p><pre><code>npm install glob-all purify-css purifycss-webpack -D</code></pre><pre><code class="javascript">const PurifyCSS = require(&#39;purifycss-webpack&#39;)const glob = require(&#39;glob-all&#39;)// ...plugins: [// 清除⽆⽤ css  new PurifyCSS(&#123;    paths: glob.sync([      // 要做 CSS Tree Shaking 的路径⽂件      path.resolve(__dirname, &#39;./src/*.html&#39;), // 请注意，我们同样需要对 html ⽂件进⾏ tree shaking      path.resolve(__dirname, &#39;./src/*.js&#39;)    ])  &#125;)]// ...</code></pre></li><li><p>JS tree shaking</p><p>只⽀持<code>import</code>⽅式引⼊，不⽀持<code>commonjs</code>的⽅式引⼊</p><p>⽣产模式不需要配置，默认开启</p><pre><code class="javascript">// ...optimization: &#123;  usedExports: true // 哪些导出的模块被使⽤了，再做打包&#125;// ...</code></pre><p>只要<code>mode</code>是<code>production</code>就会⽣效，<code>develpoment</code>的<code>tree shaking</code>是不⽣效的，因为<code>webpack</code>为了⽅便你的调试</p><p><code>sideEffects</code> 处理副作⽤<br>&#x2F;&#x2F;package.json</p><pre><code class="json">&quot;sideEffects&quot;:false</code></pre><p>正常对所有模块进⾏<code>tree shaking</code> , 仅⽣产模式有效，需要配合<code>usedExports</code>使用</p><p>或者 在数组⾥⾯排除不需要<code>tree shaking</code>的模块</p><pre><code class="json">&quot;sideEffects&quot;: [&#39;*.css&#39;,&#39;@babel/polyfill&#39;]</code></pre></li></ul><h2 id="代码分割-code-Splitting"><a href="#代码分割-code-Splitting" class="headerlink" title="代码分割 code Splitting"></a>代码分割 code Splitting</h2><p>单⻚⾯应⽤<code>spa</code>：</p><p>打包完后，所有⻚⾯只⽣成了⼀个<code>bundle.js</code></p><ul><li>代码体积变⼤，不利于下载</li><li>没有合理利⽤浏览器资源</li></ul><p>多⻚⾯应⽤mpa:</p><p>如果多个⻚⾯引⼊了⼀些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要<br>下载⼀次就缓存起来了，避免了重复下载。</p><p>其实<code>code Splitting</code>概念 与 <code>webpack</code>并没有直接的关系，只不过<code>webpack</code>中提供了⼀种更加⽅便的⽅法供我们实现代码分割</p><p><code>webpack</code>的配置基于<a href="https://webpack.js.org/plugins/split-chunks-plugin/">split-chunks-plugin</a></p><pre><code class="javascript">optimization: &#123;  splitChunks: &#123;    chunks: &quot;all&quot;, // 所有的 chunks 代码公共的部分分离出来成为⼀个单独的⽂件  &#125;,&#125;,</code></pre><pre><code class="javascript">optimization: &#123;  splitChunks: &#123;    chunks: &#39;async&#39;,  //对同步 initial，异步 async，所有的模块有效 all    minSize: 30000, //最⼩尺⼨，当模块⼤于30kb    maxSize: 0, //对模块进⾏⼆次分割时使⽤，不推荐使⽤    minChunks: 1, //打包⽣成的chunk⽂件最少有⼏个chunk引⽤了这个模块    maxAsyncRequests: 5,  //最⼤异步请求数，默认5    maxInitialRequests: 3,  //最⼤初始化请求书，⼊⼝⽂件同步请求，默认3    automaticNameDelimiter: &#39;-&#39;,  //打包分割符号    name: true, //打包后的名称，除了布尔值，还可以接收⼀个函数function    cacheGroups: &#123;  //缓存组      vendors: &#123;        test: /[\\/]node_modules[\\/]/, // 判断引入库是否是node_modules里的        name: &quot;vendor&quot;,  // 要缓存的 分隔出来的 chunk 名称        priority: -10, //缓存组优先级 数字越⼤，优先级越⾼        // filename: &#39;vendor.min.js&#39;  // 设置代码分割后的文件名，仅在chunks为initial时能用，否则报错      &#125;,      other:&#123;        chunks: &quot;initial&quot;,  // 必须三选⼀： &quot;initial&quot; | &quot;all&quot; | &quot;async&quot; (默认就是async)        test: /react|lodash/,   // 正则规则验证，如果符合就提取 chunk,        name:&quot;other&quot;,        minSize: 30000,        minChunks: 1,      &#125;,      default: &#123;        minChunks: 2, // 在拆分之前共享模块的最小块数, 默认为1，表示只要有一个地方引入，就抽离到公共模块，设置为2表示 有两个chunk 引入同一个人文件才进行抽离，设置2更为合理一点        priority: -20,        reuseExistingChunk: true  // 允许在模块完全匹配时重用现有的块，而不是创建新的块      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="webpack-bundle-analyzer-分析webpack打包后的模块依赖关系："><a href="#webpack-bundle-analyzer-分析webpack打包后的模块依赖关系：" class="headerlink" title="webpack-bundle-analyzer: 分析webpack打包后的模块依赖关系："></a>webpack-bundle-analyzer: 分析webpack打包后的模块依赖关系：</h2><pre><code class="javascript">// npm install webpack-bundle-analyzer -Dconst BundleAnalyzerPlugin = require(&#39;webpack-bundleanalyzer&#39;).BundleAnalyzerPlugin;module.exports = merge(baseWebpackConfig, &#123; //.... plugins: [ //...  new BundleAnalyzerPlugin(), ]&#125;)</code></pre><h1 id="development-vs-Production模式区分打包"><a href="#development-vs-Production模式区分打包" class="headerlink" title="development vs Production模式区分打包"></a>development vs Production模式区分打包</h1><p>区分环境打包可以创建多个不同环境的<code>config</code>文件，执行打包命令的时候指定对应的config文件，我们可以定义一个基础文件<code>webpack.common.config.js</code>存放公用的配置，然后再创建其他环境的配置文件，例如<code>webpack.prod.config.js</code>、<code>webpack.dev.config.js</code>、<code>webpack.test.config.js</code>等，在里面进行公共配置的合并</p><p>例如：</p><pre><code class="javascript">const merge = require(&quot;webpack-merge&quot;)const commonConfig = require(&quot;./webpack.common.js&quot;)const devConfig = &#123; ...&#125;module.exports = merge(commonConfig,devConfig)</code></pre><p><code>package.js</code></p><pre><code class="json">&quot;scripts&quot;:&#123; &quot;dev&quot;: &quot;webpack --config ./webpack.dev.config.js&quot;, &quot;build&quot;: &quot;webpack --config ./webpack.prod.config.js&quot;&#125;</code></pre><p>还可以借助<code>cross-env</code>基于环境变量区分，由于不同平台之间环境变量稍有不同，因此需要借助这个工具进行统一，这个工具可以在我们执行打包命令的时候，自动修改<code>node</code>的<code>process.env</code>环境变量的配置，比如</p><pre><code class="json">&quot;scripts&quot;:&#123; &quot;dev&quot;: &quot;cross-env NODE_ENV=&#39;development&#39; webpack --config ./webpack.dev.config.js&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=&#39;production&#39; webpack --config ./webpack.prod.config.js&quot;&#125;</code></pre><p>我们执行<code>npm run dev</code>的时候，<code>process.env.NODE_ENV</code> 被设置为<code>development</code>，而执行<code>npm run build</code>的时候<code>process.env.NODE_ENV</code> 被设置为<code>production</code>，然后我们可以根据这个环境变量，只写一份<code>webpack.config.js</code>配置，实现不同环境环境的打包；</p><p>例如：</p><pre><code class="javascript">const webpackEnv = process.env.NODE_ENV;const isEnvDevelopment = webpackEnv === &#39;development&#39;;const isEnvProduction = webpackEnv === &#39;production&#39;;module.exports = &#123;  mode: isEnvProduction ? &#39;production&#39; : isEnvDevelopment &amp;&amp; &#39;development&#39;,  devtool: isEnvProduction    ? shouldUseSourceMap      ? &#39;source-map&#39;      : false    : isEnvDevelopment &amp;&amp; &#39;cheap-module-source-map&#39;,  // ...&#125;</code></pre><p><code>webpack.config.js</code>还可以导出一个函数，函数接收两个入参：</p><ul><li>env：当前运行 <code>webpack</code> 的环境变量, 设置它时需要在启动 <code>webpack</code> 时候带上参数, 例如: <code>webpack --env.production</code>;</li><li>args：代表在 <code>webpack</code> 启动时候通过命令行传入的所有参数; 例如: <code>--config</code> <code>--env</code> <code>--devtool</code> 等;</li></ul><p>例如：</p><pre><code class="json">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;webpack --env development --config ./webpack.dev.config.js&quot;,  &#125;,</code></pre><pre><code class="javascript">module.exports = function(env, args) &#123;  console.log(env, args)  const isEnvDevelopment = env === &#39;development&#39;;  const isEnvProduction = env === &#39;production&#39;;  return &#123;    mode: isEnvProduction ? &#39;production&#39; : isEnvDevelopment &amp;&amp; &#39;development&#39;,    devtool: isEnvProduction      ? shouldUseSourceMap        ? &#39;source-map&#39;        : false      : isEnvDevelopment &amp;&amp; &#39;cheap-module-source-map&#39;,    // ...  &#125;&#125;</code></pre><p><code>env</code>、<code>args</code>打印结果</p><pre><code class="javascript">development // env&#123; // args  _: [],  cache: null,  bail: null,  profile: null,  color: &#123; level: 3, hasBasic: true, has256: true, has16m: true &#125;,  colors: &#123; level: 3, hasBasic: true, has256: true, has16m: true &#125;,  env: &#39;development&#39;,  config: &#39;./webpack.dev.config.js&#39;,  &#39;info-verbosity&#39;: &#39;info&#39;,  infoVerbosity: &#39;info&#39;,  &#39;$0&#39;: &#39;node_modules\\webpack\\bin\\webpack.js&#39;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browserslist的作用</title>
      <link href="/2021/08/07/browserslist%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2021/08/07/browserslist%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>browserslist</code> 实际上就是声明了⼀段浏览器的集合，我们的⼯具可以根据这段集合描述，针对性的输出兼容性代码。</p><p><code>browserslist</code>就是帮助我们来设置⽬标浏览器的⼯具。<code>browserslist</code> 被⼴泛的应⽤到 <code>Babel</code>、<code>postcsspreset-env``、autoprefixer</code> 等开发⼯具上。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>browserslist</code> 的配置可以放在<code> package.json</code> 中，也可以单独放在配置⽂件 <code>.browserslistrc</code> 中。所有的⼯具都会主动查找 <code>browserslist</code> 的配置⽂件，根据 <code>browserslist</code> 配置找出对应的⽬标浏览器集合。</p><p><code>browserslist</code> 的数据都是来⾃<a href="https://browserl.ist/">Can I Use</a>，可惜⽹站关闭了，现在需要⼿动检测：</p><pre><code>npx browserslist &quot;last 1 version, &gt;1%&quot;</code></pre><p>在 <code>package.json</code> 中的配置是增加⼀个 <code>browserslist</code> 数组属性：</p><pre><code class="json">&#123; &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;maintained node versions&quot;, &quot;notie &lt; 11&quot;]&#125;</code></pre><p>或者在项⽬的根⽬录下创建⼀个 <code>.browserslistrc</code> ⽂件：</p><pre><code># 注释是这样写的，以#号开头# 每⾏⼀个浏览器集合描述last 2 version&gt; 1%maintained node versionsnot ie &lt; 11</code></pre><h1 id="常⻅集合范围说明"><a href="#常⻅集合范围说明" class="headerlink" title="常⻅集合范围说明"></a>常⻅集合范围说明</h1><table><thead><tr><th>范围</th><th>说明</th></tr></thead><tbody><tr><td><code>last 2 versions</code></td><td><a href="https://caniuse.com/">caniuse.com</a>⽹站跟踪的最新两个版本，假如 iOS 12 是最新版本，那么向后兼容两个版本就是 iOS 11 和 iOS 12</td></tr><tr><td><code>&gt; 1%</code></td><td>全球超过 1%⼈使⽤的浏览器，类似 <code>&gt; 5% in US</code> 则指代美国 5%以上⽤户</td></tr><tr><td><code>cover 99.5%</code></td><td>覆盖 99.5%主流浏览器</td></tr><tr><td><code>chrome &gt; 50</code> 或 <code>ie 6-8</code></td><td>指定某个浏览器版本范围</td></tr><tr><td><code>unreleased versions</code></td><td>所有浏览器的 beta 版本</td></tr><tr><td><code>not ie &lt; 11</code></td><td>排除 ie11 以下版本不兼容</td></tr><tr><td><code>since 2013</code> 或 <code>last 2 years</code></td><td>某时间范围发布的所有浏览器版本</td></tr><tr><td><code>maintained node versions</code></td><td>所有被 node 基⾦会维护的 node 版本</td></tr><tr><td><code>current node</code></td><td>当前环境的 node 版本</td></tr><tr><td><code>dead</code></td><td>通过 last 2 versions 筛选的浏览器中，全球使⽤率低于 0.5% 且官⽅声明不在维护或者事实上已经两年没有再更新的版本</td></tr><tr><td><code>defaults</code></td><td>默认配置， <code>&gt; 0.5%</code> <code>last 2 versions</code> <code>Firefox ESR</code> <code>not dead</code></td></tr></tbody></table><h1 id="浏览器名称列表（⼤⼩写不敏感）"><a href="#浏览器名称列表（⼤⼩写不敏感）" class="headerlink" title="浏览器名称列表（⼤⼩写不敏感）"></a>浏览器名称列表（⼤⼩写不敏感）</h1><ul><li>Android ：安卓 webview 浏览器；</li><li>Baidu ： 百度浏览器；</li><li>BlackBerry &#x2F; bb ：⿊莓浏览器；</li><li>Chrome ：chrome 浏览器；</li><li>ChromeAndroid &#x2F; and_chr ：chrome 安卓移动浏览器；</li><li>Edge ：微软 Edge 浏览器；</li><li>Electron ：Electron；</li><li>Explorer &#x2F; ie ：ie 浏览器；</li><li>ExplorerMobile &#x2F; ie_mob ：ie 移动浏览器；</li><li>Firefox &#x2F; ff ：⽕狐浏览器； * FirefoxAndroid &#x2F; and_ff ：⽕狐安卓浏览器；</li><li>iOS &#x2F; ios_saf ：iOS Safari 浏览器；</li><li>Node ：nodejs；</li><li>Opera ：opera 浏览器；</li><li>OperaMini &#x2F; op_mini ：operaMini 浏览器；</li><li>OperaMobile &#x2F; op_mob ：opera 移动浏览器；</li><li>QQAndroid &#x2F; and_qq ：QQ 安卓浏览器；</li><li>Samsung ：三星浏览器；</li><li>Safari ：桌⾯版本 Safari；</li><li>UCAndroid &#x2F; and_uc ：UC 安卓浏览器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex 详解</title>
      <link href="/2021/08/06/Vuex-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/08/06/Vuex-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在大型的项目中，状态往往不只是父子之间传递，而是分布于各个组件中，我们通过属性传值的方式就会显得十分臃肿，并且在<code>Vue</code>中，兄弟组件之间传值并没有什么好的办法，往往通过事件总线订阅发布的方式，这种方式可行，但是我们把一些共享的状态抽离出来，统一的放在一个仓库中，哪个组件需要使用，就去仓库里拿，这种方式不是更好吗，这就是状态机的作用，在<code>React</code>中有<code>Redux</code>，<code>Mobx</code>等一些库，而在<code>Vue</code>中，官方推出的<code>Vuex</code>是最适合Vue的，<code>Vuex</code>中的状态是响应式的，完美的结合了<code>Vue</code>的优势；</p><h1 id="Vuex核心内容"><a href="#Vuex核心内容" class="headerlink" title="Vuex核心内容"></a>Vuex核心内容</h1><p>在<code>Vuex</code>对象中，其实不止有<code>state</code>,还有用来操作<code>state</code>中数据的方法集，以及当我们需要对<code>state</code>中的数据需要加工的方法集等等成员。</p><p>成员列表：</p><ul><li><code>state</code>     存放状态</li><li><code>getters</code>   加工<code>state</code>成员给外界</li><li><code>mutations</code> 同步<code>state</code>成员操作</li><li><code>actions</code>   异步操作</li><li><code>modules</code>   模块化状态管理</li></ul><h1 id="Vuex工作流程"><a href="#Vuex工作流程" class="headerlink" title="Vuex工作流程"></a>Vuex工作流程</h1><p>官网给出的流程图<br><img src="/images/vuex.png"></p><p>首先，<code>Vue</code>组件如果调用某个<code>Vuex</code>的方法过程中需要向后端请求时或者说出现异步操作时，需要<code>dispatch</code> <code>Actions</code>的方法，以保证数据的同步。可以说，<code>action</code>的存在就是为了让<code>mutations</code>中的方法能在异步操作中起作用。</p><p>如果没有异步操作，那么我们就可以直接在组件内提交状态中的Mutations中自己编写的方法来达成对<code>state</code>成员的操作。<strong>但是不建议这样做</strong>，我们希望总是由<code>action</code>去调用<code>mutations</code>修改<code>state</code></p><p>不建议在组件中直接对<code>state</code>中的成员进行操作，这是因为直接修改(例如：<code>this.$store.state.name = &#39;hello&#39;</code>)的话不能被<code>VueDevtools</code>所监控到。同样，总是应该有<code>mustaions</code>去修改<code>state</code></p><p>最后被修改后的<code>state</code>成员会被渲染到组件的当中去。</p><p>这样就形成了一个单向闭环，这样的好处是可以明确的知道数据的流向，避免数据混乱；</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm install vuex --save或者yarn add vuex</code></pre><h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p>一般我们把全局状态单独放在一个文件夹中，然后把<code>store</code>导出，在<code>main.js</code>中使用这个<code>store</code>，<code>store</code>文件夹组织类似于<br><img src="/images/vuex2.png"></p><p><code>store</code>的<code>index.js</code>文件类似于下面代码，由于<code>Vuex</code>实例化之前需要<code>Vue.use()</code>一下，因此需要先导入<code>vue</code></p><p><code>store/index.js</code></p><pre><code class="javascript">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)import state from &#39;./state&#39;import mutations from &#39;./mutations&#39;import getters from &#39;./getters&#39;import actions from &#39;./actions&#39;// 单独模块import users from &#39;./modules/users&#39;export default new Vuex.Store(&#123;  state,  mutations,  actions,  getters,  modules: &#123;    users  &#125;&#125;)</code></pre><p><code>main.js</code></p><pre><code class="javascript">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import store from &#39;./store&#39;new Vue(&#123;  store,  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><h2 id="state-mapState"><a href="#state-mapState" class="headerlink" title="state &amp; mapState"></a>state &amp; mapState</h2><p><code>state</code>的声明很简单，就是一个对象，里面存放的是响应式数据</p><p><code>state.js</code></p><pre><code class="javascript">export default &#123;    name: &#39;jerry&#39;,    age: 18&#125;</code></pre><p>由于我们把<code>state</code>抽离出来了，因此直接导出对象就行了</p><p>数据声明了，怎么使用呢？ 在组件中我们直接可以拿到<code>store</code>里的<code>state</code>，有以下几种方式</p><ul><li><p>直接在模板中使用</p><pre><code class="html">    &lt;template&gt;      &lt;div&gt;        &#123;&#123; $store.state.name &#125;&#125;        &#123;&#123; $store.state.age &#125;&#125;      &lt;/div&gt;    &lt;/template&gt;</code></pre></li><li><p><code>computed</code>中指定</p><p>当不使用<code>mapState</code>辅助函数的时候，直接定义计算属性，使用<code>this.$store.state</code>获取状态，如果很多状态，这样写代码十分冗余</p><p>但是如果需要拿到状态和本地数据进行结合，这样写是很方便的，（无法使用过滤器，过滤器中无法访问实例this）</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; name &#125;&#125;    &#123;&#123; age &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    name() &#123;      return this.$store.state.name    &#125;,    age() &#123;      return this.$store.state.age + this.localData    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li><li><p><code>mapState</code>辅助函数</p><p><code>mapState</code>的第一个参数是命名空间，字符串，结合<code>modules</code>使用，可省略，第二个参数可以是一个数组或者对象</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; name &#125;&#125;    &#123;&#123; age &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    ...mapState([&#39;name&#39;, &#39;age&#39;])  &#125;&#125;&lt;/script&gt;</code></pre><p>如果传入对象，必须定义一个计算属性名称，不能使用ES6的<code>&#123;name, age&#125;</code>的省略写法，否则报错</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; stateName &#125;&#125;    &#123;&#123; stateAge &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    ...mapState(&#123;      stateName: &#39;name&#39;,      stateAge: &#39;age&#39;    &#125;)  &#125;&#125;&lt;/script&gt;</code></pre></li></ul><h2 id="getters-mapGetters"><a href="#getters-mapGetters" class="headerlink" title="getters &amp; mapGetters"></a>getters &amp; mapGetters</h2><p><code>getter</code>可认为是<code>state</code>的计算属性，将<code>state</code>作为第一个参数，可以拿到<code>state</code>里的数据，并且还可以接受第二个参数，就是<code>getters</code>，用来调用其他<code>getter</code></p><p><code>getters.js</code></p><pre><code class="javascript">export default &#123;    // getter将state作为第一个参数    ageWithSuffix(state) &#123;        return state.age + &#39;岁&#39;    &#125;,    // getter也可将getters作为第二个参数，用来调用其他getter    ageWithPrefix(state, getters) &#123;        return &#39;今年&#39; + getters.ageWithSuffix    &#125;&#125;</code></pre><p>如何使用getters？</p><ul><li><p>模板里直接使用</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; $store.getters.ageWithSuffix &#125;&#125;    &#123;&#123; $store.getters.ageWithPrefix &#125;&#125;  &lt;/div&gt;&lt;/template&gt;</code></pre></li><li><p><code>computed</code>里使用</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; prefix &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  // ...  computed: &#123;    prefix()&#123;      return this.$store.getters.ageWithPrefix    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li><li><p><code>mapGetters</code>辅助函数<br>数组写法</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; ageWithSuffix &#125;&#125;    &#123;&#123; ageWithPrefix &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    ...mapGetters([&#39;ageWithSuffix&#39;, &#39;ageWithPrefix&#39;]),  &#125;&#125;&lt;/script&gt;</code></pre><p>对象写法</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; suffix &#125;&#125;    &#123;&#123; prefix &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;export default &#123;  // ...  computed: &#123;    ...mapGetters(&#123;       suffix: &#39;ageWithSuffix&#39;,       prefix: &#39;ageWithPrefix&#39;    &#125;)  &#125;&#125;&lt;/script&gt;</code></pre></li></ul><p>上面是定义状态以及获取状态的方法，而修改状态需要<code>dispatch</code>一个<code>action</code>，然后再由<code>action</code>去<code>commit</code>一个<code>mutation</code>，实现状态修改</p><p>所以<code>action</code>和<code>mutation</code>之间是强耦合的，我们为了去耦合，会引入一个<code>mutation-type.js</code>，这个也可以帮助我们快速找到相关代码的位置。</p><p><code>mutation-type.js</code></p><pre><code class="javascript">export const CHANGE_AGE = &#39;change_age&#39;export const CHANGE_NAME = &#39;change_name&#39;</code></pre><p>然后我们定义<code>action</code>和<code>mutation</code>的时候，通过这个中间变量，进行关联；</p><h2 id="actions-mutations"><a href="#actions-mutations" class="headerlink" title="actions &amp; mutations"></a>actions &amp; mutations</h2><ul><li><p>actions<br><code>action</code>整体是一个对象，<code>key</code>是将来我们<code>dispatch``action</code>的<code>type</code>值，因此我们可以直接使用<code>mutation-types</code>导出的值，和<code>mutaion</code>保持一致。</p><p><code>action</code> 函数第一个参数是一个与 <code>store</code> 实例具有相同方法和属性的<code>context</code> 对象，因此你可以调用 <code>context.commit</code> 提交一个 <code>mutation</code>，或者通过<code>context.state</code> 和 <code>context.getters</code> 来获取 <code>state</code> 和 <code>getters</code>，甚至可以通过<code>context.dispatch</code>派发另外一个<code>action</code>，可以通过解构来简化代码</p><p><code>action</code>里是可以执行异步代码的，等异步执行完了再去<code>commit</code> <code>mutation</code>，此时才是同步修改<code>state</code></p><p><code>actions.js</code></p><pre><code class="javascript">import &#123; CHANGE_AGE, CHANGE_NAME &#125; from &#39;./mutation-types&#39;export default &#123;    // 第二个参数是payload，用于接收数据，通常为一个对象，用于接收多个数据，也可以直接接受单个参数    [CHANGE_NAME](&#123; commit &#125;, payload) &#123;        commit(CHANGE_NAME, payload)    &#125;,&#125;</code></pre><p>  如果我们利用 <code>async / await</code>，我们可以如下组合 <code>action</code>，在<code>action</code>中调用另外一个<code>action</code></p><pre><code class="javascript">// 假设 getData() 和 getOtherData() 返回的是 Promiseasync actionA(&#123; commit &#125;) &#123;  commit(&#39;gotData&#39;, await getData())&#125;,async actionB(&#123; dispatch, commit &#125;) &#123;  await dispatch(&#39;actionA&#39;) // 等待 actionA 完成  commit(&#39;gotOtherData&#39;, await getOtherData())&#125;</code></pre></li><li><p>mutations</p><p><code>mutation</code>接收两个参数，一个是<code>state</code>，用于修改状态，一个是<code>payload</code>，用于接收<code>action</code>传参，<code>payload</code>大多数为一个对象，用以传递多个数据</p><p><code>mutations.js</code></p><pre><code class="javascript">import &#123; CHANGE_AGE, CHANGE_NAME &#125; from &#39;./mutation-types&#39;export default &#123;    // [CHANGE_AGE] 为es6语法，可以将表达式作为属性名    [CHANGE_AGE](state, payload) &#123;        console.log(payload);        state.age = payload.age    &#125;,    [CHANGE_NAME](state, payload) &#123;        state.name = payload.name    &#125;,&#125;</code></pre></li></ul><h2 id="store-dispatch-mapActions"><a href="#store-dispatch-mapActions" class="headerlink" title="$store.dispatch &amp; mapActions"></a>$store.dispatch &amp; mapActions</h2><ul><li><p>$store.dispatch</p><p><code>$store.dispatch</code>可以直接派发一个<code>action</code>，<code>dispatch</code>接收一个对象作为参数，对象必须指定一个<code>type</code>属性，表示派发哪一个<code>action</code>，或者把<code>type</code>放在第一个参数上</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CHANGE_NAME &#125; from &#39;@/store/mutation-types&#39;export default &#123;  // ...  methods: &#123;    changeName() &#123;      this.$store.dispatch(&#123;        type: CHANGE_NAME,        name: &#39;tom&#39;      &#125;)      // 把type放在第一个参数上      this.$store.dispatch(CHANGE_NAME, &#123;        name: &#39;tom&#39;      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li><li><p>mapActions</p><p><code>mapActions</code> 辅助函数将组件的 <code>methods</code> 映射为 <code>store.dispatch</code> 调用</p><pre><code class="javascript">import &#123; mapActions &#125; from &#39;vuex&#39;export default &#123;  // ...  methods: &#123;    ...mapActions([      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`      // `mapActions` 也支持载荷：      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#39;incrementBy&#39;, amount)`    ]),    ...mapActions(&#123;      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`，相当于取了个别名    &#125;)  &#125;&#125;</code></pre><p>引入<code>mutation-types</code>的例子：</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CHANGE_NAME &#125; from &#39;@/store/mutation-types&#39;import &#123; mapActions &#125; from &#39;vuex&#39;export default &#123;  // ...  methods: &#123;    ...mapActions([CHANGE_NAME]),    changeName() &#123;      this[CHANGE_NAME](&#123;name: &#39;tom&#39;&#125;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li></ul><h2 id="store-commit-mapMutations"><a href="#store-commit-mapMutations" class="headerlink" title="$store.commit &amp; mapMutations"></a>$store.commit &amp; mapMutations</h2><ul><li><p>$store.commit</p><p>我们是可以直接跳过<code>action</code>直接提交一个<code>mutation</code>的，但是不建议这么做，即使你知道并没有异步操作</p><p><code>$store.commit</code>可以直接提交一个<code>mutation</code>，<code>commit</code>接收一个对象作为参数，对象必须指定一个<code>type</code>属性，表示提交哪一个<code>mutation</code>，或者把<code>type</code>放在第一个参数上</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CHANGE_NAME, CHANGE_AGE &#125; from &#39;@/store/mutation-types&#39;export default &#123;  // ...  methods: &#123;    changeAge() &#123;      this.$store.commit(&#123;        type: CHANGE_AGE,        age: 20      &#125;)      // 把type放在第一个参数上      this.$store.commit(CHANGE_AGE, &#123;        age: 20      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li><li><p>mapMutations</p><pre><code class="javascript">import &#123; mapMutations &#125; from &#39;vuex&#39;export default &#123;  // ...  methods: &#123;    ...mapMutations([      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.commit(&#39;increment&#39;)`      // `mapMutations` 也支持载荷：      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#39;incrementBy&#39;, amount)`    ]),    ...mapMutations(&#123;      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.commit(&#39;increment&#39;)`    &#125;)  &#125;&#125;</code></pre><p>引入<code>mutation-types</code>的例子：</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CHANGE_AGE &#125; from &#39;@/store/mutation-types&#39;import &#123; mapMutations &#125; from &#39;vuex&#39;export default &#123;  // ...  methods: &#123;    ...mapMutations([CHANGE_AGE]),    changeAge() &#123;      this[CHANGE_AGE](&#123;age: 20&#125;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li></ul><h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>在外面使用<code>state</code>时，通过 <code>&#123;&#123;$store.state.users.username&#125;&#125;</code> 获取，</p><p>这里的<code>users</code>是根据<code>new Vuex.Store(&#123; modules: &#123; users: users &#125; &#125;)</code> 的<code>key</code>来指定的</p><p>是否启用命名空间对模块内的<code>state</code>都没有影响，取值的方式都需要加上命名空间</p><p>因此取值方式变成了</p><pre><code class="html">&lt;template&gt;  &#123;&#123;$store.state.users.username&#125;&#125;  &lt;/template&gt;</code></pre><p>或者</p><pre><code class="javascript">...mapState(&#39;account&#39;, [&#39;user&#39;])</code></pre><p>或者</p><pre><code class="javascript">...mapState(&#123;  tomRole: state =&gt; state.users.role,  tomAge: state =&gt; state.users.age&#125;)</code></pre><p>如果仅仅是区分了模块，而没有设置命名空间，那么<code>getters</code>、<code>actions</code>、<code>mutations</code>将会和根状态合并，外部直接获取，不需要加上命名空间</p><p>如果设置命名空间为<code>true</code>，则在外面获取时需要加上命名空间，如下</p><p>如果使用命名空间，那么使用<code>getters</code>、<code>actions</code>、<code>mutaions</code>都需要使用命名空间的写法，</p><pre><code class="javascript">[this.]$store.getters[&#39;account/isAdmin&#39;]   或  ...mapGetters(&#39;account&#39;, [&#39;isAdmin&#39;])[this.]$store.dispatch(&#39;account/login&#39;)    或  ...mapActions(&#39;account&#39;, [&#39;login&#39;])[this.]$store.commit(&#39;account/login&#39;)      或  ...mapMutations(&#39;account&#39;, [&#39;login&#39;])</code></pre><pre><code class="javascript">export default &#123;    namespaced: true,    // 可以注意到state是一个函数返回了对象，避免自己和其他state数据互相污染，实际上和Vue组件内的data是同样的问题    state() &#123;        return &#123;            username: &#39;Tom&#39;,            role: &#39;admin&#39;,            age: 20        &#125;    &#125;,    // 在这个模块的 getter 中，`getters` 被局部化了， 你可以使用 getter 的第四个参数来调用 `rootGetters`    // 如果你希望使用全局 state 和 getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，    // 也会通过 context 对象的属性传入 action。    getters: &#123;        role(state, getters, rootState, rootGetters) &#123;            return state.role        &#125;,        allAge(state, getters, rootState, rootGetters) &#123;            return state.age + rootState.age        &#125;    &#125;,    // 对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：    actions: &#123;        change_role(&#123; commit, rootState &#125;) &#123;            commit(&#39;m_change_role&#39;)        &#125;,        // 在这个模块中， dispatch 和 commit 也被局部化了，他们可以接受 `root` 属性以访问根 dispatch 或 commit        // 若需要在全局命名空间内分发 action 或提交 mutation，将 &#123; root: true &#125; 作为第三参数传给 dispatch 或 commit 即可。        someAction(&#123; dispatch, commit, getters, rootGetters &#125;) &#123;            getters.someGetter                                  // -&gt; &#39;users/someGetter&#39;            rootGetters.someGetter                              // -&gt; &#39;someGetter&#39;            dispatch(&#39;someOtherAction&#39;)                         // -&gt; &#39;users/someOtherAction&#39;            dispatch(&#39;someOtherAction&#39;, null, &#123; root: true &#125;)   // -&gt; &#39;someOtherAction&#39;            commit(&#39;someMutation&#39;)                              // -&gt; &#39;users/someMutation&#39;            commit(&#39;someMutation&#39;, null, &#123; root: true &#125;)        // -&gt; &#39;someMutation&#39;        &#125;,        // 若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。例如：        globalAction: &#123;            root: true,            handler(namespacedContext, payload) &#123; &#125;        &#125;    &#125;,    mutations: &#123;        m_change_role(state, payload) &#123;            state.role = &#39;vip&#39;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 中一些常常令人忽视的重要知识点</title>
      <link href="/2021/08/03/Vue-%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E5%B8%B8%E4%BB%A4%E4%BA%BA%E5%BF%BD%E8%A7%86%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/08/03/Vue-%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E5%B8%B8%E4%BB%A4%E4%BA%BA%E5%BF%BD%E8%A7%86%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要是总结一下自己在使用和学习<code>Vue</code>的过程中容易忽视的重要知识点</p><h1 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h1><p><code>inheritAttrs</code>的作用是组件根元素上是否继承来自父组件定义给该组件的属性，这里的属性不包括已经在子组件中使用<code>props</code>接收到的属性和<code>class</code>、<code>style</code>属性；这些属性可以使用<code>$attrs</code>获取到；</p><p>默认值是<code>true</code></p><p>例如以下父子组件：<br>父组件 ParentComp.vue</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp aaa=&quot;123&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  // inheritAttrs: false,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>父组件中，在子组件定义了一个属性<code>aaa</code>为<code>123</code>，<code>inheritAttrs</code>默认值是<code>true</code>，因此，在子组件的根元素<code>div</code>上，会跟着有<code>aaa</code>为<code>123</code>的属性；</p><p>如图：<br><img src="/images/vue1.png"></p><p>如果此时把子组件的<code>inheritAttrs</code>设置为<code>false</code>，此时子组件的根元素上就不会有该属性了；</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  inheritAttrs: false,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><p><img src="/images/vue2.png"></p><p><strong>那我要怎么拿到这个属性呢？</strong></p><p>可以使用<code>Vue</code>提供的<code>$attrs</code> API来获取组件的属性；</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  inheritAttrs: false,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,  created() &#123;    console.log(&#39;$attrs&#39;, this.$attrs)  &#125;&#125;&lt;/script&gt;</code></pre><p><img src="/images/vue3.png"></p><p>有了这个api就好办了，我们可以把该属性放到自己想要放到的任意元素上，而不是默认的根元素上；</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p v-bind=&quot;$attrs&quot;&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  inheritAttrs: false,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,  created() &#123;    console.log(&#39;$attrs&#39;, this.$attrs)  &#125;&#125;&lt;/script&gt;</code></pre><p>使用<code>v-bind=&quot;$attrs&quot;</code>，可以直接把<code>$attrs</code>里面的属性绑定到元素上，有多少个就绑定多少个;</p><p><strong>最后再强调一下，这里的<code>$attrs</code>是排除了组件<code>props</code>已接收到的属性和<code>class</code>、<code>style</code>属性的；</strong><br>通过一个例子综合看下效果：</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp aaa=&quot;123&quot; bbb=&quot;456&quot; ccc=&quot;789&quot; class=&quot;class1&quot; style=&quot;color: red&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p v-bind=&quot;$attrs&quot;&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  inheritAttrs: false,  props: [&#39;ccc&#39;],  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,  created() &#123;    console.log(&#39;$attrs&#39;, this.$attrs)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>可以看到，<code>class</code>属性和<code>style</code>属性被设置到了根元素上，而此时<code>ccc</code>属性被子组件<code>props</code>接收了，因此只有<code>aaa</code>和<code>bbb</code>属性了;<br><img src="/images/vue4.png"></p><p><img src="/images/vue5.png"></p><h1 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h1><p><code>.sync</code>修饰符有什么作用呢，很简单，我们都知道，父组件向子组件传值可以使用<code>props</code>，子组件是不能直接修改传过来<code>props</code>的，此时常用的方法是子组件通过<code>$emit</code>一个自定义事件，父组件中监听这个时间，然后去修改<code>props</code>的值，从而在子组件中修改<code>props</code>。</p><p>这样并没有任何问题，但是如果每次修改都需要在父组件中定义一个自定义事件，这样十分冗余，那有没有什么方式能够实现<code>props</code>的“双向绑定”呢，这就是<code>.sync</code>的作用，<code>.sync</code>实际上就是上述实现方法的语法糖，通过下面的例子我们可以看到；</p><p>通过自定义方法修改<code>props</code> </p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp @change-msg=&quot;msg = $event&quot;  :msg=&quot;msg&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;$emit(&#39;change-msg&#39;, &#39;我不是传奇&#39;)&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  props: [&#39;msg&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>修改一下自定义事件名，修改为<code>update:msg</code>，也是可以正常工作的。为什么要修改成这样？后面再看。</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp @update:msg=&quot;msg = $event&quot; :msg=&quot;msg&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;$emit(&#39;update:msg&#39;, &#39;我不是传奇&#39;)&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  props: [&#39;msg&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>修改为<code>.sync</code>修饰符的方式，可以看到，我们把父组件的<code>@update:msg=&quot;msg = $event&quot; :msg=&quot;msg&quot;</code> 这直接替换成了<code>:msg.sync=&quot;msg&quot;</code>，仍然能正常工作，实际上<code>.sync</code>就是上述写法的语法糖，不用自己定义事件了，方便了许多；</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp :msg.sync=&quot;msg&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;$emit(&#39;update:msg&#39;, &#39;我不是传奇&#39;)&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  props: [&#39;msg&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><h1 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs&#x2F;$listeners"></a>$attrs&#x2F;$listeners</h1><p><code>$attrs</code>可以拿到绑定到该组件的属性，可以使用<code>v-bind=&quot;$attrs&quot;</code>进行透传，类似于<code>react</code>的<code>&#123;...restProps&#125;</code>，<strong>但是注意，这里的<code>$attrs</code>是排除组件<code>props</code>已接收到的属性和<code>class</code>、<code>style</code>属性</strong></p><p><code>$listeners</code>可以拿到绑定到该组件的绑定的事件，可以使用<code>v-on=&quot;$listeners&quot;</code>进行透传;</p><p>这两个api常用于多个属性，或多个事件的父子组件（或祖孙组件）通信，例如自己封装组件库的时候，一般一个组件层级不会太深，引入<code>vuex</code>进行通信又不合适，使用这两个属性就非常合适了</p><p>我们先看看两个东西具体长啥样，</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp props1=&quot;props1&quot; props2=&quot;props2&quot; @event1=&quot;handleEvent1&quot; @event2=&quot;handleEvent2&quot;&gt;&lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;&#125;  &#125;,  methods: &#123;      handleEvent1(val)&#123;        console.log(&#39;handleEvent1&#39;, val)      &#125;,      handleEvent2(val)&#123;        console.log(&#39;handleEvent2&#39;, val)      &#125;,    &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;    return &#123;&#125;  &#125;,  created() &#123;    console.log(this.$attrs);    console.log(this.$listeners);  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue6.png"></p><p>我们可以拿到父组件传递的属性和监听的事件了，如果这些属性和事件不是给子组件用的，而是给子组件的子组件用的，此时我们就可以进行透传，将其原封不动的传递给孙组件</p><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;!-- 这里进行透传 --&gt;    &lt;grand-son-comp v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/grand-son-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandSonComp from &#39;./GrandSonComp.vue&#39;export default &#123;  name: &#39;ChildComp&#39;,  components: &#123;    GrandSonComp  &#125;,  data() &#123;    return &#123;&#125;  &#125;,  created() &#123;    console.log(this.$attrs);    console.log(this.$listeners);  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 孙组件 GrandSonComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;GrandSonComp&lt;/p&gt;    &#123;&#123;props1&#125;&#125;    &#123;&#123;props2&#125;&#125;    &lt;button @click=&quot;$emit(&#39;event1&#39;, &#39;触发事件event1&#39;)&quot;&gt;触发事件event1&lt;/button&gt;    &lt;button @click=&quot;$emit(&#39;event2&#39;, &#39;触发事件event2&#39;)&quot;&gt;触发事件event2&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;GrandSonComp&#39;,  props: [&#39;props1&#39;, &#39;props2&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue7.gif"></p><p>这样我们就把属性和事件透传给孙组件了，在孙组件里面进行接收和使用；</p><h1 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide&#x2F;inject"></a>provide&#x2F;inject</h1><p><code>provide/inject</code>提供了一个方法，使你能够跨层级进行数据传递，但是注意，传递过去的属性并不是响应式的；</p><p><code>provide</code>可以是一个对象也可以是一个返回对象的函数；</p><p>后代元素可以直接<code>inject</code>注入数据，可以使用字符串数组接收，也可以使用对象，给定一个<code>default</code>，使其变成可选项（后文有例子）</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;button @click=&quot;changeMsg&quot;&gt;change msg&lt;/button&gt;    &lt;child-comp&gt;&lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  provide() &#123;    return &#123;      dataFromParent: &#39;data from parent&#39;,      msg: this.msg,    &#125;  &#125;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,  methods: &#123;    changeMsg() &#123;      this.msg = &#39;我不是传奇&#39;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;grand-son-comp&gt;&lt;/grand-son-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandSonComp from &#39;./GrandSonComp.vue&#39;export default &#123;  name: &#39;ChildComp&#39;,  components: &#123;    GrandSonComp  &#125;,  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 孙组件 GrandSonComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;GrandSonComp&lt;/p&gt;    &#123;&#123; dataFromParent &#125;&#125;    &#123;&#123; msg &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;GrandSonComp&#39;,  inject: [&#39;dataFromParent&#39;, &#39;msg&#39;],  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue8.gif"></p><p>上述代码，我们在<code>ParentComp</code>中<code>provide</code>了两个数据，一个是<code>dataFromParent</code>，一个是<code>msg</code>，子组件中并没有对着两个属性进行接收传递，而在孙组件<code>GrandSonComp</code>中使用<code>inject</code>可以直接拿到那两个数据，这就是<code>provide/inject</code>的作用，同时，我们可以看到，虽然<code>msg</code>在父组件中是响应式的，但是孙组件<code>inject</code>进来的<code>msg</code><strong>并不具备响应式能力</strong>，这是为了避免<code>props</code>混乱而刻意为之的，但是如果provide提供的本身是一个响应式对象，则可以进行响应式；</p><p>如果我们在父组件中直接把父组件的实例传递<code>provide</code>，则后代可以拿到这个父实例，并且拿到父实例绑定的<code>data</code>，这些<code>data</code>都是响应式的，例如：</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &#123;&#123; msg &#125;&#125;    &lt;button @click=&quot;changeMsg&quot;&gt;change msg&lt;/button&gt;    &lt;child-comp&gt;&lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  provide() &#123;    return &#123;      dataFromParent: &#39;data from parent&#39;,      msg: this.msg,      // 直接把父组件实例给到provide      parentInstance: this    &#125;  &#125;,  data() &#123;    return &#123;      msg: &#39;我是传奇&#39;    &#125;  &#125;,  methods: &#123;    changeMsg() &#123;      this.msg = &#39;我不是传奇&#39;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;grand-son-comp&gt;&lt;/grand-son-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandSonComp from &#39;./GrandSonComp.vue&#39;export default &#123;  name: &#39;ChildComp&#39;,  components: &#123;    GrandSonComp  &#125;,  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 孙组件 GrandSonComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;GrandSonComp&lt;/p&gt;    &#123;&#123; dataFromParent &#125;&#125;    &#123;&#123; msg &#125;&#125;    &#123;&#123; parentInstance.msg &#125;&#125;    &lt;button @click=&quot;changeMsg&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;GrandSonComp&#39;,  inject: [&#39;dataFromParent&#39;, &#39;msg&#39;, &#39;parentInstance&#39;],  data() &#123;    return &#123;&#125;  &#125;,  methods: &#123;      changeMsg() &#123;          this.parentInstance.msg = &#39;我也不是传奇 - from GrandSonComp&#39;      &#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue9.gif"></p><p>可以看到，我们直接把父组件实例给到<code>provide</code>，后代组件可以直接拿到，然后我们队父组件实例的数据修改，后代组件都能响应式处理，并且，也可以在后代组件中对父组件实例进行操作，比如修改属性等，十分灵活，但是这种用法不建议在应用程序中使用，而是更多的应用于基础组件的封装；</p><p>拓展一下，<code>inject</code>不仅可以使用字符串数组的方式，还可以使用对象的方式，还可以修改属性名，就以上的例子，下面的写法是相同的；</p><blockquote><p>由于msg已经被重命名为parentMsg了，因此模板里的msg也需要随之修改</p></blockquote><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;GrandSonComp&lt;/p&gt;    &#123;&#123; dataFromParent &#125;&#125;    &#123;&#123; parentMsg &#125;&#125;    &#123;&#123; parentInstance.msg &#125;&#125;    &lt;button @click=&quot;changeMsg&quot;&gt;change msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;GrandSonComp&#39;,  // inject: [&#39;dataFromParent&#39;, &#39;msg&#39;, &#39;parentInstance&#39;],  inject: &#123;      dataFromParent: &#123; default: &#39;default value&#39; &#125;, // 给定default，如果provide中没有就使用默认值      parentMsg: &#123;  // msg是父组件provide过来的，如果想要在后代中修改属性名，可以使用这种方式，from是provide里的key          from: &#39;msg&#39;,          default: &#39;default msg&#39;      &#125;,      parentInstance: &#39;parentInstance&#39; // 这种也可以，什么都不指定  &#125;,  data() &#123;    return &#123;&#125;  &#125;,  methods: &#123;      changeMsg() &#123;          this.parentInstance.msg = &#39;我也不是传奇 - from GrandSonComp&#39;      &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h1 id="slots-scopedSlots"><a href="#slots-scopedSlots" class="headerlink" title="$slots &amp; $scopedSlots"></a>$slots &amp; $scopedSlots</h1><p><code>$slots</code>只能拿到具名插槽分发的内容，不能拿到作用域插槽的内容，默认插槽实际上也是具名插槽，只不过可以简写；</p><p><code>$scopedSlots</code>用来获取作用域插槽的内容；</p><p>在如下组件中，子组件<code>ChildComp</code>定义了一个默认插槽，一个具名插槽，一个作用域插槽，而在我们获取<code>$slots</code>的时候，只能获取到<code>default</code>和<code>slot1</code>的插槽内容</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp&gt;      &lt;template #slot1&gt;        slot1 content      &lt;/template&gt;      &lt;template #slot2=&quot;&#123;compName&#125;&quot;&gt;        &#123;&#123;compName&#125;&#125;        123      &lt;/template&gt;      default slot content    &lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &lt;slot&gt;&lt;/slot&gt;    &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;    &lt;slot name=&quot;slot2&quot; :comp-name=&quot;compName&quot;&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;    return &#123;      compName: &quot;ChildComp&quot;    &#125;  &#125;,  created() &#123;    console.log(this.$slots)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue9.png"></p><h1 id="Vue-delete删除数组"><a href="#Vue-delete删除数组" class="headerlink" title="Vue.delete删除数组"></a>Vue.delete删除数组</h1><p>使用js 的delete删除数组的时候，只是将该索引位的值变为了empty，实际长度是没变的，而使用Vue.delete删除数组的时候，会将该索引位的值直接删除，索引会前进一位<br><img src="/images/vue8.png"></p><h1 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="$forceUpdate"></a>$forceUpdate</h1><p>当视图层无法进行数据更新时，用<code>this.$forceUpdate()</code>进行视图层重新渲染。例如我们知道，对一个数组类型的数据，直接使用索引去修改数据，数据是不会响应式变化的，此时我们就可以使用<code>$forceUpdate</code>强制更新组件并重新渲染</p><p>例如下面的代码，我们点击了<code>change</code>按钮之后，<code>data</code>里面的值是发生了变化的，但是页面没有相应变化，就是没有重新渲染，当我们点击<code>forceUpdate</code>后，页面变化了;</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;button @click=&quot;change&quot;&gt;change&lt;/button&gt;    &lt;button @click=&quot;forceUpdate&quot;&gt;forceUpdate&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      list: [1, 2, 3, 5]    &#125;  &#125;,  methods: &#123;    change() &#123;      this.list[1] = 999    &#125;,    forceUpdate() &#123;      this.$forceUpdate()    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p><img src="/images/vue10.gif"></p><h1 id="hook-lifecycle"><a href="#hook-lifecycle" class="headerlink" title="@hook:[lifecycle]"></a>@hook:[lifecycle]</h1><p>试想一下，父子组件的挂载顺序是<code>beforeCreate-&gt; created -&gt; beforeMount -&gt; mounted</code>，那我们有没有什么方法能够在父组件中监听到子组件是否挂载了呢？通常我们的做法是在子组件的<code>mounted</code>钩子中<code>$emit</code>一个自定义事件，在父组件中监听，这样确实可以，但是如果说子组件是一个第三方的组件，我们无法直接修改子组件里的代码，此时该怎么办？</p><p>此时我们就可以使用下面介绍的方法，在<code>Vue</code>中，当每个生命周期执行的时候，都会<code>emit</code>一个自定义事件，例如在<code>created</code>生命周期中，会<code>$emit(&#39;hook:created&#39;)</code>，这是<code>Vue</code>内部自己做的事情，我们不需要手动做，有了这一个东西，我们就可以在引用这个组件的任意组件中进行这个自定义事件的监听，例如<code>@hook:created</code></p><p>通过代码能更直观的感受到这个方式的好处</p><!-- tab 父组件 ParentComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;child-comp @hook:mounted=&quot;handleChildCompMounted&quot; @hook:created=&quot;handleChildCompCreated&quot;&gt;&lt;/child-comp&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;&#125;  &#125;,  methods: &#123;    handleChildCompMounted() &#123;      console.log(&#39;child-comp mounted&#39;)    &#125;,    handleChildCompCreated() &#123;      console.log(&#39;child-comp created&#39;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 ChildComp.vue --><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;    return &#123;      compName: &quot;ChildComp&quot;    &#125;  &#125;,  created()&#123;    console.log(&#39;ChildComp created --- from ChildComp&#39;)  &#125;,  mounted() &#123;    console.log(&#39;ChildComp mounted --- from ChildComp&#39;)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><p>查看结果：<br><img src="/images/vue11.png"></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 生命周期及父子组件生命周期钩子执行顺序</title>
      <link href="/2021/08/03/Vue-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2021/08/03/Vue-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h1><p>我们先来看看Vue的生命周期，Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>updated</td><td>组件数据更新之后</td></tr><tr><td>activited</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestory</td><td>组件销毁前调用</td></tr><tr><td>destoryed</td><td>组件销毁后调用</td></tr></tbody></table><p>图示：<br><img src="/images/lifecycle.png"></p><h1 id="父子组件声明周期执行顺序"><a href="#父子组件声明周期执行顺序" class="headerlink" title="父子组件声明周期执行顺序"></a>父子组件声明周期执行顺序</h1><p>在单一组件中，挂载时钩子的执行顺序是<code>beforeCreate-&gt; created -&gt; beforeMount -&gt; mounted</code>，但当父子组件嵌套时，父组件和子组件各拥有各自独立的钩子函数，这些父子组件的这些钩子是如何交融执行，且执行顺序又是怎样的呢?</p><p>我们先给出父子组件的代码；</p><!-- tab 父组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;gray&#39;, padding: &#39;10px&#39;&#125;&quot;&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;ChildComp /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;    &#125;  &#125;,  methods: &#123;  &#125;,  beforeCreate() &#123;    console.log(`ParentComp - beforeCreate - $&#123;new Date().getTime()&#125;`)  &#125;,  created() &#123;    console.log(`ParentComp - created - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeMount() &#123;    console.log(`ParentComp - beforeMount - $&#123;new Date().getTime()&#125;`)  &#125;,  mounted() &#123;    console.log(`ParentComp - mounted - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeUpdate() &#123;    console.log(`ParentComp - beforeUpdate - $&#123;new Date().getTime()&#125;`)  &#125;,  updated() &#123;    console.log(`ParentComp - updated - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeDestroy() &#123;    console.log(`ParentComp - beforeDestroy - $&#123;new Date().getTime()&#125;`)  &#125;,  destroyed() &#123;    console.log(`ParentComp - destroyed - $&#123;new Date().getTime()&#125;`)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;green&#39;&#125;&quot;&gt;    &lt;p&gt;ChildComp&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;      return &#123;      &#125;  &#125;,  methods: &#123;  &#125;,  beforeCreate() &#123;    console.log(`ChildComp - beforeCreate - $&#123;new Date().getTime()&#125;`)  &#125;,  created() &#123;    console.log(`ChildComp - created - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeMount() &#123;    console.log(`ChildComp - beforeMount - $&#123;new Date().getTime()&#125;`)  &#125;,  mounted() &#123;    console.log(`ChildComp - mounted - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeUpdate() &#123;    console.log(`ChildComp - beforeUpdate - $&#123;new Date().getTime()&#125;`)  &#125;,  updated() &#123;    console.log(`ChildComp - updated - $&#123;new Date().getTime()&#125;`)  &#125;,  beforeDestroy() &#123;    console.log(`ChildComp - beforeDestroy - $&#123;new Date().getTime()&#125;`)  &#125;,  destroyed() &#123;    console.log(`ChildComp - destroyed - $&#123;new Date().getTime()&#125;`)  &#125;&#125;&lt;/script&gt;</code></pre><!-- endtab --><h1 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h1><p><img src="/images/vue_lifecycle2.gif"></p><p>子组件挂载完成后，父组件还未挂载。所以组件数据回显的时候，在父组件<code>mounted</code>中获取<code>api</code>的数据，子组件的<code>mounted</code>是拿不到的。</p><pre><code>ParentComp - beforeCreate - 1627923686788ParentComp - created - 1627923686807ParentComp - beforeMount - 1627923686808ChildComp - beforeCreate - 1627923686810ChildComp - created - 1627923686810ChildComp - beforeMount - 1627923686811ChildComp - mounted - 1627923686814ParentComp - mounted - 1627923686815</code></pre><h1 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h1><p>当数据发生更新的时候，组件会触发<code>beforeUpdate</code>和<code>updated</code>这两个钩子函数，下面我们来看看在父子组件中，这两个钩子的触发顺序是怎样的；</p><h2 id="父子组件各自更新"><a href="#父子组件各自更新" class="headerlink" title="父子组件各自更新"></a>父子组件各自更新</h2><p>父子组件各自在自己组件内部更新自己的数据，此时都只会触发各自的钩子；</p><!-- tab 父组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;gray&#39;, padding: &#39;10px&#39;&#125;&quot;&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &#123;&#123; parentData &#125;&#125;    &lt;button @click=&quot;updateParentData&quot;&gt;update parent data&lt;/button&gt;    &lt;ChildComp /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      parentData: &#39;parentData&#39;    &#125;  &#125;,  methods: &#123;    updateParentData() &#123;      this.parentData = &#39;new parentData&#39;    &#125;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;green&#39;&#125;&quot;&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &#123;&#123;childData&#125;&#125;    &lt;button @click=&quot;updateChildData&quot;&gt;update child data&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;      return &#123;        childData: &#39;childData&#39;      &#125;  &#125;,  methods: &#123;    updateChildData() &#123;      this.childData = &#39;new childData&#39;    &#125;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue_lifecycle1.gif"></p><p>可以看到，父子组件各自更新，不会互相影响，只会触发自己的更新钩子</p><h2 id="props更新"><a href="#props更新" class="headerlink" title="props更新"></a>props更新</h2><p>当使用<code>props</code>将数据传递给子组件的时候，由于父组件自身的数据发生了变化，因此会触发钩子函数，子组件虽然没有显示的修改数据，但是父组件穿过类的<code>props</code>数据发生了变化，此时子组件也会触发钩子函数，可以理解为子组件将父组件传过来的<code>props</code>作为了<code>data</code>里的数据，此时<code>props</code>变了，也会触发钩子，也可以看到模板里使用<code>props</code>的数据直接实用就好了，和<code>data</code>里声明的数据是同样的使用方式</p><!-- tab 父组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;gray&#39;, padding: &#39;10px&#39;&#125;&quot;&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;button @click=&quot;updatePropsData&quot;&gt;update child props data&lt;/button&gt;    &lt;ChildComp :childPropsData=&quot;childPropsData&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;      childPropsData: &#39;props data&#39;    &#125;  &#125;,  methods: &#123;    updatePropsData() &#123;      this.childPropsData = &#39;new props data&#39;    &#125;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;green&#39;&#125;&quot;&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &#123;&#123; childPropsData &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  props: [&#39;childPropsData&#39;],  data() &#123;      return &#123;      &#125;  &#125;,  methods: &#123;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue_lifecycle3.gif"></p><p>可以看到，通过修改<code>props</code>来更新数据，会先触发父组件的<code>beforeUpdate</code>钩子，让后等到子组件更新完毕，再触发父组件的<code>updated</code>钩子</p><h2 id="通过ref更新"><a href="#通过ref更新" class="headerlink" title="通过ref更新"></a>通过ref更新</h2><p>我们再来看看直接通过ref更新子组件的数据，此时父组件是没有数据修改的，因此不会触发钩子，但是子组件的数据被父组件修改了，因此会触发钩子函数</p><!-- tab 父组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;gray&#39;, padding: &#39;10px&#39;&#125;&quot;&gt;    &lt;p&gt;ParentComp&lt;/p&gt;    &lt;button @click=&quot;updateChildData&quot;&gt;update child data&lt;/button&gt;    &lt;ChildComp ref=&quot;childComp&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp  &#125;,  name: &#39;ParentComp&#39;,  data() &#123;    return &#123;    &#125;  &#125;,  methods: &#123;    updateChildData() &#123;      this.$refs.childComp.childData = &#39;new child data&#39;    &#125;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><!-- tab 子组件 --><pre><code class="html">&lt;template&gt;  &lt;div :style=&quot;&#123; backgroundColor: &#39;green&#39;&#125;&quot;&gt;    &lt;p&gt;ChildComp&lt;/p&gt;    &#123;&#123; childData &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;ChildComp&#39;,  data() &#123;      return &#123;        childData: &#39;child data&#39;      &#125;  &#125;,  methods: &#123;  &#125;,  // 其余重复生命周期代码同上&#125;&lt;/script&gt;</code></pre><!-- endtab --><p><img src="/images/vue_lifecycle4.gif"></p><p>可以看到，通过ref去更新子组件的数据，也只会触发子组件的<code>beforeUpdate</code>和<code>updated</code>钩子；</p><h1 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h1><p><img src="/images/vue_lifecycle5.gif"></p><p>父组件开始销毁，然后当子组件都销毁了之后，父组件才会执行<code>destroyed</code>钩子</p><pre><code>ParentComp - beforeDestroy - 1627927903322ChildComp - beforeDestroy - 1627927903322ChildComp - destroyed - 1627927903323ParentComp - destroyed - 1627927903323</code></pre><h1 id="异步引入组件"><a href="#异步引入组件" class="headerlink" title="异步引入组件"></a>异步引入组件</h1><p>如果是异步引入组件，我们来看看有什么不同的地方；<br>我们只需要将引入子组件的方式修改成为异步的方式，例如：</p><pre><code class="html">&lt;script&gt;// import ChildComp from &#39;./ChildComp.vue&#39;export default &#123;  components: &#123;    ChildComp: () =&gt; import(&#39;./ChildComp.vue&#39;)  &#125;,&#125;&lt;/script&gt;</code></pre><p>很明显的区别在于，异步引入组件，父组件是直接挂载完成的，<code>mounted</code>之后才去开始挂载子组件，此时我们不刷新页面，卸载组件后重新挂载，钩子函数的触发顺序又和之前一样了，因此，只有当第一次挂载组件的时候，才会等到父组件挂载完成之后再去挂载子组件，之后无论卸载重新挂载多少次，钩子的触发顺序和同步引入的方式就一致了</p><p><img src="/images/vue_lifecycle6.gif"></p><p>对于其他场景的钩子触发顺序，则都是一样的，只有在第一次挂载的时候有所差异；</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa + axios + jwt  实现token自动续期</title>
      <link href="/2021/07/29/koa-axios-jwt-%E5%AE%9E%E7%8E%B0token%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F/"/>
      <url>/2021/07/29/koa-axios-jwt-%E5%AE%9E%E7%8E%B0token%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.baihuzi.com/2021/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/">深入理解token</a>这篇文章详细讲解了token的作用及优势，这篇文章我们通过jwt和koa来简单实现一个自动续期token。</p><p>首先来看看JWT</p><h1 id="Json-web-token-JWT"><a href="#Json-web-token-JWT" class="headerlink" title="Json web token (JWT)"></a>Json web token (JWT)</h1><p><code>Json web token (JWT)</code>, 是为了在网络应用环境间传递声明而执行的一种基于<code>JSON</code>的开放标准<code>(RFC 7519)</code>，该<code>token</code>被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。<code>JWT</code>的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><p>一个完整的<code>JWT</code>长这样</p><pre><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImJhaWh1emkiLCJhZG1pbiI6dHJ1ZSwiYWdlIjoxOCwiaWF0IjoxNjI3NTU4MjU3LCJleHAiOjE2Mjc1NTg4NTd9.FmiN7MoQm8uzGAFXXNve6z3r94JRVFGmCcKWVQyz2T9o-0ovhFRC1eQ6xgFX8AKFMSqMIBs8Yd_rDSXNFqBgQkxkBQEHqQlv4-BjhvxA3W1FpclUtqQfSQx9mWeWDN79RPOV7ayTZ-8e9hDJVqB3hoFZsWddHxens1IKbSEQylZrgEGNJVGbeN2sTNyHvXQoxUzft5E3k2odp5lnS-Fl0dwkrwsBEvQ81cNQio24d4VINBDCcF6nOBii6mEMA9VLBj4j1PDT2BEBgZlCbrvHbsuYCQUljvsHInkRrnySzc4DwiIxzrKEapr8raD--MHH0Iz78__hJrqCZTAxve-iaA</code></pre><p>包括三段信息，通过<code>.</code>分隔，第一部分我们称它为头部（<code>header</code>),第二部分我们称其为载荷（<code>payload</code>, 类似于飞机上承载的物品)，第三部分是签名（<code>signature</code>）.</p><h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><p>jwt的头部承载两部分信息：</p><ul><li>声明类型，这里是<code>JWT</code></li><li>声明加密的算法 通常直接使用 <code>HMAC</code>或<code>SHA256</code><br>完整的头部就像下面这样的JSON：</li></ul><pre><code class="javascript">&#123;  &quot;alg&quot;:&quot;RS256&quot;,      // 算法  &quot;typ&quot;:&quot;JWT&quot;         // 类型&#125;</code></pre><p>然后将头部进行<code>base64</code>加密（该加密是可以对称解密的),构成了第一部分.</p><pre><code class="javascript">new Buffer.from(&#39;&#123;&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#39;).toString(&#39;base64&#39;);// eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9</code></pre><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ul><p>标准中注册的声明 (建议但不强制使用)：</p><ul><li>iss: jwt签发者</li><li>sub: jwt所面向的用户</li><li>aud: 接收jwt的一方</li><li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li><li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li><li>iat: jwt的签发时间</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li></ul><p>公共的声明：<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><p>私有的声明 ：<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为<code>base64</code>是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>定义一个payload:</p><pre><code class="javascript">&#123;  &quot;username&quot;:&quot;daryl&quot;,  &quot;age&quot;:18,  &quot;admin&quot;:true&#125;</code></pre><pre><code class="javascript">new Buffer.from(&#39;eyJ1c2VybmFtZSI6ImJhaWh1emkiLCJhZG1pbiI6dHJ1ZSwiYWdlIjoxOCwiaWF0IjoxNjI3NTU4MjU3LCJleHAiOjE2Mjc1NTg4NTd9&#39; , &#39;base64&#39;).toString();// &#123;&quot;username&quot;:&quot;baihuzi&quot;,&quot;admin&quot;:true,&quot;age&quot;:18,&quot;iat&quot;:1627558257,&quot;exp&quot;:1627558857&#125;</code></pre><h2 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h2><p>签名是把<code>header</code>和<code>payload</code>对应的<code>json</code>结构进行<code>base64</code>url编码之后得到的两个串用英文句点号拼接起来，然后根据<code>header</code>里面<code>alg</code>指定的签名算法生成出来的。</p><p>算法不同，签名结果不同。<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以自我签发<code>jwt</code>了。</p><h2 id="JWT的签发与验签"><a href="#JWT的签发与验签" class="headerlink" title="JWT的签发与验签"></a>JWT的签发与验签</h2><p><code>RS256</code>是非对称算法，有一对公私秘钥，需要自己生成，通过私钥进行签名，只有自己签发的才是合法的，防止恶意伪造token，通过公钥进行验签，如果token被修改挥着过期了，验签就会失败</p><pre><code class="javascript">let jwt = require(&#39;jsonwebtoken&#39;);let fs = require(&#39;fs&#39;)let data = &#123;    username: &#39;daryl&#39;,    age: 18,    admin: true&#125;// 用私钥进行签名，用公钥进行验签，防止客户端伪造tokenlet privateKey = fs.readFileSync(&#39;./private.pem&#39;)let token = jwt.sign(data, privateKey, &#123; algorithm: &#39;RS256&#39;, expiresIn: 60 * 10 &#125;);console.log(token)// 用公钥进行验签let publicKey = fs.readFileSync(&#39;./public.pem&#39;)let res = jwt.verify(token, publicKey, &#123; algorithm: &#39;RS256&#39; &#125;)console.log(res);</code></pre><pre><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImRhcnlsIiwiYWdlIjoxOCwiYWRtaW4iOnRydWUsImlhdCI6MTYyNzU3Mzc1MiwiZXhwIjoxNjI3NTc0MzUyfQ.snfD-YTXbCGb7et_BYtmw2FGZQ7wev_DAcdnn-StN13_PSpOw5zEUN7ldsL7_8RFH5m5Mu5Ot6WzdTKgP8JiuZuO-G01QsdECvSeEU3D7r2Yoj2x_H13lZpYpuZ6dgVsKE4CeWDME1MAN1YRwIygkse9Ds614nnfIx6ewRs1FNZXnusEXx4D6T1fMmhLBEcJs5gdFMdSrNQyuJvZtmIyqzY5wYYGfHen1CRmM_cFSq8EcnGgLsR_91S4sDzw3JVfw47rV8vp3OwlvI2Nldz_Zk7C6wLdkPw9VHxCigC4mJZ10tH4ICKU8XpZEzxhHgu7_o_luOOvXGfa6dm4-CrR6A&#123;  username: &#39;daryl&#39;,  age: 18,  admin: true,  iat: 1627573752,  // 签发时间  exp: 1627574352   // 过期时间&#125;</code></pre><h1 id="koa-jwt实现token续期"><a href="#koa-jwt实现token续期" class="headerlink" title="koa-jwt实现token续期"></a>koa-jwt实现token续期</h1><pre><code class="javascript">const Koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;)const betterBody = require(&#39;koa-better-body&#39;);const jwt = require(&#39;jsonwebtoken&#39;)const koaJwt = require(&#39;koa-jwt&#39;)// 假用户数据const user = &#123; username: &#39;jerry&#39;, password: &#39;123456&#39; &#125;// jwt 秘钥，默认使用的是HS256算法，签名和验签使用同一个秘钥const jwtSecret = &#39;sdD(Sdsdfsd^%8ds^^&amp;5s&#39;let app = new Koa()app.listen(8080);// 跨域设置，需要注意的是，要将Authorization头设置到Access-Control-Allow-Headers里面去，否则无法跨域发送Authorization头app.use(async (ctx, next) =&gt; &#123;    ctx.set(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);    ctx.set(&#39;Access-Control-Allow-Headers&#39;, &#39;x-requested-with,content-type,Authorization&#39;)    ctx.set(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT, POST, GET, DELETE, OPTIONS&#39;);    if (ctx.method == &#39;OPTIONS&#39;) &#123;        ctx.set(&quot;Access-Control-Max-Age&quot;, &quot;1728000000&quot;);        ctx.body = &#39;ok&#39;;    &#125; else &#123;        await next();    &#125;&#125;)app.use(betterBody());let router = new Router();// 模拟登录接口，成功就发送token// 发送accessToken 和 refreshToken两个tokenrouter.post(&#39;/login&#39;, async ctx =&gt; &#123;    let &#123; username, password &#125; = ctx.request.fields;    if (!username) &#123;        ctx.body = &#123; code: 201, msg: &#39;用户名不存在&#39; &#125;;    &#125; else &#123;        let &#123; username: name, password: pass &#125; = user        if (username == name &amp;&amp; password == pass) &#123;            let token = createToken(&#123; username &#125;)            ctx.body = &#123; code: 200, msg: &#39;登录成功&#39;, token &#125;        &#125; else &#123;            ctx.body = &#123; code: 202, msg: &#39;用户名或密码错误&#39; &#125;        &#125;    &#125;&#125;)// token自动续期接口router.post(&#39;/refreshToken&#39;, async ctx =&gt; &#123;    let refreshToken = ctx.headers.authorization;    await verifyToken(refreshToken)        .then(async (token) =&gt; &#123;            // 校验成功就重新发送accessToken和refreshToken            let newToken = createToken(&#123; username: token.username &#125;);            // 等待5秒再返回，方便查看效果            await sleep(5000).then(() =&gt; &#123;                ctx.body = &#123; code: 200, msg: &#39;续期成功&#39;, token: newToken &#125;            &#125;)        &#125;)        .catch((e) =&gt; &#123;            ctx.status = 402;            ctx.body = &#123; code: 402, msg: &#39;续期失败，请重新登录&#39; &#125;        &#125;)&#125;)// ---------------------------------koa-jwt----------------------------------// 验证失败时捕获401，返回自定义信息app.use(function (ctx, next) &#123;    return next().catch((err) =&gt; &#123;        if (401 == err.status) &#123;            ctx.status = 401;            ctx.body = &#123; code: 401, msg: &#39;token expired&#39; &#125;;        &#125; else &#123;            throw err;        &#125;    &#125;);&#125;);// 默认校验在请求头中的[ Authorization: Bearer TOKEN ] 头,&#39;Bearer &#39; (后面有一个空格)// token不合法或者过期都会返回401错误// 另外定义在unless中路由不会被校验app.use(koaJwt(&#123; secret: jwtSecret &#125;).unless(&#123; path: [/^\/login/, /^\/refreshToken/] &#125;))// ---------------------------------koa-jwt----------------------------------// 测试接口router.get(&#39;/a&#39;, async ctx =&gt; &#123;    ctx.body = &#123; code: 200, msg: &#39;a&#39; &#125;&#125;)router.get(&#39;/b&#39;, async ctx =&gt; &#123;    ctx.body = &#123; code: 200, msg: &#39;b&#39; &#125;&#125;)router.get(&#39;/c&#39;, async ctx =&gt; &#123;    ctx.body = &#123; code: 200, msg: &#39;c&#39; &#125;&#125;)app.use(router.routes())// 生成token函数function createToken(obj) &#123;    // 为了模拟续期，把token的时效设置短一点，单位是秒    // 生成两个token，accessToken用于接口访问，refreshToken用于请求token续期接口    let accessToken = jwt.sign(obj, jwtSecret, &#123; expiresIn: 15 &#125;)    let refreshToken = jwt.sign(obj, jwtSecret, &#123; expiresIn: 30 &#125;)    return &#123; accessToken, refreshToken &#125;&#125;// 校验refreshToken函数function verifyToken(refreshToken) &#123;    return new Promise((resolve, reject) =&gt; &#123;        jwt.verify(refreshToken.split(&#39; &#39;)[1], jwtSecret, (err, token) =&gt; &#123;            if (err) &#123;                reject(err)            &#125; else &#123;                resolve(token)            &#125;        &#125;)    &#125;)&#125;// 异步延时函数function sleep(time = 0) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve();        &#125;, time);    &#125;)&#125;</code></pre><h1 id="axios实现自动续期"><a href="#axios实现自动续期" class="headerlink" title="axios实现自动续期"></a>axios实现自动续期</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;script src=&quot;./axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;button id=&quot;login&quot;&gt;登录&lt;/button&gt;    &lt;button id=&quot;abc&quot;&gt;同时获取abc&lt;/button&gt;    &lt;script&gt;        let loginBtn = document.querySelector(&#39;#login&#39;);        let requestBtn = document.querySelector(&#39;#abc&#39;);        axios.defaults.baseURL = &#39;http://localhost:8080&#39;        loginBtn.onclick = function () &#123;            axios.post(&#39;/login&#39;, &#123;                username: &#39;jerry&#39;,                password: &#39;123456&#39;            &#125;).then(res =&gt; &#123;                if (res.data.code == 200) &#123;                    localStorage.setItem(&#39;accessToken&#39;, res.data.token.accessToken)                    localStorage.setItem(&#39;refreshToken&#39;, res.data.token.refreshToken)                &#125; else &#123;                    alert(&#39;用户名或密码错误&#39;)                &#125;            &#125;)        &#125;        requestBtn.onclick = function () &#123;            axios.all([axios.get(&#39;/a&#39;), axios.get(&#39;b&#39;), axios.get(&#39;/c&#39;)]).then(axios.spread(function (a, b, c) &#123;                console.log(a.data, b.data, c.data);            &#125;))        &#125;        // 请求拦截器，根据url设置不同的请求token        axios.interceptors.request.use(function (config) &#123;            if (config.url == &#39;/refreshToken&#39;) &#123;                config.headers.Authorization = &#39;Bearer &#39; + localStorage.getItem(&#39;refreshToken&#39;)            &#125; else if (config.url !== &#39;/login&#39;) &#123;                config.headers.Authorization = &#39;Bearer &#39; + localStorage.getItem(&#39;accessToken&#39;)            &#125;            return config;        &#125;, function (error) &#123;            return Promise.reject(error);        &#125;);        // 如果正在请求续期接口，则不再请求了，避免重复请求续期接口        let isRefreshing = false;        // 请求401后，把失败的请求放在这里面，等到token续期后拿出来重新请求        let retryRequests = [];        axios.interceptors.response.use(response =&gt; &#123;            const &#123;code&#125; = response.data;            if (code !== 200) &#123;                return Promise.reject(response)            &#125; else &#123;                return response            &#125;        &#125;, error =&gt; &#123;            if (!error.response) return Promise.reject(error)            // 401 accessToken过期，402 refreshToken过期            if (error.response.data.code === 401) &#123;                const config = error.config                if (!isRefreshing) &#123;                    isRefreshing = true;                    axios.post(&#39;/refreshToken&#39;).then(res =&gt; &#123;                        if (res.data.code == 200) &#123;                            localStorage.setItem(&#39;accessToken&#39;, res.data.token.accessToken)                            localStorage.setItem(&#39;refreshToken&#39;, res.data.token.refreshToken)                            retryRequests.forEach(req =&gt; req())                            retryRequests = []                            return axios(config)                        &#125;                    &#125;).catch(err =&gt; &#123;                        alert(&#39;请重新登录&#39;);                    &#125;).finally(()=&gt;&#123;                        isRefreshing = false;                    &#125;)                &#125; else &#123;                    return new Promise((resolve) =&gt; &#123;                        // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行                        retryRequests.push((newToken) =&gt; &#123;                            resolve(axios(config))                        &#125;)                    &#125;)                &#125;            &#125;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>查看效果：</p><p>可以看到，多个请求<code>401</code>，只会去调用一次<code>refreshToken</code>接口，并且当续期接口成功返回后，之前失败的<code>401</code>请求也会重新请求，当续期接口的<code>token</code>也过期后，会返回<code>402</code>，让用户重新登录；<br><img src="/images/refreshToken.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> token </tag>
            
            <tag> jwt </tag>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】深入理解token</title>
      <link href="/2021/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/"/>
      <url>/2021/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://my.oschina.net/jamesfancy/blog/1613994">深入理解token</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p><code>Token</code> 是在服务端产生的。如果前端使用<code>用户名/密码</code>向服务端请求认证，服务端认证成功，那么在服务端会返回 <code>Token</code> 给前端。前端可以在每次请求的时候带上 <code>Token</code> 证明自己的合法地位</p><p>不久前，我在在前后端分离实践中提到了基于 <code>Token</code> 的认证，现在我们稍稍深入一些。</p><p>通常情况下，我们在讨论某个技术的时候，都是从问题开始。那么第一个问题：</p><h1 id="为什么要用-Token？"><a href="#为什么要用-Token？" class="headerlink" title="为什么要用 Token？"></a>为什么要用 Token？</h1><p>而要回答这个问题很简单——因为它能解决问题！</p><p>可以解决哪些问题呢？</p><ol><li><code>Token</code> 完全由应用管理，所以它可以避开同源策略</li><li><code>Token</code> 可以避免 <code>CSRF</code> 攻击(<a href="http://dwz.cn/7joLzx">http://dwz.cn/7joLzx</a>)</li><li><code>Token</code> 可以是无状态的，可以在多个服务间共享</li></ol><p><code>Token</code> 是在服务端产生的。如果前端使用<code>用户名/密码</code>向服务端请求认证，服务端认证成功，那么在服务端会返回 <code>Token</code> 给前端。前端可以在每次请求的时候带上 <code>Token</code> 证明自己的合法地位。如果这个 <code>Token</code> 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。</p><p>于是，又一个问题产生了：需要为 <code>Token</code> 设置有效期吗？</p><h1 id="需要设置有效期吗？"><a href="#需要设置有效期吗？" class="headerlink" title="需要设置有效期吗？"></a>需要设置有效期吗？</h1><p>对于这个问题，我们不妨先看两个例子。一个例子是登录密码，一般要求定期改变密码，以防止泄漏，所以密码是有有效期的；另一个例子是安全证书。<code>SSL</code> 安全证书都有有效期，目的是为了解决吊销的问题，对于这个问题的详细情况，来看看<a href="https://www.zhihu.com/question/20803288">知乎的回答</a>。所以无论是从安全的角度考虑，还是从吊销的角度考虑，<code>Token</code> 都需要设有效期。</p><p>那么有效期多长合适呢？</p><p>只能说，根据系统的安全需要，尽可能的短，但也不能短得离谱——想像一下手机的自动熄屏时间，如果设置为 10 秒钟无操作自动熄屏，再次点亮需要输入密码，会不会疯？如果你觉得不会，那就亲自试一试，设置成可以设置的最短时间，坚持一周就好（不排除有人适应这个时间，毕竟手机厂商也是有用户体验研究的）。</p><p>然后新问题产生了，如果用户在正常操作的过程中，<code>Token</code> 过期失效了，要求用户重新登录……用户体验岂不是很糟糕？</p><p>为了解决在操作过程不能让用户感到 <code>Token</code> 失效这个问题，有一种方案是在服务器端保存 <code>Token</code> 状态，用户每次操作都会自动刷新（推迟） <code>Token</code> 的过期时间（<code>Session</code> 就是采用这种策略来保持用户登录状态的）。然而仍然存在这样一个问题，在前后端分离、单页 App 这些情况下，每秒种可能发起很多次请求，每次都去刷新过期时间会产生非常大的代价。如果 <code>Token</code> 的过期时间被持久化到数据库或文件，代价就更大了。所以通常为了提升效率，减少消耗，会把 <code>Token</code> 的过期时保存在缓存或者内存中。</p><p>还有另一种方案，使用 <code>Refresh Token</code>，它可以避免频繁的读写操作。这种方案中，服务端不需要刷新 <code>Token</code> 的过期时间，一旦 <code>Token</code> 过期，就反馈给前端，前端使用 <code>Refresh Token</code> 申请一个全新 <code>Token</code> 继续使用。这种方案中，服务端只需要在客户端请求更新 <code>Token</code> 的时候对 <code>Refresh Token</code> 的有效性进行一次检查，大大减少了更新有效期的操作，也就避免了频繁读写。当然 <code>Refresh Token</code> 也是有有效期的，但是这个有效期就可以长一点了，比如，以天为单位的时间。</p><h1 id="时序图表示"><a href="#时序图表示" class="headerlink" title="时序图表示"></a>时序图表示</h1><p>使用 <code>Token</code> 和 <code>Refresh Token</code> 的时序图如下：</p><p>1）登录<br><img src="/images/token.jpg"></p><p>2）业务请求<br><img src="/images/token2.jpg"></p><p>3）Token 过期，刷新 Token<br><img src="/images/token3.jpg"></p><p>上面的时序图中并未提到 <code>Refresh Token</code> 过期怎么办。不过很显然，<code>Refresh Token</code> 既然已经过期，就该要求用户重新登录了。</p><p>当然还可以把这个机制设计得更复杂一些，比如，<code>Refresh Token</code> 每次使用的时候，都更新它的过期时间，直到与它的创建时间相比，已经超过了非常长的一段时间（比如三个月），这等于是在相当长一段时间内允许 <code>Refresh Token</code> 自动续期。</p><p>到目前为止，<code>Token</code> 都是有状态的，即在服务端需要保存并记录相关属性。那说好的无状态呢，怎么实现？</p><h1 id="无状态-Token"><a href="#无状态-Token" class="headerlink" title="无状态 Token"></a>无状态 Token</h1><p>如果我们把所有状态信息都附加在 <code>Token</code> 上，服务器就可以不保存。但是服务端仍然需要认证 <code>Token</code> 有效。不过只要服务端能确认是自己签发的 <code>Token</code>，而且其信息未被改动过，那就可以认为 <code>Token</code> 有效——“签名”可以作此保证。平时常说的签名都存在一方签发，另一方验证的情况，所以要使用非对称加密算法。但是在这里，签发和验证都是同一方，所以对称加密算法就能达到要求，而对称算法比非对称算法要快得多（可达数十倍差距）。</p><p>更进一步思考，对称加密算法除了加密，还带有还原加密内容的功能，而这一功能在对 <code>Token</code> 签名时并无必要——既然不需要解密，摘要（散列）算法就会更快。可以指定密码的散列算法，自然是 <code>HMAC</code>。</p><p>上面说了这么多，还需要自己去实现吗？不用！<code>JWT</code> 已经定义了详细的规范，而且有各种语言的若干实现。</p><p>不过在使用无状态 <code>Token</code> 的时候在服务端会有一些变化，服务端虽然不保存有效的 <code>Token</code> 了，却需要保存未到期却已注销的 <code>Token</code>。如果一个 <code>Token</code> 未到期就被用户主动注销，那么服务器需要保存这个被注销的 <code>Token</code>，以便下次收到使用这个仍在有效期内的 <code>Token</code> 时判其无效。有没有感到一点沮丧？</p><p>在前端可控的情况下（比如前端和服务端在同一个项目组内），可以协商：前端一但注销成功，就丢掉本地保存（比如保存在内存、<code>LocalStorage</code> 等）的 <code>Token</code> 和 <code>Refresh Token</code>。基于这样的约定，服务器就可以假设收到的 <code>Token</code> 一定是没注销的（因为注销之后前端就不会再使用了）。</p><p>如果前端不可控的情况，仍然可以进行上面的假设，但是这种情况下，需要尽量缩短 <code>Token</code> 的有效期，而且必须在用户主动注销的情况下让 <code>Refresh Token</code> 无效。这个操作存在一定的安全漏洞，因为用户会认为已经注销了，实际上在较短的一段时间内并没有注销。如果应用设计中，这点漏洞并不会造成什么损失，那采用这种策略就是可行的。</p><p>在使用无状态 <code>Token</code> 的时候，有两点需要注意：</p><ol><li><code>Refresh Token</code> 有效时间较长，所以它应该在服务器端有状态，以增强安全性，确保用户注销时可控</li><li>应该考虑使用二次认证来增强敏感操作的安全性</li></ol><p>到此，关于 <code>Token</code> 的话题似乎差不多了——然而并没有，上面说的只是认证服务和业务服务集成在一起的情况，如果是分离的情况呢？</p><h1 id="分离认证服务"><a href="#分离认证服务" class="headerlink" title="分离认证服务"></a>分离认证服务</h1><p>当 <code>Token</code> 无状态之后，单点登录就变得容易了。前端拿到一个有效的 <code>Token</code>，它就可以在任何同一体系的服务上认证通过——只要它们使用同样的密钥和算法来认证 <code>Token</code> 的有效性。就样这样：<br><img src="/images/token4.jpg"></p><p>当然，如果 <code>Token</code> 过期了，前端仍然需要去认证服务更新 <code>Token</code>：<br><img src="/images/token5.jpg"></p><h1 id="不受信的业务服务器"><a href="#不受信的业务服务器" class="headerlink" title="不受信的业务服务器"></a>不受信的业务服务器</h1><p>遇到不受信的业务服务器时，很容易想到的办法是使用不同的密钥。认证服务器使用密钥1签发，业务服务器使用密钥2验证——这是典型非对称加密签名的应用场景。认证服务器自己使用私钥对 <code>Token</code> 签名，公开公钥。信任这个认证服务器的业务服务器保存公钥，用于验证签名。幸好，<code>JWT</code> 不仅可以使用 <code>HMAC</code> 签名，也可以使用 <code>RSA</code>（一种非对称加密算法）签名。</p><p>不过，当业务服务器已经不受信任的时候，多个业务服务器之间使用相同的 <code>Token</code> 对用户来说是不安全的。因为任何一个服务器拿到 <code>Token</code> 都可以仿冒用户去另一个服务器处理业务……悲剧随时可能发生。</p><p>为了防止这种情况发生，就需要在认证服务器产生 <code>Token</code> 的时候，把使用该 <code>Token</code> 的业务服务器的信息记录在 <code>Token</code> 中，这样当另一个业务服务器拿到这个 <code>Token</code> 的时候，发现它并不是自己应该验证的 <code>Token</code>，就可以直接拒绝。</p><p>现在，认证服务器不信任业务服务器，业务服务器相互也不信任，但前端是信任这些服务器的——如果前端不信任，就不会拿 <code>Token</code> 去请求验证。那么为什么会信任？可能是因为这些是同一家公司或者同一个项目中提供的若干服务构成的服务体系。</p><p>但是，前端信任不代表用户信任。如果 <code>Token</code> 不没有携带用户隐私（比如姓名），那么用户不会关心信任问题。但如果 <code>Token</code> 含有用户隐私的时候，用户得关心信任问题了。这时候认证服务就不得不再啰嗦一些，当用户请求 <code>Token</code> 的时候，问上一句，你真的要授权给某某某业务服务吗？而这个“某某某”，用户怎么知道它是不是真的“某某某”呢？用户当然不知道，甚至认证服务也不知道，因为公钥已经公开了，任何一个业务都可以声明自己是“某某某”。</p><p>为了得到用户的信任，认证服务就不得不帮助用户来甄别业务服务。所以，认证服器决定不公开公钥，而是要求业务服务先申请注册并通过审核。只有通过审核的业务服务器才能得到认证服务为它创建的，仅供它使用的公钥。如果该业务服务泄漏公钥带来风险，由该业务服务自行承担。现在认证服务可以清楚的告诉用户，“某某某”服务是什么了。如果用户还是不够信任，认证服务甚至可以问，某某某业务服务需要请求  A、B、C 三项个人数据，其中 A 是必须的，不然它不工作，是否允许授权？如果你授权，我就把你授权的几项数据加密放在 <code>Token</code> 中……</p><p>废话了这么多，有没有似曾相识……对了，这类似开放式 <code>API</code> 的认证过程。开发式 <code>API</code> 多采用 <code>OAuth</code> 认证，而关于 <code>OAuth</code> 的探讨资源非常丰富，这里就不深究了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie session token详解</title>
      <link href="/2021/07/27/cookie-session-token%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/07/27/cookie-session-token%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>cookie</code>、<code>session</code> 和 <code>token</code>是前端开发中很重要的概念，很多朋友并不真正了解这三者有什么区别，或者这三者到底是个什么的东西，面试的时候也只能模模糊糊的说一点，不能很清晰的讲明白，这里我们就这三个东西讨论下，彻底搞懂。</p><h1 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h1><p>众所周知，<code>http</code>协议本身是一个无连接的协议，<code>web</code>早期只是用来浏览文档，不需要交互，每次<code>http</code>请求都是一个全新的请求，服务端并不关心到底是谁在访问，但是随着交互式<code>web</code>应用的发展，我们必须要识别客户端到底是谁，否则根本无法进行交互，比如商城应用，后端服务必须要知道是谁在买东西，每个客户端要区分开，这时候就需要客户端要和服务端能够进行数据的相互传递，有时还需要在不同的域名下实现数据共享，<code>cookie</code>就是用来解决这一问题的。</p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p><code>cookie</code>是一个真实存在的东西，保存在客户端浏览器中，当一个请求发起后，后端如果想要设置<code>cookie</code>，则在响应头中添加一个<code>Set-Cookie</code>字段，浏览器识别到此响应头，就把里面的数据存放到浏览器本地，当下次再次请求的时候，将该<code>cookie</code>放到请求头中，发送给后端，实现前后端的交互。<br><img src="/images/cookie.png"></p><p>cookie是有大小和数量限制的，根据浏览器的不同这个有所差异；</p><p>Set-Cookie响应头类似于<code>Set-Cookie: username=daryl; path=/; expires=Thu, 26 Aug 2021 16:37:43 GMT; domain=localhost; samesite=none; secure; httponly</code></p><p>这个值是后端设置的，可选的属性有以下几种</p><ul><li><p>maxAge</p><p>用来告诉浏览器此<code>cookie</code>多久过期（单位是毫秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。</p></li><li><p>expires</p><p>失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。</p></li><li><p>path</p><p>表示这个cookie影响到的路径，浏览器跟会根据这项配置，向指定域中匹配的路径发送cookie。</p></li><li><p>domain</p><p>cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：<code>yq.aliyun.com</code>)，也可以不包含它(如：<code>.aliyun.com</code>，则对于<code>aliyun.com</code>的所有子域都有效).</p></li><li><p>secure</p><p>安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置</p></li><li><p>secureProxy?: boolean | undefined;</p><p>“secureProxy” option is deprecated; use “secure” option, provide “secure” to constructor if needed</p></li><li><p>httpOnly?: boolean | undefined;</p><p>a boolean indicating whether the cookie is only to be sent over HTTP(S),<br>and not made available to client JavaScript (true by default).</p></li><li><p>sameSite?: ‘strict’ | ‘lax’ | ‘none’ | boolean | undefined;</p><p>a boolean or string indicating whether the cookie is a “same site” cookie (false by default).<br>This can be set to ‘strict’, ‘lax’, or true (which maps to ‘strict’).</p></li><li><p>signed</p><p>是否对cookie进行签名（默认为false），如果设置为true，还将发送附加的另一个同名的后缀是.sig的cookie ，值类似于<code>Set-Cookie: username.sig=yuJIW4DxsPvY4BoKAP2YMpH5p5k; path=/; expires=Thu, 26 Aug 2021 16:37:43 GMT; domain=localhost; samesite=none; secure; httponly</code>，此签名密钥用于在下次收到cookie时检测篡改。</p></li><li><p>overwrite</p><p>是否覆盖以前的设置同名cookies（默认为false）</p></li></ul><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p><code>session</code>实际上是一个概念，即会话；<code>session</code>的实现有很多方式，最常见的是基于<code>cookie</code>的方式，后端生成一个<code>session</code>，有一个唯一的<code>session id</code>，标识唯一性，然后把这个<code>session id</code>通过<code>cookie</code>发送给客户端，客户端保存起来，下次请求的时候再携带包含<code>session id</code>值的<code>cookie</code>发送给后端，后端拿到后再去通过<code>session id</code>值查找对应的<code>session</code>；所以<code>session</code>实际上是保存在后端的，而发送给客户端的只是一个<code>session id</code>。</p><p><code>session</code>这种方式的弊端在于服务器必须要保存<code>session</code>，无论是保存在文件里还是数据库里，都是一个很大的开销，并且一旦用户量过于庞大，<code>session</code>也会非常庞大，做负载均衡的话如果请求负载到了不同的机器，会造成<code>session</code>失效。</p><h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p><code>token</code>这种方案现在已经被广泛应用了，相比于<code>cookie + session</code>的实现方式，<code>token</code>不需要保存在服务器上，而是将数据签名，然后发送给客户端（可以通过<code>cookie</code>也可以通过其他方式），下次请求的时候再校验<code>token</code>的合法性，如果合法，则响应成功，如果不合法，则响应失败，这种方式就是用计算资源来节省空间资源，好处是我们不需要关心<code>token</code>的存储，而只需要扩展机器增加算力即可。</p><p>详细的token解决方案，可以阅读<a href="https://www.baihuzi.com/2021/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3token/">深入理解token</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域设置cookie</title>
      <link href="/2021/07/26/%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AEcookie/"/>
      <url>/2021/07/26/%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AEcookie/</url>
      
        <content type="html"><![CDATA[<p>我们先从一个问题来引入接下来的内容，先看下以下代码</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());// cookie循环秘钥server.keys = [    &#39;sdf7as9d8f7asd7f9sdfa9s&#39;,    &#39;sdfasd6fgjhgjgdgjsfgsf5&#39;,    &#39;nk54h3k2klj78kh89kh5kh3&#39;,];router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p>我们开启了一个服务器，当请求<code>/api/user</code>接口的时候，我们设置跨域，并且设置了一个<code>cookie</code>，<code>key</code>为<code>username</code>，<code>value</code>为<code>daryl</code></p><p>当我们直接在浏览器中请求这个接口，我们发现可以将<code>cookie</code>设置成功，响应头中有<code>set-cookie</code>响应头，并在<code>application</code>中可以看到已经设置成功<br><img src="/images/cors_cookie2.png"><br><img src="/images/cors_cookie.png"></p><p>但是当我们使用<code>ajax</code>请求去调用接口，此时<code>cookie</code>无论如何也设置不上</p><p>客户端代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;http://localhost:8080/api/user&#39;,        )            .then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>我们可以看到，在响应头中也有<code>set-cookie</code>字段，但是<code>application</code>中就是设置不成功<br><img src="/images/cors_cookie3.png"><br><img src="/images/cors_cookie4.png"></p><p>这是什么原因？实际上是因为当我们使用<code>ajax</code>去请求接口时，是发生了跨域的，而设置<code>cookie</code>是不允许跨域设置的，浏览器也不会跨域发送<code>cookie</code></p><p>如果想要能够跨域设置<code>cookie</code>或发送<code>cookie</code>，需要服务端和<code>ajax</code>同时配置，才能允许跨域设置<code>cookie</code></p><p>服务端需要添加一个<code>Access-Control-Allow-Credentials</code>响应头，客户端<code>ajax</code>请求时需要设置<code>withCredentials</code>属性为<code>true</code>（使用fetch的配置是<code>&#123; credentials: &#39;include&#39; &#125;</code>，不同的库有不同的设置方法）</p><p>我们加上这两个设置，看能不能设置成功。</p><pre><code class="javascript">router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><pre><code class="javascript">btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;    fetch(&#39;http://localhost:8080/api/user&#39;,    &#123;        credentials: &#39;include&#39;    &#125;    )      .then(response =&gt; &#123;          return response.json();      &#125;)      // 请求的数据      .then(data =&gt; &#123;          console.log(data);      &#125;).catch(err =&gt; console.log(err));&#125;);</code></pre><p>我们来看看效果<br><img src="/images/cors_cookie5.png"><br>直接报跨域错误了，咋回事，我们明明设置了<code>Access-Control-Allow-Origin</code>为<code>*</code>啊。</p><p>记住，这是因为一旦当我们设置了<code>Access-Control-Allow-Credentials</code>请求头，我们<code>Access-Control-Allow-Origin</code>就不能直接设置为<code>*</code>了，需要指定明确的源，因此这里我们需要设置为<code>http://127.0.0.1:5500</code>（客户端的<code>url</code>是这个）</p><pre><code class="javascript">router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p>我们再来看看效果<br><img src="/images/cors_cookie6.png"></p><p>跨域错误没有了，但是在<code>set-cookie</code>头的这里出现了一个黄色的感叹号，<code>application</code>里面<code>cookie</code>也没有设置成功</p><p>这个警告是什么？</p><p>这个警告是告诉我们<code>cookie</code>的<code>SameSite</code>属性当前默认是<code>Lax</code>，如果我们需要跨站点访问<code>cookie</code>，需要将其设置为<code>None</code></p><p>这个<code>SameSite</code>用来限制第三方 <code>Cookie</code>，可以设置三个值</p><ul><li><p>Strict</p><p><code>Strict</code>最为严格，完全禁止第三方 <code>Cookie</code>，跨站点时，任何情况下都不会发送 <code>Cookie</code>。换言之，只有当前网页的 <code>URL</code> 与请求目标一致，才会带上 <code>Cookie</code>。</p><p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 <code>GitHub</code>链接，用户点击跳转就不会带有<code> GitHub</code> 的 <code>Cookie</code>，跳转过去总是未登陆状态。</p></li><li><p>Lax</p><p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 <code>Cookie</code>，但是导航到目标网址的 <code>Get</code> 请求除外。</p><p>导航到目标网址的 <code>GET</code> 请求，只包括三种情况：链接，预加载请求，<code>GET</code> 表单。详见下表。</p><table><thead><tr><th>请求类型</th><th>示例</th><th>正常情况</th><th>设置Lax后</th></tr></thead><tbody><tr><td>链接</td><td><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>预加载</td><td><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>GET 表单</td><td><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>POST 表单</td><td><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>iframe</td><td><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>AJAX</td><td><code>$.get(&quot;...&quot;)</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>Image</td><td><code>&lt;img src=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr></tbody></table></li><li><p>None</p><p><code>Chrome</code> 计划将Lax变为默认设置。这时，网站可以选择显式关闭<code>SameSite</code>属性，将其设为<code>None</code>。不过，前提是必须同时设置<code>Secure</code>属性（<code>Cookie</code> 只能通过 <code>HTTPS</code> 协议发送），否则无效。</p><p>下面的设置无效。</p><pre><code>Set-Cookie: widget_session=abc123; SameSite=None</code></pre><p>下面的设置有效。</p><pre><code>Set-Cookie: widget_session=abc123; SameSite=None; Secure</code></pre></li></ul><p>因此，如果我们想要跨站点发送<code>cookie</code>，需要设置<code>SameSite=None</code>，并且同时设置<code>Secure</code>属性（即配置<code>https</code>）</p><p>我们就来配置下</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);const fs = require(&#39;fs&#39;);const https = require(&#39;https&#39;);const sslify = require(&#39;koa-sslify&#39;).default;var options = &#123;    key: fs.readFileSync(&#39;./private_key.pem&#39;),  //私钥文件路径    cert: fs.readFileSync(&#39;./ca-cert.pem&#39;)  //证书文件路径&#125;;let server = new koa();server.use(sslify());let router = new Router();server.use(router.routes());https.createServer(options, server.callback()).listen(8080, (err) =&gt; &#123;    if (err) &#123;      console.log(&#39;服务启动出错&#39;, err);    &#125; else &#123;      console.log(&#39;guessWord-server运行在&#39; + 8080 + &#39;端口&#39;);    &#125;&#125;);// cookie循环秘钥server.keys = [    &#39;sdf7as9d8f7asd7f9sdfa9s&#39;,    &#39;sdfasd6fgjhgjgdgjsfgsf5&#39;,    &#39;nk54h3k2klj78kh89kh5kh3&#39;,];router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,        sameSite: &#39;none&#39;,        secure: true    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p>此时请求路径则需要修改为<code>https</code></p><pre><code class="javascript">btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;    fetch(&#39;https://localhost:8080/api/user&#39;,    &#123;        credentials: &#39;include&#39;    &#125;    )      .then(response =&gt; &#123;          return response.json();      &#125;)      // 请求的数据      .then(data =&gt; &#123;          console.log(data);      &#125;).catch(err =&gt; console.log(err));&#125;);</code></pre><p>来看看效果，可以看到警告没了，并且<code>application</code>里看<code>cookie</code>也成功设置上了<br><img src="/images/cors_cookie7.gif"></p><p>最后来看看设置成功后，请求会不会带上当前的cookie，发送给服务端（最终版）</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);const fs = require(&#39;fs&#39;);const https = require(&#39;https&#39;);const sslify = require(&#39;koa-sslify&#39;).default;var options = &#123;    key: fs.readFileSync(&#39;./private_key.pem&#39;),  //私钥文件路径    cert: fs.readFileSync(&#39;./ca-cert.pem&#39;)  //证书文件路径&#125;;let server = new koa();server.use(sslify());let router = new Router();server.use(router.routes());https.createServer(options, server.callback()).listen(8080, (err) =&gt; &#123;    if (err) &#123;      console.log(&#39;服务启动出错&#39;, err);    &#125; else &#123;      console.log(&#39;guessWord-server运行在&#39; + 8080 + &#39;端口&#39;);    &#125;&#125;);// cookie循环秘钥server.keys = [    &#39;sdf7as9d8f7asd7f9sdfa9s&#39;,    &#39;sdfasd6fgjhgjgdgjsfgsf5&#39;,    &#39;nk54h3k2klj78kh89kh5kh3&#39;,];router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    ctx.cookies.set(&#39;username&#39;, &#39;daryl&#39;, &#123;        signed: true,        maxAge: 86400 * 30,        sameSite: &#39;none&#39;,        secure: true    &#125;)    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);router.get(&#39;/api/cookie&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);    console.log(ctx.cookies.get(&#39;username&#39;));    ctx.body = ctx.cookies.get(&#39;username&#39;); // 将cookie的值作为返回值&#125;);</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;button id=&quot;btn_cookie&quot;&gt;send cookie&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;https://localhost:8080/api/user&#39;,        &#123;            credentials: &#39;include&#39;        &#125;        )            .then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);    let btn_cookie = document.getElementById(&#39;btn_cookie&#39;);    btn_cookie.addEventListener(&#39;click&#39;, () =&gt; &#123;        fetch(&#39;https://localhost:8080/api/cookie&#39;,&#123;            credentials: &#39;include&#39;        &#125;).then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/cors_cookie8.gif"></p><p>可以看到，最终<code>cookie</code>值会放到请求头中，发送给服务端，而接口的返回值也是服务器读到的<code>cookie</code>中的值;</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域资源共享(CORS)</title>
      <link href="/2021/07/22/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-CORS/"/>
      <url>/2021/07/22/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-CORS/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>跨域是前端开发中常见的一个问题，其本身跟http协议没有关系，而是浏览器的一种安全机制，称之为同源策略；</p><p>同源策略指的是当前网站和需要访问的目标网站的<code>协议</code>、<code>域名</code>、<code>端口</code>都要相同，其中主要有一个不相同，就会产生跨域问题；</p><table><thead><tr><th>当前url</th><th>目标url</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="http://www.test.com/index.html">http://www.test.com/index.html</a></td><td>否</td><td>同源（协议、域名、端口相同）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="https://www.test.com/index.html">https://www.test.com/index.html</a></td><td>是</td><td>协议不同（http&#x2F;https），不只是这两种协议、如本地的file协议，websocket的ws协议等都算</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="http://www.test1.com/index.html">http://www.test1.com/index.html</a></td><td>是</td><td>主域名不同（test&#x2F;test1）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="http://mail.test.com/index.html">http://mail.test.com/index.html</a></td><td>是</td><td>子域名不同（www&#x2F;mail）</td></tr><tr><td><a href="http://www.test.com:8000/">http://www.test.com:8000</a></td><td><a href="http://www.test.com:8080/index.html">http://www.test.com:8080/index.html</a></td><td>是</td><td>端口不同（8000&#x2F;8080）</td></tr></tbody></table><h1 id="跨域会造成的问题"><a href="#跨域会造成的问题" class="headerlink" title="跨域会造成的问题"></a>跨域会造成的问题</h1><p>跨域会造成很多问题，比如</p><ul><li>无法读取非同源网页的 <code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexedDB</code></li><li>无法接触非同源网页的 <code>DOM</code></li><li>无法向非同源地址发送 <code>AJAX</code> 请求</li></ul><p>对于现在前后端分离的开发模式，我们最常见的跨域问题就是当请求后端接口时候发生的。如果遇到以下错误，就是发生了跨域问题，我们通过<code>fetch</code>，去请求后端接口（<code>http://localhost.com/api/user</code>），由于当前url是本地的，协议是<code>file</code>协议，就会发生跨域问题<br><img src="/images/cors.png"></p><h1 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h1><h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>在之前最常见的解决跨域问题是通过<code>jsonp</code>来进行的，<code>jsonp</code>的原理是在标签中的请求不会发生跨域问题，可以将请求放到标签上，然后再后台进行数据返回，前端定义一个获取数据的函数，后端将执行函数的代码当做字符串返回，前端会自动执行该代码，从而获取到了数据，但是<code>jsonp</code>有个最大的问题就是<code>jsonp</code>跨域<strong>只能处理</strong><code>get</code>请求。</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);router.get(&#39;/api/jsonp&#39;, async (ctx, next) =&gt; &#123;    const user = JSON.stringify(&#123;username: &#39;daryl&#39;, age: 18&#125;);    // jsonp就是这样处理，拿到客户端定义的callback函数，返回函数调用的字符串，将数据包在里面    const &#123; callback &#125; = ctx.query    ctx.body = `$&#123;callback&#125;($&#123;user&#125;)`;&#125;);</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;button id=&quot;btn_jsonp&quot;&gt;jsonp&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;http://localhost:8080/api/user&#39;,        )            .then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);    // jsonp     let btn_jsonp = document.getElementById(&#39;btn_jsonp&#39;);    btn_jsonp.addEventListener(&#39;click&#39;, () =&gt; &#123;        // 删除上个请求的script标签，避免html中充斥大量的无用script标签        let prevScript = document.querySelector(`script[src=&#39;http://localhost:8080/api/jsonp?callback=getUser&#39;]`);        if (prevScript) &#123;            document.body.removeChild(prevScript);        &#125;        let script = document.createElement(&#39;script&#39;);        script.setAttribute(&#39;src&#39;, &#39;http://localhost:8080/api/jsonp?callback=getUser&#39;);        document.body.appendChild(script);    &#125;)        // 这里的函数名就是上面的callback参数指定的名字    function getUser(data) &#123;        console.log(data);    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/cors1.gif"></p><p>我们可以看到，当我们直接去<code>fetch</code>的时候，发生了跨域，但是当我们通过<code>jsonp</code>处理后，可以拿到后端返回的数据</p><h2 id="后端设置"><a href="#后端设置" class="headerlink" title="后端设置"></a>后端设置</h2><p>浏览器将<code>CORS</code>请求分成两类：简单请求（<code>simple request</code>）和非简单请求（<code>not-so-simple request</code>）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><ol><li>请求方法是以下三种方法之一：</li></ol><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><ol start="2"><li>HTTP的头信息不超出以下几种字段：</li></ol><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li></ul><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器对这两种请求的处理，是不一样的</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>对于简单请求，浏览器直接发出<code>CORS</code>请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br><img src="/images/cors2.png"><br>上面的<code>Origin</code>字段是<code>null</code>，是因为我们是使用浏览器直接打开的本地文件，当我们使用<code>live server</code>模拟真实环境时，就会变成真实的<code>Origin</code><br><img src="/images/cors3.png"></p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的<code>HTTP</code>回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个跨域错误；<br><img src="/images/cors4.png"></p><p>我们可以在后端设置<code>Access-Control-Allow-Origin</code>，表示允许那些源进行跨域请求</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    // * 表示允许所有源进行跨域请求    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p><img src="/images/cors5.png"></p><p>后端还可以设置其他响应头，有其他作用，比如：</p><ul><li><p>Access-Control-Allow-Credentials</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在<code>CORS</code>请求之中。设为<code>true</code>，即表示服务器明确许可，<code>Cookie</code>可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。</p><p>注意：如果要把<code>Cookie</code>发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>为<code>true</code>，还要将客户端的<code>ajax</code>请求指定<code>withCredentials</code>，例如：</p><pre><code class="javascript">var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></pre><p>或者</p><pre><code class="javascript">fetch(url, &#123;  credentials: &#39;include&#39;&#125;)</code></pre><p>这篇文章<a href="https://www.baihuzi.com/2021/07/26/%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AEcookie/">跨域设置cookie</a>详细讲解了这个属性和客户端设置<code>cookie</code>相关的内容</p></li><li><p>Access-Control-Expose-Headers</p><p>该字段可选。<code>CORS</code>请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到7个基本字段（简单响应首部）：<code>Cache-Control</code>、<code>Content-Length</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。<br>例如：<br>我们设置了自定义头<code>Other-Header</code>，值为<code>other-header</code></p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    // 我们设置了自定义头Other-Header，值为other-header    ctx.set(&quot;Other-Header&quot;, &quot;other-header&quot;);    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p>此时通过<code>fetch</code>的<code>api</code>去获取响应头，是拿不到<code>Other-Header</code>的</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;http://localhost:8080/api/user&#39;,        )            .then(response =&gt; &#123;                for (let [key, value] of response.headers) &#123;                     console.log(`$&#123;key&#125; : $&#123;value&#125;`);                  &#125;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/cors6.gif"></p><p>但如果我们加上<code>ctx.set(&quot;Access-Control-Expose-Headers&quot;, &quot;Other-Header&quot;);</code>此时就可以拿到了</p><pre><code class="javascript">router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.set(&quot;Other-Header&quot;, &quot;other-header&quot;);    ctx.set(&quot;Access-Control-Expose-Headers&quot;, &quot;Other-Header&quot;);    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);</code></pre><p><img src="/images/cors7.gif"></p></li></ul><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的<code>CORS</code>请求，会在正式通信之前，增加一次<code>HTTP</code>查询请求，称为”预检”请求（<code>preflight</code>）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些<code>HTTP</code>动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>我们来模拟一个非简单请求，在请求头中加入一个自定义字段<code>Authorization</code></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn_get&quot;&gt;get&lt;/button&gt;&lt;script&gt;    // 直接fetch请求    let btn_get = document.getElementById(&#39;btn_get&#39;);    btn_get.addEventListener(&quot;click&quot;, () =&gt; &#123;        fetch(&#39;http://localhost:8080/api/user&#39;,        &#123;            headers: &#123;                &#39;Authorization&#39;: &#39;some token&#39;            &#125;        &#125;        )            .then(response =&gt; &#123;                return response.json();            &#125;)            // 请求的数据            .then(data =&gt; &#123;                console.log(data);            &#125;).catch(err =&gt; console.log(err));    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/cors8.gif"></p><p>预检请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p><p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p><ul><li><p>Access-Control-Request-Method</p><p>该字段是必须的，用来列出浏览器的<code>CORS</code>请求会用到哪些<code>HTTP</code>方法，上例是<code>GET</code>。</p></li><li><p>Access-Control-Request-Headers</p><p>该字段是一个逗号分隔的字符串，指定浏览器<code>CORS</code>请求会额外发送的头信息字段，上例是<code>authorization</code>。</p></li></ul><p>预检请求也是一个真实的请求，我们后端需要对其进行处理，否则就会出现<code>404</code>错误（如上图），对于预检请求的响应，关键的是<code>Access-Control-Allow-Origin</code>字段，表示哪些源可以请求数据，如果在预检请求里面没有指定这个资源，而仅在需要的请求中指定，则也会发生跨域问题；例如：</p><pre><code class="javascript">const koa = require(&#39;koa&#39;);const Router = require(&#39;koa-router&#39;);let server = new koa();let router = new Router();server.listen(8080);server.use(router.routes());router.get(&#39;/api/user&#39;, async (ctx, next) =&gt; &#123;    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.body = &#123;username: &#39;daryl&#39;, age: 18&#125;;&#125;);router.options(&#39;*&#39;, async (ctx, next) =&gt; &#123;    // 如果预检请求这里没有指定Access-Control-Allow-Origin，而仅在上面设置了，也会发生跨域问题    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    ctx.set(&quot;Access-Control-Allow-Methods&quot;, &quot;OPTIONS, GET, PUT, POST, DELETE&quot;);    ctx.set(&quot;Access-Control-Allow-Headers&quot;, &quot;authorization&quot;);    ctx.set(&quot;Access-Control-Max-Age&quot;, &quot;1728000&quot;);    ctx.body = &#39;ok&#39;;&#125;)</code></pre><p>还有一些其他的相关字段：</p><ul><li><p>Access-Control-Allow-Methods</p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p></li><li><p>Access-Control-Allow-Headers</p><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p></li><li><p>Access-Control-Max-Age</p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p></li><li><p>Access-Control-Allow-Credentials</p><p>该字段与简单请求时的含义相同</p></li></ul><h2 id="vue跨域配置"><a href="#vue跨域配置" class="headerlink" title="vue跨域配置"></a>vue跨域配置</h2><ul><li><p>vue3.0</p><p>首先声明我们真实的接口地址是<code>http://localhost:8080/api/user</code></p><p><strong>vite.config.js</strong></p><pre><code class="javascript">  import &#123; defineConfig &#125; from &#39;vite&#39;  import vue from &#39;@vitejs/plugin-vue&#39;  import path from &#39;path&#39;  // https://vitejs.dev/config/  export default defineConfig(&#123;      plugins: [vue()],      server:&#123;          port: 3000,          proxy: &#123;              // /api 属性声明axios中url以/api开头的请求都适用于该规则，例如axios.get(&#39;/api/xxx&#39;)，对应下面按钮1的请求              &#39;/api&#39; : &#123;                  target: &#39;http://localhost:8080&#39;,                  changeOrigin: true,              &#125;,              // /local_api 属性声明axios中url以/local_api开头的请求都适用于该规则，例如axios.get(&#39;/local_api/api/xxx&#39;)，对应下面按钮2的请求              // 但是由于我们真实的接口地址是http://localhost:8080/api/user，而此时请求的是http://localhost:8080/local_api/api/user，因此需要将多余的路径进行重写，需要rewrite一下，将local_api/去掉，使其成为http://localhost:8080/api/user              &#39;/local_api&#39; : &#123;                  target: &#39;http://localhost:8080&#39;,                  changeOrigin: true,                  rewrite: (path) =&gt; &#123;console.log(path) ;return path.replace(/^\/local_api/, &#39;&#39;)&#125;              &#125;          &#125;      &#125;  &#125;)</code></pre><pre><code class="html">  &lt;template&gt;  &lt;div&gt;      &lt;button @click=&quot;getData&quot;&gt;按钮1&lt;/button&gt;      &lt;button @click=&quot;getData2&quot;&gt;按钮2&lt;/button&gt;  &lt;/div&gt;  &lt;/template&gt;  &lt;script&gt;  import axios from &#39;axios&#39;  export default &#123;      methods: &#123;          getData() &#123;              axios.get(&#39;/api/user&#39;).then(res =&gt; &#123;                  console.log(res.data)              &#125;)          &#125;,          getData2() &#123;              axios.get(&#39;/local_api/api/user&#39;).then(res =&gt; &#123;                  console.log(res.data)              &#125;)          &#125;,      &#125;  &#125;  &lt;/script&gt;</code></pre><p><img src="/images/cors7.png"><br><img src="/images/cors8.png"></p><p>两个请求都成功了，请求中的地址是本地的地址，正是因为我们做了代理</p></li><li><p>vue2.0</p><p>vue2.0的配置原理是相同的，只不过写法有一点差异而已，下面是相关配置</p><p><strong>vue.config.js</strong></p><pre><code class="javascript">  const path = require(&#39;path&#39;)  module.exports = &#123;      devServer: &#123;          proxy: &#123;              &#39;^/api&#39;: &#123;                  // 注意是以/api开头，即：axios.get(&#39;/api/xxx&#39;)，不能带接口的域名及端口                  target: &#39;http://localhost:8080&#39;, // 代理目标                  ws: true, // 启用websocket                  changeOrigin: true              &#125;,              &#39;^/local_api&#39;: &#123;                  // 注意是以/local_api开头，即：axios.get(&#39;/local_api/api/xxx&#39;)，不能带接口的域名及端口                  target: &#39;http://localhost:8080&#39;, // 代理目标                  changeOrigin: true,                  ws: true, // 启用websocket                  // 匹配到的地址重写， /local_api/api/xxx  =&gt;  https://www.baihuzi.com/api/xxx                  pathRewrite: &#123; &#39;^/local_api&#39;: &#39;&#39; &#125;              &#125;          &#125;      &#125;,  &#125;</code></pre><p>注意和<code>vite</code>的配置的写法不一样</p></li></ul><h2 id="react跨域配置"><a href="#react跨域配置" class="headerlink" title="react跨域配置"></a>react跨域配置</h2><p>react跨域配置需要使用第三方库<code>http-proxy-middleware</code>来解决，之前在<code>package.json</code>文件中配置<code>proxy</code>的方式已经不适用了，可能是希望将跨域配置放到后端来做，这样既省事也能保证安全。</p><p>首先需要安装<code>http-proxy-middleware</code></p><pre><code class="bash">yarn add http-proxy-middleware</code></pre><p>然后在<code>src</code>目录下新建文件<code>setupProxy.js</code>文件，项目启动的时候，会自动去找这个文件，我们不需要我们在其他地方引入</p><pre><code class="javascript">const &#123;createProxyMiddleware&#125; = require(&#39;http-proxy-middleware&#39;)module.exports = function (app) &#123;    // proxy第一个参数为要代理的路由    // 第二参数中target为代理后的请求网址，changeOrigin是否改变请求头，其他参数请看官网    app.use(createProxyMiddleware(&#39;/api&#39;, &#123;        target: &#39;http://localhost:8080&#39;,        changeOrigin: true,    &#125;))    app.use(createProxyMiddleware(&#39;/local_api&#39;, &#123;        target: &#39;http://localhost:8080&#39;,        changeOrigin: true,        pathRewrite: &#123; &#39;^/local_api&#39;: &#39;&#39; &#125;    &#125;))&#125;</code></pre><p>测试</p><pre><code class="javascript">import React from &#39;react&#39;import axios from &#39;axios&#39;const GetData = () =&gt; &#123;    const getData = () =&gt; &#123;        axios.get(&#39;/api/user&#39;).then(res =&gt; &#123;            console.log(res.data);        &#125;)    &#125;    const getData2 = () =&gt; &#123;        axios.get(&#39;/local_api/api/user&#39;).then(res =&gt; &#123;            console.log(res.data);        &#125;)    &#125;    return &lt;&gt;        &lt;button onClick=&#123;getData&#125;&gt;按钮1&lt;/button&gt;        &lt;button onClick=&#123;getData2&#125;&gt;按钮2&lt;/button&gt;    &lt;/&gt;&#125;export default GetData</code></pre><p><img src="/images/cors9.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的强缓存和协商缓存</title>
      <link href="/2021/07/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
      <url>/2021/07/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在前端工程化中，前端代码打包之后的生成的静态资源就要发布到静态服务器上，这时候就要做对这些静态资源做一些运维配置，其中，<code>gzip</code>和设置缓存是必不可少的。这两项是最直接影响到网站性能和用户体验的。</p><p>浏览器缓存主要有以下几个优点：</p><ul><li>减少重复数据请求，避免通过网络再次加载资源，节省流量。</li><li>降低服务器的压力，提升网站性能。</li><li>加快客户端加载网页的速度， 提升用户体验。</li></ul><p>浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：</p><ul><li>强缓存在资源过期之前，不会向服务器发送网络请求，直接从本地缓存读取资源，响应码为<code>200  (from memory cache)</code>或者 <code>200  (from disk cache)</code>;</li><li>协商缓存会向服务器发送一次请求，服务器会根据这个请求的<code>Request Headers</code>的一些参数来判断是否命中协商缓存，如果命中，则返回<code>304</code>状态码并带上新的<code>Response Headers</code>通知浏览器从缓存中读取资源;</li></ul><h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><p>强缓存是根据返回头中的<code>expires</code>（http 1.0 规范）或者<code>Cache-Control</code>（http 1.1 规范）两个字段来控制的，都是表示资源的缓存有效时间。</p><ul><li><p><code>expires</code>的值是一个<code>GMT</code>格式的时间，这个时间代表资源的过期时间，在这个时间之前请求该资源，将直接命中强缓存。但是这个时间有个缺点，它是一个绝对时间，如果本地时间被修改，则将会导致缓存失效，所以<code>expires</code>还是有些缺陷的。</p></li><li><p>为了解决上述问题，http 1.1协议重新给了一个参数<code>Cache-Control</code>，这个值也是设置资源的过期时间，但是这个参数的值是一个相对时间，比如<code>cache-control: max-age=3600</code>，浏览器会根据这个相对时间结合响应头的<code>date</code>参数，得出资源的过期时间是<code>date</code>的时间加上3600秒，需要注意的是，并不是每次请求都进行计算生效时间，只有当当前请求是200，或者304的时候，才会进行计算，否则每次计算，每次都加3600秒，那资源永远都不会过期了。</p><p><code>Cache-Control</code>还有一些其他的值可以设置</p><ol><li><code>no-cache</code>：不使用强缓存，直接使用协商缓存。</li><li><code>no-store</code>：直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 <code>network</code> 中的 <code>disabled cache</code>。</li><li><code>public</code>：可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。</li><li><code>private</code>：只能被终端用户的浏览器缓存。</li></ol></li></ul><p>如果 <code>Cache-Control</code> 与 <code>expires</code> 同时存在的话， <code>Cache-Control</code> 的优先级高于 <code>expires</code></p><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, <code>last-modified</code> 或者 <code>etag</code>，则后续请求则会带上对应的请求字段 <code>if-modified-since</code>或者 <code>if-none-match</code>，若响应头没有 <code>last-modified</code> 或者 <code>etag</code> 字段，则请求头也不会有对应的字段。</p><ul><li><p><code>last-modified/if-modified-since</code>，值是<code>GMT</code>格式的时间字符串， <code>last-modified</code> 标记最后文件修改时间， 下一次请求时，请求头中会带上的 <code>if-modified-since</code> 值就是 <code>last-modified</code> ，告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 <code>304 Not Modified</code> ，请求不会返回资源内容，浏览器直接使用本地缓存。如果有变化，则返回<code>200</code>，返回最新的资源。</p></li><li><p><code>etag/if-none-match</code>， 值是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个唯一值并通过 <code>etag</code>字段返回给浏览器。当下次请求时，浏览器会将上次接收到的<code>etag</code>值赋给 <code>if-none-match</code> 字段，服务器通过比较两者是否一致来判定文件内容是否被改变。</p></li></ul><p><code>etag</code>的优先级比<code>last-modified</code>要高，先判断资源是否有更新</p><h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><p>浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：</p><ul><li>浏览器会获取该缓存资源的 header 中的信息，根据 <code>Response Headers</code> 中的 <code>expires</code> 和 <code>cache-control</code> 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。</li><li>如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 <code>IF-Modified-Since</code> 或者 <code>IF-None-Match</code>, 它们的值分别是第一次请求返回 <code>Last-Modified</code> 或者 <code>Etag</code>，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。</li></ul><p><img src="/images/%E7%BC%93%E5%AD%98%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png"></p><p>我们通过几个例子来实际看看会是什么效果，注意，设置缓存可以通过代理服务器设置，也可以直接使用代码设置，这里我们为了方便，直接使用<code>nginx</code>进行设置，<code>nginx</code>设置请求头需要<code>ngx_http_headers_module</code>模块支持，通过<code>yum</code>安装的<code>nginx</code>默认不支持此模块，需要另行编译安装；</p><blockquote><p>下面的例子，我们设置缓存事件都设置为30s，只是为了看效果，实际上不可能设置这么短的时间</p></blockquote><h2 id="设置expires"><a href="#设置expires" class="headerlink" title="设置expires"></a>设置<code>expires</code></h2><pre><code class="nginx">location ~* \.(js|css)$ &#123;  expires 30s;&#125;</code></pre><p>第一次请求直接返回200，可以看到虽然我们仅仅设置了<code>expires</code>，但是响应头中也会带上<code>cache-control</code>。<code>expires</code>是一个绝对时间，该时间由<code>date</code>的时间加上设置的<code>30s</code>；<br><img src="/images/expires1.png"><br>在过期时间内重复请求，都会命中强缓存，直接从浏览器本地读取资源<br><img src="/images/expires2.png"><br>如果超过了过期时间，则不会命中强缓存，走协商缓存，返回304（因为资源没有发生变化），同时我们可以看到，<code>date</code>和<code>expires</code>都更新了，重新计算缓存过期时间<br><img src="/images/expires3.png"></p><h2 id="设置cache-control-max-age-30"><a href="#设置cache-control-max-age-30" class="headerlink" title="设置cache-control: max-age=30"></a>设置<code>cache-control: max-age=30</code></h2><pre><code class="nginx">location ~* \.(js|css)$ &#123;  add_header Cache-Control max-age=30;&#125;</code></pre><p>设置了<code>cache-control</code>，此时可以看到响应头中已经不存在<code>expires</code>了，其他的请求行为和设置<code>expires</code>行为一样，这里不贴图了。<br><img src="/images/cache_control1.png"></p><h2 id="设置cache-control-no-cache，不使用强缓存，使用协商缓存"><a href="#设置cache-control-no-cache，不使用强缓存，使用协商缓存" class="headerlink" title="设置cache-control: no-cache，不使用强缓存，使用协商缓存"></a>设置<code>cache-control: no-cache</code>，不使用强缓存，使用协商缓存</h2><pre><code class="nginx">location ~* \.(js|css)$ &#123;  add_header Cache-Control no-cache;&#125;</code></pre><p>第一次请求直接返回200，并设置<code>cache-control</code>为<code>no-cache</code><br><img src="/images/cache_control2.png"><br>因为不使用强缓存，直接使用协商缓存，则之后每次都会返回304（因为资源没有发生变化）<br>注意每次请求都会讲上次响应头里的<code>etag</code>值（通过<code>if-none-match</code>请求头）和<code>last-modified</code>（通过<code>if-modified-since</code>请求头）发送给服务端<br><img src="/images/cache_control3.png"></p><h2 id="使用协商缓存，资源发生了改变（etag会发生变化）"><a href="#使用协商缓存，资源发生了改变（etag会发生变化）" class="headerlink" title="使用协商缓存，资源发生了改变（etag会发生变化）"></a>使用协商缓存，资源发生了改变（<code>etag</code>会发生变化）</h2><p>如果不使用强缓存，并且资源没有发生变化，则之后的每次请求都会返回304，但是如果我们的资源发生了变化，此时会将上次<code>etag</code>值（通过<code>if-none-match</code>请求头发送给服务器）和服务器上的最新资源<code>etag</code>值进行比较，发现资源更新了，则返回响应码200，并返回最新的资源。<br>资源没有发生变化，多次请求返回304，<code>etag</code>值为<code>60ede052-5dd</code><br><img src="/images/cache_control3.png"><br>修改<code>config.js</code>文件，更新资源，此时<code>etag</code>值会发生变化，此时<code>etag</code>值为<code>60ede48c-5eb</code>，响应码为200，请求了最新的资源。<br><img src="/images/cache_control4.png"></p><h2 id="使用协商缓存，资源没有改变，但是文件时间戳更新了（last-modified会发生变化）"><a href="#使用协商缓存，资源没有改变，但是文件时间戳更新了（last-modified会发生变化）" class="headerlink" title="使用协商缓存，资源没有改变，但是文件时间戳更新了（last-modified会发生变化）"></a>使用协商缓存，资源没有改变，但是文件时间戳更新了（<code>last-modified</code>会发生变化）</h2><p>我们先将<code>config.js</code>文件还原，避免混淆；<br>我们先看看当前文件的最后修改时间是多少，我们通过<code>linux</code>的<code>stat</code>命令查看，时间是<code>2021-07-14 03:17:06.109141809 +0800</code>，注意是<code>UTC</code>时间。<br><img src="/images/cache_control5.png"><br>多次请求，返回304，注意此时<code>last-modified</code>时间为<code>Tue, 13 Jul 2021 19:17:06 GMT</code>，<code>GMT</code>格式，加8个小时，正好是上面的<code>UTC</code>时间<br><img src="/images/cache_control6.png"><br>此时我们更新一下时间戳，通过<code>linux</code>的<code>touch</code>命令，更新<code>config.js</code>文件的时间戳（修改时间也会被修改），此时修改时间为<code>2021-07-14 03:25:30.121617196 +0800</code><br><img src="/images/cache_control7.png"><br>再次请求资源，响应头中的<code>last-modified</code>时间正好是我们更新时间戳后的时间，而上次的<code>last-modified</code>时间通过请求头中的<code>if-modified-since</code>传递给后端（注意<code>GMT</code>和<code>UTC</code>时间转换），发现两者时间不一致，响应码为200，请求了最新的资源。<br><img src="/images/cache_control8.png"></p><h1 id="etag拓展"><a href="#etag拓展" class="headerlink" title="etag拓展"></a><code>etag</code>拓展</h1><p>HTTP1.1 中<code>etag</code>的出现主要是为了解决几个<code>last-modified</code>比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新请求；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，<code>if-modified-since</code>能检查到的粒度是秒级的，使用<code>etag</code>就能够保证这种需求下客户端在1秒内能刷新 N 次 cache。</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p><code>etag</code>计算方式</p><p><code>etag</code>计算方式并没有明确规定，只要能标识文件唯一性就行了，但是对于大量的http请求，计算<code>etag</code>不能有太高的消耗，否则对响应速度以及服务器的运算能力都会有影响</p><p><code>etag</code>默认格式是<code>xxxxxxxx-xxx</code>，http默认计算<code>etag</code>的方式是通过文件的<code>last-modified</code>和<code>content-length</code>值的十六进制数标识的，形如<code>$&#123;last-modified&#125;-$&#123;content-length&#125;</code></p><p>对于以下<code>config.js</code>文件<br><img src="/images/cache_control9.png"></p><p>通过js计算该文件的<code>etag</code>值</p><pre><code class="javascript">`$&#123;(new Date(&#39;Tue, 13 Jul 2021 19:25:30 GMT&#39;).getTime() / 1000).toString(&#39;16&#39;)&#125;-$&#123;Number(1501).toString(&#39;16&#39;)&#125;`// 60ede8aa-5dd</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 事件循环（event loop）、宏任务、微任务</title>
      <link href="/2021/07/07/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88event-loop%EF%BC%89%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
      <url>/2021/07/07/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88event-loop%EF%BC%89%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Google工程师<code>Jake Archibald</code>写了一篇关于事件循环以及宏任务微任务的文章，非常经典，本文的例子都来源于改文章，有兴趣的可以去浏览原文<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly">Tasks, microtasks, queues and schedules</a></p><p>在该文中也提供了<code>Philip Roberts</code>在youtube上的一个关于事件循环的视频<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway?</a>（需要梯子），视频里讲的非常好，有兴趣可以看下。</p><h1 id="事件循环的基本概念"><a href="#事件循环的基本概念" class="headerlink" title="事件循环的基本概念"></a>事件循环的基本概念</h1><ul><li><code>JavaScript</code>是单线程的，同时只能执行一个代码片段。如果存在耗时的异步操作，则会被阻塞（<code>blocking</code>）.</li><li><code>JavaScript</code>代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(<code>task queue</code>)来搞定另外一些代码的执行，例如<code>setTimeout</code>，<code>AJAX(XHR)</code>等，这些都是<code>Web API</code>，由浏览器提供，不存在于<code>V8引擎</code>内。</li><li>任务队列又分为<code>macro-task</code>（宏任务）与<code>micro-task</code>（微任务），在最新标准中，它们被分别称为<code>task</code>与<code>jobs</code>。<strong>微任务在一次事件循环中，总是先于宏任务执行</strong></li><li>一个线程中，事件循环是唯一的，但是任务队列里的任务可以拥有多个。</li><li><code>macro-task</code>大概包括：<code>script</code>(整体代码), <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, <code>I/O</code>, <code>UI rendering</code>。</li><li><code>micro-task</code>大概包括: <code>process.nextTick</code>, <code>Promise</code>的<code>then catch finally</code>, <code>Object.observe</code>(已废弃), <code>MutationObserver</code>(<code>html5</code>新特性)</li><li><code>setTimeout/Promise</code>等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</li><li><code>Promise</code>的实例化会在主执行栈中执行</li></ul><h1 id="通过一个简单的例子来理解"><a href="#通过一个简单的例子来理解" class="headerlink" title="通过一个简单的例子来理解"></a>通过一个简单的例子来理解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="javascript">console.log(&#39;script start&#39;);setTimeout(function () &#123;  console.log(&#39;setTimeout&#39;);&#125;, 0);Promise.resolve()  .then(function () &#123;    console.log(&#39;promise1&#39;);  &#125;)  .then(function () &#123;    console.log(&#39;promise2&#39;);  &#125;);console.log(&#39;script end&#39;);</code></pre><p>打印结果：</p><pre><code>script startscript endpromise1promise2setTimeout</code></pre><h2 id="为什么会有这样的结果？"><a href="#为什么会有这样的结果？" class="headerlink" title="为什么会有这样的结果？"></a>为什么会有这样的结果？</h2><p>逐步分析：</p><ol><li>主执行栈开始，执行<code>console.log(&#39;script start&#39;);</code>，打印<code>script start</code></li><li>执行栈往下执行<code>setTimeout</code>，由于<code>setTimeout</code>是属于宏任务，浏览器等待<code>0ms</code>，将<code>setTimeout</code>的<code>callback</code>函数放入宏任务队列中</li><li>执行栈继续执行<code>Promise</code>，由于<code>Promise</code>的<code>then</code>属于微任务，则将<strong>第一个</strong><code>then</code>中的回调函数放入到微任务队列中，第二个<code>then</code>需要等待第一个<code>then</code>执行完毕才会执行，因此这里不会讲第二个<code>then</code>的回调函数放入微任务队列中</li><li>执行栈执行<code>console.log(&#39;script end&#39;);</code>，打印<code>script end</code></li><li>由于微任务总是先于宏任务执行，则先取出微任务队列中的第一个then的回调函数执行，打印<code>promise1</code></li><li>第一个<code>then</code>执行完，紧接着又有一个<code>then</code>，再将其放入微任务队列中</li><li>只要微任务队列中还有任务没有执行完，则优先执行，因此执行第二个<code>then</code>的回调函数，打印<code>promise2</code></li><li>微任务队列都执行完毕，此时执行宏任务队列里的任务，打印<code>setTimeout</code></li></ol><p>动画演示：<br><img src="/images/eventloop.gif"></p><h1 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background: #D4D4D4;            padding: 25px;            width: 92px;            margin: 0 auto;        &#125;        .inner &#123;            background: #ADADAD;            padding: 46px;            width: 0;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;outer&quot;&gt;        &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // Let&#39;s get hold of those elements        var outer = document.querySelector(&#39;.outer&#39;);        var inner = document.querySelector(&#39;.inner&#39;);        // Let&#39;s listen for attribute changes on the        // outer element        new MutationObserver(function () &#123;        console.log(&#39;mutate&#39;);        &#125;).observe(outer, &#123;        attributes: true,        &#125;);        // Here&#39;s a click listener…        function onClick() &#123;        console.log(&#39;click&#39;);        setTimeout(function () &#123;            console.log(&#39;timeout&#39;);        &#125;, 0);        Promise.resolve().then(function () &#123;            console.log(&#39;promise&#39;);        &#125;);        outer.setAttribute(&#39;data-random&#39;, Math.random());        &#125;        // …which we&#39;ll attach to both elements        inner.addEventListener(&#39;click&#39;, onClick);        outer.addEventListener(&#39;click&#39;, onClick);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>打印结果：</p><pre><code>clickpromisemutateclickpromisemutatetimeouttimeout</code></pre><p>我们这里就不逐步分析了，由于事件的冒泡机制，当第一个事件循环结束后，事件冒泡，会开启第二个事件循环，重复来一遍，看下动画演示：<br><img src="/images/eventloop2.gif"></p><h1 id="使用代码派发事件会发生什么事？"><a href="#使用代码派发事件会发生什么事？" class="headerlink" title="使用代码派发事件会发生什么事？"></a>使用代码派发事件会发生什么事？</h1><p>上面的代码，我们是通过点击鼠标来触发事件，但是如果我们直接在代码中触发事件，会发生什么事呢？</p><pre><code class="javascript">// 其他代码不变inner.click(); // 在代码中派发事件</code></pre><p>打印结果：</p><pre><code>clickclickpromisemutatepromisetimeouttimeout</code></pre><p>为什么差距这么大，哪里影响了代码的执行顺序？实际上是我们触发事件的方式引起的区别（废话），当直接在代码中触发事件的时候，此时js主执行栈并不是空的，因此不会先去执行微任务宏任务队列中的任务，再去触发<code>outer element</code>的点击事件，而是直接触发<code>outer element</code>的点击事件，当主执行栈没有任务的时候，再去执行微任务宏任务队列中的任务。</p><p>为什么<code>mutate</code>只打印了一次，那是因为<code>MutationObserver</code>的监听是异步触发，在所有的DOM操作完成后才触发使回调函数进入微任务队列。</p><p>比如，程序中有10个修改DOM的操作，只有在第十个处理完之后，回调函数才进入微任务队列。</p><p>通过动画就一目了然了：<br><img src="/images/eventloop3.gif"></p><h1 id="async-await的事件循环"><a href="#async-await的事件循环" class="headerlink" title="async&#x2F;await的事件循环"></a>async&#x2F;await的事件循环</h1><pre><code class="javascript">async function async1() &#123;    console.log( &#39;async1 start&#39; )     await async2()    console.log( &#39;async1 end&#39; )&#125;async function async2() &#123;    console.log( &#39;async2&#39; )&#125;console.log( &#39;script start&#39; )setTimeout( function () &#123;    console.log( &#39;setTimeout&#39; )&#125;, 0 )async1();new Promise(function ( resolve ) &#123;    console.log( &#39;promise1&#39; )    resolve();&#125;).then(function () &#123;    console.log( &#39;promise2&#39; ) &#125;)console.log( &#39;script end&#39; )</code></pre><p>执行结果：</p><pre><code>script startasync1 startasync2promise1script endasync1 endpromise2setTimeout</code></pre><p><code>await</code>之后的代码必须等<code>await</code>语句执行完成后（包括微任务完成），才能执行后面的，也就是说，只有运行完<code>await</code>语句，才把<code>await</code>语句后面的全部代码加入到微任务行列</p><p><code>await</code>语句是同步的，<code>await</code>语句后面全部代码才是异步的微任务<br><img src="/images/eventloop4.png"><br><img src="/images/eventloop5.png"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的重排与重绘</title>
      <link href="/2021/07/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98/"/>
      <url>/2021/07/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p>重排和重绘是浏览器运行过程中一个很重要的特性，页面的动画，结构变化都会涉及到重排与重绘，重排与重绘也是影响前端页面性能的一个很重要的因素，如果页面存在大量的重排与重绘，页面会显得非常“卡”，影响用户体验。</p><p>说道重排与重绘，首先要了解浏览器的渲染原理，浏览器渲染展示页面的过程，大致分为以下几步：</p><ul><li>解析<code>HTML</code>结构（<code>HTML Parser</code>），构建<code>DOM树</code>（<code>DOM Tree</code>）</li><li>解析<code>CSS</code>（<code>CSS Parser</code>），构建<code>CSS规则树</code>（<code>Style Rules</code>）</li><li>将<code>DOM树</code>与<code>CSS规则树</code>合并，构建<code>渲染树</code>（<code>Rendering Tree</code>）</li><li>布局（<code>Layout</code>）和绘制（<code>Paint</code>）</li><li>如果在渲染过程中发生了结构变化或者样式变化，则会进行重排（<code>reflow</code>）和重绘（<code>repaint</code>）</li></ul><blockquote><p>重排（<code>reflow</code>）也称为回流</p></blockquote><p>Webkit内核渲染引擎工作原理（Chrome，Safari，Opera）<br><img src="/images/Webkit%E5%86%85%E6%A0%B8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><p>Geoko内核渲染引擎工作原理（Firefox）<br><img src="/images/Geoko%E5%86%85%E6%A0%B8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><h1 id="什么是重排（reflow）？"><a href="#什么是重排（reflow）？" class="headerlink" title="什么是重排（reflow）？"></a>什么是重排（reflow）？</h1><p>当页面布局完成后，由于用户操作，增删了节点，修改了节点的宽高等，浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做<code>reflow</code>.</p><p>reflow(回流)是导致DOM脚本执行效率低的关键因素之一，页面上任何一个节点触发了reflow，会导致它的子节点及祖先节点重新渲染。</p><p>简单解释一下 Reflow：当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程称为 Reflow。</p><p>当页面布局和几何属性改变时就需要重排。下述情况会发生浏览器重排：</p><ul><li>添加或者删除可见的DOM元素</li><li>元素位置改变</li><li>元素尺寸改变（包括：内外边距、边框厚度、宽度和高度等属性的改变）</li><li>内容改变，例如：文本改变或者图片被另一个不同尺寸的图片替代</li><li>页面渲染器初始化</li><li>浏览器窗口尺寸改变</li><li>对可见元素 display：none，或者对不可见元素 display：block 时</li><li>激活伪类(:hover)</li><li>transition对宽高的处理，在整个transition的每一帧中，浏览器都要去重新布局，绘制页面(参考)</li></ul><h1 id="什么是重绘（repaint）？"><a href="#什么是重绘（repaint）？" class="headerlink" title="什么是重绘（repaint）？"></a>什么是重绘（repaint）？</h1><p><code>repaint</code>是在一个元素的外观被改变，但没有改变布局的情况下发生的，如改变了<code>visibility</code>、<code>outline</code>、<code>background</code>等。当<code>repaint</code>发生时，浏览器会验证<code>DOM树</code>上所有其他节点的<code>visibility</code>属性。</p><p>避免过分重绘(<code>Repaints</code>)<br>当元素改变的时候，将不会影响元素在页面当中的位置（比如 <code>background-color</code>, <code>border-color</code>, <code>visibility</code>），浏览器仅仅会应用新的样式重绘此元素，此过程称为 <code>Repaint</code>。</p><p>当 <code>render tree</code> 中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如 <code>background-color</code>，则称之为重绘。</p><ul><li>改变字体</li><li>增加或者移除样式表</li><li>内容变化，比如用户在input框中输入文字</li><li>激活CSS伪类(:hover)</li><li>脚本操作DOM （也有可能造成回流）</li><li>计算 offsetWidth 和 offsetHeight 的属性</li><li>设置style属性的值</li></ul><h1 id="通过例子分析重排和重绘"><a href="#通过例子分析重排和重绘" class="headerlink" title="通过例子分析重排和重绘"></a>通过例子分析重排和重绘</h1><p>我们可以结合浏览器的性能分析工具，来看到浏览器的渲染过程，通过以下代码，我们来分别看看重排和重绘何时发生</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        .main&#123;            border: 1px solid red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;button id=&quot;addNode&quot;&gt;添加节点&lt;/button&gt;  &lt;button id=&quot;changeStyle&quot;&gt;修改颜色&lt;/button&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;ul class=&quot;ul&quot;&gt;      &lt;li&gt;11111&lt;/li&gt;      &lt;li&gt;22222&lt;/li&gt;      &lt;li&gt;33333&lt;/li&gt;      &lt;li&gt;44444&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.bootcss.com/zepto/1.2.0/zepto.min.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    const ul = document.querySelector(&#39;.ul&#39;);    const addNodeBtn = document.querySelector(&#39;#addNode&#39;);    const changeStyleBtn = document.querySelector(&#39;#changeStyle&#39;);    addNodeBtn.onclick = function addNode() &#123;      const newLi = document.createElement(&#39;li&#39;);      newLi.innerText = Math.random() * 10000;      ul.appendChild(newLi);    &#125;    changeStyleBtn.onclick = function changeStyle() &#123;      $(&#39;.main&#39;).css(&#39;color&#39;, &#39;red&#39;)    &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>当我们向<code>ul</code>中添加一个<code>li</code>，此时<code>dom</code>结构发生了变化，会发生重排<br><img src="/images/%E9%87%8D%E6%8E%92.gif"></p><p>当我们仅仅只是修改了文字的颜色，此时并不会发生重排，仅仅会发生重绘<br><img src="/images/%E9%87%8D%E7%BB%98.gif"></p><p>同时我们可以看到，只要发生了重排，则必然会出现重绘，而重绘并不一定会重排，我们可以得出一个结论：<strong>重排必定会引发重绘，但重绘不一定会引发重排。</strong></p><h1 id="渲染树变化的排队与刷新"><a href="#渲染树变化的排队与刷新" class="headerlink" title="渲染树变化的排队与刷新"></a>渲染树变化的排队与刷新</h1><p>浏览器会维护一个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会<code>flush</code>队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。然而你可能会（经常不知不觉）强制刷新队列并要求计划任务立即执行。获取布局信息的操作会导致队列刷新，比如以下方法：</p><ul><li><code>offsetTop</code>，<code>offsetLeft</code>，<code>offsetWidth</code>，<code>offsetHeight</code></li><li><code>scrollTop</code>，<code>scrollLeft</code>，<code>scrollWidth</code>，<code>scrollHeight</code></li><li><code>clientTop</code>，<code>clientLeft</code>，<code>clientWidth</code>，<code>clientHeight</code></li><li><code>width</code>，<code>height</code></li><li><code>getComputedStyle()</code> (<code>currentStyle</code> in IE)</li><li>JS更改元素style</li></ul><p>以上属性和方法需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理”变化并触发重排以返回正确的值。</p><p>在修改样式的过程中，最好避免使用上面列出的属性。它们都会刷新渲染队列，即使你是在获取最近未发生改变的或者与最新变化无关的布局信息。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>上述提到的浏览器自己的优化，维护一个队列，队重排和重绘进行批处理</p><p>开发者需要注意的优化</p><ul><li>直接改变元素的<code>className</code></li><li><code>display：none;</code> 先设置元素为<code>display：none;</code>，然后进行页面布局等操作；设置完成后将元素设置为<code>display：block;</code>，这样的话就只引发两次重绘和重排；</li><li>不要经常访问浏览器的flush队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流；</li><li>使用<code>cloneNode</code>(true or false) 和 <code>replaceChild</code> 技术，引发一次回流和重绘；</li><li>将需要多次重排的元素，<code>position</code>属性设为<code>absolute</code>或<code>fixed</code>，元素脱离了文档流，它的变化不会影响到其他元素；</li><li>如果需要创建多个<code>DOM</code>节点，可以使用<code>DocumentFragment</code>创建完后一次性的加入<code>document</code>；</li><li>尽量不要使用<code>table</code>布局。</li><li>制作动画时，尽量使用 <code>CSS3</code> 的 <code>transform</code>，因为 <code>transform</code> 属性不会改变元素的布局（更详细的知识可以参考：<a href="https://juejin.cn/post/6844903502678867981">详谈层合成composite</a> ）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 原型、原型链、继承</title>
      <link href="/2021/06/30/js-%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/06/30/js-%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>在<code>JavaScript</code>中，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript的对象中都包含了一个<code>[[Prototype]]</code>内部属性，这个属性所对应的就是该对象的原型。<br><code>[[Prototype]]</code>作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了<code>__proto__</code>这个非标准（不是所有浏览器都支持）的访问器（ECMA引入了标准对象原型访问器<code>Object.getPrototype(object)</code>）。在<code>JavaScript</code>的原型对象中，还包含一个<code>constructor</code>属性，这个属性对应创建所有指向该原型的实例的构造函数</p><h1 id="原型对象，对象原型"><a href="#原型对象，对象原型" class="headerlink" title="原型对象，对象原型"></a>原型对象，对象原型</h1><p>构造函数，实例，原型对象三者的关系可以使用一张图来理解<br><img src="/images/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png"></p><h2 id="原型对象prototype"><a href="#原型对象prototype" class="headerlink" title="原型对象prototype"></a>原型对象<code>prototype</code></h2><p>每一个构造函数都有一个属性<code>prototype</code>，我们也称之为原型对象，原型对象另外开辟一个内存空间，用来存放方法，作用是为了共享方法，从而达到节省内存</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;Person.prototype.eat = function () &#123;    console.log(&#39;吃饭&#39;);&#125;;let jerry = new Person(&#39;jerry&#39;, 18);jerry.eat();// 实例对象有一个__proto__属性，可以指向该实例对象的构造函数的原型对象console.log(jerry.__proto__);console.log(Person.prototype);console.log(jerry.__proto__ === Person.prototype);      // true</code></pre><h2 id="原型对象属性constructor"><a href="#原型对象属性constructor" class="headerlink" title="原型对象属性constructor"></a>原型对象属性<code>constructor</code></h2><p>原型对象上有个属性<code>constructor</code>，用来指向该原型对象的构造函数</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;// 这里指向的就是Person构造函数console.log(Person.prototype.constructor === Person);   // true</code></pre><p>可以通过<code>Person.prototype.run = function()&#123;&#125;</code>的方式添加方法<br>以这种方式创建方法的话，原型对象上其中有个自带的属性<code>constructor</code>，用来指向原型对象的构造函数</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;Person.prototype.sing = function () &#123;    console.log(&#39;sing&#39;);&#125;Person.prototype.jump = function () &#123;    console.log(&#39;jump&#39;);&#125;console.log(Person.prototype);</code></pre><p>另外一种创建方法的方式，这种方式创建会覆盖原有的原型对象，且原型对象上的<code>constructor</code>属性也会没有，所以必须重新将<code>constructor</code>指向构造函数</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;Person.prototype = &#123;    rap: function () &#123;        console.log(&#39;rap&#39;);    &#125;,    basketball: function () &#123;        console.log(&#39;basketball&#39;);    &#125;,    // 重新指向构造函数    constructor: Person,&#125;console.log(Person.prototype);</code></pre><h2 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型__proto__"></a>对象原型<code>__proto__</code></h2><p>实例对象有一个属性，可以指向该实例对象的构造函数的原型对象</p><pre><code class="javascript">function Person(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;;let jerry = new Person(&#39;jerry&#39;, 18);// 实例对象有一个属性，可以指向该实例对象的构造函数的原型对象console.log(jerry.__proto__);console.log(Person.prototype);console.log(jerry.__proto__ === Person.prototype);      // true</code></pre><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。<br>如果没有就查找它的原型（也就是<code>__proto__</code>指向的<code>prototype</code>原型对象）。<br>如果还没有就查找原型对象的原型（<code>Object</code>的原型对象）。<br>依此类推一直找到<code>Object</code> 为止（<code>null</code>）。<br><code>__proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</p><pre><code class="javascript">function Person(name, age) &#123;    this.name = name;    this.age = age;&#125;let jerry = new Person(&#39;jerry&#39;, 18);// Person.prototype指向Person构造函数的原型对象// jerry.__proto__也指向Person构造函数的原型对象// 原型对象也是对象，也有__proto__方法，原型对象的原型对象是Objectconsole.log(Person.prototype.__proto__);// Object原型对象的构造函数是Object()构造函数console.log(Person.prototype.__proto__.constructor);// 在往上找Object原型对象的原型对象，是null，这个就是原型链的顶端，并不是无限下去的console.log(Person.prototype.__proto__.__proto__);</code></pre><h2 id="对象的原型链"><a href="#对象的原型链" class="headerlink" title="对象的原型链"></a>对象的原型链</h2><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.png"></p><h2 id="构造函数的原型链"><a href="#构造函数的原型链" class="headerlink" title="构造函数的原型链"></a>构造函数的原型链</h2><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg"></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><pre><code class="javascript">// 原型链继承，定义一个父类function Father(name) &#123;  this.fatherName = [name]&#125;// 父类定义一个方法Father.prototype.printFatherName = function () &#123;  console.log(this.fatherName);&#125;// 定义一个子类function Son(name) &#123;  this.sonName = name&#125;// 把子类的原型对象指向父类的实例Son.prototype = new Father(&#39;Father&#39;)// 由于覆盖了原有的prototype，需要将它上面的constructor指向子类，否则原型链就会混乱Son.prototype.constructor = SonSon.prototype.printSonName = function () &#123;  console.log(this.sonName);&#125;// 实例化子类，此时子类就继承了父类的printFatherName方法（原型链方法会向上查找）let s = new Son(&#39;Son&#39;)s.printFatherName()             // [&quot;Father&quot;]s.printSonName()                // Sonconsole.log(s.fatherName);      // [&quot;Father&quot;]console.log(s.sonName);         // Son// 原型链继承的缺陷，对于引用数据类型，如果Son有多个实例，其中一个实例对继承的父类属性做了修改，那么所有实例都会随之修改let s1 = new Son(&#39;Son1&#39;)s1.printFatherName()            // [&quot;Father&quot;]s1.printSonName()               // Son1console.log(s1.fatherName);     // [&quot;Father&quot;]console.log(s1.sonName);        // Son1s.fatherName.push(&#39;newName&#39;)    // s 对继承的属性做了修改，此时 s1 也会随之修改console.log(s.fatherName);      // [&quot;Father&quot;, &quot;newName&quot;]console.log(s1.fatherName);     // [&quot;Father&quot;, &quot;newName&quot;]</code></pre><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF.jpg"></p><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>使用<code>call</code>改变了<code>this</code>指向的继承方式，称为构造函数继承</p><pre><code class="javascript">function Father(name) &#123;  this.fatherName = [name]&#125;Father.prototype.printFatherName = function () &#123;  console.log(this.fatherName);&#125;function Son(name) &#123;  // 使用call改变了this指向，  // 调用Father函数就相当于是把函数执行了一遍，在子类里面创建了一个和父类相同的属性，但是this是指向的子类实例  Father.call(this, name)&#125;let s = new Son(&#39;Son&#39;)console.log(s.fatherName);let s1 = new Son(&#39;Son1&#39;)console.log(s1.fatherName);// 解决了多个子类修改父类属性造成同步更改的问题s.fatherName.push(&#39;newName&#39;)console.log(s.fatherName);      // [&quot;Son&quot;, &quot;newName&quot;]console.log(s1.fatherName);     // [&quot;Son1&quot;]// 但是又有个问题就是子类无法继承父类的方法s.printFatherName()             // 报错  Uncaught TypeError: s.printFatherName is not a function</code></pre><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>把原型链继承和构造函数继承结合使用，就是组合继承</p><pre><code class="javascript">function Father(name) &#123;  this.name = name  this.arr = [1, 2, 3]&#125;Father.prototype.printName = function () &#123;  console.log(this.name);&#125;// 构造函数继承父类的方法和属性function Son(name, age) &#123;  Father.call(this, name)  this.age = age&#125;// 原型链继承父类原型上的方式和属性Son.prototype = new Father()Son.prototype.constructor = SonSon.prototype.printSonAge = function () &#123;  console.log(this.age);&#125;let s = new Son(&#39;son&#39;, 18)s.printSonAge()s.printName()console.log(s.arr);s.arr.push(4)// 可以调用父类原型上面的方法，实例的属性修改也不会影响其他实例的属性let s1 = new Son(&#39;son1&#39;, 20)s1.printSonAge()s1.printName()console.log(s.arr);       // [1, 2, 3, 4]console.log(s1.arr);      // [1, 2, 3 ]// 缺点：会调用两次父类的构造函数，第一次是在 new Faher() 的时候， 第二次是在new Son()的时候（new Son() 里面会执行 Father.call）// 因此实例的原型对象上会有两份相同的属性，解决这个问题可以用寄生组合继承</code></pre><p><img src="/images/%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF.png"></p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><pre><code class="javascript">let Father = &#123;  name: &#39;Father&#39;,  friends: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],  printName: function () &#123; console.log(this.name); &#125;&#125;// 原型式继承原理是，创建一个中间实例，中间实例的原型指向父类（这个父类此时是一个对象的实例）// 这个函数是Object.create函数的模拟实现function createObj(obj) &#123;  function F() &#123; &#125;  F.prototype = obj  return new F()&#125;let Son1 = createObj(Father)let Son2 = createObj(Father)// 使用下面Object.create()函数是一样的// let Son1 = Object.create(Father)// let Son2 = Object.create(Father)// 这里修改name值，并不是修改了原型上的name，而是给自己身上加了一个name属性Son1.name = &#39;Son1&#39;Son2.name = &#39;Son2&#39;Son1.printName()Son2.printName()// 缺点：原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。Son1.friends.push(&#39;D&#39;)console.log(Son1.friends);  // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(Son2.friends);  // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</code></pre><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><pre><code class="javascript">let Father = &#123;  name: &#39;Father&#39;,  friends: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],  printName: function () &#123; console.log(this.name); &#125;&#125;// 寄生式继承主要用来增强对象function createObj(obj) &#123;  var clone = Object.create(obj)  clone.printAge = function () &#123; console.log(this.age); &#125;  return clone&#125;let son1 = createObj(Father)son1.name = &#39;jerry&#39;son1.age = 18son1.printName()son1.printAge()let son2 = createObj(Father)son2.age = 20son2.printName()son2.printAge()</code></pre><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>寄生组合继承应该算是es5中最完美的继承方式</p><pre><code class="javascript">function Father(name) &#123;  this.name = name  this.friends = [&#39;A&#39;, &#39;B&#39;]&#125;Father.prototype.printName = function () &#123;  console.log(this.name);&#125;function Son(name, age) &#123;  Father.call(this, name)  this.age = age&#125;// 创建一个中间函数let tempFunc = function () &#123; &#125;// 中间函数的prototype指向Father的原型对象tempFunc.prototype = Father.prototype// 子类的prototype指向中间函数的实例Son.prototype = new tempFunc()// 修正constructor指针Son.prototype.constructor = Son// 子类增加一个方法，对其他继承Father的子类没有影响Son.prototype.printAge = function () &#123; console.log(this.age); &#125;let son1 = new Son(&#39;jerry&#39;, 18)son1.printName()  // jerryson1.printAge()   // 18let son2 = new Son(&#39;tom&#39;, 20)son2.printName()  // tomson2.printAge()   // 20son1.friends.push(&#39;D&#39;)console.log(son1.friends);  // [&quot;A&quot;, &quot;B&quot;, &quot;D&quot;]console.log(son2.friends);  // [&quot;A&quot;, &quot;B&quot;]// 有人要问，为什么不能直接Son.prototype = Father.prototype，// 这是因为如果多个子类，都指向同一个父类的prototype，子类的独立性就没有了，// 如果其中一个子类对原型上面的东西做了修改，其他所有子类都会发生变化// 其他子类function Child(name, age) &#123;  Father.call(this, name)  this.age = age&#125;let F = function () &#123; &#125;F.prototype = Father.prototypeChild.prototype = new F()Child.prototype.constructor = Child// 子类的原型上添加属性或方法，不会影响其他子类Child.prototype.printAge = function () &#123; console.log(&#39;child age&#39;, this.age); &#125;let c1 = new Child(&#39;child1&#39;, 22)c1.printName()  // child1c1.printAge()   // child age 22</code></pre><p><img src="/images/%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF.jpg"></p><h1 id="ES6-class-继承"><a href="#ES6-class-继承" class="headerlink" title="ES6 class 继承"></a>ES6 class 继承</h1><p>先看一个简单的例子</p><pre><code class="javascript">class Father &#123;    constructor(name, age) &#123;        this.name = name;        this.age = age;    &#125;    run() &#123;        console.log(&#39;I\&#39;m running, by father&#39;);    &#125;&#125;class Son extends Father &#123;    constructor(name, age, birth) &#123;        super(name, age);        this.birth = birth;    &#125;;    run() &#123;        super.run();    &#125;    fly() &#123;        console.log(&#39;I\&#39;m flying&#39;);    &#125;&#125;let son = new Son(&#39;jerry&#39;, 18, &#39;2000&#39;);console.log(son.name);  // jerryconsole.log(son.age);   // 18son.run();              // I&#39;m running, by fatherson.fly();              // I&#39;m flying</code></pre><p>一个稍微复杂的例子</p><pre><code class="javascript">class fatherCalculator &#123;    constructor(num1, num2) &#123;        this.num1 = num1;        this.num2 = num2;    &#125;;    sum() &#123;        return this.num1 + this.num2;    &#125;    multiply() &#123;        return this.num1 * this.num2;    &#125;    log() &#123;        return [this.num1, this.num2];    &#125;&#125;let cal = new fatherCalculator(1, 2);console.log(cal.sum());;    // 3// super关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数// super关键字指向当前对象的原型对象， sonCalculator.prototype 指向的是 fatherCalculatorclass sonCalculator extends fatherCalculator &#123;    constructor(num1, num2) &#123;        super(num1, num2);    &#125;;    sum() &#123;        return super.sum()    &#125;;    reduce() &#123;        return this.num1 - this.num2;    &#125;&#125;let cal2 = new sonCalculator(3, 4);console.log(cal2);console.log(cal2.sum());    // 7console.log(cal2.reduce()); // -1// 如果子类中没有方法，会向父类中去找，就近原则console.log(cal2.multiply());  // 12// 当子类没有constructor的时候可以随意用父类的，但是如果子类也含有的话，constructor会返回实例，this的指向不同，不可以再直接使用父类的东西class son extends fatherCalculator &#123; &#125;;let cal3 = new son(10, 10);console.log(cal3.sum());    // 20class son1 extends fatherCalculator &#123;    constructor(a, b, c) &#123;  // 前两个参数是父类构造函数中的参数，无法在子类中拿到，但是可以调用父类的方法来获取到        super(a, b)         // 子类constructor中必须先使用super，否则报错继承 Uncaught ReferenceError: Must call super constructor in derived class before accessing &#39;this&#39; or returning from derived constructor        this.c = c    &#125;    log() &#123;        // 在子类中无法直接拿到父类中的属性，但是可以在父类中暴露api，子类中进行获取        console.log(super.log());               // [1, 2]          // 这里无法拿到a, b参数，只能拿到自己的属性c        console.log(this.a, this.b, this.c);    // undefined undefined 33        return [super.sum(), this.c]      &#125;&#125;let cal4 = new son1(1, 2, 33)console.log(cal4.log());    // [3, 33]</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js ES6新增数据类型Set/Map/Symbol</title>
      <link href="/2021/06/11/js-ES6%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSet-Map-Symbol/"/>
      <url>/2021/06/11/js-ES6%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSet-Map-Symbol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://es6.ruanyifeng.com/#docs/set-map">本文参考阮一峰ES6基础教程</a></p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p><code>ES6</code> 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p><code>Set</code>本身是一个构造函数，用来生成 <code>Set</code> 数据结构。</p><p><code>Set</code>函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化</p><pre><code class="javascript">// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll(&#39;div&#39;));set.size // 56// 类似于const set = new Set();document .querySelectorAll(&#39;div&#39;) .forEach(div =&gt; set.add(div));set.size // 56</code></pre><p><code>Set</code>中没有重复的值，里面包含了各个item和一个size属性</p><pre><code class="javascript">let set = new Set([1, 1, 2, 2, 3, 3])console.log(set);</code></pre><p><img src="/images/set.gif"></p><p>基于这一特性，我们可以进行去重处理</p><pre><code class="javascript">// 去除数组的重复成员[...new Set([1, 2, 3, 3, 3])]// [1, 2, 3][...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)// &quot;abc&quot;vxcx</code></pre><p><strong>注意</strong>，两个对象是不相等的，而<code>NaN</code>，<code>null</code>，<code>undefined</code>都视为相等的，<code>Set</code>内部判断两个值是否不同，使用的算法叫做<code>Same-value-zero equality</code>，它类似于精确相等运算符（<code>===</code>）</p><pre><code class="javascript">let set1 = new Set();set1.add(NaN).add(NaN);console.log(set1);  // Set结构 &#123;NaN&#125;let set2 = new Set();set2.add(null).add(null);console.log(set2);  // Set结构 &#123;null&#125;let set3 = new Set();set3.add(undefined).add(undefined);console.log(set3);  // Set结构 &#123;undefined&#125;let set4 = new Set();set4.add(&#123;&#125;).add(&#123;&#125;);console.log(set4);  // Set结构 &#123;&#123;&#125;, &#123;&#125;&#125;</code></pre><p><code>Set</code>数据结构的<code>key</code>和<code>value</code>是相同的；</p><pre><code class="javascript">for (let item of colorSet.keys()) &#123;    console.log(item);&#125;// red// green// bluefor (let item of colorSet.values()) &#123;    console.log(item);&#125;// red// green// bluefor (let item of colorSet.entries()) &#123;    console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;]</code></pre><h2 id="Set结构的实例属性和方法"><a href="#Set结构的实例属性和方法" class="headerlink" title="Set结构的实例属性和方法"></a><code>Set</code>结构的实例属性和方法</h2><p><code>Set</code>结构的实例有以下属性</p><ul><li><code>Set.prototype.constructor</code>   构造函数，默认就是Set函数。</li><li><code>Set.prototype.size</code>          返回Set实例的成员总数。</li></ul><p><code>Set</code>实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p><ul><li><code>Set.prototype.add(value)</code>        添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>     删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>        返回一个布尔值，表示该值是否为Set的成员。</li><li><code>Set.prototype.clear()</code>           清除所有成员，没有返回值。</li></ul><h2 id="Set的遍历"><a href="#Set的遍历" class="headerlink" title="Set的遍历"></a><code>Set</code>的遍历</h2><ol><li><code>keys()</code>，<code>values()</code>，<code>entries()</code></li></ol><pre><code class="javascript">for (let item of colorSet.keys()) &#123;    console.log(item);&#125;// red// green// bluefor (let item of colorSet.values()) &#123;    console.log(item);&#125;// red// green// bluefor (let item of colorSet.entries()) &#123;    console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;]</code></pre><ol start="2"><li><code>forEach()</code><br><code>Set</code>结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</li></ol><pre><code class="javascript">let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))// 1 : 1// 4 : 4// 9 : 9</code></pre><ol start="3"><li><code>Set</code>结合遍历的应用<br>数组的<code>map</code>和<code>filter</code>方法也可以间接用于<code>Set</code>。</li></ol><pre><code class="javascript">let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125;</code></pre><p>使用 <code>Set</code> 可以很容易地实现并集（<code>Union</code>）、交集（<code>Intersect</code>）和差集（<code>Difference</code>）。</p><pre><code class="javascript">let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// （a 相对于 b 的）差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125;</code></pre><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>ES6</code>提供了<code>Map</code>数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，<code>Object</code>结构提供了“字符串—值”的对应，<code>Map</code> 结构提供了“值—值”的对应，是一种更完善的<code>Hash</code>结构实现。如果你需要“键值对”的数据结构，<code>Map</code>比 <code>Object</code>更合适。</p><p><code>Map</code>构造函数传入的参数一定要是一个可迭代对象;</p><pre><code class="javascript">let map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2]])let map1 = new Map(new Set([[&#39;c&#39;, 3], [&#39;d&#39;, 4]]))console.log(map, map1);</code></pre><p><img src="/images/map.png"></p><p>也可以对一个<code>map</code>实例动态添加，任何数据类型都可以作为<code>Map</code>的<code>key</code></p><pre><code class="javascript">let map = new Map();map.set(1, &#39;1&#39;)map.set(Symbol(), &#39;hello&#39;)map.set(&#123; key: true &#125;, &#39;value&#39;)map.set(false, &#39;false&#39;)console.log(map);console.log(map.has(false));        // trueconsole.log(map.has(Symbol()));     // false，注意这里是false，因为symbol很特殊，其值是唯一的，即使两个symbol声明方式一样，他们也是两个不同的数据console.log(map.get(1));            // 1console.log(map.get(Symbol()));     // undefined 原因和上面相同</code></pre><p><img src="/images/map2.png"></p><h2 id="Map实例的属性和操作方法"><a href="#Map实例的属性和操作方法" class="headerlink" title="Map实例的属性和操作方法"></a><code>Map</code>实例的属性和操作方法</h2><ul><li><code>size</code>                                <code>size</code>属性返回 <code>Map</code> 结构的成员总数。</li><li><code>Map.prototype.set(key, value)</code>       <code>set</code>方法设置键名key对应的键值为<code>value</code>，然后返回整个 <code>Map</code> 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li><li><code>Map.prototype.get(key)</code>              <code>get</code>方法读取key对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li><li><code>Map.prototype.has(key)</code>              <code>has</code>方法返回一个布尔值，表示某个键是否在当前 <code>Map</code> 对象之中。</li><li><code>Map.prototype.delete(key)</code>           <code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li><li><code>Map.prototype.clear()</code>               <code>clear</code>方法清除所有成员，没有返回值。</li></ul><h1 id="WeakSet-WeakMap"><a href="#WeakSet-WeakMap" class="headerlink" title="WeakSet &amp; WeakMap"></a>WeakSet &amp; WeakMap</h1><p><a href="https://es6.ruanyifeng.com/#docs/set-map#WeakSet">WeakSet</a></p><p><a href="https://es6.ruanyifeng.com/#docs/set-map#WeakMap">WeakMap</a></p><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p><code>ES6</code>引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 <code>JavaScript</code> 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）。</p><p><code>Symbol</code>值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的<code>Symbol</code>类型。凡是属性名属于 <code>Symbol</code> 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><p>新建一个<code>symbol</code>数据不能使用<code>new</code>的方式，因为<code>new</code>出来的是一个对象，而<code>symbol</code>并不是对象;</p><p><code>Symbol()</code>可以传一个字符串作为标识，这里的字符串仅作为标识，用于区分不同的<code>symbol</code>，因为默认<code>symbol</code>打印出来就是<code>Symbol()</code>，无法正常区分</p><pre><code class="javascript">let sym = Symbol(&#39;sym&#39;);let sym1 = Symbol(&#39;sym1&#39;);</code></pre><p>当<code>symbol</code>作为属性名是，需要使用<code>[]</code>包起来，否则会认为<code>sym</code>是字符串而不是<code>symbol</code>数据</p><pre><code class="javascript">let sym = Symbol(&#39;sym&#39;);let sym1 = Symbol(&#39;sym1&#39;);let obj = &#123;    [sym]: sym1&#125;// 或者，注意下面的sym没有引号let obj1 = &#123;&#125;;obj1[sym] = sym1</code></pre><p>可以使用<code>description</code>属性打印出<code>symbol</code>的标识</p><pre><code class="javascript">console.log(sym.description);   // &#39;sym&#39;console.log(sym1.description);  // &#39;sym1&#39;</code></pre><p>即使标识符相同，也是两个不同的数据</p><pre><code class="javascript">let s1 = Symbol(&#39;aaa&#39;);let s2 = Symbol(&#39;aaa&#39;);console.log(s1 === s2);     // false</code></pre><p><code>symbol</code>还可以作为属性值，这能确保属性值都是唯一的，且不关心值到底是什么</p><pre><code class="javascript">let obj2 = &#123;    red: Symbol(&#39;red&#39;),    yellow: Symbol(&#39;yellow&#39;),    blue: Symbol(&#39;blue&#39;),&#125;;</code></pre><p>使用<code>Symbol</code>作为对象的属性名，可以隐藏某些属性</p><pre><code class="javascript">let jerry = &#123; name: &#39;jerry&#39;, age: 18, [Symbol(&#39;salary&#39;)]: 1000 &#125;let json = JSON.stringify(jerry)    // 这里不会转化Symbol的属性console.log(json);                  // &#123;&quot;name&quot;:&quot;jerry&quot;,&quot;age&quot;:18&#125;</code></pre><p>获取到的属性名也没有包含<code>Symbol</code>的</p><pre><code class="javascript">let props = Object.getOwnPropertyNames(jerry)console.log(props);                 // [&#39;name&#39;, &#39;age&#39;]</code></pre><p>要获取<code>Symbol</code>属性名，需要使用<code>Object.getOwnPropertySymbols</code>方法</p><pre><code class="javascript">let symbolProps = Object.getOwnPropertySymbols(jerry)console.log(symbolProps);           // [Symbol(salary)]console.log(jerry[symbolProps[0]]); // 1000</code></pre><p>使用<code>Reflect.ownKeys</code>可以获取到所有的属性名，包括<code>Symbol</code>的</p><pre><code class="javascript">let allProps = Reflect.ownKeys(jerry)console.log(allProps);              // [&quot;name&quot;, &quot;age&quot;, Symbol(salary)]</code></pre><p><code>Symbol</code>值不能与其他类型的值进行运算，会报错</p><pre><code class="javascript">let sym = Symbol(&#39;My symbol&#39;);&quot;your symbol is &quot; + sym// TypeError: can&#39;t convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can&#39;t convert symbol to string</code></pre><p>但是，<code>Symbol</code> 值可以显式转为字符串。</p><pre><code class="javascript">let sym = Symbol(&#39;My symbol&#39;);String(sym) // &#39;Symbol(My symbol)&#39;sym.toString() // &#39;Symbol(My symbol)&#39;</code></pre><p>另外，<code>Symbol</code> 值也可以转为布尔值，但是不能转为数值。</p><pre><code class="javascript">let sym = Symbol();conole.log(Boolean(sym)) // trueconole.log(!sym)  // falseif (sym) &#123;  // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js for...in循环和for...of循环</title>
      <link href="/2021/06/11/js-for-in%E5%BE%AA%E7%8E%AF%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/"/>
      <url>/2021/06/11/js-for-in%E5%BE%AA%E7%8E%AF%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p><code>for...in</code>循环和<code>for...of</code>循环结合ES6新增的方法<code>Object.keys()</code>&#x2F;<code>Object.values()</code>&#x2F;<code>Object.entries()</code>，可以以自己想要的方式遍历对象，两者结合使用非常nice</p><h1 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h1><p><code>for...in</code>是ES5的标准，该方法遍历的是对象的属性名称(<code>key</code>：键名)。一个<code>Array</code>对象也是一个对象，数组中的每个元素的索引被视为属性名称，所以在使用<code>for...in</code>遍历<code>Array</code>时，拿到的是每个元素索引</p><blockquote><p>注意：<code>Object.keys()</code>返回的是一个数组，对这个数组进行<code>for...in</code>循环，也会拿到数组的原型链上的属性，这点需要注意</p></blockquote><ul><li>一般用于遍历对象自身的和继承的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。</li><li>不建议使用<code>for...in</code>遍历数组，因为输出的顺序是不固定的。</li><li>如果迭代的对象的变量值是<code>null</code>或者<code>undefined</code>, <code>for...in</code>不执行循环体，建议在使用<code>for...in</code>循环之前，先检查该对象的值是不是<code>null</code>或者<code>undefined</code></li><li><code>for…in</code> 语句以原始插入顺序迭代对象的<strong>可枚举属性</strong>(只能迭代出可枚举的属性，可枚举属性【js自定义属性】&#x2F;不可枚举属性【对象的内置属性】，如数组的<code>length</code>就是一个内置属性，所以<code>for…in</code>遍历不出来】)。</li><li><code>for…in</code>的原理是: <code>Object.keys()</code>：返回给定对象所有可枚举属性的字符串数组</li></ul><h2 id="for-in循环数组"><a href="#for-in循环数组" class="headerlink" title="for...in循环数组"></a><code>for...in</code>循环数组</h2><pre><code class="javascript">let arr = [1, 2, 3]arr.__proto__.name = &#39;jerry&#39;for (let i in arr) &#123;  console.log(i)    // 0, 1, 2, name&#125;for (let i in Object.keys(arr)) &#123;  console.log(i)    // 0, 1, 2, name&#125;for (let i = 0; i &lt; arr.length; i++) &#123;  console.log(i)    // 0, 1, 2&#125;;</code></pre><h1 id="for-in循环对象"><a href="#for-in循环对象" class="headerlink" title="for...in循环对象"></a><code>for...in</code>循环对象</h1><pre><code class="javascript">let obj = &#123;a: &#39;aaa&#39;, b: &#39;bbb&#39;, c: &#39;ccc&#39;&#125;obj.__proto__.name = &#39;jerry&#39;for (let i in obj) &#123;  console.log(i)    // a, b, c, name&#125;for (let i in Object.keys(obj)) &#123;  console.log(i)    // 0, 1, 2, name&#125;</code></pre><h1 id="for-in循环字符串"><a href="#for-in循环字符串" class="headerlink" title="for...in循环字符串"></a><code>for...in</code>循环字符串</h1><blockquote><p>如果<code>Object.keys()</code>传入的是一个字符串，对<code>Object.keys()</code>的结果进行<code>for...in</code>循环，不会获取原型链上的属性</p></blockquote><pre><code class="javascript">let str = &#39;abcde&#39;str.__proto__.age = 18for (let i in str) &#123;  console.log(i)    // 0, 1, 2, 3, 4, age&#125;for (let i in Object.keys(str)) &#123;  console.log(i)    // 0, 1, 2, 3, 4  // 这里没有age属性&#125;for (let i = 0; i &lt; str.length; i++) &#123;  console.log(i)    // 0, 1, 2, 3, 4&#125;;</code></pre><h1 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for...of循环"></a><code>for...of</code>循环</h1><p><code>for...of</code>是<code>ES6</code>的标准，该方法遍历的是对象的属性所对应的值(<code>value</code>：键值)。所以它用来遍历数组时得到每个元素的值</p><ul><li><code>for…of</code>语句在可迭代对象（包括 <code>Array</code>，<code>String</code>，<code>Set</code>，<code>Map</code>，<code>TypedArray</code>，<code>arguments</code>，<code>Generators</code>，<code>DOM collection</code>对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</li><li><code>for…of</code>语句遍历可迭代对象定义要迭代的数据（非自定义属性）</li><li><code>for…of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象、Generator 对象，以及字符串。</li></ul><h2 id="for-of循环数组"><a href="#for-of循环数组" class="headerlink" title="for...of循环数组"></a><code>for...of</code>循环数组</h2><pre><code class="javascript">let arr1 = [10, 20, 30];for (let value of arr1) &#123;    console.log(value);&#125;// 10// 20// 30// 我们可以使用const来替代let，这样它就变成了在循环里的不可修改的静态变量。let arr2 = [100, 200, 300];for (const value of arr2) &#123;    console.log(value);&#125;// 100// 200// 300</code></pre><h2 id="for-of循环字符串"><a href="#for-of循环字符串" class="headerlink" title="for...of循环字符串"></a><code>for...of</code>循环字符串</h2><pre><code class="javascript">let str1 = &quot;abcde&quot;;for (let value of str1) &#123;    console.log(value);&#125;// a// b// c// d// e</code></pre><h2 id="for-of循环Set"><a href="#for-of循环Set" class="headerlink" title="for...of循环Set"></a><code>for...of</code>循环<code>Set</code></h2><pre><code class="javascript"> let set1 = new Set([1, 1, 2, 2, 3, 3]);for (let value of set1) &#123;    console.log(value);&#125;// 1// 2// 3</code></pre><h2 id="for-of循环Map"><a href="#for-of循环Map" class="headerlink" title="for...of循环Map"></a><code>for...of</code>循环<code>Map</code></h2><pre><code class="javascript">let map1 = new Map([[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]);for (let [key, value] of map1) &#123;    console.log(key, value);&#125;// &#39;a&#39; 1// &#39;b&#39; 2// &#39;c&#39; 3for (let entry of map1) &#123;    console.log(entry);&#125;// [a, 1]// [b, 2]// [c, 3]</code></pre><h2 id="for-of循环类型化数组（TypedArray）"><a href="#for-of循环类型化数组（TypedArray）" class="headerlink" title="for...of循环类型化数组（TypedArray）"></a><code>for...of</code>循环类型化数组（<code>TypedArray</code>）</h2><pre><code class="javascript">let tArr = new Uint8Array([0x00, 0xff]);for (let value of tArr) &#123;    console.log(value);&#125;// 0// 255</code></pre><h2 id="for-of循环arguments"><a href="#for-of循环arguments" class="headerlink" title="for...of循环arguments"></a><code>for...of</code>循环<code>arguments</code></h2><pre><code class="javascript">function func() &#123;    for (let arg of arguments) &#123;        console.log(arg);    &#125;&#125;func(1, 2, 3)// 1// 2// 3</code></pre><h2 id="for-of循环generator"><a href="#for-of循环generator" class="headerlink" title="for...of循环generator"></a><code>for...of</code>循环<code>generator</code></h2><pre><code class="javascript">function* gen() &#123; // a generator function    yield 1;    yield 2;    yield 3;&#125;for (let n of gen()) &#123;    console.log(n);&#125;// 1// 2// 3function* fibonacci() &#123; // a generator function    let [prev, curr] = [0, 1];    while (true) &#123;        [prev, curr] = [curr, prev + curr];        yield curr;    &#125;&#125;for (let n of fibonacci()) &#123;    console.log(n);    // truncate the sequence at 100    if (n &gt;= 100) &#123;        break;    &#125;&#125;// 1// 2// 3// 5// 8// 13// 21// 34// 55// 89// 144</code></pre><h2 id="for-of循环DOM-collection"><a href="#for-of循环DOM-collection" class="headerlink" title="for...of循环DOM collection"></a><code>for...of</code>循环<code>DOM collection</code></h2><pre><code class="javascript">let articleParagraphs = document.querySelectorAll(&quot;article &gt; p&quot;);for (let paragraph of articleParagraphs) &#123;    paragraph.classList.add(&quot;read&quot;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 函数参数以及内置参数arguments</title>
      <link href="/2021/06/11/js-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%86%85%E7%BD%AE%E5%8F%82%E6%95%B0arguments/"/>
      <url>/2021/06/11/js-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%86%85%E7%BD%AE%E5%8F%82%E6%95%B0arguments/</url>
      
        <content type="html"><![CDATA[<h1 id="普通传参"><a href="#普通传参" class="headerlink" title="普通传参"></a>普通传参</h1><ul><li><code>ES5</code>中如果函数在调用时如果未提供隐式参数（实参），参数会默认设置为<code>undefined</code></li><li>实参比形参多的时候，多出来的直接被忽略</li></ul><pre><code class="javascript">function getSum(a, b, c) &#123;    console.log(a + b + c);&#125;let res1 = getSum(1, 2)         // NaN，形参c没有赋值，为undefined，结果是 1 + 2 + undefined ,NaNlet res2 = getSum(1, 2, 3, 4)   // 实参比形参多的时候，多出来的直接被忽略</code></pre><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>默认参数，<code>ES5</code>中不值吃形参直接定义默认参数，需要自己再函数体中自己判断</p><pre><code class="javascript">function fn1(x, y) &#123;    if (y === undefined) &#123;        y = 0;    &#125;&#125;// 或者function fn2(x, y) &#123;    y = y || 0;&#125;</code></pre><p>在<code>ES6</code>中，可以在形参中直接设置默认参数；</p><pre><code class="javascript">function sumAll(a, b = 10) &#123;    console.log(a + b);&#125;sumAll(2, 2);       // 输出4，此时a = 2，b = 10sumAll(2);          // 输出12，此时a = 2，b = 10（取默认值）；</code></pre><h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><p><code>JavaScript</code> 函数有个内置的对象<code>arguments</code>对象。<code>argument</code> 对象包含了函数调用的参数数组。<code>arguments</code>是一个伪数组，具有数组特性的<code>arguments</code>对象</p><pre><code class="javascript">function fn3() &#123;    console.log(arguments);   // Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]    for (let i = 0; i &lt; arguments.length; i++) &#123;        console.log(arguments[i]);   // 1, 2, 3    &#125;&#125;fn3(1, 2, 3)</code></pre><p>通过这种方式你可以很方便的找到最大的一个参数的值。</p><pre><code class="javascript">function findMax() &#123;    var i, max = arguments[0];    if (arguments.length &lt; 2) return max;    for (i = 0; i &lt; arguments.length; i++) &#123;        if (arguments[i] &gt; max) &#123;            max = arguments[i];        &#125;    &#125;    return max;&#125;let res = findMax(1, 123, 500, 115, 44, 88);console.log(res); // 500</code></pre><p><code>arguments</code>是一个伪数组，只有一个<code>length</code>属性，不能使用数组的一些方法，使用<code>Array.prototype.slice.call()</code>方法可以把伪数组对象变成一个真正的数组(注意此方法转换的对象必须要有<code>length</code>属性)</p><pre><code class="javascript">function fn() &#123;    console.log([].slice.call(arguments));&#125;fn(1, 2, 3)</code></pre><p>如果在参数中传递<code>...args</code>，表示剩余参数，保存在一个数组里面，如果有像下面的形式，那么将会把第一个参数给到<code>x</code>，其他的再保存在<code>args</code>数组里面</p><pre><code class="javascript">function fn1(x, ...args) &#123;    console.log(x);     // 1    console.log(args);  // [2, 3]&#125;fn1(1, 2, 3)</code></pre><p>解构参数</p><pre><code class="javascript">function fn2(...args) &#123;    console.log(args);  // [1, 2, 3, 4, 5, 6]&#125;let args1 = [1, 2, 3]let args2 = [4, 5, 6]fn2(...args1, ...args2)    // 参数解构// console.log(...[1, 2, 3]);  // 1, 2, 3</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 防抖和节流</title>
      <link href="/2021/06/11/js-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2021/06/11/js-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p><code>lodash</code>里面有封装好的现成的方法，可以直接拿来用，下面是自己的实现</p><h1 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h1><pre><code class="javascript">/*** @desc   函数防抖      “立即执行版本” 和 “非立即执行版本” 的组合版本* @param  func         需要执行的函数* @param  wait         延迟执行时间（毫秒）* @param  immediate    true表示立即执行 false表示非立即执行 默认false**/function debounce(func, wait, immediate = false) &#123;    let timer;    // 这里用到了闭包，timer本来在debounde函数执行完毕的时候就会被销毁    // 但是下面return的代码中使用了timer，因此不会被销毁，被保留了下来    return function (...args) &#123;        if (timer) clearTimeout(timer);        if (immediate) &#123;            var callNow = !timer;            timer = setTimeout(() =&gt; &#123;                timer = null;            &#125;, wait)            if (callNow) func.apply(this, args)        &#125; else &#123;            timer = setTimeout(() =&gt; &#123;                func.apply(this, args)  // 这里要修改this指向，否则this指向的不是时间出发对象，而是window            &#125;, wait);        &#125;    &#125;&#125;</code></pre><h1 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h1><pre><code class="javascript">/*** @desc  函数节流   “立即执行版本” 和 “非立即执行版本” 的组合版本* @param func      需要执行的函数* @param wait      延迟执行毫秒数* @param immediate true表示立即执行 false表示非立即执行 默认false*/function throttle(func, wait, immediate = false) &#123;    if (immediate) &#123;        var previous = 0;    &#125; else &#123;        var timeout;    &#125;    return function () &#123;        let args = arguments;        if (immediate) &#123;            let now = Date.now();            if (now - previous &gt; wait) &#123;                func.apply(this, args);                previous = now;            &#125;        &#125; else &#123;            if (!timeout) &#123;                timeout = setTimeout(() =&gt; &#123;                    timeout = null;                    func.apply(this, args)                &#125;, wait)            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js this指向问题以及改变this指向的三种方法（call/apply/bind）</title>
      <link href="/2021/06/08/js-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88call-apply-bind%EF%BC%89/"/>
      <url>/2021/06/08/js-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88call-apply-bind%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在<code>JavaScript</code>中，<code>this</code>指向是一个很令人头疼的一个东西，由于<code>JavaScript</code>可以运行在浏览器环境中，也可以运行在<code>node</code>环境中，两者的<code>this</code>指向有着不同的特性，<code>this</code>指向问题往往会令你的代码朝着意想不到的方向运行，因此<code>JavaScript</code>也提供了几种修改<code>this</code>指向的方法，我们一一说明。</p><h1 id="浏览器环境中this的指向"><a href="#浏览器环境中this的指向" class="headerlink" title="浏览器环境中this的指向"></a>浏览器环境中<code>this</code>的指向</h1><p>下面先介绍在浏览器环境中<code>this</code>的指向问题；</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        // 全局模式下，this指向window        console.log(this);        // 全局变量是设置在window上的，因此下面的写法是一样的        a = 10;                     // window.a = 10        this.b = 10;        console.log(a === b);       // true        function fn1() &#123;            console.log(this);        &#125;        fn1();              // this指向window        window.fn1();       // this还是指向window        var obj = &#123;            c: 10,            fn2: function () &#123;                console.log(this);            &#125;        &#125;        obj.fn2()           // this指向obj        window.obj.fn2()    // this指向obj        var obj2 = &#123;            d: 10,            e: &#123;                f: 10,                fn3: function () &#123;                    console.log(this);                &#125;            &#125;        &#125;        window.obj2.e.fn3()     // this指向e        let fn4 = window.obj2.e.fn3;        fn4()                   // this指向window    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>总结：</p><ul><li><code>this</code>在定义的时候不会指定，只有在函数调用的时候才会指定</li><li><code>this</code>指向的是在调用函数时最近的调用者</li></ul><h1 id="node环境中this的指向"><a href="#node环境中this的指向" class="headerlink" title="node环境中this的指向"></a><code>node</code>环境中<code>this</code>的指向</h1><p>而在<code>node</code>环境中，<code>this</code>的指向和浏览器中有着较大出入；<br>在全局打印<code>this</code>，这里的<code>this</code>是一个空对象<code>&#123;&#125;</code></p><pre><code class="javascript">console.log(this); // &#123;&#125;</code></pre><p>在浏览器环境中，这里的结果是<code>true</code>，但是在<code>node</code>环境中，会报错，因为变量<code>b</code>是定义在this上的，而<code>this</code>指向的是一个空对象，而<code>a === b</code>中的变量<code>b</code>是根本没有定义的</p><pre><code class="javascript">a = 10;this.b = 10;console.log(a === b); // ReferenceError: b is not defined</code></pre><p>有趣的是，在函数中，this指向的又不是空对象，而是<code>global</code>对象，指向函数<code>fn1</code>的调用者<code>global</code></p><pre><code class="javascript"> function fn1() &#123;    console.log(this);&#125;fn1(); // Object [global] &#123;...&#125;</code></pre><pre><code class="javascript">var obj = &#123;    c: 10,    fn2: function () &#123;        console.log(this);    &#125;&#125;obj.fn2() // &#123; c: 10, fn2: [Function: fn2] &#125; =&gt; 指向obj</code></pre><pre><code class="javascript">var obj2 = &#123;    d: 10,    e: &#123;        f: 10,        fn3: function () &#123;            console.log(this);        &#125;    &#125;&#125;obj2.e.fn3() // &#123; f: 10, fn3: [Function: fn3] &#125; =&gt; 指向e</code></pre><p>总结：</p><ul><li><code>node</code>环境中直接打印的<code>this</code>指向空对象，浏览器环境直接打印<code>this</code>指向<code>window</code></li><li><code>this</code>指向和浏览器环境中是一样的，只是区别在于，浏览器环境全局是<code>window</code>，而<code>node</code>环境全局是<code>global</code></li></ul><h1 id="改变this指向的三种方法；"><a href="#改变this指向的三种方法；" class="headerlink" title="改变this指向的三种方法；"></a>改变<code>this</code>指向的三种方法；</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><pre><code class="javascript">function fun1(a, b, c) &#123;    console.log(this);    console.log(a + b + c);&#125;obj = &#123; name: &#39;jerry&#39;, age: 18 &#125;;fun1() // 这里函数里的this指向window对象fun1.call(obj, 1, 2, 3); // 这里函数中的this指向obj，而不是fun1</code></pre><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p><code>apply</code>和<code>call</code>的区别是<code>apply</code>传递的参数需要使用数组，而<code>call</code>直接传就行了</p><pre><code class="javascript"> function fun2(a, b, c) &#123;    console.log(this);    console.log(a + b + c);&#125;fun2.apply(obj, [1, 2, 3])</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code>区别是<code>bind</code>只会改变<code>this</code>指向，并不会执行函数，而<code>call</code>和<code>apply</code>不仅改变<code>this</code>指向，并且会执行函数</p><pre><code class="javascript"> function fun3(a, b, c) &#123;    console.log(this);    console.log(a + b + c);&#125;fun3.bind(obj, 1, 2, 3); // 并不会执行fun3</code></pre><p>需要特别注意的是，bind方法并不会直接去更改函数的this指向，而是返回一个新的修改了this指向的函数，如果要调用，则需要使用其他变量接收或者直接调用</p><pre><code class="javascript"> function fun3(a, b, c) &#123;    console.log(this);    console.log(a + b + c);&#125;fun3.bind(obj, 1, 2, 3); // 并不会执行fun3fun3() // 这里的this指向并没有发生改变// 如果想要调用，用变量接收let newFun3 = fun3.bind(obj, 1, 2, 3);newFun3()// 或者直接调用fun3.bind(obj, 1, 2, 3)()</code></pre><h1 id="一个bind方法的小例子"><a href="#一个bind方法的小例子" class="headerlink" title="一个bind方法的小例子"></a>一个bind方法的小例子</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button&gt;获取验证码&lt;/button&gt;    &lt;script&gt;        // 注意这里，如果不加bind(this)，那么定时器里面的this指向的是window        // 这里加了bind(this)，那么定时器里面的this就指向了btn事件源，从而可以使用this来操作btn        let btn = document.querySelector(&#39;button&#39;);        btn.onclick = function () &#123;            let time = 10;            this.disabled = true;            this.innerText = `重新获取($&#123;time&#125;)`            this.timer = setInterval(function () &#123;                time -= 1;                this.innerText = `重新获取($&#123;time&#125;)`                if (time == 0) &#123;                    this.disabled = false;                    this.innerText = `获取验证码`                    clearInterval(this.timer)                &#125;            &#125;.bind(this), 1000)        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/bind.gif"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bluebird Promise库</title>
      <link href="/2021/06/03/bluebird-Promise%E5%BA%93/"/>
      <url>/2021/06/03/bluebird-Promise%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>整理一些<code>Promise</code>库<code>bluebird</code>的常用api</p><h1 id="Promis-promisify"><a href="#Promis-promisify" class="headerlink" title="Promis.promisify"></a>Promis.promisify</h1><p><code>promisify</code>可以帮我们吧一些常用异步方法或者库转化成<code>Promise</code>对象，这样我们就不用自己封装了；</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);readFile(&#39;./data/a.txt&#39;).then(data =&gt; console.log(data.toString()));</code></pre><blockquote><p>这里仅做个最简单的介绍，更多详细用法查看官网<a href="http://bluebirdjs.com/docs/features.html">Promis.promisify</a></p></blockquote><h1 id="Promise-promisifyAll"><a href="#Promise-promisifyAll" class="headerlink" title="Promise.promisifyAll"></a>Promise.promisifyAll</h1><pre><code class="javascript">const Promise = require(&#39;bluebird&#39;);const fs = Promise.promisifyAll(require(&#39;fs&#39;));fs.readFileAsync(&quot;./data/a.txt&quot;).then(contents =&gt; &#123; // 实际是readFile方法，Async只是Promise.promisifyAll为我们自动添加的后缀，下面会介绍    console.log(contents);&#125;).catch(err =&gt; &#123;    console.error(err);&#125;);</code></pre><p>可以为包装后的函数添加后缀，以区分原始方法，默认的后缀是<code>Async</code></p><pre><code class="javascript">const Promise = require(&#39;bluebird&#39;);const fs = Promise.promisifyAll(require(&#39;fs&#39;), &#123;suffix: &#39;Promise&#39;&#125;);fs.readFilePromise(&quot;./data/a.txt&quot;, &quot;utf8&quot;).then(contents =&gt; &#123;    console.log(contents);&#125;).catch(err =&gt; &#123;    console.error(err);&#125;);</code></pre><blockquote><p>更多用法查看官网<a href="http://bluebirdjs.com/docs/api/promise.promisifyall.html">Promis.promisify</a></p></blockquote><p><code>Promise.promisifyAll</code>可以接受数组，一次性<code>promisify</code>多个类；</p><pre><code class="javascript">var Pool = require(&quot;mysql/lib/Pool&quot;);var Connection = require(&quot;mysql/lib/Connection&quot;);Promise.promisifyAll([Pool, Connection]);</code></pre><h1 id="Cancellation"><a href="#Cancellation" class="headerlink" title="Cancellation"></a>Cancellation</h1><p>javascript中的Promise是不支持取消异步操作的，但是bluebird支持取消异步操作，这个是一个很好的特性，能够帮我们解决很多问题，比如在React中，组件挂载时请求接口，如果在接口返回之前这个组件被卸载了，React会抛出一个异常，我们就可以利用bluebird的这一特性，来帮我们处理这个问题；</p><p>想要使用<code>Cancellation</code>必须配置开启，如下第二行代码，此时Promise就可以取消了，还可以定义取消的回调函数，当取消的时候，执行一些操作。</p><p>注意：<code>.cancel</code>操作是同步的</p><pre><code class="javascript">const Promise = require(&#39;bluebird&#39;);Promise.config(&#123;cancellation: true&#125;);let p1 = new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;p1&#39;), 3000);&#125;)// 第三个参数只有当cancellation配置为true时才有let p2 = new Promise((resolve, reject, onCancel) =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;p2&#39;), 5000);    onCancel(() =&gt; console.log(&#39;p2 canceled&#39;))&#125;)let p3 = new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;p3&#39;), 7000);&#125;)p1.then(res =&gt; console.log(res));p2.then(res =&gt; console.log(res));p3.then(res =&gt; console.log(res));console.log(&#39;-----------------&#39;);p2.cancel();</code></pre><p>输出</p><pre><code>----------------- // 执行栈直接输出p2 canceled       // 调用p2的cancel方法时输出，.cancel方法是同步的，因此会在-----后直接输出p1                // 等待3秒后输出p3                // 等待7秒后输出，注意这里不是p1三秒结束后再等待7秒，而是从一开始等待7秒，因为Promise一旦创建就立即执行了</code></pre><p>使用已经取消了的<code>Promise</code>是会报错的<code>SubError [CancellationError]: late cancellation observer</code></p><pre><code class="javascript">const Promise = require(&#39;bluebird&#39;);Promise.config(&#123;cancellation: true&#125;);let p2 = new Promise((resolve, reject, onCancel) =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;p2&#39;), 5000);    onCancel(() =&gt; console.log(&#39;p2 canceled&#39;));&#125;)p2.cancel(); // 已取消p2.then(res =&gt; &#123;    console.log(res);&#125;).catch(err =&gt; console.log(err));</code></pre><p>结果</p><pre><code>p2 canceledSubError [CancellationError]: late cancellation observer    at Promise._then (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\promise.js:285:21)    at Promise.then (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\promise.js:154:17)    at Object.&lt;anonymous&gt; (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo    ...</code></pre><h1 id="Promise-spread"><a href="#Promise-spread" class="headerlink" title="Promise.spread"></a>Promise.spread</h1><p><code>Promise.spread</code>可以把一个<code>Promise</code>数组进行解构，例如我们使用<code>Promise.all</code>进行多个异步操作，正常的<code>.then</code>拿到的入参就是一个数组，如果我们使用<code>Promise.spread</code>，那么我们获取到的就是数组里对应的值，而不是一个数组，结果和<code>Promise</code>对象的数组顺序一一对应，如果只传一个入参，则只获取第一个结果。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.all([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/b.txt&#39;)]).then(res =&gt; console.log(res.map(str =&gt; str.toString())))// [ &#39;aaaaaaaaaaaaaaaaaaaaaa&#39;, &#39;bbbbbbbbbbbbbbbbbbbbbb&#39; ]</code></pre><p>使用<code>Promise.spread</code>，我们可以看到入参是数组每一项的值，而不是一整个数组</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.all([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/b.txt&#39;)]).spread((res1, res2) =&gt; console.log(res1.toString(), res2.toString()))// &#39;aaaaaaaaaaaaaaaaaaaaaa&#39; &#39;bbbbbbbbbbbbbbbbbbbbbb&#39;</code></pre><h1 id="Promise-bind"><a href="#Promise-bind" class="headerlink" title="Promise.bind"></a>Promise.bind</h1><p><code>Promise.bind</code>可以修改当前的<code>this</code>指向</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);class MyClass &#123;    constructor()&#123;        this.fileName = &#39;./data/a.txt&#39;;    &#125;    error(error) &#123;        console.log(error)    &#125;&#125;MyClass.prototype.method = function() &#123;    console.log(this); // 这里this指向MyClass    return readFile(this.fileName).bind(this) // 绑定this指向    .then((contents) =&gt; &#123;        console.log(contents)        console.log(this)   // 这里this指向MyClass，如果没有上面的bind(this)，那么这里将指向全局对象    &#125;).catch((e) =&gt; &#123;        this.error(e.stack); // 这里this指向MyClass，，如果没有上面的bind(this)，那么这里将指向全局对象    &#125;);&#125;;let me = new MyClass()me.method()</code></pre><h1 id="Promise-props"><a href="#Promise-props" class="headerlink" title="Promise.props"></a>Promise.props</h1><p><code>Promise.props</code>和<code>Promise.all</code>的作用类似，都是组合<code>Promise</code>对象，最大的区别是，<code>Promise.all</code>是需要一个具有<code>iterator</code>接口的对象，例如数组，而<code>Promise.props</code>的入参是一个<code>key: [Promise]</code>对象，而结果也会是一个<code>key: [result]</code>对象，</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.props(&#123;    txtA: readFile(&#39;./data/a.txt&#39;),    txtB: readFile(&#39;./data/b.txt&#39;),&#125;).then(result =&gt; &#123;    console.log(result.txtA.toString());    console.log(result.txtB.toString());&#125;)// aaaaaaaaaaaaaaaaaaaaaa// bbbbbbbbbbbbbbbbbbbbbb</code></pre><h1 id="Promise-some"><a href="#Promise-some" class="headerlink" title="Promise.some"></a>Promise.some</h1><p><code>Promise.some</code>接收两个参数，第一个是<code>Promise</code>对象数组（不一定是数组，具有<code>iterator</code>接口就行），第二个参数是返回的个数，这个个数是在所有的<code>Promise</code>对象中，状态最快变为<code>fulfilled</code>的前几个，例如下面的代码，读取4个文件，返回最快读到的前2个；</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.some([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/b.txt&#39;),    readFile(&#39;./data/c.txt&#39;),    readFile(&#39;./data/d.txt&#39;),], 2).then(res =&gt; &#123;console.log(res)&#125;)</code></pre><p>如果成功的个数小于第二个参数指定的个数，会抛出一个异常</p><pre><code class="javascript">Unhandled rejection AggregateError: aggregate error    at SomePromiseArray._checkOutcome (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\some.js:82:17)    at SomePromiseArray._promiseRejected (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\some.js:69:17)    at Promise._settlePromise (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\promise.js:611:26)</code></pre><p>我们可以直接<code>.catch</code>捕获，但是此时捕获的错误是一个<code>rejected Promise</code>的数组，具有<code>length</code>属性和一些数组的操作方法</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.some([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/bd.txt&#39;),    readFile(&#39;./data/cd.txt&#39;),], 2).then(res =&gt; &#123;console.log(res)&#125;).catch(err =&gt; console.log(err))</code></pre><p>此时<code>bd.txt</code>和<code>cd.txt</code>文件是不存在的，只有<code>a.txt</code>能读取成功，而我们定义了成功的数量是前两个，此时就会进入异常</p><pre><code class="javascript">SubError [AggregateError]: aggregate error    at SomePromiseArray._checkOutcome (C:\Users\lyucan\Desktop\pro\newRepo\Repositories\node_modules\bluebird\js\release\some.js:82:17)    ...    at processImmediate (internal/timers.js:439:21) &#123;  &#39;0&#39;: [OperationalError: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\bd.txt&#39;] &#123;    cause: [Error: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\bd.txt&#39;] &#123;      errno: -4058,      code: &#39;ENOENT&#39;,      syscall: &#39;open&#39;,      path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\bd.txt&#39;    &#125;,    isOperational: true,    errno: -4058,    code: &#39;ENOENT&#39;,    syscall: &#39;open&#39;,    path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\bd.txt&#39;  &#125;,  &#39;1&#39;: [OperationalError: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\cd.txt&#39;] &#123;    cause: [Error: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\cd.txt&#39;] &#123;      errno: -4058,      code: &#39;ENOENT&#39;,      syscall: &#39;open&#39;,      path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\cd.txt&#39;    &#125;,    isOperational: true,    errno: -4058,    code: &#39;ENOENT&#39;,    syscall: &#39;open&#39;,    path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\cd.txt&#39;  &#125;,  length: 2&#125;</code></pre><p>返回的整个错误是可以调用数组方法的，例如</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&#39;bluebird&#39;);const readFile = Promise.promisify(fs.readFile);Promise.some([    readFile(&#39;./data/a.txt&#39;),    readFile(&#39;./data/bd.txt&#39;),    readFile(&#39;./data/cd.txt&#39;),], 2).then(res =&gt; &#123;console.log(res)&#125;).catch(err =&gt; console.log(err.map(errItem =&gt; errItem)))</code></pre><p>结果</p><pre><code class="javascript">[  [OperationalError: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\bd.txt&#39;] &#123;    cause: [Error: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\bd.txt&#39;] &#123;      errno: -4058,      code: &#39;ENOENT&#39;,      syscall: &#39;open&#39;,      path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\bd.txt&#39;    &#125;,    isOperational: true,    errno: -4058,    code: &#39;ENOENT&#39;,    syscall: &#39;open&#39;,    path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\bd.txt&#39;  &#125;,  [OperationalError: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\cd.txt&#39;] &#123;    cause: [Error: ENOENT: no such file or directory, open &#39;C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\promise\data\cd.txt&#39;] &#123;      errno: -4058,      code: &#39;ENOENT&#39;,      syscall: &#39;open&#39;,      path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\cd.txt&#39;    &#125;,    isOperational: true,    errno: -4058,    code: &#39;ENOENT&#39;,    syscall: &#39;open&#39;,    path: &#39;C:\\Users\\lyucan\\Desktop\\pro\\newRepo\\Repositories\\myrepo\\nodejs\\promise\\data\\cd.txt&#39;  &#125;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js Promise</title>
      <link href="/2021/05/31/js-Promise/"/>
      <url>/2021/05/31/js-Promise/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Promise</code>是<code>js</code>里一种异步编程解决方案，比较传统的是回调函数和事件，熟悉<code>nodejs</code>的都知道，在<code>Promise</code>还没出现之前，一切异步编程都是通过回调函数来实现的，包括文件读取，数据库操作等，很容易造成回调地狱，而<code>Promise</code>可以帮我们很好的解决这个问题。</p><p><code>Promise</code>可以看做是一个容器，里面存放着未来某个时间才会结束的异步操作，其内部有三种状态，分别是<code>pending</code>（进行中），<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有内部异步操作的结果，会影响这三种状态，其他任何操作都无法影响这三种状态。</p><p><code>Promise</code>对象的状态改变，只可能有两种可能：<code>pending -&gt; fulfilled</code>或者<code>pending -&gt; rejected</code>。只要状态改变了，就不会再改变了。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><code>Promise</code>是一个构造函数，用来生成<code>Promise</code>实例，<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己指定。如果<code>Promise</code>内部的异步操作成功，则调用<code>resolve</code>函数，把<code>Promise</code>内部的状态由<code>pending</code>变为<code>fulfilled</code>，并把结果作为参数抛出去，否则调用<code>reject</code>函数把<code>Promise</code>内部的状态由<code>pending</code>变为<code>rejected</code>，把错误作为参数抛出去。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);// 1、创建promise对象，一经创建，立马执行new Promise((resolve, reject) =&gt; &#123;    fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        if (err) &#123;            reject(err);        &#125; else &#123;            // 请求成功时，调用.then()里面自己写的resolve函数            resolve(data);        &#125;    &#125;);&#125;)</code></pre><p>抛出去的结果我们可以使用<code>Promise</code>的<code>then</code>方法进行接收，<code>Promise</code>的<code>then</code>方法接收两个回调函数作为参数，第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);// 1、创建promise对象，一经创建，立马执行new Promise((resolve, reject) =&gt; &#123;    fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        if (err) &#123;            reject(err);        &#125; else &#123;            resolve(data);        &#125;    &#125;);&#125;).then(    // 下面这个函数式作为上面Promise的resolve使用    (data) =&gt; &#123; // 这里的参数就是上面Promise里resolve传出来的参数        console.log(data.toString());    &#125;,    // 这个作为reject使用    (err) =&gt; &#123;        console.log(err)    &#125;)</code></pre><p>使用Promise的注意点</p><ul><li>调用resolve或reject并不会终结 Promise 的参数函数的执行。</li></ul><pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;  resolve(1);  console.log(2);&#125;).then(r =&gt; &#123;  console.log(r);&#125;);// 2// 1</code></pre><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即<code>resolved</code>的<code>Promise</code>是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说一旦<code>Promise</code>内部调用r<code>esolve</code>或者<code>reject</code>之后，它的任务就完成了，不应该继续在后面执行其他任务，因此我们最好再<code>resolve</code>和<code>reject</code>前面加上return</p><pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;  return resolve(1);  // 后面的语句不会执行  console.log(2);&#125;)</code></pre><h1 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h1><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><p>第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);// then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。// 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。new Promise((resolve, reject) =&gt; &#123;    fs.readFile(&#39;./data/a.txt&#39;, (err, data) =&gt; &#123;        if (!err) &#123;            resolve(data)        &#125; else &#123;            reject(err)        &#125;    &#125;)&#125;)    .then((data) =&gt; &#123;        console.log(data.toString());        return &#39;在.then()中返回的结果，会传入下一个then的参数中&#39;    &#125;)    .then((data) =&gt; &#123;        console.log(data);        return 1    &#125;)    .then((data) =&gt; &#123;        console.log(data);    &#125;)    .catch((err) =&gt; &#123;        console.log(&#39;err&#39;, err);    &#125;)</code></pre><p>输出</p><pre><code class="javascript">aaaaaaaaaaaaaaaaaaaaaa // 文件a.txt的内容在.then()中返回的结果，会传入下一个then的参数中1</code></pre><h1 id="Promise封装"><a href="#Promise封装" class="headerlink" title="Promise封装"></a>Promise封装</h1><p>假如我们要依次地区文件的内容，我们可能会像下面这样编码</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);new Promise((resolve, reject) =&gt; &#123;    fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        if (err) &#123;            reject(err);        &#125; else &#123;            resolve(data);        &#125;    &#125;);&#125;).then((data) =&gt; &#123;    console.log(data.toString());    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(__dirname + &#39;/data/b.txt&#39;, (err, data) =&gt; &#123;            if (err) &#123;                reject(err);            &#125; else &#123;                resolve(data);            &#125;        &#125;);    &#125;)&#125;).then((data) =&gt; &#123;    console.log(data.toString());    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;            if (err) &#123;                reject(err);            &#125; else &#123;                resolve(data);            &#125;        &#125;);    &#125;)&#125;).then((data) =&gt; &#123;    console.log(data.toString());&#125;);</code></pre><p>这样写没问题，但是充斥了大量的重复代码，因此我们可以对读取文件的Promise进行一层封装，改造成以下代码</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);function readFiles(...args) &#123;    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(...args, (err, data) =&gt; &#123;            if (err) &#123;                reject(err);            &#125; else &#123;                resolve(data);            &#125;        &#125;)    &#125;)&#125;readFiles(__dirname + &#39;/data/a.txt&#39;, &#39;utf8&#39;)    .then((data) =&gt; &#123;        console.log(data);        return readFiles(__dirname + &#39;/data/b.txt&#39;, &#39;utf8&#39;);    &#125;)    .then((data) =&gt; &#123;        console.log(data);        return readFiles(__dirname + &#39;/data/c.txt&#39;, &#39;utf8&#39;);    &#125;)    .then((data) =&gt; &#123;        console.log(data);        return readFiles(__dirname + &#39;/data/a.txt&#39;, &#39;utf8&#39;);    &#125;)    .then((data)=&gt;&#123;        console.log(data);    &#125;);</code></pre><p>我们封装了一个<code>readFiles</code>函数，返回一个读取文件的<code>Promise</code>对象，在链式调用中，<code>then</code>函数返回的也是一个<code>Promise</code>对象，因此可以一层一层往下调用</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p><code>Promise</code>的错误处理有两种方式，一种是在<code>then</code>函数的第二个回调函数参数中进行处理，另一种是使用<code>Promise.catch</code>进行错误捕获。</p><p>例如：</p><pre><code class="javascript">let p = new Promise(...)p.then(null, reject =&gt; console.log(reject))</code></pre><p>或者</p><pre><code class="javascript">let p = new Promise(...)p.then(resolve =&gt; console.log(resolve)) .catch(err =&gt; console.log(err))</code></pre><p><code>Promise.catch</code>具有”冒泡”性质，意思是无论<code>then</code>链式调用了多少层，<code>Promise.catch</code>都能捕获到其中任意一层发生的错误</p><pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;  return getJSON(post.commentURL);&#125;).then(function(comments) &#123;  // some code&#125;).catch(function(error) &#123;  // 处理前面三个Promise产生的错误&#125;);</code></pre><p>因此我们推荐总是使用<code>Promise.catch</code>进行异常捕获</p><h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><p>不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的<code>Promise</code>状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于<code>Promise</code>的执行结果。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;读取文件b.txt出错了&#39;)&#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.all([P1, P2, P3])    .then(res =&gt; &#123;        console.log(res);        res.map(file =&gt; console.log(file.toString()))    &#125;)    .catch(err =&gt; console.log(err))    .finally(() =&gt; console.log(&#39;文件读取完毕&#39;))</code></pre><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p><code>Promise.all</code>可以把多个<code>Promise</code>实例，组装成一个<code>Promise</code>实例，此时只有当所有的<code>Promise</code>的状态都变为<code>fulfilled</code>时，<code>Promise.all</code>实例的状态才会变为<code>fulfilled</code>，只要其中有一个实例状态变为了<code>rejected</code>，最终<code>Promise.all</code>实例的状态就会变成<code>rejected</code>。</p><p><code>Promise.all</code>我们常用来并发的执行异步操作，比如我们想要同时读取三个文件，使用<code>Promise</code>链式调用会逐一读取，会造成一定的性能损失。</p><p><code>Promise.all</code>接收一个<code>Promise</code>的数组（不一定是数组，只要有<code>iterator</code>接口就行）作为参数，返回包装后的<code>Promise</code>实例，实例的<code>then</code>方法接收的结果是所有<code>Promise</code>实例结果的数组。无论异步操作哪个先执行完毕，结果数组的顺序和<code>Promise.all</code>传入的<code>Promise</code>实例数组的顺序相同</p><blockquote><p>再次强调一下，<code>Promise.all</code>入参不一定是数组，只要有iterator接口就行</p></blockquote><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/b.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.all([P1, P2, P3]).then(res =&gt; &#123;    console.log(res);    res.map(file =&gt; console.log(file.toString()))&#125;)</code></pre><p>输出</p><pre><code>[  &lt;Buffer 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61&gt;,  &lt;Buffer 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62&gt;,  &lt;Buffer 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63&gt;]aaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccccc</code></pre><p>注意，如果作为参数的<code>Promise</code>实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;读取文件b.txt出错了&#39;)&#125;).catch(err =&gt; err);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.all([P1, P2, P3])    .then(res =&gt; &#123;        console.log(res);        res.map(file =&gt; console.log(file.toString()))    &#125;)    .catch(err =&gt; console.log(err))</code></pre><p>结果</p><pre><code class="javascript">aaaaaaaaaaaaaaaaaaaaaaError: 读取文件b.txt出错了cccccccccccccccccccccc</code></pre><p>如果P2没有自己的catch方法，错误则会被Promise.all捕获</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;读取文件b.txt出错了&#39;)&#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.all([P1, P2, P3])    .then(res =&gt; &#123;        console.log(res);        res.map(file =&gt; console.log(file.toString()))    &#125;)    .catch(err =&gt; console.log(err))</code></pre><p>结果报错</p><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h1><p><code>Promise.race</code>，顾名思义，<code>race</code>是竞赛的意思，<code>Promise.race</code>里包装的<code>Promise</code>实例，只要有一个实例的状态率先改变了，那么<code>Promise.race</code>的状态就随之改变，那个率先改变状态的返回值，将作为<code>Promise.race``then</code>函数的入参，无论那个实力是成功或者失败，<code>Promise.race</code>的状态都会随之改变</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/a.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P2 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/b.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.race([P1, P2, P3]).then(res =&gt; &#123;    console.log(res.toString())&#125;).catch(err =&gt; console.log(err));</code></pre><p><code>Promise.race</code>额错误处理与<code>Promise.all</code>有着相同的特性，如果作为参数的<code>Promise</code>实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，就不会触发<code>Promise.race()</code>的<code>catch</code>方法。</p><h1 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h1><p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束，和前面的方法不同的是，<code>Promise.allSettled</code>的返回值，不是结果数组，而是一个<code>&#123;status: &#39;fulfilled&#39; | &#39;rejected&#39;, [reason|value]: VALUE&#125;</code>对象的数组，如果<code>status</code>是<code>fulfilled</code>，表示该<code>Promise</code>实例成功，那么第二个属性是<code>value</code>，值是异步操作的结果，如果<code>status</code>是<code>rejected</code>，表示该<code>Promise</code>实例有异常，那么第二个属性是<code>reason</code>，值是异常信息。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const P1 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;错了&#39;)&#125;);const P2 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;错了&#39;)&#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.allSettled([P1, P2, P3]).then(res =&gt; &#123;    console.log(res)&#125;).catch(err =&gt; console.log(err));</code></pre><p>结果</p><pre><code>[  &#123;    status: &#39;rejected&#39;,    reason: Error: 错了        at C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\Promise        ...  &#125;,  &#123;    status: &#39;rejected&#39;,    reason: Error: 错了        at C:\Users\lyucan\Desktop\pro\newRepo\Repositories\myrepo\nodejs\Promise        ...  &#125;,  &#123;    status: &#39;fulfilled&#39;,    value: &lt;Buffer 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63&gt;  &#125;]</code></pre><blockquote><p>往往我们需要自己手动筛选出成功的结果或失败的结果，根据需要自行处理</p></blockquote><h1 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h1><p>只要参数实例有任何一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 <code>Promise</code>变成<code>rejected</code>状态而结束。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const Promise = require(&quot;bluebird&quot;);const P1 = new Promise((resolve) =&gt; &#123;     throw new Error(&#39;错了&#39;)&#125;);const P2 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/b.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);const P3 = new Promise((resolve) =&gt; &#123;     fs.readFile(__dirname + &#39;/data/c.txt&#39;, (err, data) =&gt; &#123;        resolve(data)    &#125;) &#125;);Promise.any([P1, P2, P3]).then(res =&gt; &#123;    console.log(res.toString())&#125;).catch(err =&gt; console.log(err));</code></pre><p>结果</p><pre><code>bbbbbbbbbbbbbbbbbbbbbb</code></pre><blockquote><p>如果<code>c.txt</code>文件优先读取完毕，那么结果就是<code>c.txt</code>文件的内容</p></blockquote><p>需要注意的是，<code>Promise.any</code>还只是草案里的特性，不能直接使用，我们可以引用社区的<code>Promise</code>库<code>bluebird</code>来使用</p><h1 id="Promise-resolve-Promise-reject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve &amp; Promise.reject"></a>Promise.resolve &amp; Promise.reject</h1><p><code>Promise.resolve</code>可以直接把一个对象转化为<code>Promise</code>对象。</p><p>传入不同的对象，<code>Promise.resolve</code>有不同的行为</p><ol><li><p>传入<code>Promise</code>实例<br>如果参数是<code>Promise</code>实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p></li><li><p>参数是一个<code>thenable</code>对象<br><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p></li></ol><pre><code class="javascript">let thenable = &#123;    then: (resolve, reject) =&gt; &#123;        resolve(42);    &#125;&#125;;</code></pre><p><code>Promise.resolve()</code>方法会将这个对象转为<code>Promise</code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><pre><code class="javascript">let thenable = &#123;    then: (resolve, reject) =&gt; &#123;        resolve(42);    &#125;&#125;;  let p1 = Promise.resolve(thenable); // 此时p1的状态已经变成fulfilled了p1.then(val =&gt; console.log(val));   // 42</code></pre><pre><code class="javascript">let thenable = &#123;    then: (resolve, reject) =&gt; &#123;        reject(42);    &#125;&#125;;  let p1 = Promise.resolve(thenable); // 此时p1的状态已经变成rejected了p1.catch(err =&gt; console.log(err));</code></pre><pre><code class="javascript">let thenable = &#123;    then: (resolve, reject) =&gt; &#123;        throw new Error(&#39;出错了&#39;)    &#125;&#125;;  let p1 = Promise.resolve(thenable); // 此时p1的状态已经变成rejected了p1.catch(err =&gt; console.log(err));  // Error: 出错了</code></pre><ol start="3"><li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象</li></ol><pre><code class="javascript">let p1 = Promise.resolve(&#39;hello world&#39;);p1.then(res =&gt; console.log(res)); // hello world</code></pre><p>以上代码等价于</p><pre><code class="javascript">let p1 = new Promise(resolve =&gt; resolve(&#39;hello world&#39;));p1.then(res =&gt; console.log(res));</code></pre><ol start="4"><li>不带有任何参数</li></ol><pre><code class="javascript">let p = Promise.resolve();p.then(res =&gt; console.log(res)); // undefined</code></pre><p><code>Promise.reject(reason)</code>方法也会返回一个新的<code>Promise</code>实例，该实例的状态为<code>rejected</code>。</p><pre><code class="javascript">let p = Promise.reject(&#39;出错了&#39;);p.catch(err =&gt; console.log(err)); // 出错了</code></pre><p>以上代码等同于</p><pre><code class="javascript">let p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;));p.catch(err =&gt; console.log(err)); // 出错了</code></pre><p>最后提一下，在社区有很多库实现了<code>Promise</code>，都遵循<a href="https://promisesaplus.com/">Primise&#x2F;A+</a>规范，有人测试社区的多种实现中，<a href="http://bluebirdjs.com/docs/getting-started.html">bluebird.js</a>的性能比官方的ES6要高三倍，而且很多还在草案中的特性，<code>bluebird.js</code>都已经实现了，如果想要使用或者学习新的<code>Promise</code>特性，不妨试试<code>bluebird.js</code>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js async/await函数</title>
      <link href="/2021/05/30/js-async-await%E5%87%BD%E6%95%B0/"/>
      <url>/2021/05/30/js-async-await%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><code>async</code>函数就是<code>generator</code>函数的语法糖，一般结合<code>Promise</code>使用</p><p>我们可以把generator函数函数改写成async&#x2F;await函数，例如</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var co = require(&#39;co&#39;);var readFile = function (fileName) &#123;    return new Promise(function (resolve, reject) &#123;        fs.readFile(fileName, function (error, data) &#123;            if (error) reject(error);            resolve(data.toString());        &#125;);    &#125;);&#125;;function* read() &#123;    // resolve multiple promises in parallel    var a = yield readFile(&#39;./data/a.text&#39;)    var b = yield readFile(&#39;./data/b.text&#39;)    console.log(a.toString());    console.log(b.toString());&#125;co(read)</code></pre><p>改写成</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var readFile = function (fileName) &#123;    return new Promise(function (resolve, reject) &#123;        fs.readFile(fileName, function (error, data) &#123;            if (error) reject(error);            resolve(data.toString());        &#125;);    &#125;);&#125;;async function read() &#123;    // resolve multiple promises in parallel    var a = await readFile(&#39;./data/a.text&#39;)    var b = await readFile(&#39;./data/b.text&#39;)    console.log(a.toString());    console.log(b.toString());&#125;read()</code></pre><p>输出和上面的<code>generator</code>函数是一样的，但是我们对比可以发现，<code>async</code>函数只是将<code>generator</code>函数的<code>*</code>去掉了，然后在前面加了一个<code>async</code>，函数内部的<code>yield</code>替换成了<code>await</code>，其他的都没有变化</p><p><code>async</code>函数的改进，体现在以下几点：</p><ul><li>内置执行器：我们发现是用<code>async</code>函数，我们不需要引入<code>co</code>模块，就能使用，因为<code>async</code>函数内置了执行器</li><li>更好的语义：<code>async/await</code>相比<code>generator</code>的<code>yield</code>有更好的语义，<code>async</code>表示函数内部有异步操作，而<code>await</code>表示紧跟在后面的表达式需要等待结果，才能继续执行下面的代码</li><li>更广的适用性：<code>co</code>模块约定，<code>yield</code>命令后面只能是<code>thunk</code>函数或 <code>Promise</code>对象，而<code>async</code>函数的<code>await</code>命令后面，可以是<code>Promise</code>对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即<code>resolved</code>的 <code>Promise</code>对象）。</li><li>返回值是<code>Promise</code>：<code>async</code>函数的返回值是<code>Promise</code>对象，这比 <code>generator</code>函数的返回值是<code>iterator</code>对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</li></ul><p><code>async</code>函数的返回值是一个<code>Promise</code>对象，函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><pre><code class="javascript">async function fn() &#123;    return 123&#125;fn().then(d =&gt; console.log(d))  // 123</code></pre><p><strong>错误处理</strong><br>async函数的错误处理方式可以放在函数内部也可以放在函数外部</p><p>放在函数内部</p><pre><code class="javascript">async function f() &#123;  try &#123;    await new Promise(function (resolve, reject) &#123;      throw new Error(&#39;出错了&#39;);    &#125;);  &#125; catch(e) &#123;  &#125;  return await(&#39;hello world&#39;);&#125;</code></pre><p>放在函数外部</p><pre><code class="javascript">async function f() &#123;  await new Promise(function (resolve, reject) &#123;    throw new Error(&#39;出错了&#39;);  &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))</code></pre><p>如果有多个await命令，可以统一放在try…catch结构中。</p><pre><code class="javascript">async function f() &#123;  try &#123;    const val1 = await firstStep();    const val2 = await secondStep(val1);    const val3 = await thirdStep(val1, val2);    console.log(&#39;Final: &#39;, val3);  &#125;  catch (err) &#123;    console.error(err);  &#125;&#125;</code></pre><p>思考一下下面的代码为什么会按照<code>1、3、2</code>的顺序输出，那是因为执行<code>fn</code>函数，执行<code>console.log(1)</code>，然后返回一个<code>Promise</code>对象，又由于<code>Promise</code>对象的<code>then</code>属于微任务，放到微任务执行队列里面，执行下面的<code>console.log(3)</code>，后面执行栈没有代码了，然后执行微任务队列里的任务，执行<code>console.log(2)</code></p><pre><code class="javascript">async function fn() &#123;    console.log(1)    return 2&#125;fn().then(d =&gt; console.log(d))console.log(3)</code></pre><p>输出结果</p><pre><code class="javascript">132</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js generator函数</title>
      <link href="/2021/05/29/js-generator%E5%87%BD%E6%95%B0/"/>
      <url>/2021/05/29/js-generator%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="generator函数特性"><a href="#generator函数特性" class="headerlink" title="generator函数特性"></a>generator函数特性</h1><ul><li>函数声明<code>function</code>和<code>函数名</code>之间加<code>*</code>号，<code>*</code>只要在中间，中间有空格也无所谓</li><li><code>yield</code> 关键字后面跟上返回值，使用<code>.next()</code>调用，输出<code>&#123;value: VALUE, done: [falise|true]&#125;</code></li><li>当<code>done</code>状态为<code>true</code>之后，<code>value</code>值就全都是<code>undefined</code>了，<code>value</code> 为 <code>undefined</code>不能被<code>for of</code>循环获取到</li><li>同一个作用域中函数不能被重复调用，执行完一遍之后 内部的<code>done</code>变为 <code>true</code>之后就不能再调用了</li><li>如果一个对象实现了<code>iterator</code>属性，且这个属性是一个<code>generator</code>函数，则<code>generator</code>函数的<code>yield</code>的值可以作为遍历的值</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><code>generator</code>函数的调用方式和普通函数不一样，<code>generator</code>函数直接调用会返回一个迭代器对象，该迭代器对象可以使用<code>for</code>进行循环，也可以使用<code>next()</code>进行调用，区别是使用<code>for</code>循环调用的输出是<code>yield</code>关键字后面的返回值，而使用<code>next()</code>的输出是<code>&#123;value: VALUE, done: [falise|true]&#125;</code>对象</p><p>注意，使用for循环调用的时候，不会遍历return后面的值；</p><pre><code class="javascript">function* generator () &#123;  yield 1  yield 2  return &#39;ending&#39;   // return 标记结束，但还可以调用，return的值不会在for of循环中被获取到&#125;let g = generator()console.log(g.next());  // &#123; value: 1, done: false &#125;console.log(g.next());  // &#123; value: 2, done: false &#125;console.log(g.next());  // &#123; value: &#39;ending&#39;, done: true &#125;let g2 =generator()for (let a of g2) &#123;  console.log(a);&#125;// 1// 2console.log(g.next());  // &#123; value: undefined, done: true &#125;// 在同一个作用域中，多次调用generator函数，一旦done的状态为true了之后，函数就不能再调用了，而使用next()强行调用，会返回`&#123; value: undefined, done: true &#125;`</code></pre><h2 id="递归输出"><a href="#递归输出" class="headerlink" title="递归输出"></a>递归输出</h2><p>我们可以写一个递归函数，自己自动调用<code>next</code>，进行输出</p><pre><code class="javascript">function* generator () &#123;  yield 1  yield 2  return &#39;ending&#39;&#125;let g = generator()// 递归执行，自己写的递归会打印ending，for of 不会function next () &#123;  let &#123; value, done &#125; = g.next();  console.log(value);  if (!done) &#123;    next()  &#125;&#125;next();</code></pre><h2 id="next传参"><a href="#next传参" class="headerlink" title="next传参"></a>next传参</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作<strong>上一个</strong><code>yield</code>表达式的返回值。</p><p>先看第一个例子，不传参的情况</p><pre><code class="javascript">function* say (num) &#123;  let x = 2 * (yield (num + 1));  console.log(x);  let y = x * (yield (num + 2));  console.log(y);  return &#39;ending&#39;&#125;const g1 = say(1);0console.log(g1.next())  // &#123; value: 2, done: false &#125;console.log(g1.next())  // NaN                        // &#123; value: 3, done: false &#125;console.log(g1.next())  // NaN                        // &#123; value: &#39;ending&#39;, done: true &#125;</code></pre><ul><li>第一个<code>next</code>，<code>num</code>是<code>1</code>，碰到<code>yield</code>就退出，输出<code>&#123; value: 2, done: false &#125;</code></li><li>第二个<code>next</code>，<code>num</code>是<code>1</code>，由于没有传入参数，则<code>yield</code>返回值是<code>undefined</code>，<code>x</code>等于 <code>2 * undefined</code>，<code>x</code>结果是<code>NaN</code>，执行<code>console.log(x)</code>,输出<code>NaN</code>，然后碰到<code>yield</code>退出，输出<code>&#123; value: 3, done: false &#125;</code></li><li>第三个<code>next</code>，<code>num</code>是<code>1</code>，由于没有传入参数，<code>y</code>等于<code> NaN * NaN</code>，<code>y</code>结果是<code>NaN</code>，然后<code>return</code>出<code>&#123; value: &#39;ending&#39;, done: true &#125;</code></li></ul><p>再来看看传参的情况</p><pre><code class="javascript">const g2 = say(1);console.log(g2.next(1))   // &#123; value: 2, done: false &#125;console.log(g2.next(5))   // 10                          // &#123; value: 3, done: false &#125;console.log(g2.next(10))   // 100                          // &#123; value: &#39;ending&#39;, done: true &#125;</code></pre><ul><li>第一个<code>next</code>，<code>num</code>是<code>1</code>，传入了参数<code>1</code>，但是没用，在此次<code>yield</code>之前没有<code>yield</code>，所以没用，然后碰到<code>yield</code>退出，输出<code>&#123; value: 2, done: false &#125;</code></li><li>第二个<code>next</code>，<code>num</code>是<code>1</code>，传入了参数<code>5</code>，，<code>x</code>结果是<code>2 * 5</code>（这里的第二个<code>5</code>是<code>next</code>传入的<code>5</code>），<code>x</code>的结果是<code>10</code>，执行<code>console.log(x)</code>,输出<code>10</code>，然后碰到<code>yield</code>退出，输出<code>&#123; value: 3, done: false &#125;</code></li><li>第三个<code>next</code>，<code>num</code>是<code>1</code>，传入了参数<code>10</code>，<code>y</code>等于<code>10 * 10</code>，<code>y</code>结果是<code>100</code>，然后<code>return</code>出<code>&#123; value: &#39;ending&#39;, done: true &#125;</code></li></ul><h1 id="和iterator接口的关系"><a href="#和iterator接口的关系" class="headerlink" title="和iterator接口的关系"></a>和iterator接口的关系</h1><p>实际上可以通过<code>for</code>循环遍历的对象都有一个<code>Symbol.iterator</code>属性，该属性就是一个<code>generator</code>函数，可以直接进行遍历，就有<code>Symbol.iterator</code><br><img src="/images/generator.png"></p><p>如果我们把数组对象的<code>Symbol.iterator</code>属性修改了，则数组就无法进行遍历了<br><img src="/images/generator1.png"></p><p>我们还可以改写<code>Symbol.iterator</code>属性，使其按照我们想要的形式输出，由于<code>Symbol.iterator</code>属性就是一个<code>generator</code>函数，我们则可以给它赋值一个自定义<code>generator</code>函数<br><img src="/images/generator2.png"></p><p>我们都知道，普通的<code>key-value</code>对象是不具备迭代能力的，因此不能直接进行<code>for</code>循环，需要使用<code>Object.keys</code>或者<code>Object.values</code>函数辅助进行遍历，我们可以把<code>generator</code>赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有<code>iterator</code>接口。</p><pre><code class="javascript">function* objectEntries() &#123;  let propKeys = Object.keys(this);  for (let propKey of propKeys) &#123;    yield [propKey, this[propKey]];  &#125;&#125;let jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123;  console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe</code></pre><h1 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h1><p>ES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><pre><code class="javascript">function* foo() &#123;  yield &#39;a&#39;;  yield &#39;b&#39;;&#125;function* bar() &#123;  yield &#39;x&#39;;  yield* foo();  yield &#39;y&#39;;&#125;// 等同于function* bar() &#123;  yield &#39;x&#39;;  yield &#39;a&#39;;  yield &#39;b&#39;;  yield &#39;y&#39;;&#125;// 等同于function* bar() &#123;  yield &#39;x&#39;;  for (let v of foo()) &#123;    yield v;  &#125;  yield &#39;y&#39;;&#125;for (let v of bar())&#123;  console.log(v);&#125;// &quot;x&quot;// &quot;a&quot;// &quot;b&quot;// &quot;y&quot;</code></pre><blockquote><p>以上示例来自<a href="https://es6.ruanyifeng.com/#docs/generator#yield--%E8%A1%A8%E8%BE%BE%E5%BC%8F">阮一峰的ES6教程</a></p></blockquote><p>使用generator实现二叉树遍历</p><pre><code class="javascript">// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123;  this.left = left;  this.label = label;  this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123;  if (t) &#123;    yield* inorder(t.left);    yield t.label;    yield* inorder(t.right);  &#125;&#125;// 下面生成二叉树function make(array) &#123;  // 判断是否为叶节点  if (array.length == 1) return new Tree(null, array[0], null);  return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123;  result.push(node);&#125;console.log(result)// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</code></pre><blockquote><p>以上示例来自<a href="https://es6.ruanyifeng.com/#docs/generator#yield--%E8%A1%A8%E8%BE%BE%E5%BC%8F">阮一峰的ES6教程</a></p></blockquote><h1 id="generator函数异步应用"><a href="#generator函数异步应用" class="headerlink" title="generator函数异步应用"></a>generator函数异步应用</h1><p><code>javascript</code>的异步操作都是使用回调函数的方式进行的，但是会造成回调地狱的问题，后来<code>generator</code>函数出现了，配合<code>thunk</code>函数和执行器可以实现同步操作，而不使用回调函数，再结合后面的<code>async/await</code>，可以使我们用同步的形式写异步代码</p><h2 id="thunkify"><a href="#thunkify" class="headerlink" title="thunkify"></a>thunkify</h2><p><code>Thunk</code> 函数是自动执行<code>Generator</code>函数的一种方法。<code>Thunk</code>函数不是函数类型，而是一种编程方式，把多个入参的函数转换为一个入参的方式</p><p>例如</p><pre><code class="javascript">// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）var Thunk = function (fileName) &#123;  return function (callback) &#123;    return fs.readFile(fileName, callback);  &#125;;&#125;;var readFileThunk = Thunk(fileName);readFileThunk(callback);</code></pre><p><code>thunk</code>函数在<code>generator</code>函数中的使用，一般使用<code>thunkify</code>模块</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var thunkify = require(&#39;thunkify&#39;);var readFileThunk = thunkify(fs.readFile);var gen = function* () &#123;    var r1 = yield readFileThunk(&#39;./data/a.text&#39;);    var r2 = yield readFileThunk(&#39;./data/b.text&#39;);    console.log(r1.toString());    console.log(r2.toString());&#125;;// 手动的执行var g = gen();var r1 = g.next();console.log(r1);        // &#123; value: [Function], done: false &#125;   vale值就是yield出来的thunk函数r1.value(function (err, data) &#123;   // 执行thunk函数的回调函数, data就是readFileThunk的结果，然后把结果传入给generator    if (err) throw err;    // console.log(data.toString()); // aaaaa, 但是一般不在执行器里面处理结果，执行器仅进行流程控制，一般是把得到的结果传给generator，在generator里面进行处理    var r2 = g.next(data); // 把结果data传入generator函数中    r2.value(function (err, data) &#123;        if (err) throw err;        g.next(data);    &#125;);&#125;);</code></pre><p><code>generator</code>自动执行器，自动管理需要自己写一个方法，递归的进行自动处理，或者使用下文介绍的<code>co</code>模块</p><pre><code class="javascript">function run(fn) &#123;    var gen = fn();    function next(err, data) &#123;        var result = gen.next(data);        if (result.done) return;        result.value(next);    &#125;    next();&#125;run(gen)</code></pre><blockquote><p>上面这种方式是同步输出的</p></blockquote><h2 id="co"><a href="#co" class="headerlink" title="co"></a>co</h2><p><code>co</code>模块是著名程序员<code>TJ Holowaychuk</code> 于 2013 年 6 月发布的一个小工具，用于<code>Generator</code> 函数的自动执行。效果和自己写的<code>run</code>方法作用一样，但是<code>co</code>内部进行了很多处理，逻辑更加严谨，在<code>co</code>的<code>4.0</code>版本中,<code>yield</code>不仅可以是一个<code>thunk</code>函数,也可以是一个<code>Promise</code>对象</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var thunkify = require(&#39;thunkify&#39;);var readFileThunk = thunkify(fs.readFile);var co = require(&#39;co&#39;)var gen = function* () &#123;    var r1 = yield readFileThunk(&#39;./data/a.text&#39;);    var r2 = yield readFileThunk(&#39;./data/b.text&#39;);    console.log(r1.toString());    console.log(r2.toString());&#125;;co(gen)</code></pre><p><code>co</code>还支持并发的异步操作，就是把各个一步操作放在一个数组里面，当所有的操作执行成功后，再进行下一步</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);var co = require(&#39;co&#39;)var readFile = function (fileName) &#123;    return new Promise(function (resolve, reject) &#123;        fs.readFile(fileName, function (error, data) &#123;            if (error) reject(error);            resolve(data.toString());        &#125;);    &#125;);&#125;;// 数组的写法co(function* () &#123;    var res = yield [        readFile(&#39;./data/a.text&#39;),        readFile(&#39;./data/b.text&#39;)    ];    console.log(&#39;res&#39;, res);&#125;).catch();// 对象的写法co(function* () &#123;    var res = yield &#123;        1: Promise.resolve(1),        2: Promise.resolve(2),    &#125;;    console.log(res);&#125;).catch();</code></pre><p>输出结果</p><pre><code class="javascript">&#123; &#39;1&#39;: 1, &#39;2&#39;: 2 &#125;res [ &#39;aaaaa&#39;, &#39;bbbbb&#39; ]</code></pre><p>由于都是异步操作，虽然读取文件是在<code>Promise.resolve</code>前面，但是读取文件是需要时间的，所以对象写法的输出会在前面</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 箭头函数</title>
      <link href="/2021/05/28/js-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2021/05/28/js-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="箭头函数特性"><a href="#箭头函数特性" class="headerlink" title="箭头函数特性"></a>箭头函数特性</h1><ul><li>不能使用<code>new</code>关键字，不能用作构造函数</li><li>箭头函数不能用作<code>generator</code>函数</li><li>箭头函数内部没有内置的<code>arguments</code>参数，通过剩余参数获取</li><li><code>this</code>指向的不是调用者，而是指向箭头函数所在作用域的环境上下文，箭头函数一旦声明，则<code>this</code>的指向就固定了，不会变</li></ul><p>我们先来看看面试中常问到的箭头函数中的<code>this</code>指向问题</p><p>下面的代码中，箭头函数<code>say</code>作为属性，放在<code>obj</code>对象中</p><pre><code class="javascript">let obj = &#123;    username: &#39;jerry&#39;,    say: () =&gt; &#123;        console.log(&#39;this指向：&#39;, this);        console.log(&#39;username&#39;, this.username);    &#125;&#125;</code></pre><p>调用<code>say</code>方法，看看函数输出，并看看<code>this</code>指向哪里</p><pre><code class="javascript">obj.say(); // this指向： window// username undefined</code></pre><p>结果<code>this</code>指向的是<code>window</code>，而不是指向<code>obj</code>，这是因为箭头函数的特殊性，箭头函数所处在的作用域是<code>obj</code>，而<code>obj</code>所存在的环境上下文是<code>window</code>，因此<code>obj</code>内部的<code>this</code>指向<code>window</code>，而此时打印<code>this.username</code>，输出的是<code>window</code>上的<code>username</code>，如果<code>window</code>上有<code>username</code>，则打印相应的值，否则打印<code>undefined</code>;</p><p>再来看另外一个例子</p><pre><code class="javascript">let obj2 = &#123;  username: &#39;tom&#39;,  say: function () &#123;      return () =&gt; &#123;        console.log(&#39;this指向：&#39;, this);        console.log(&#39;username：&#39;, this.username);      &#125;  &#125;&#125;</code></pre><p>调用结果</p><pre><code class="javascript">this指向： &#123;username: &quot;tom&quot;, say: ƒ&#125;username： tom</code></pre><p>结果<code>this</code>指向的<code>obj2</code>对象，此时箭头函数所在的作用是函数<code>say</code>的作用域，而<code>say</code>函数的上下文是在<code>obj2</code>里，因此<code>this</code>指向的是<code>obj2</code>，打印的<code>username</code>是<code>obj2</code>对象的<code>username</code>，即<code>tom</code></p><p>总结：</p><ul><li>箭头函数的<code>this</code>不是由调用者决定，而是在生成的时候就绑定了，在任何地方调用都不会改变箭头函数里的<code>this</code>指向</li><li>箭头函数的this指向的是该箭头函数创建时的作用域的父级上下文环境</li></ul><p>箭头函数其他的一些特性：</p><ul><li>箭头函数不能用作构造函数，不能使用 <code>new</code> 关键字</li><li>箭头函数不能用作<code>generator</code>函数</li><li>箭头函数中没有<code>arguments</code>对象，可以使用<code>...args</code>获取参数</li></ul><pre><code class="javascript">const fun1 = (...args) =&gt; &#123;  console.log(args);      // [1, 2, [3, 4], &#123;num: 5&#125;]  console.log(arguments); // 报错：arguments is not defined&#125;fun1(1, 2, [3, 4], &#123;num: 5&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var、let、const声明过程</title>
      <link href="/2021/05/26/var%E3%80%81let%E3%80%81const%E5%A3%B0%E6%98%8E%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/05/26/var%E3%80%81let%E3%80%81const%E5%A3%B0%E6%98%8E%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>先抛出结论：<br>js使用<code>var</code>、<code>let</code>、<code>const</code>声明变量的时候，会有两个步骤，一个是提升变量声明，一个是初始化（初始化为undefined）。</p><ul><li><code>var</code> 会提升变量的申明和初始化</li><li><code>let</code> 会提升变量申明，但不会提升初始化</li><li><code>const</code> 和 <code>let</code> 一样，但是<code>const</code>不能像<code>var</code>、<code>let</code>那样使用<code>var a</code>、<code>let b</code>这样初始化，只能<code>const c = 1</code>这种同时申明并初始化</li></ul><h1 id="var"><a href="#var" class="headerlink" title="var"></a>var</h1><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  var x = 1;  console.log(&#39;结果：&#39; + x);&#125;</code></pre><p>输出结果：</p><pre><code>结果：undefined结果：1</code></pre><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  var x;&#125;</code></pre><p>输出结果：</p><pre><code>结果：undefined</code></pre><p>从结果不难看出，<code>var</code>的声明被提升了，并初始化为了<code>undefined</code>，然后再将<code>1</code>赋值给<code>x</code></p><h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  let x = 1;  console.log(&#39;结果：&#39; + x);&#125;</code></pre><p>输出结果：</p><pre><code>Uncaught ReferenceError: Cannot access &#39;x&#39; before initialization</code></pre><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  let x;&#125;</code></pre><p>输出结果：</p><pre><code>Uncaught ReferenceError: Cannot access &#39;x&#39; before initialization</code></pre><p>从结果可以看出，<code>let</code>和<code>var</code>结果不一样，正是因为<code>let</code>仅仅提升了变量的声明，并不会提升初始化，所以这里在<code>let</code>之前访问<code>x</code>会报错，在初始化之前无法访问<code>x</code>,这里有一个官方叫法，叫暂存死区（<code>temporal dead zone</code>）</p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  const x = 1;  console.log(&#39;结果：&#39; + x);&#125;</code></pre><p>输出结果：</p><pre><code>Uncaught ReferenceError: Cannot access &#39;x&#39; before initialization</code></pre><pre><code class="javascript">&#123;  console.log(&#39;结果：&#39; + x);  const x;&#125;</code></pre><p>输出结果：</p><pre><code>Uncaught SyntaxError: Missing initializer in const declaration</code></pre><p>从结果可以看出，<code>const</code>和<code>let</code>都有暂存死区问题，但是报错信息不同，<code>const</code>在声明的同时必须赋值；</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>在浏览器环境中，<code>var</code>定义的<strong>全局变量</strong>都属于<code>window</code>对象，而let定义的<strong>全局变量</strong>，部署于<code>window</code>对象</p><pre><code class="javascript">var attr1 = &#39;tom&#39;console.log(window.attr1); // tom</code></pre><p>在浏览器环境中，let定义的全局变量，不属于window对象</p><pre><code class="javascript">var attr2 = &#39;jerry&#39;console.log(window.attr2); // undefined</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 作用域链</title>
      <link href="/2021/05/26/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2021/05/26/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>局部变量：在函数中通过var声明的变量。</p><p>全局变量：在函数外通过var声明的变量。</p><p>没有声明就使用的变量，默认为全局变量，不论这个变量在哪被使用。</p><h1 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h1><p>在函数内部定义的变量，为局部变量，局部变量只能在该局部作用域中访问</p><pre><code class="javascript">function fn1() &#123;    var username = &#39;jerry&#39;;    console.log(username);&#125;fn1()   // jerry</code></pre><p>此时在全局访问username，则会报错</p><pre><code class="javascript"> console.log(username);  // 报错，username未定义</code></pre><h1 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h1><p>函数内部和外部都可以访问该变量</p><pre><code class="javascript">var age = 12;function fn2() &#123;    console.log(age);&#125;fn2()     // 12console.log(age);  // 12</code></pre><p>如果在函数内部没有使用var定义变量，那么 gender &#x3D; ‘male’;就是个赋值语句，会找到最近的定义的变量进行赋值（注意变量提升），如果都没找到，则为全局变量</p><pre><code class="javascript">function fn3() &#123;    gender = &#39;male&#39;;    console.log(gender);&#125;fn3();</code></pre><p>如果上面的函数没有调用，那么在外面使用gender会报错，因为在 <code>fn3()</code> 被第一次调用之前， <code>gender</code>变量是不存在的。<code>fn3()</code> 被调用过之后，gender成为全局变量</p><h1 id="多层函数嵌套"><a href="#多层函数嵌套" class="headerlink" title="多层函数嵌套"></a>多层函数嵌套</h1><p>如果内层函数没有使用var定义变量，则可以看做是赋值语句，会向上层依次找到该变量的定义语句，并赋值给它,如果向上找都没有没找到，则为全局变量</p><p>这里在<code>fn5</code>函数这个作用域中没有找到<code>num</code>，则向上查找，找到<code>fn4</code>作用域中的<code>num</code>，赋值为<code>100</code>，则下面的<code>fn4里在fn5调用后的num</code>是<code>100</code></p><pre><code class="javascript">var num = 1;function fn4() &#123;    var num = 10    console.log(&#39;fn4里在fn5调用前的num &#39; + num);    function fn5() &#123;        num = 100        console.log(&#39;fn5里的num &#39; + num);    &#125;    fn5()    console.log(&#39;fn4里在fn5调用后的num &#39; + num);&#125;fn4()console.log(&#39;全局的num &#39; + num);</code></pre><p>输出结果:</p><pre><code>fn4里在fn5调用前的num 10fn5里的num 100fn4里在fn5调用后的num 100全局的num 1</code></pre><hr><p>这里在<code>fn5</code>函数内部的<code>num = 100</code>后面加了一个<code>var num = 200</code>，此时由于存在变量提升，<code>num</code>定义提升到函数顶部，并初始化为<code>undefined</code>，然后赋值<code>num = 100</code>（这里赋值的是<code>fn5</code>函数内部提升的<code>num</code>），再赋值<code>num = 200</code>，因此<code>fn5里的num</code>输出200，而<code>fn4里在fn5调用后的num</code>输出10</p><pre><code class="javascript">var num = 1;function fn4() &#123;    var num = 10    console.log(&#39;fn4里在fn5调用前的num &#39; + num);    function fn5() &#123;        num = 100        var num = 200        console.log(&#39;fn5里的num &#39; + num);    &#125;    fn5()    console.log(&#39;fn4里在fn5调用后的num &#39; + num);&#125;fn4()console.log(&#39;全局的num &#39; + num);</code></pre><p>输出结果:</p><pre><code>fn4里在fn5调用前的num 10fn5里的num 200fn4里在fn5调用后的num 10全局的num 1</code></pre><hr><p>这里在<code>fn5</code>函数内部的<code>num = 100</code>后面加了一个<code>let num = 200</code>，此时由于存在变量提升，<code>num</code>定义提升到函数顶部，但并不会初始化为<code>undefined</code><strong>（这是由于let的变量提升和var的变量提升有差异导致的）</strong>，此时<code>num</code>提升之后，执行<code>num = 100</code>，但是由于仅仅提升了变声声明，这个时候并没有初始化为<code>undefined</code>，因此会报错<code>Uncaught ReferenceError: Cannot access &#39;num&#39; before initialization</code></p><pre><code class="javascript">var num = 1;function fn4() &#123;    var num = 10    console.log(&#39;fn4里在fn5调用前的num &#39; + num);    function fn5() &#123;        num = 100        let num = 200        console.log(&#39;fn5里的num &#39; + num);    &#125;    fn5()    console.log(&#39;fn4里在fn5调用后的num &#39; + num);&#125;fn4()console.log(&#39;全局的num &#39; + num);</code></pre><p>输出结果:</p><pre><code>fn4里在fn5调用前的num 10报错: `Uncaught ReferenceError: Cannot access &#39;num&#39; before initialization`</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 引用数据类型和值数据类型</title>
      <link href="/2021/05/26/js-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/05/26/js-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>引用数据类型：对象(Object)、数组(Array)、函数(Function)、正则(RegExp)、日期(Date)等</p><p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p><p>栈内存中保存了变量标识符和指向堆内存中该对象的指针，堆内存中保存了对象的内容</p><p>值数据类型存放在栈中，而引用数据类型存放在堆中，栈中存放的是对象的引用内存地址</p><p>如果变量引用了同一块内存地址，修改其中一个变量的值，其他变量也会跟着修改</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><pre><code class="javascript">let obj1 = obj2 = &#123; name: &#39;jerry&#39;, age: 2 &#125;;obj2[&#39;age&#39;] = 10;console.log(obj1, obj2); // &#123;name: &quot;jerry&quot;, age: 10&#125; &#123;name: &quot;jerry&quot;, age: 10&#125;</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><pre><code class="javascript">let arr1 = [1, 2, 3];let arr2 = arr1;arr2[0] = 999;console.log(arr1, arr2);  // [999, 2, 3]  [999, 2, 3]</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数在js中是一个对象，函数体是保存在函数对象的属性上的，可以使用valueOf修改函数体</p><pre><code class="javascript">let f1 = function () &#123; console.log(&#39;function&#39;); &#125;let f2 = f1f2.valueOf = function () &#123; return &#39;new funciton&#39; &#125;console.log(f1.valueOf()); // new funcitonconsole.log(f2.valueOf()); // new funciton</code></pre><p>栈内存中包括了变量的标识符和变量的值。</p><p>如下所示，其实是分配了两块地址，修改其中一个变量，另一个变量不会随之修改</p><pre><code class="javascript">let str1 = str2 = &#39;hello&#39;;str2 = &#39;world&#39;;console.log(str1, str2);  // hello world</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 伪数组</title>
      <link href="/2021/05/25/js-%E4%BC%AA%E6%95%B0%E7%BB%84/"/>
      <url>/2021/05/25/js-%E4%BC%AA%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>在js中，通过document的查询元素api查出来NodeList对象或者<code>arguments</code>等都会以伪数组的方式输出，例如下面的html中，通过<code>document.getElementsByTagName(&#39;li&#39;);</code>查出来的就是伪数组，伪数组和数组都具有length属性，但是伪数组不预备数组的<code>pop</code>、<code>push</code>、<code>slice</code>等方法</p><pre><code class="html">&lt;ul&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;</code></pre><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%84.png"></p><p>我们使用查出来的结果进行数组的操作，会报错，例如：</p><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%841.png"></p><p>如果我们想要正常操作该数组，则需要将伪数组转为数组，再进行操作。</p><p>伪数组转数组的方式有很多种，下面介绍几种常用的</p><ul><li><code>Array.prototype.slice.call()</code>或者<code>[].slice.call()</code></li></ul><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%842.png"></p><blockquote><p><code>Array.prototype.slice.call()</code>和<code>[].slice.call()</code>其实是一个东西，都是调用数组原型上的slice方法</p></blockquote><ul><li><code>Array.from()</code></li></ul><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%843.png"></p><ul><li>es6 解构赋值</li></ul><p><img src="/images/%E4%BC%AA%E6%95%B0%E7%BB%844.png"></p><ul><li>其他方法<br>例如使用循环，将伪数组一个个push到一个空数组里，也可以进行转化，这种比较繁琐，一般不常用</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL通过二进制日志恢复数据</title>
      <link href="/2018/04/10/MySQL%E9%80%9A%E8%BF%87%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/04/10/MySQL%E9%80%9A%E8%BF%87%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="开启二进制日志"><a href="#开启二进制日志" class="headerlink" title="开启二进制日志"></a>开启二进制日志</h1><pre><code>[root@lyucan ~]# vim /etc/my.cnf[mysqld]server-id=1log-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=statement[root@lyucan ~]# service mysqld restartShutting down MySQL.. SUCCESS!Starting MySQL.. SUCCESS!</code></pre><blockquote><p>上面的 <code>binlog_format=statement</code> 参数默认是<code>row</code>，表示用行来记录，这里为了方便观察，直接使用<code>statement</code>模式，这个参数可以动态修改；</p></blockquote><h1 id="查看二进制日志是否开启"><a href="#查看二进制日志是否开启" class="headerlink" title="查看二进制日志是否开启"></a>查看二进制日志是否开启</h1><pre><code class="sql">mysql&gt; show variables like &#39;log_bin%&#39;;+---------------------------------+-----------------------------+| Variable_name                   | Value                       |+---------------------------------+-----------------------------+| log_bin                         | ON                          || log_bin_basename                | /data/mysql/mysql-bin       || log_bin_index                   | /data/mysql/mysql-bin.index || log_bin_trust_function_creators | OFF                         || log_bin_use_v1_row_events       | OFF                         |+---------------------------------+-----------------------------+5 rows in set (0.00 sec)</code></pre><h1 id="常用binlog操作命令"><a href="#常用binlog操作命令" class="headerlink" title="常用binlog操作命令"></a>常用binlog操作命令</h1><ol><li>查看所有<code>binlog</code>列表</li></ol><pre><code class="sql">mysql&gt; show master logs;+------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |      2052 || mysql-bin.000002 |       943 || mysql-bin.000003 |       154 |+------------------+-----------+3 rows in set (0.00 sec)</code></pre><ol start="2"><li>查看<code>master</code>状态，即最后（最新）的一个<code>binlog</code>日志的编号及最后一个<code>position</code>的值</li></ol><pre><code class="sql">mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000003 |      154 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><ol start="3"><li><code>flush logs</code>刷新日志</li></ol><pre><code class="sql">mysql&gt; flush logs;Query OK, 0 rows affected (0.01 sec)mysql&gt; show master logs;+------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |      2052 || mysql-bin.000002 |       943 || mysql-bin.000003 |       201 || mysql-bin.000004 |       154 |+------------------+-----------+4 rows in set (0.00 sec)</code></pre><blockquote><p>注意：当mysql服务器重启时，自动刷新<code>binlog</code>；</p></blockquote><ol start="4"><li>清空所有日志</li></ol><pre><code class="sql">mysql&gt; reset master;Query OK, 0 rows affected (0.01 sec)mysql&gt; show master logs;+------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |       154 |+------------------+-----------+1 row in set (0.00 sec)</code></pre><h1 id="查看二进制日志的方法"><a href="#查看二进制日志的方法" class="headerlink" title="查看二进制日志的方法"></a>查看二进制日志的方法</h1><ol><li>使用<code>mysqlbinlog</code>工具来查看二进制日志；</li></ol><pre><code>[root@lyucan ~]# mysqlbinlog /data/mysql/mysql-bin.000002......# at 484                      ##position号#180410 15:51:27 server id 1  end_log_pos 484 CRC32 0xb489f444       IntvarSET INSERT_ID=1/*!*/;#180410 15:51:27 server id 1  end_log_pos 606 CRC32 0xdbf27bfd       Query       thread_id=3   exec_time=0   error_code=0SET TIMESTAMP=1523346687/*!*/;insert into t_user (user_name) values (&#39;张三&#39;)       ##当binlog_format设置为statement时，可以看到明文的DML语句；     /*!*/;# at 606......</code></pre><pre><code>[root@lyucan ~]# mysqlbinlog -v -v /data/mysql/mysql-bin.000001......# at 343#180410 15:35:16 server id 1  end_log_pos 390 CRC32 0x554a373c       Write_rows: table id 141 flags: STMT_END_FBINLOG &#39;NGnMWhMBAAAANAAAAFcBAAAAAI0AAAAAAAEABHRlc3QABnRfdXNlcgACAw8CWgAAt/Mk7w==NGnMWh4BAAAALwAAAIYBAAAAAI0AAAAAAAEAAgAC//wEAAAABuW8oOS4iTw3SlU=&#39;/*!*/;# INSERT INTO `test`.`t_user`             ##当binlog_format设置为row时，需要加上-v -v 才能看到明文的DML语句；# SET#   @1=4 /* INT meta=0 nullable=0 is_null=0 */#   @2=&#39;张三&#39; /* VARSTRING(90) meta=90 nullable=0 is_null=0 */# at 390......</code></pre><ol start="2"><li>在数据库里查</li></ol><ul><li>语法</li></ul><pre><code class="sql">mysql&gt; show binlog events [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count];## FROM pos：起始position号，不指定就是当前文件的第一个开始；## LIMIT offset：偏移量，就是从起始position跳过几个再开始## row_count：查询多少行，不指定就查到文件尾行；</code></pre><pre><code class="sql">mysql&gt; show binlog events in &#39;mysql-bin.000002&#39;;+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                                         |+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+| mysql-bin.000002 |   4 | Format_desc    |         1 |         123 | Server ver: 5.7.21-log, Binlog ver: 4                        || mysql-bin.000002 | 123 | Previous_gtids |         1 |         154 |                                                              || mysql-bin.000002 | 154 | Anonymous_Gtid |         1 |         219 | SET @@SESSION.GTID_NEXT= &#39;ANONYMOUS&#39;                         || mysql-bin.000002 | 219 | Query          |         1 |         308 | use `test`; truncate t_user                                  || mysql-bin.000002 | 308 | Anonymous_Gtid |         1 |         373 | SET @@SESSION.GTID_NEXT= &#39;ANONYMOUS&#39;                         || mysql-bin.000002 | 373 | Query          |         1 |         452 | BEGIN                                                        || mysql-bin.000002 | 452 | Intvar         |         1 |         484 | INSERT_ID=1                                                  || mysql-bin.000002 | 484 | Query          |         1 |         606 | use `test`; insert into t_user (user_name) values (&#39;张三&#39;)   || mysql-bin.000002 | 606 | Xid            |         1 |         637 | COMMIT /* xid=18 */                                          || mysql-bin.000002 | 637 | Anonymous_Gtid |         1 |         702 | SET @@SESSION.GTID_NEXT= &#39;ANONYMOUS&#39;                         || mysql-bin.000002 | 702 | Query          |         1 |         781 | BEGIN                                                        || mysql-bin.000002 | 781 | Query          |         1 |         889 | use `test`; delete from t_user where user_id=1               || mysql-bin.000002 | 889 | Xid            |         1 |         920 | COMMIT /* xid=21 */                                          || mysql-bin.000002 | 920 | Stop           |         1 |         943 |                                                              |+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+14 rows in set (0.00 sec)mysql&gt; show binlog events in &#39;mysql-bin.000002&#39; from 154 limit 5,5;+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                                         |+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+| mysql-bin.000002 | 484 | Query          |         1 |         606 | use `test`; insert into t_user (user_name) values (&#39;张三&#39;)   || mysql-bin.000002 | 606 | Xid            |         1 |         637 | COMMIT /* xid=18 */                                          || mysql-bin.000002 | 637 | Anonymous_Gtid |         1 |         702 | SET @@SESSION.GTID_NEXT= &#39;ANONYMOUS&#39;                         || mysql-bin.000002 | 702 | Query          |         1 |         781 | BEGIN                                                        || mysql-bin.000002 | 781 | Query          |         1 |         889 | use `test`; delete from t_user where user_id=1               |+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------+5 rows in set (0.00 sec)</code></pre><p>恢复数据一定要和备份一起操作，否则即使有二进制日志，也不能完全恢复数据；</p><h1 id="恢复二进制日志的方法"><a href="#恢复二进制日志的方法" class="headerlink" title="恢复二进制日志的方法"></a>恢复二进制日志的方法</h1><pre><code class="sql">mysqlbinlog mysql-bin.0000xx | mysql -u用户名 -p密码 数据库名</code></pre><hr><h2 id="常用参数选项解释：-–start-position-123-起始pos点-–stop-position-456-结束pos点-–start-datetime-”2016-9-25-22-01-08”-起始时间点-–stop-datetime-”2019-9-25-22-09-46”-结束时间点-–database-test1-指定只恢复test1数据库-一台主机上往往有多个数据库，只限本地log日志"><a href="#常用参数选项解释：-–start-position-123-起始pos点-–stop-position-456-结束pos点-–start-datetime-”2016-9-25-22-01-08”-起始时间点-–stop-datetime-”2019-9-25-22-09-46”-结束时间点-–database-test1-指定只恢复test1数据库-一台主机上往往有多个数据库，只限本地log日志" class="headerlink" title="常用参数选项解释：- –start-position&#x3D;123: 起始pos点- –stop-position&#x3D;456: 结束pos点- –start-datetime&#x3D;”2016-9-25 22:01:08”: 起始时间点- –stop-datetime&#x3D;”2019-9-25 22:09:46”: 结束时间点- –database&#x3D;test1: 指定只恢复test1数据库(一台主机上往往有多个数据库，只限本地log日志)"></a>常用参数选项解释：<br>- –start-position&#x3D;123: 起始pos点<br>- –stop-position&#x3D;456: 结束pos点<br>- –start-datetime&#x3D;”2016-9-25 22:01:08”: 起始时间点<br>- –stop-datetime&#x3D;”2019-9-25 22:09:46”: 结束时间点<br>- –database&#x3D;test1: 指定只恢复test1数据库(一台主机上往往有多个数据库，只限本地log日志)</h2><p>不常用选项： </p><ul><li>-u –user&#x3D;name: 连接到远程主机的用户名</li><li>-p –password[&#x3D;name]: 连接到远程主机的密码</li><li>-h –host&#x3D;name: 从远程主机上获取binlog日志</li><li>–read-from-remote-server: 从某个MySQL服务器上读取binlog日志</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>假设t1表里有这几个字段，我们误将第四行记录delete掉了，再通过binlog找回；</p><ul><li>删除表里的数据</li></ul><pre><code class="sql">mysql&gt; select * from t1;+----+--------+-----+--------+| id | name   | age | addr   |+----+--------+-----+--------+|  1 | 张三   |  12 | 南京   ||  2 | 李四   |  21 | 北京   ||  3 | 王五   |  23 | 上海   ||  4 | 二蛋   |  10 | 农村   |+----+--------+-----+--------+4 rows in set (0.00 sec)mysql&gt; delete from t1  where id=4;Query OK, 1 row affected (0.00 sec)</code></pre><ul><li>找到pos点</li></ul><pre><code class="sql">mysql&gt; show binlog events in &#39;mysql-bin.000004&#39;\G;......*************************** 75. row ***************************   Log_name: mysql-bin.000004        Pos: 6566Event_type: Query  Server_id: 1End_log_pos: 6685       Info: use `test`; insert into t1 values(4,&#39;二蛋&#39;,10,&#39;农村&#39;)*************************** 76. row ***************************</code></pre><ul><li>恢复这条数据</li></ul><pre><code>[root@lyucan mysql]# mysqlbinlog --start-position=6566 --stop-position=6685 mysql-bin.000004 | mysql -uroot -p test</code></pre><p>上面的例子可能举得不是很恰当，因为我们都知道已经丢失的数据是什么了，但是在实际情况中，我们往往不知道丢失了哪些数据，万一drop掉了整个数据库，难道要一条条去恢复吗，显然不可能，这就需要我们定时做好备份工作，一个完整的备份往往是全量备份+增量备份+二进制日志备份，在进行全量备份的时候，我们需要知道当前二进制日志的<code>position</code>号，这样就可以进行完全恢复；</p><p>在进行<code>mysqldump</code>的时候，我们可以指定一个<code>-F</code>参数，在备份的时候刷新下<code>binlog</code>日志，这样新的操作都会记录到另一个新的<code>binlog</code>文件里面去，便于我们进行数据恢复，而不用费时费力去找要从哪里进行我二进制日志的恢复；</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在vue中替换使用默认的svg loader</title>
      <link href="/2017/07/13/%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E6%9B%BF%E6%8D%A2%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84svg-loader/"/>
      <url>/2017/07/13/%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E6%9B%BF%E6%8D%A2%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84svg-loader/</url>
      
        <content type="html"><![CDATA[<h1 id="1、要知道如何修改，首先要知道如何查看"><a href="#1、要知道如何修改，首先要知道如何查看" class="headerlink" title="1、要知道如何修改，首先要知道如何查看"></a>1、要知道如何修改，首先要知道如何查看</h1><p><code>vue-cli3</code> 默认是不暴露webpack的配置在项目目录中的，在项目根目录使用<code>vue inspect</code>可以查看所有的webpack配置（如果实在是想看，可以使用<code>vue eject</code> 把所以配置暴露出来，但是该操作不可逆，拿出来了就藏不回去了，慎重使用）</p><p>由于<code>vue inspect</code>命令的输出太太太长了，这里就不贴出来了，但是vue想到了这一点，我们可以指定命令选项来查看我们需要的信息</p><p><code>vue inspect --rule svg </code></p><pre><code class="js">/* config.module.rule(&#39;svg&#39;) */&#123;  test: /\.(svg)(\?.*)?$/,  use: [    /* config.module.rule(&#39;svg&#39;).use(&#39;file-loader&#39;) */    &#123;      loader: &#39;D:\\Microsoft VS Code\\Repositories\\myrepo\\z-knowledge\\Vue\\project\\study\\node_modules\\file-loader\\dist\\cjs.js&#39;,      options: &#123;        name: &#39;img/[name].[hash:8].[ext]&#39;      &#125;    &#125;  ]&#125;</code></pre><p>我们想要把默认的处理svg的file-loader修改成为<code>svg-sprite-loader</code></p><h1 id="2、安装-svg-sprite-loader"><a href="#2、安装-svg-sprite-loader" class="headerlink" title="2、安装 svg-sprite-loader"></a>2、安装 svg-sprite-loader</h1><pre><code class="js">npm i svg-sprite-loader -D </code></pre><h1 id="3、修改vue-config-js"><a href="#3、修改vue-config-js" class="headerlink" title="3、修改vue.config.js"></a>3、修改vue.config.js</h1><pre><code class="js">const path = require(&#39;path&#39;) // 下面的处理目录只能使用绝对路径，因此使用nodejs的path方法module.exports = &#123;    chainWebpack: config =&gt; &#123;        config.module.rule(&#39;svg&#39;)            .exclude.add(path.resolve(__dirname, &#39;./src/icons/svgs&#39;)); // svg规则不再处理&#39;./src/icons/svgs&#39;目录下的文件        config.module.rule(&#39;icons&#39;) // 新增一个icons规则，处理.svg后缀的文件            .test(/\.svg$/)            .include.add(path.resolve(__dirname, &#39;./src/icons/svgs&#39;))                .end()            .use(&#39;svg-sprite-loader&#39;)                .loader(&#39;svg-sprite-loader&#39;)                .options(&#123; symbolId: &#39;icon-[name]&#39; &#125;) // 定义使用svg的方式                .end()    &#125;&#125;</code></pre><p>修改后会新增一个规则<code>icons</code>,该配置如下</p><p><code>vue inspect --rule icons</code></p><pre><code class="js">/* config.module.rule(&#39;icons&#39;) */&#123;  test: /\.svg$/,  include: [    &#39;./src/icons/svgs&#39;  ],  use: [    /* config.module.rule(&#39;icons&#39;).use(&#39;svg-sprite-loader&#39;) */    &#123;      loader: &#39;svg-sprite-loader&#39;,      options: &#123;        symbolId: &#39;icon-[name]&#39;      &#125;    &#125;  ]&#125;</code></pre><h1 id="4、使用svg图标"><a href="#4、使用svg图标" class="headerlink" title="4、使用svg图标"></a>4、使用svg图标</h1><h2 id="4-1-在阿里图标库下载svg格式的图标，保存在src-icons目录下"><a href="#4-1-在阿里图标库下载svg格式的图标，保存在src-icons目录下" class="headerlink" title="4.1 在阿里图标库下载svg格式的图标，保存在src/icons目录下"></a>4.1 在阿里图标库下载svg格式的图标，保存在<code>src/icons</code>目录下</h2><pre><code>|--icons   |--svgs      wx.svg      qq.xvg</code></pre><h2 id="4-2-然后在组件-页面中进行导入"><a href="#4-2-然后在组件-页面中进行导入" class="headerlink" title="4.2 然后在组件&#x2F;页面中进行导入"></a>4.2 然后在组件&#x2F;页面中进行导入</h2><pre><code class="js">import &#39;@/icons/svgs/wx.svg&#39;import &#39;@/icons/svgs/qq.svg&#39;</code></pre><h2 id="4-3-在标签中进行使用"><a href="#4-3-在标签中进行使用" class="headerlink" title="4.3 在标签中进行使用"></a>4.3 在标签中进行使用</h2><pre><code class="html">&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-wx&quot;&gt;&lt;/use&gt;&lt;/svg&gt;&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-qq&quot;&gt;&lt;/use&gt;&lt;/svg&gt;</code></pre><h1 id="5、每次都按需导入十分麻烦，可以一次性导入所有svg图标"><a href="#5、每次都按需导入十分麻烦，可以一次性导入所有svg图标" class="headerlink" title="5、每次都按需导入十分麻烦，可以一次性导入所有svg图标"></a>5、每次都按需导入十分麻烦，可以一次性导入所有svg图标</h1><p>新建文件<code>src/icons/index.js</code>，添加以下代码</p><pre><code class="js">const requireAll = requireContext =&gt; requireContext.keys().map(requireContext);const req = require.context(&quot;./svgs&quot;, false, /.svg$/);requireAll(req);</code></pre><p>在<code>main.js</code>中引入该<code>index.js</code>文件</p><pre><code class="js">import &#39;@/icons/index&#39;</code></pre><p>此时就不用了每次使用都单独导入了，因此上面4.2步骤中的导入可以不写了</p><h1 id="6、封装svg组件"><a href="#6、封装svg组件" class="headerlink" title="6、封装svg组件"></a>6、封装svg组件</h1><blockquote><p><code>&#39;@/components/icons/SvgIcon&#39;</code></p></blockquote><pre><code class="js">&lt;template&gt;  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;    &lt;use :xlink:href=&quot;iconName&quot; /&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;svg-icon&#39;,    props: &#123;        iconClass: &#123;            type: String,            required: true        &#125;,        className: &#123;            type: String,            default: &#39;&#39;        &#125;    &#125;,    computed: &#123;        iconName() &#123;            return `#icon-$&#123;this.iconClass&#125;`        &#125;,        svgClass() &#123;            if (this.className) &#123;                return &#39;svg-icon&#39; + this.className            &#125; else &#123;                return &#39;svg-icon&#39;            &#125;        &#125;    &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123;    width: 1em;    height: 1em;    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;&#125;&lt;/style&gt;</code></pre><p>使用</p><pre><code class="html">&lt;SvgIcon icon-class=&quot;wx&quot;&gt;&lt;/SvgIcon&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端几种常见的布局方式</title>
      <link href="/2017/07/04/%E5%89%8D%E7%AB%AF%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2017/07/04/%E5%89%8D%E7%AB%AF%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h1><p>两栏布局是前端常见的几种布局方式之一，一般是左侧固定宽度，右侧自适应，或者右侧固定宽度，左侧自适应，利用定位进行布局</p><!-- tab Html --><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--自适应两栏布局        需要将上面的块设置成定位，让下面的块挤上去    --&gt;    &lt;div class=&quot;one-left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;one-right&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two-left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two-right&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><!-- endtab --><!-- tab CSS --><pre><code class="css">* &#123;    margin: 0;    padding: 0;&#125;.one-left &#123;    width: 200px;    height: 200px;    background-color: red;    position: absolute;    right: 0;    opacity: 0.1;&#125;.one-right &#123;    height: 200px;    background-color: green;    margin-right: 300px;&#125;/*---------------------------------------*/.two-left &#123;    width: 200px;    height: 200px;    background-color: palevioletred;    position: absolute;&#125;.two-right &#123;    height: 200px;    background-color: #3665ee;    margin-left: 300px;&#125;</code></pre><!-- endtab --><p>效果图：<br><img src="/images/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80.gif"></p><hr><h1 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h1><p>两侧宽度固定，中间宽度自适应的三栏布局</p><p>中间部分在DOM结构上优先，以便优先渲染，只需要使用一个额外的div标签</p><p>实现步骤：</p><ul><li>写下如下HTML代码</li><li>使三个区域都处于做悬浮状态，并使main的宽度成父容器的<code>100%</code></li><li>为两侧侧边栏添加<strong>负margin</strong>，用来调整位置，其中摆在左边的left的<code>margin-left</code>为<code>-100%</code>，</li><li>而右边<code>right</code>的<code>margin-right</code>为负的其自身宽度。（利用了浮动元素的<strong>负margin</strong>到一定值后会使其自身往上一行移动的原理）</li><li>为<code>class=&#39;container&#39;</code>的主容器设置<strong>左右padding</strong>值，使其为以后的侧边栏空出位置，padding的值为侧边栏的宽度</li><li>对left和right添加<code>position: relative</code>，然后对他们进行定位移动到两侧，圣杯布局就完成了</li></ul><!-- tab Html --><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;    &lt;meta name=&quot;description&quot; content=&quot;&quot;/&gt;    &lt;title&gt;圣杯布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;main&quot;&gt;中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中&lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><!-- endtab --><!-- tab CSS --><pre><code class="css">* &#123;    margin: 0;    padding: 0;&#125;.container &#123;    min-width: 600px;    height: 500px;    background-color: #f5f5f5;    padding: 0 200px;&#125;.left, .right &#123;    width: 200px;    height: 500px;    background-color: red;    float: left;&#125;.left &#123;    margin-left: -100%;    position: relative;    left: -200px;&#125;.right &#123;    margin-left: -200px;    position: relative;    right: -200px;&#125;.main &#123;    width: 100%;    height: 500px;    background-color: green;    float: left;&#125;</code></pre><!-- endtab --><p><img src="/images/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.gif"></p><hr><h1 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h1><p>双飞翼布局最初是淘宝试用的一种布局方式，不同于圣杯布局的是， 双飞翼布局多嵌套了一层div</p><!-- tab Html --><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;    &lt;meta name=&quot;description&quot; content=&quot;&quot;/&gt;    &lt;title&gt;双飞翼布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div class=&quot;main_content&quot;&gt;中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><!-- endtab --><!-- tab CSS --><pre><code class="css">* &#123;    margin: 0;    padding: 0;&#125;.container &#123;    min-width: 600px;    background-color: #f5f5f5;    height: 500px;&#125;.left, .right &#123;    width: 200px;    height: 500px;    background-color: red;    float: left;&#125;.main &#123;    width: 100%;    height: 500px;    background-color: blue;    float: left;&#125;.left &#123;    margin-left: -100%;&#125;.right &#123;    margin-left: -200px;&#125;.main_content &#123;    margin: 0 200px;&#125;</code></pre><!-- endtab --><p><img src="/images/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.gif"></p><hr><p>以上实现方式都是通过浮动和定位来做的，我们也可以用html5的flex布局进行布局，相比于传统方式，flex布局实现方式更加简单。</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="/2017/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
      <url>/2017/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h1><p>事务是数据库区别于文件系统的重要特性之一,事务会把数据库从一种一致状态转换为另一种一致状态.在数据库提交工作时，可以确保其要么所有修改都已经保存，要么所有修改都不保存。</p><p>Innodb存储引擎中的事务完全符合ACID的特性：</p><ol><li>原子性（atomicity）：原子性是指整个数据库事务是不可分割的工作单位.只有使事务中所有的数据库操作执行都成功，才算整个事务成功.如果事务中任何一个sql语句执行失败，那么已经执行成功的sql语句也必须撤销,数据库状态应该退回到执行事务前的状态.</li><li>一致性（consistency）：一致性是指事务将数据库从一种状态转变为下一种一致的状态，在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏.</li><li>隔离性（isolation）：一个事务的影响在该事务提交前对其他事务都不可见</li><li>持久性（durability）：事务一旦提交，其结果就是永久性.</li></ol><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>Sql标准定义的四个隔离级别：</p><ol><li>未提交读（Read uncommitted）</li><li>提交读（Read committed）</li><li>可重复读（Repeatable read）</li><li>串行化（Serializable）</li></ol><blockquote><p>mysql默认为<code>repeatable read</code><br>oracle默认为<code>read committed</code></p></blockquote><h2 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h2><pre><code class="sql">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL&#123;  READ UNCOMMITTED  | READ COMMITTED  | REPEATABLE READ  | SERIALIZABLE&#125;</code></pre><h2 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h2><p>Mysql命令行的默认设置下，事务都是自动提交的,即执行sql语句后就会马上执行<code>commit</code>操作.因此开始一个事务，必须使用<code>begin</code>,<code>start transaction</code>,或者执行<code>set autocommit=0</code>,以禁用当前会话的自动提交；</p><ul><li>Start transaction | begin：显示地开启一个事务</li><li>Commit：提交事务，并使得已对数据库做的所有修改成为永久性</li><li>Rollback：回滚事务，撤销正在进行的所有未提交的修改</li></ul><h2 id="隐式提交的sql语句"><a href="#隐式提交的sql语句" class="headerlink" title="隐式提交的sql语句"></a>隐式提交的sql语句</h2><p>某些Sql语句会产生一个隐式的提交操作,即执行完这些语句后，会有一个隐式的commit操作；<br><img src="/images/%E4%BA%8B%E5%8A%A1.png" alt="事务"></p><blockquote><p>注意：Truncate table 语句是DDL，虽然和delete整张表的结果一样，但它不能被回滚</p></blockquote><h2 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h2><p>在innodb存储引擎中，事务日志通过重做（redo）日志文件和innodb存储引擎的日志缓冲来实现，当开始一个事务时，会记录该事务的一个lSN;当事务执行时，会往innodb存储引擎的日志缓冲里插入事务日志;当事务提交时，必须将innodb存储引擎的日志缓冲写入磁盘,也就是写数据前，需要先写日志.称为预写日志方式（WAL）；</p><p>Innodb存储引擎通过预写日志的方式，来保证事务的完整性.这意味着磁盘上存储的数据页和内存缓冲池中的页是不同步的,对于内存缓冲池中页的修改，先是写入重做日志文件，然后再写入磁盘，是一种异步方式.；</p><ul><li>Log sequence number 表示当前的LSN</li><li>Log flushed up to 表示刷新到重做日志文件的LSN</li><li>Last checkpoint at表示刷新到磁盘的lSN</li><li>Pages flushed up to 刷新事务和提交后的LSN（新添加的参数）</li></ul><h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>重做日志记录了事务的行为，可以很好地通过其进行重做，但是事务有时还需要撤销，这时就需要<code>undo</code>，<code>undo</code>与<code>redo</code>正好相反，对于数据库进行修改时，数据库不但产生<code>redo</code>，而且还会产生一定量的<code>undo</code>，即使你执行的事务或语句由于某种原因失败了，或者如果你用一条<code>rollback</code>语句请求回滚,就可以利用这些<code>undo</code>信息将数据回滚到修改之前的样子。与<code>redo</code>不同的是，<code>redo</code>存放在重做日志文件中，<code>undo</code>存放在数据库内部的一个特殊段中，<code>undo segment</code>。<code>undo</code>段位于共享表空间内;</p><h1 id="innodb存储引擎中的锁"><a href="#innodb存储引擎中的锁" class="headerlink" title="innodb存储引擎中的锁"></a>innodb存储引擎中的锁</h1><p>锁的类型</p><ul><li>共享锁（S） ： 允许事务读一行数据</li><li>排他锁(X) ： 允许事务删除或更新一条数据</li><li>意向共享锁（IS）： 事务想要获取一张表中某几行的共享锁</li><li>意向排他锁（IX）： 事务想要获取一张表中某几行的排他锁</li></ul><p>兼容性（Y：兼容，N：不兼容）</p><table><thead><tr><th></th><th>S</th><th>X</th><th>IS</th><th>IX</th></tr></thead><tbody><tr><td>S</td><td>Y</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>X</td><td>N</td><td>N</td><td>N</td><td>N</td></tr><tr><td>IS</td><td>Y</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>IX</td><td>N</td><td>N</td><td>Y</td><td>Y</td></tr></tbody></table><h2 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h2><ul><li>Record Lock：单行记录上上锁</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-key Lock：Record Lock + Gap Lock，锁定一个范围，并锁定记录本身，目的是为了解决幻读现象</li></ul><h2 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h2><p>一致性非锁定读是值InnoDB存储引擎通过多版本控制（multi versioning）的方式来读取当前执行时间数据库中的数据。如果被读的数据行被加了排他锁，在读取这行数据的时候并不会等待锁释放，而是读取该行的一个快照数据。</p><p>之所以称为非锁定读，因为不需要等待被访问行的X锁的释放。快照数据是指改行之前的数据版本，该实现通过<code>undo</code>段来完成。</p><p>非锁定读的方式极大提高了数据库的并发性。在<code>InnoDB</code>存储引擎中，这是默认的读取方式。</p><p>快照数据其实就是当前行数据的一个历史版本，每行记录可能有多个版本。这种技术成为行多版本技术。由此带来的并发控制，成为多版本并发控制（Multi Version Concurrency Control,MVCC）。</p><p>在事务的隔离级别，<code>READ COMMITED</code>和<code>REPEATABLE READ</code>下，对快照数据的定义不同。在<code>READ COMMITTED</code>事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在<code>REPEATABLE READ</code>事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的数据版本。</p><p>也就是说在<code>READ COMMITTED</code>事务隔离级别下，非锁定读读取到的数据是最新的快照版本数据，也就是可以读到另一个事务已经提交了的快照数据。而在<code>REPEATABLE READ</code>下，只会读到事务开始前的数据。</p><h2 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h2><p>在默认情况下，InnoDB存储引擎对数据采用的是一致性非锁定读。但是有些情况下为了保证数据逻辑的一致性，需要对SELECT的操作加锁。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）操作：</p><ol><li>SELECT …… FOR UPDATE</li><li>SELECT …… LOCK IN SHARE MODE</li></ol><p>其中，SELECT …… FOR UPDATE对读取的记录加一个X锁，其他事务不能对已锁定的行加任何锁。而SELECT …… LOCK IN SHARE MODE是对读取的记录加一个S锁。</p><p>即使被读取的行被加了一致性锁定读，如果有另一个一致性非锁定读的操作来读取该行数据是不会阻塞的，读取的是该行的快照版本。</p><p><code>SELECT …… FOR UPDATE</code>和<code>SELECT …… LOCK IN SHARE MODE</code>必须在一个事务中，当一个事务提交了，锁就释放了。因此在使用上述两个SELECT锁定语句时，必须开启事务。</p><blockquote><p>关于一致性非锁定读和一致性锁定读自己的理解：</p><ul><li>一致性非锁定读情况下，事务A进行了select操作，此时事务B可以对事务A select的行进行update操作，此时事务A再次进行select操作，读取到的结果和事务的隔离级别有关，如果是<code>repeatable read</code>级别，不论事务B有没有进行commit操作，事务A此时查询到的结果还是第一次的结果，如果是<code>read committed</code>级别，若事务B没有提交，此时查询到的结果还是第一次的结果，若事务B提交了，此时查询到的结果就会是事务B更新之后的结果。</li><li>一致性锁定读情况下，事务B无法对事务A select的行进行update操作。</li></ul></blockquote><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="repeatable-read"><a href="#repeatable-read" class="headerlink" title="repeatable-read"></a>repeatable-read</h3><blockquote></blockquote><table><thead><tr><th>步骤</th><th>事务A<br>SET @@tx_isolation&#x3D;’repeatable-read’</th><th>事务B<br>SET @@tx_isolation&#x3D;’repeatable-read’</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td></td></tr><tr><td>2</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;李四</td><td></td></tr><tr><td>3</td><td></td><td>begin；</td></tr><tr><td>4</td><td></td><td>update users set name&#x3D;’张三’ where user_id&#x3D;1;</td></tr><tr><td>5</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;李四</td><td></td></tr><tr><td>6</td><td></td><td>commit;</td></tr><tr><td>7</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;李四</td><td></td></tr><tr><td>8</td><td>commit;</td><td></td></tr><tr><td>9</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;张三</td><td></td></tr></tbody></table><h3 id="read-committed（幻读）"><a href="#read-committed（幻读）" class="headerlink" title="read-committed（幻读）"></a>read-committed（幻读）</h3><table><thead><tr><th>步骤</th><th>事务A<br>SET @@tx_isolation&#x3D;’read-committed’</th><th>事务B<br>SET @@tx_isolation&#x3D;’read-committed’</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td></td></tr><tr><td>2</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;李四</td><td></td></tr><tr><td>3</td><td></td><td>begin；</td></tr><tr><td>4</td><td></td><td>update users set name&#x3D;’张三’ where user_id&#x3D;1;</td></tr><tr><td>5</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;李四</td><td></td></tr><tr><td>6</td><td></td><td>commit;</td></tr><tr><td>7</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;张三</td><td></td></tr><tr><td>8</td><td>commit;</td><td></td></tr><tr><td>9</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;张三</td><td></td></tr></tbody></table><blockquote><p>在事务A同一个事务中，事务B已经修改了用户名为张三并commit了，但是在事务A中仍然读出来的是李四，这种情况称之为幻读</p></blockquote><h3 id="read-uncommitted（脏读）"><a href="#read-uncommitted（脏读）" class="headerlink" title="read-uncommitted（脏读）"></a>read-uncommitted（脏读）</h3><table><thead><tr><th>步骤</th><th>事务A<br>SET @@tx_isolation&#x3D;’read-committed’</th><th>事务B<br>SET @@tx_isolation&#x3D;’read-committed’</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td></td></tr><tr><td>2</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;李四</td><td></td></tr><tr><td>3</td><td></td><td>begin；</td></tr><tr><td>4</td><td></td><td>update users set name&#x3D;’张三’ where user_id&#x3D;1;</td></tr><tr><td>5</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;张三</td><td></td></tr><tr><td>6</td><td></td><td>commit;</td></tr><tr><td>7</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;张三</td><td></td></tr><tr><td>8</td><td>commit;</td><td></td></tr><tr><td>9</td><td>select * from users where user_id&#x3D;1;<br>user_id &nbsp;&nbsp;&nbsp;&nbsp;name <br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;张三</td><td></td></tr></tbody></table><blockquote><p>在事务A同一个事务中，事务B已经修改了用户名为张三并commit了，但是在事务A中，并没有commit，在此事务中读出来的内容一定是一致的，但是此时仍然读出来的是李四，这种情况称之为脏读</p></blockquote><h1 id="外键锁"><a href="#外键锁" class="headerlink" title="外键锁"></a>外键锁</h1><p>对于外键值的插入和更新，首先需要查找父表中的记录，即SELECT父表。但是对于父表的SELECT操作，不是采用一致性非锁定读的方式，因为这样可能会发生数据不一致的问题。此时采用过的是SELECT …… LOCK IN SHARE MODE的方式，给父表的记录加一个S锁。如果此时对父表加一个X锁，则会被阻塞。</p><h1 id="事务和锁最重要的三张表"><a href="#事务和锁最重要的三张表" class="headerlink" title="事务和锁最重要的三张表"></a>事务和锁最重要的三张表</h1><p>在information_schema下，有三张表记录了事务和锁的信息：</p><ul><li>INNODB_TRX</li><li>INNODB_LOCKS</li><li>INNODB_LOCK_WAITS</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Innodb </tag>
            
            <tag> ACID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql Innodb特性</title>
      <link href="/2017/05/10/Mysql-Innodb%E7%89%B9%E6%80%A7/"/>
      <url>/2017/05/10/Mysql-Innodb%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Innodb特性"><a href="#Innodb特性" class="headerlink" title="Innodb特性"></a>Innodb特性</h1><h2 id="插入缓存（insert-buffer）"><a href="#插入缓存（insert-buffer）" class="headerlink" title="插入缓存（insert buffer）"></a>插入缓存（insert buffer）</h2><p>对非聚集索引的插入或者<code>update</code>，<code>purge</code>等操作，并非每一次直接插入索引页，而是把若干对于同一页面的更新缓存起来合并为一次操作，随机IO –&gt; 顺序IO，避免随机IO带的性能消耗，提高写性能。</p><p>原理：</p><p>先判断插入的非聚集索引页是否在缓冲池中,如果在，直接插入<br>如果不在，想放到插入缓冲区，欺骗数据库，这个非聚集的索引已经插入到叶子节点了<br>然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作</p><p>条件：</p><ul><li>索引是辅助索引</li><li>索引不是唯一的<blockquote><p>注意：在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认最大可以占用1&#x2F;2的缓冲池内存</p></blockquote></li></ul><h2 id="二次写-（double-write）"><a href="#二次写-（double-write）" class="headerlink" title="二次写 （double write）"></a>二次写 （double write）</h2><p>带给innodb存储引擎数据的可靠性</p><p>起因：</p><p>当数据库宕机时，可能发生数据库写一个页面，而这个页只写了一部分，这就是所谓的部分写失效（partial page write），它会导致数据丢失，这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。</p><p>恢复原理：</p><p>mysql在恢复的时候是通过检查page的checksum来决定这个页是否需要恢复，checksum就是当前这个页最后一个事务的事务号，如果系统找不到checksum，mysql就无法对该行数据进行写入操作</p><p><img src="/images/Innodb.png" alt="Innodb"></p><p>两次写需要额外添加两个部分：</p><ol><li>内存中的两次写缓冲（doublewrite buffer），大小为2MB</li><li>磁盘上共享表空间中连续的128页，大小也为2MB</li></ol><p>其原理是这样的：</p><ol><li>当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的两次写缓冲区。</li><li>接着从两次写缓冲区分两次写入磁盘共享表空间中，每次写入1MB</li><li>待第2步完成后，再将两次写缓冲区写入数据文件</li></ol><p>这样就可以解决上文提到的部分写失效的问题，因为在磁盘共享表空间中已有数据页副本拷贝，如果数据库在页写入数据文件的过程中宕机，在实例恢复时，可以从共享表空间中找到该页副本，将其拷贝覆盖原有的数据页，再应用重做日志即可。</p><h2 id="自适应哈希索引（adapter-hash-index）"><a href="#自适应哈希索引（adapter-hash-index）" class="headerlink" title="自适应哈希索引（adapter hash index）"></a>自适应哈希索引（adapter hash index）</h2><ul><li>innodb存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引，所以称为自适应的。</li><li>自适应哈希索引通过缓冲池的B+树构造而来，因为建立的速度很快，而且不需要将整个表都建立哈希索引，innodb会自动根据访问频率和模式来为某些页建立哈希索引。</li><li>启用自适应哈希索引后，读写速度提高两倍，辅助索引的链接操作，性能提高五倍。</li><li>数据库自动优化，不需要认为干预。</li><li>可以通过 show engine innodb status\G来查看自适应哈西索引的使用情况。可以使用innodb_adaptive_hash_index来禁用和启用hash索引，默认开启。</li></ul><h2 id="异步IO（async-IO）"><a href="#异步IO（async-IO）" class="headerlink" title="异步IO（async IO）"></a>异步IO（async IO）</h2><p>为提高性能，采用异步IO来处理磁盘操作，好处是可以进行合并IO；</p><h2 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h2><p>当刷新一个页的时候，innodb存储引擎会检测该页所在区的所有页，如果是脏页，就一起进行刷新。</p><p>如果使用的是固态硬盘，关掉它可以有效的提高性能。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Innodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL备份-LOAD DATA</title>
      <link href="/2017/04/18/MySQL%E5%A4%87%E4%BB%BD-LOAD-DATA/"/>
      <url>/2017/04/18/MySQL%E5%A4%87%E4%BB%BD-LOAD-DATA/</url>
      
        <content type="html"><![CDATA[<p>注意，使用load data备份恢复方式，表结构必须存在；</p><p>使用<code>select ...into outfile</code>备份数据</p><p>语法格式如下：</p><pre><code>select 语句 into outfile BACKFILE  [OPTIONS]</code></pre><p>[OPTIONS]</p><ul><li>fields terminated by ‘字符串’ ： 字符串分割符，默认是制表符’\t’</li><li>fileds escaped by ’字符‘ ： 转义字符，默认是’\‘</li><li>fileds [optionally] enclose by 字符’‘： 字段引用符，负责向字段值两端加上字段引用符。如果使用optionally 选项，则表示字符串类型上添加字段分隔符。</li><li>lines starting by ‘字符串’，每条记录前添加该字段。</li><li>lines terminated by ’字符串‘，每条记录后添加该字符串，默认是换行符 ‘\n’</li></ul><p>例如：</p><pre><code class="sql">mysql&gt; select * from test.t1 into outfile &#39;/data/mysql/t1_bak&#39;;Query OK, 3 rows affected (0.01 sec)</code></pre><p>结果会生成在<code>/data/mysql/</code>目录下，对应的数据库目录下面。可以直接使用cat命令查看。</p><pre><code>[root@lyucan ~]# cat /data/mysql/t1_bak1      张三   12     南京2      李四   21     北京3      王五   23     上海</code></pre><p>恢复表数据：</p><p>使用<code>load data infile...</code>快速地从一个指定格式的文本文件中读取数据到一个数据库表中。</p><p>语法：</p><pre><code>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE db2.my_table;</code></pre><p>例如：</p><pre><code class="sql">mysql&gt; delete from test.t1;Query OK, 3 rows affected (0.00 sec)mysql&gt; LOAD DATA INFILE &#39;/data/mysql/t1_bak&#39; INTO TABLE test.t1;Query OK, 3 rows affected (0.00 sec)Records: 3  Deleted: 0  Skipped: 0  Warnings: 0mysql&gt; select * from test.t1;+----+--------+-----+--------+| id | name   | age | addr   |+----+--------+-----+--------+|  1 | 张三   |  12 | 南京   ||  2 | 李四   |  21 | 北京   ||  3 | 王五   |  23 | 上海   |+----+--------+-----+--------+3 rows in set (0.00 sec)</code></pre><blockquote><p>注意：如果导出数据的时候后面使用了分隔符，导入的时候不需要加，还是按照上面的方式导；</p></blockquote><p>更复杂的配置就不写了，没什么必要，还增加大脑的负担。等用到的时候，去网上查找具体的参数即可，我们并不擅长记忆这些并不常用的选项。 一句话概括这种逻辑备份的精要：怎么吃我的，怎么给我吐出来。怎么吐出来来，怎么给我装进去。选用了什么样的分割选项，导入数据的时候就需要使用对应的分割选项去导入数据。 结合我自己平时的工作内容与实践，基本上不使用这种方式导出。反而使用mysqldump 更多一点。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql备份-mysqldump</title>
      <link href="/2017/04/18/MySQL%E5%A4%87%E4%BB%BD-mysqldump/"/>
      <url>/2017/04/18/MySQL%E5%A4%87%E4%BB%BD-mysqldump/</url>
      
        <content type="html"><![CDATA[<p>使用mysqldump对MySQL进行备份，备份少量数据可以使用这种方法，大量数据备份和恢复否会消耗大量的时间；</p><p>mysqldump可以导出存储过程，触发器，事件，数据，但是不能导出视图，如果数据库中有视图，备份完成后还需要导出视图的定义，或者备份视图定义的frm文件，并在恢复时导入；</p><h1 id="备份基本语法"><a href="#备份基本语法" class="headerlink" title="备份基本语法"></a>备份基本语法</h1><ul><li>备份单个数据或单个数据中的指定表：</li></ul><pre><code>mysqldump [OPTIONS] database [tb1] [tb2]… &gt; TB_BACKFILE</code></pre><ul><li>备份多个数据库：</li></ul><pre><code>mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...] &gt; DB_BACKFILE</code></pre><ul><li>备份所有数据库：</li></ul><pre><code>mysqldump [OPTIONS] --all-databases [OPTIONS] &gt; ALL_DB_BACKFILE</code></pre><ul><li>例如一个标准的备份语句：</li></ul><pre><code>mysqldump --single-transaction -uroot -p -B -F -R database1 t1 &gt; t1_20180407.sql</code></pre><h1 id="恢复基本语法"><a href="#恢复基本语法" class="headerlink" title="恢复基本语法"></a>恢复基本语法</h1><pre><code>mysql -uxxx -pxxx &lt; BACKFILE       ##注意是mysql 而不是mysqldump</code></pre><p>或者连到mysql数据库里面，source BACKFILE</p><p>恢复表时，需要指定表所在的数据库；</p><pre><code>mysql -uxxx -pxxx DATABASE &lt; TABLE_BACKFILE</code></pre><p><code>--single-transaction</code>（强烈建议加上）</p><p>该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于InnoDB存储引擎。本选项和<code>--lock-tables</code> 选项是互斥的，因为LOCK  TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用<code>--quick</code> 选项。</p><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --single-transaction</code></pre><h1 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h1><ul><li>--default-character-set： 设置字符集</li><li>--single-transaction：将导出设置成事务</li><li>--no-data：导出的SQL脚本中，将只包含创建表的create 语句。</li><li>--add-drop-table：导出的脚本中，包含 drop table if exists</li><li>--routines：导出存储过程及函数</li><li>--events：导出事件</li><li>--triggers：导出触发器</li></ul><h1 id="备份选项-OPTIONS-说明"><a href="#备份选项-OPTIONS-说明" class="headerlink" title="备份选项[OPTIONS]说明"></a>备份选项[OPTIONS]说明</h1><ul><li>--all-databases  , -A<br>导出全部数据库。</li></ul><pre><code>mysqldump  -uroot -p --all-databases</code></pre><ul><li>--all-tablespaces  , -Y<br>导出全部表空间。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --all-tablespaces</code></pre><ul><li>--no-tablespaces  , -y<br>不导出任何表空间信息。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --no-tablespaces</code></pre><ul><li>--add-drop-database<br>每个数据库创建之前添加drop数据库语句。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --add-drop-database</code></pre><ul><li>--add-drop-table<br>每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用<code>--skip-add-drop-table</code>取消选项)</li></ul><pre><code>mysqldump  -uroot -p --all-databases  (默认添加drop语句)mysqldump  -uroot -p --all-databases –skip-add-drop-table  (取消drop语句)</code></pre><ul><li>--add-locks<br>在每个表导出之前增加LOCK TABLES并且之后UNLOCK  TABLE。(默认为打开状态，使用–skip-add-locks取消选项)</li></ul><pre><code>mysqldump  -uroot -p --all-databases  (默认添加LOCK语句)mysqldump  -uroot -p --all-databases –skip-add-locks   (取消LOCK语句)</code></pre><ul><li>--allow-keywords<br>允许创建是关键词的列名字。这由表名前缀于每个列名做到。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --allow-keywords</code></pre><ul><li>--apply-slave-statements<br>在’CHANGE MASTER’前添加’STOP SLAVE’，并且在导出的最后添加’START SLAVE’。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --apply-slave-statements</code></pre><ul><li>--character-sets-dir<br>字符集文件的目录</li></ul><pre><code>mysqldump  -uroot -p --all-databases  --character-sets-dir=/usr/local/mysql/share/mysql/charsets</code></pre><ul><li>--comments<br>附加注释信息。默认为打开，可以用–skip-comments取消</li></ul><pre><code>mysqldump  -uroot -p --all-databases  (默认记录注释)mysqldump  -uroot -p --all-databases --skip-comments   (取消注释)</code></pre><ul><li>--compatible<br>导出的数据将和其它数据库或旧版本的MySQL 相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，<br>要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --compatible=ansi</code></pre><ul><li>--compact<br>导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：<code>--skip-add-drop-table</code>  <code>--skip-add-locks</code> <code>--skip-comments</code> <code>--skip-disable-keys</code></li></ul><pre><code>mysqldump  -uroot -p --all-databases --compact</code></pre><ul><li>--complete-insert,  -c<br>使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到<code>max_allowed_packet</code>参数的影响而导致插入失败。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --complete-insert</code></pre><ul><li>--compress, -C<br>在客户端和服务器之间启用压缩传递所有信息</li></ul><pre><code>mysqldump  -uroot -p --all-databases --compress</code></pre><ul><li>--create-options,  -a<br>在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)</li></ul><pre><code>mysqldump  -uroot -p --all-databases</code></pre><ul><li>--databases,  -B<br>导出几个数据库。参数后面所有名字参量都被看作数据库名。</li></ul><pre><code>mysqldump  -uroot -p --databases test mysql</code></pre><ul><li>--debug<br>输出debug信息，用于调试。默认值为：d:t:o,&#x2F;tmp&#x2F;mysqldump.trace</li></ul><pre><code>mysqldump  -uroot -p --all-databases --debugmysqldump  -uroot -p --all-databases --debug=” d:t:o,/tmp/debug.trace”</code></pre><ul><li>--debug-check<br>检查内存和打开文件使用说明并退出。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --debug-check</code></pre><ul><li>--debug-info<br>输出调试信息并退出</li></ul><pre><code>mysqldump  -uroot -p --all-databases --debug-info</code></pre><ul><li>--default-character-set<br>设置默认字符集，默认值为utf8</li></ul><pre><code>mysqldump  -uroot -p --all-databases --default-character-set=latin1</code></pre><ul><li>--delayed-insert<br>采用延时插入方式（INSERT DELAYED）导出数据</li></ul><pre><code>mysqldump  -uroot -p --all-databases --delayed-insert</code></pre><ul><li>--delete-master-logs<br>master备份后删除日志. 这个参数将自动激活–master-data。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --delete-master-logs</code></pre><ul><li>--disable-keys<br>对于每个表，用<code>ALTER TABLE tbl_name DISABLE KEYS;</code>和<code>ALTER TABLE tbl_name ENABLE KEYS;</code>语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。</li></ul><pre><code>mysqldump  -uroot -p --all-databases</code></pre><ul><li>--dump-slave<br>该选项将导致主的binlog位置和文件名追加到导出数据的文件中。设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，在命令前增加说明信息。该选项将会打开<code>--lock-all-tables</code>，除非<code>--single-transaction</code>被指定。该选项会自动关闭<code>--lock-tables</code>选项。默认值为0。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --dump-slave=1mysqldump  -uroot -p --all-databases --dump-slave=2</code></pre><ul><li>--events, -E<br>导出事件。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --events</code></pre><ul><li>--extended-insert,  -e<br>使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用–skip-extended-insert取消选项。</li></ul><pre><code>mysqldump  -uroot -p --all-databasesmysqldump  -uroot -p --all-databases--skip-extended-insert   (取消选项)</code></pre><ul><li>--fields-terminated-by<br>导出文件中忽略给定字段。与–tab选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项</li></ul><pre><code>mysqldump  -uroot -p test test --tab=”/home/mysql” --fields-terminated-by=”#”</code></pre><ul><li>--fields-enclosed-by<br>输出文件中的各个字段用给定字符包裹。与<code>--tab</code>选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项</li></ul><pre><code>mysqldump  -uroot -p test test --tab=”/home/mysql” --fields-enclosed-by=”#”</code></pre><ul><li>--fields-optionally-enclosed-by<br>输出文件中的各个字段用给定字符选择性包裹。与<code>--tab</code>选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项</li></ul><pre><code>mysqldump  -uroot -p test test --tab=”/home/mysql”  --fields-enclosed-by=”#” --fields-optionally-enclosed-by  =”#”</code></pre><ul><li>--fields-escaped-by<br>输出文件中的各个字段忽略给定字符。与<code>--tab</code>选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项</li></ul><pre><code>mysqldump  -uroot -p mysql user --tab=”/home/mysql” --fields-escaped-by=”#”</code></pre><ul><li>--flush-logs -F<br>开始导出之前刷新日志。<br>请注意：假如一次导出多个数据库(使用选项–databases或者–all-databases)，将会逐个数据库刷新日志。除使用–lock-all-tables或者–master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用–lock-all-tables 或者–master-data 和–flush-logs。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --flush-logs</code></pre><ul><li>--flush-privileges<br>在导出mysql数据库之后，发出一条FLUSH  PRIVILEGES 语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --flush-privileges</code></pre><ul><li>--force<br>在导出过程中忽略出现的SQL错误。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --force</code></pre><ul><li>--help<br>显示帮助信息并退出。</li></ul><pre><code>mysqldump  --help</code></pre><ul><li>--hex-blob<br>使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。</li></ul><pre><code>mysqldump  -uroot -p --all-databases --hex-blob</code></pre><ul><li>--host, -h<br>需要导出的主机信息</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre><ul><li>--ignore-table<br>不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：<code>--ignore-table=database.table1</code> <code>--ignore-table=database.table2</code> ……</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --ignore-table=mysql.user</code></pre><ul><li>--include-master-host-port<br>在<code>--dump-slave</code>产生的<code>CHANGE  MASTER TO..</code>语句中增加<code>MASTER_HOST=&lt;host&gt;，MASTER_PORT=&lt;port&gt;</code></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --include-master-host-port</code></pre><ul><li>--insert-ignore<br>在插入行时使用INSERT IGNORE语句.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --insert-ignore</code></pre><ul><li>--lines-terminated-by<br>输出文件的每行用给定字符串划分。与–tab选项一起使用，不能用于<code>--databases</code>和<code>--all-databases</code>选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost test test --tab=”/tmp/mysql”  --lines-terminated-by=”##”</code></pre><ul><li>--lock-all-tables,  -x<br>提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭<code>--single-transaction</code> 和<code>--lock-tables</code> 选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --lock-all-tables</code></pre><ul><li>--lock-tables,  -l<br>开始导出前，锁定所有表。用READ  LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，<code>--single-transaction</code>是一个更好的选择，因为它根本不需要锁定表。<br>请注意当导出多个数据库时，–lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --lock-tables</code></pre><ul><li>--log-error<br>附加警告和错误信息到给定文件</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases  --log-error=/tmp/mysqldump_error_log.err</code></pre><ul><li>--master-data<br>该选项将binlog的位置和文件名追加到输出文件中。如果为1，将会输出CHANGE MASTER 命令；如果为2，输出的CHANGE  MASTER命令前添加注释信息。该选项将打开<code>--lock-all-tables</code> 选项，除非<code>--single-transaction</code>也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的<code>--single-transaction</code>选项）。该选项自动关闭<code>--lock-tables</code>选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --master-data=1;mysqldump  -uroot -p --host=localhost --all-databases --master-data=2;</code></pre><ul><li>--max_allowed_packet<br>服务器发送和接受的最大包长度。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --max_allowed_packet=10240</code></pre><ul><li>--net_buffer_length<br>TCP&#x2F;IP和socket连接的缓存大小。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --net_buffer_length=1024</code></pre><ul><li>--no-autocommit<br>使用autocommit&#x2F;commit 语句包裹表。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-autocommit</code></pre><ul><li>--no-create-db,  -n<br>只导出数据，而不添加CREATE DATABASE 语句。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-create-db</code></pre><ul><li>--no-create-info,  -t<br>只导出数据，而不添加CREATE TABLE 语句。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-create-info</code></pre><ul><li>--no-data, -d<br>不导出任何数据，只导出数据库表结构。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-data</code></pre><ul><li>--no-set-names,  -N<br>等同于<code>--skip-set-charset</code></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-set-names</code></pre><ul><li>--opt<br>等同于<code>--add-drop-table</code>,  <code>--add-locks</code>, <code>--create-options</code>, <code>--quick</code>, <code>--extended-insert</code>, <code>--lock-tables</code>,  <code>--set-charset</code>, <code>--disable-keys</code> 该选项默认开启,  可以用<code>--skip-opt</code>禁用.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --opt</code></pre><ul><li>--order-by-primary<br>如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --order-by-primary</code></pre><ul><li>--password, -p<br>连接数据库密码，使用命名管道连接mysql</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --pipe</code></pre><ul><li><p>--port, -P<br>连接数据库端口号</p></li><li><p>--protocol<br>使用的连接协议，包括：tcp, socket, pipe, memory.</p></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --protocol=tcp</code></pre><ul><li>--quick, -q<br>不缓冲查询，直接导出到标准输出。默认为打开状态，使用<code>--skip-quick</code>取消该选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-quick</code></pre><ul><li>--quote-names,-Q<br>使用（&#96;）引起表和列名。默认为打开状态，使用–skip-quote-names取消该选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-quote-names</code></pre><ul><li>--replace<br>使用REPLACE INTO 取代INSERT INTO.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --replace</code></pre><ul><li>--result-file,  -r<br>直接输出到指定文件中。该选项应该用在使用回车换行对（\r\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --result-file=/tmp/mysqldump_result_file.txt</code></pre><ul><li>--routines, -R<br>导出存储过程以及自定义函数。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --routines</code></pre><ul><li>--set-charset<br>添加<code>SET NAMES  default_character_set</code>到输出文件。默认为打开状态，使用<code>--skip-set-charset</code>关闭选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-set-charset</code></pre><ul><li>--single-transaction（强烈建议加上）<br>该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于InnoDB存储引擎。本选项和<code>--lock-tables</code> 选项是互斥的，因为LOCK  TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用<code>--quick</code> 选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --single-transaction</code></pre><ul><li>--dump-date<br>将导出时间添加到输出文件中。默认为打开状态，使用–skip-dump-date关闭选项。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-dump-date</code></pre><ul><li>--skip-opt<br>禁用–opt选项.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --skip-opt</code></pre><ul><li>--socket,-S<br>指定连接mysql的socket文件位置，默认路径<code>/tmp/mysql.sock</code></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --socket=/tmp/mysqld.sock</code></pre><ul><li>--tab,-T<br>为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost test test --tab=&quot;/home/mysql&quot;</code></pre><ul><li>--tables<br>覆盖<code>--databases (-B)</code>参数，指定需要导出的表名。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --databases test --tables test</code></pre><ul><li>--triggers<br>导出触发器。该选项默认启用，用–skip-triggers禁用它。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --triggers</code></pre><ul><li>--tz-utc<br>在导出顶部设置时区<code>TIME_ZONE=&#39;+00:00&#39;</code> ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --tz-utc</code></pre><ul><li><p>--user, -u<br>指定连接的用户名。</p></li><li><p>--verbose, –v<br>输出多种平台信息。</p></li><li><p>--version, -V<br>输出mysqldump版本信息并退出</p></li><li><p>--where, -w<br>只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。</p></li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --where=&quot;user=&#39;root&#39;&quot;</code></pre><ul><li>--xml, -X<br>导出XML格式.</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --xml</code></pre><ul><li>--plugin_dir<br>客户端插件的目录，用于兼容不同的插件版本。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --plugin_dir=”/usr/local/lib/plugin”</code></pre><ul><li>--default_auth<br>客户端插件默认使用权限。</li></ul><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --default-auth=”/usr/local/lib/plugin/&lt;PLUGIN&gt;”</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysqldump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql MHA高可用架构原理及应用</title>
      <link href="/2017/04/18/Mysql-MHA%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2017/04/18/Mysql-MHA%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本DeNA公司youshimaton（现就职于Facebook公司）开发，是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA能在最大程度上保证数据的一致性，以达到真正意义上的高可用。</p><p>该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）。MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上。MHA Node运行在每台MySQL服务器上，MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。整个故障转移过程对应用程序完全透明。</p><p>在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失，但这并不总是可行的。例如，如果主服务器硬件故障或无法通过ssh访问，MHA没法保存二进制日志，只进行故障转移而丢失了最新的数据。使用MySQL 5.5的半同步复制，可以大大降低数据丢失的风险。MHA可以与半同步复制结合起来。如果只有一个slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性。</p><p>目前MHA主要支持一主多从的架构，要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器，一主二从，即一台充当master，一台充当备用master，另外一台充当从库，因为至少需要三台服务器，出于机器成本的考虑，淘宝也在该基础上进行了改造，目前淘宝TMHA已经支持一主一从。另外对于想快速搭建的可以参考：<a href="http://www.cnblogs.com/gomysql/p/6547797.html">MHA快速搭建</a></p><p><img src="/images/MHA.png" alt="MHA"></p><blockquote><p>我们自己使用其实也可以使用1主1从，但是master主机宕机后无法切换，以及无法补全binlog。master的mysqld进程crash后，还是可以切换成功，以及补全binlog的。</p></blockquote><h2 id="MHA工作原理总结"><a href="#MHA工作原理总结" class="headerlink" title="MHA工作原理总结"></a>MHA工作原理总结</h2><ol><li>从宕机崩溃的master保存二进制日志事件（binlog events）;</li><li>识别含有最新更新的slave；</li><li>应用差异的中继日志（relay log）到其他的slave；</li><li>应用从master保存的二进制日志事件（binlog events）；</li><li>提升一个slave为新的master；</li><li>使其他的slave连接新的master进行复制；</li></ol><h2 id="Manager工具"><a href="#Manager工具" class="headerlink" title="Manager工具"></a>Manager工具</h2><ol><li>masterha_check_ssh: 检查MHA的SSH配置；</li><li>masterha_check_repl: 检查MySQL复制；</li><li>masterha_manager: 启动MHA；</li><li>masterha_stop: 停止MHA；</li><li>masterha_check_status: 检测当前MHA运行状态；</li><li>masterha_master_monitor: 监测master是否宕机；</li><li>masterha_master_switch: 控制故障转移(自动或手动)；</li><li>masterha_conf_host: 添加或删除配置的server信息；</li><li>masterha_secondary_check：检查备节点；</li></ol><h2 id="Node工具"><a href="#Node工具" class="headerlink" title="Node工具"></a>Node工具</h2><ol><li>save_binary_logs: 保存和复制master的二进制日志。</li><li>apply_diff_relay_logs: 识别差异的中继日志事件并应用于其它slave。</li><li>filter_mysqlbinlog: 去除不必要的ROLLBACK事件(MHA已不再使用这个工具)。</li><li>purge_relay_logs: 清除中继日志(不会阻塞SQL线程)。</li></ol><h1 id="部署MHA环境介绍"><a href="#部署MHA环境介绍" class="headerlink" title="部署MHA环境介绍"></a>部署MHA环境介绍</h1><table><thead><tr><th>mysql角色</th><th>主机名</th><th>IP地址</th><th>MHA角色</th><th>说明</th></tr></thead><tbody><tr><td>master</td><td>mysql-master-1003306</td><td>10.10.10.100</td><td>node</td><td>主库</td></tr><tr><td>slave1</td><td>mysql-slave-1013306</td><td>10.10.10.101</td><td>node</td><td>从库，当主库宕机时，自动切换到这台从库</td></tr><tr><td>slave2</td><td>mysql-slave-1023306</td><td>10.10.10.102</td><td>node、manager</td><td>从库，只读，不作为master切换节点，由于资源有限，将manager同时安装在slave2上</td></tr></tbody></table><h1 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h1><h2 id="三台机器修改-etc-hosts-三台机器配置相同"><a href="#三台机器修改-etc-hosts-三台机器配置相同" class="headerlink" title="三台机器修改&#x2F;etc&#x2F;hosts(三台机器配置相同)"></a>三台机器修改&#x2F;etc&#x2F;hosts(三台机器配置相同)</h2><pre><code># master slave1 slave2[root@mysql-master-1003306 ~]# cat /etc/hosts127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain610.10.10.100 mysql-master-100330610.10.10.101 mysql-slave-101330610.10.10.102 mysql-slave-1023306</code></pre><h2 id="三台机器互相建立ssh互信，下面仅举一个例子，其他的按照下面方法逐个添加"><a href="#三台机器互相建立ssh互信，下面仅举一个例子，其他的按照下面方法逐个添加" class="headerlink" title="三台机器互相建立ssh互信，下面仅举一个例子，其他的按照下面方法逐个添加"></a>三台机器互相建立ssh互信，下面仅举一个例子，其他的按照下面方法逐个添加</h2><pre><code>[root@mysql-master-1003306 ~]# ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsaGenerating public/private rsa key pair.Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:d0:ba:b2:62:09:6e:a1:4b:8a:c9:30:2c:e8:ef:d9:78 root@mysql-master-1003306The key&#39;s randomart image is:+--[ RSA 2048]----+|                 ||       .         ||      . .        ||       o         ||      . S        ||+.     .         ||B+... .          ||X=+ +E           ||*=o*o.           |+-----------------+[root@mysql-master-1003306 ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@10.10.10.101/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@10.10.10.101&#39;s password:Number of key(s) added: 1Now try logging into the machine, with:   &quot;ssh &#39;root@10.10.10.101&#39;&quot;and check to make sure that only the key(s) you wanted were added.</code></pre><blockquote><p>注意使用ssh IP 和 ssh HOSTNAME 进行验证！</p></blockquote><blockquote><p>由于后面我们会把<code>node</code>和<code>manager</code>同时安装在<code>slave2</code>上，所以<code>slave2</code>上需要自己和自己互信，否则后面mha的ssh检测脚本会失败</p></blockquote><h1 id="搭建一主两从架构（基于GTID模式）"><a href="#搭建一主两从架构（基于GTID模式）" class="headerlink" title="搭建一主两从架构（基于GTID模式）"></a>搭建一主两从架构（基于GTID模式）</h1><ul><li>master配置文件</li></ul><pre><code># master[mysqld]server-id=1003306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1enforce_gtid_consistency=1##realylogrelay-log=mysql-relay-binrelay_log_purge=0                ## 禁止 SQL 线程在执行完一个 relay log 后自动将其删除，对于MHA场景下，对于某些滞后从库的恢复依赖于其他从库的relaylog，因此采取禁用自动删除功能</code></pre><blockquote><p>后面会介绍如何通过mha清理relay log；</p></blockquote><ul><li>slave1配置文件</li></ul><pre><code># slave1[mysqld]server-id=1013306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1enforce_gtid_consistency=1##relaylogrelay-log=mysql-relay-binrelay_log_purge=0</code></pre><ul><li>slave2配置文件</li></ul><pre><code># slave2[mysqld]server-id=1023306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1enforce_gtid_consistency=1##relaylogrelay-log=mysql-relay-binrelay_log_purge=0</code></pre><blockquote><p>从库不要在配置文件中开启read-only，因为从库随时可能切换成主库，可以使用动态设置set global read_only&#x3D;1</p></blockquote><ul><li>主库同步数据到两台从库</li></ul><pre><code># master[root@mysql-master-1003306 ~]# mysqldump -uroot -p --single-transaction -A --master-data=2 &gt; all.sqlEnter password:##这里加不加--master-data=2都行，因为复制已经不再是基于position号的形式了。[root@mysql-master-1003306 ~]# scp all.sql 10.10.10.101:/root               #将备份文件拷贝到从库[root@mysql-master-1003306 ~]# scp all.sql 10.10.10.102:/root</code></pre><ul><li>从库恢复数据</li></ul><pre><code># slave1[root@mysql-slave-1013306 ~]# mysql -uroot -p &lt; all.sqlEnter password:# slave2[root@mysql-slave-1023306 ~]# mysql -uroot -p &lt; all.sqlEnter password:</code></pre><ul><li>开启复制</li></ul><p>在<code>master</code>和<code>slave1</code>上创建复制账号，因为<code>slave1</code>随时会变成<code>master</code>，需要创建复制账号；<code>slave2</code>后面控制其不会成为<code>master</code>，所以不需要创建复制账号，当然，创建也可以；</p><pre><code class="sql"># mastermysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;mharepl&#39;@&#39;10.10.10.%&#39; IDENTIFIED BY &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)# slave1mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;mharepl&#39;@&#39;10.10.10.%&#39; IDENTIFIED BY &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)</code></pre><p>在slave上开启复制</p><pre><code class="sql"># slave1mysql&gt; CHANGE MASTER TO MASTER_HOST=&#39;10.10.10.100&#39;,MASTER_USER=&#39;mharepl&#39;,MASTER_PASSWORD=&#39;echo123.&#39;,MASTER_PORT=3306,MASTER_AUTO_POSITION=1;Query OK, 0 rows affected, 2 warnings (0.03 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.06 sec)# slave2mysql&gt; CHANGE MASTER TO MASTER_HOST=&#39;10.10.10.100&#39;,MASTER_USER=&#39;mharepl&#39;,MASTER_PASSWORD=&#39;echo123.&#39;,MASTER_PORT=3306,MASTER_AUTO_POSITION=1;Query OK, 0 rows affected, 2 warnings (0.03 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.02 sec)</code></pre><p>查看主从状态</p><pre><code class="sql"># slave1mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.100                  Master_User: mharepl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000011          Read_Master_Log_Pos: 2805               Relay_Log_File: mysql-relay-bin.000002                Relay_Log_Pos: 2978        Relay_Master_Log_File: mysql-bin.000011             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 2805              Relay_Log_Space: 3225              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1003306                  Master_UUID: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:29-36            Executed_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:1-36                Auto_Position: 1         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)# slave2mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.100                  Master_User: mharepl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000011          Read_Master_Log_Pos: 2805               Relay_Log_File: mysql-relay-bin.000002                Relay_Log_Pos: 2978        Relay_Master_Log_File: mysql-bin.000011             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 2805              Relay_Log_Space: 3185              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1003306                  Master_UUID: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:29-36            Executed_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:1-36                Auto_Position: 1         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)</code></pre><ul><li>验证<br>主库创建一张表并插入一行数据</li></ul><pre><code class="sql"># mastermysql&gt; use test;Database changedmysql&gt; create table t (id int);Query OK, 0 rows affected (0.04 sec)mysql&gt; insert into t values (1);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from t;+------+| id   |+------+|    1 |+------+1 row in set (0.01 sec)</code></pre><p>从库检查数据</p><pre><code class="sql"># slave1mysql&gt; use test;Database changedmysql&gt; select * from t;+------+| id   |+------+|    1 |+------+1 row in set (0.00 sec)# slave2mysql&gt; use test;Database changedmysql&gt; select * from t;+------+| id   |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><p>将两台从数据库设置为只读<code>set global read_only=1</code>，不要在配置文件里面开启；</p><pre><code class="sql"># slave1mysql&gt; set global read_only=1;Query OK, 0 rows affected (0.00 sec)#slave2mysql&gt; set global read_only=1;Query OK, 0 rows affected (0.00 sec)</code></pre><p>至此，基于GTID的主从搭建完毕，接下来就是搭建MHA高可用集群了；</p><h1 id="安装MHA"><a href="#安装MHA" class="headerlink" title="安装MHA"></a>安装MHA</h1><p>配置yum源</p><pre><code># 163的源[root@mysql-slave-1013306 ~]# wget http://mirrors.163.com/.help/CentOS7-Base-163.repo -O /etc/yum.repos.d/163.repo       # epel源[root@mysql-slave-1013306 ~]# wget http://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-11.noarch.rpm [root@mysql-slave-1013306 ~]# rpm -ivh epel-release-7-11.noarch.rpmwarning: epel-release-7-11.noarch.rpm: Header V3 RSA/SHA256 Signature, key ID 352c64e5: NOKEYPreparing...                          ############################### [100%]Updating / installing...   1:epel-release-7-11                ############################### [100%]</code></pre><p>在<code>master</code>、<code>slave1</code>、<code>slave2</code>三台机器上装<code>node</code>，在<code>slave2</code>上装<code>manager</code>，<code>manager</code>可以单独安装一台机器，我这里资源有限，将其放在<code>slave2</code>上；</p><p>安装node</p><pre><code># master slave1 slave2[root@mysql-slave-1013306 ~]# yum -y install perl-DBD-MySQL* perl-ExtUtils* perl-CPAN[root@mysql-slave-1013306 ~]# tar -xf mha4mysql-node-0.57.tar.gz[root@mysql-slave-1013306 ~]# cd mha4mysql-node-0.57/[root@mysql-slave-1013306 mha4mysql-node-0.57]# perl Makefile.PL*** Module::AutoInstall version 1.06*** Checking for Perl dependencies...[Core Features]- DBI        ...loaded. (1.627)- DBD::mysql ...loaded. (4.023)*** Module::AutoInstall configuration finished.Checking if your kit is complete...Looks goodWriting Makefile for mha4mysql::node[root@mysql-slave-1013306 mha4mysql-node-0.57]# make &amp;&amp; make installcp lib/MHA/BinlogManager.pm blib/lib/MHA/BinlogManager.pmcp lib/MHA/BinlogPosFindManager.pm blib/lib/MHA/BinlogPosFindManager.pmcp lib/MHA/BinlogPosFinderXid.pm blib/lib/MHA/BinlogPosFinderXid.pmcp lib/MHA/BinlogHeaderParser.pm blib/lib/MHA/BinlogHeaderParser.pmcp lib/MHA/BinlogPosFinder.pm blib/lib/MHA/BinlogPosFinder.pmcp lib/MHA/NodeUtil.pm blib/lib/MHA/NodeUtil.pm......Installing /usr/local/bin/filter_mysqlbinlogInstalling /usr/local/bin/apply_diff_relay_logsInstalling /usr/local/bin/purge_relay_logsInstalling /usr/local/bin/save_binary_logsAppending installation info to /usr/lib64/perl5/perllocal.pod</code></pre><blockquote><p>安装完成后会在&#x2F;usr&#x2F;local&#x2F;bin下安装4个可执行文件<code>filter_mysqlbinlog</code>、<code>apply_diff_relay_logs</code>、<code>purge_relay_logs</code>、<code>save_binary_logs</code>；</p></blockquote><p>在slave2上安装manager</p><pre><code># slave2[root@mysql-slave-1023306 ~]# yum -y install perl-Config-Tiny perl-Log-Dispatch perl-Parallel-ForkManager perl-Time-HiRes[root@mysql-slave-1023306 ~]# tar -xf mha4mysql-manager-0.57.tar.gz[root@mysql-slave-1023306 ~]# cd mha4mysql-manager-0.57/[root@mysql-slave-1023306 mha4mysql-manager-0.57]# perl Makefile.PL*** Module::AutoInstall version 1.06*** Checking for Perl dependencies...[Core Features]- DBI                   ...loaded. (1.627)- DBD::mysql            ...loaded. (4.023)- Time::HiRes           ...loaded. (1.9725)- Config::Tiny          ...loaded. (2.14)- Log::Dispatch         ...loaded. (2.41)- Parallel::ForkManager ...loaded. (1.18)- MHA::NodeConst        ...loaded. (0.57)*** Module::AutoInstall configuration finished.Checking if your kit is complete...Looks goodWriting Makefile for mha4mysql::manager[root@mysql-slave-1023306 mha4mysql-manager-0.57]# make &amp;&amp; make installcp lib/MHA/ManagerUtil.pm blib/lib/MHA/ManagerUtil.pmcp lib/MHA/Config.pm blib/lib/MHA/Config.pmcp lib/MHA/HealthCheck.pm blib/lib/MHA/HealthCheck.pm......Installing /usr/local/bin/masterha_stop    Installing /usr/local/bin/masterha_conf_hostInstalling /usr/local/bin/masterha_check_replInstalling /usr/local/bin/masterha_check_statusInstalling /usr/local/bin/masterha_master_monitorInstalling /usr/local/bin/masterha_check_sshInstalling /usr/local/bin/masterha_master_switchInstalling /usr/local/bin/masterha_secondary_checkInstalling /usr/local/bin/masterha_managerAppending installation info to /usr/lib64/perl5/perllocal.pod</code></pre><h1 id="配置MHA"><a href="#配置MHA" class="headerlink" title="配置MHA"></a>配置MHA</h1><p>安装完成后，在所有数据库节点中中创建用于MHA管理的超管账号；</p><pre><code># master slave1 slave2mysql&gt; grant all privileges on *.* to &#39;mhamanager&#39;@&#39;%&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.18 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.12 sec)</code></pre><p>创建MHA目录，MHA可以管理多套主从架构，因此我在这里将这套环境所有的配置存放在&#x2F;home&#x2F;mha&#x2F;app1里，如果有其他的环境，可以创建app2、app3等用于区分</p><pre><code># slave2 # 创建工作目录[root@mysql-slave-1023306 ~]# mkdir -p /home/mha/app1# 创建配置文件目录[root@mysql-slave-1023306 ~]# mkdir /home/mha/app1/conf#创建脚本存放目录[root@mysql-slave-1023306 ~]# mkdir /home/mha/app1/scripts</code></pre><p>在<code>mha4mysql-manager-0.57.tar.gz</code>解压后的目录里面，有默认的配置文件和脚本，我们将其复制到我们定义的目录中</p><pre><code>[root@mysql-slave-1023306 ~]# cp mha4mysql-manager-0.57/samples/conf/* /home/mha/app1/conf/[root@mysql-slave-1023306 ~]# cp mha4mysql-manager-0.57/samples/scripts/* /home/mha/app1/scripts/</code></pre><p>修改配置app1.conf文件</p><pre><code>[root@mysql-slave-1023306 conf]# vim app1.cnf[server default]manager_log=/home/mha/app1/manager.log              ##设置manager的日志文件manager_workdir=/home/mha/app1                      ##设置manager的工作目录master_binlog_dir=/data/mysql                       ##设置master保存binlog的目录，以便MHA找到master的日志master_ip_failover_script= /home/mha/app1/scripts/master_ip_failover   ##设置自动failover时的切换脚本master_ip_online_change_script= /home/mha/app1/scripts/master_ip_online_change  ##设置手动切换时的切换脚本user=mhamanager                                     ##设置监控用户，就是上面创建的超管用户password=echo123.                                   ##设置监控用户密码ping_interval=1                                     ##设置监控主库发送ping包的时间间隔，默认是3，这里设置成1remote_workdir=/home/mysql                          ##设置远端mysql在发生切换时binlog保存的位置repl_user=mharepl                                   ##设置复制环境中的复制用户的用户名repl_password=echo123.                              ##设置复制环境中复制用户的密码report_script=/home/mha/app1/scripts/send_report    ##设置发生切换是的告警脚本secondary_check_script= /usr/local/bin/masterha_secondary_check -s 10.10.10.101 -s 10.10.10.102  --user=root --master_host=10.10.10.100 --master_ip=10.10.10.100 --master_port=3306   ##一旦MHA到master之间监控出现问题，MHA  manager会判断其他从库是否能建立到master_ip 3306的连接shutdown_script=&quot;&quot;                                  ##设置故障发生后关闭故障主机的脚本（防止脑裂现象），我这里不指定ssh_user=root                                       ##设置ssh登录的用户名ssh_port=22                                         ##设置ssh登录的端口[server1]hostname=10.10.10.100port=3306candidate_master=1check_repl_delay=0 [server2]hostname=10.10.10.101port=3306candidate_master=1                                  ##设置为候选mastercheck_repl_delay=0                                  ##默认情况下如果一个slave落后master 100M的relay logs的话，MHA将不会选择该slave作为一个新的master，因为对于这个slave的恢复需要花费很长时间，通过设置check_repl_delay=0,MHA触发切换在选择一个新的master的时候将会忽略复制延时，这个参数对于设置了candidate_master=1的主机非常有用，因为它保证了这个候选主在切换过程中一定是最新的master[server3]hostname=10.10.10.102port=3306no_master=1                                         ##设置其不会成为候选master</code></pre><p>修改<code>master_ip_failover</code>和<code>master_ip_online_change</code>脚本</p><pre><code>[root@mysql-slave-1023306 scripts]# cd /home/mha/app1/scripts/[root@mysql-slave-1023306 scripts]# cp master_ip_failover master_ip_failover_bak[root@mysql-slave-1023306 scripts]# cp master_ip_online_change master_ip_online_change_bak[root@mysql-slave-1023306 scripts]# vim master_ip_failover</code></pre><blockquote><p><code>master_ip_failover</code></p></blockquote><pre><code class="perl">#!/usr/bin/env perl use strict;use warnings FATAL =&gt; &#39;all&#39;;use Getopt::Long;my (    $command,          $ssh_user,        $orig_master_host, $orig_master_ip,    $orig_master_port, $new_master_host, $new_master_ip,    $new_master_port);##这下面的根据实际情况修改my $vip = &#39;10.10.10.200/24&#39;;my $key = &#39;0&#39;;my $ssh_start_vip = &quot;/sbin/ifconfig eno16777736:$key $vip&quot;;          my $ssh_stop_vip = &quot;/sbin/ifconfig eno16777736:$key down&quot;;GetOptions(    &#39;command=s&#39;          =&gt; \$command,    &#39;ssh_user=s&#39;         =&gt; \$ssh_user,    &#39;orig_master_host=s&#39; =&gt; \$orig_master_host,    &#39;orig_master_ip=s&#39;   =&gt; \$orig_master_ip,    &#39;orig_master_port=i&#39; =&gt; \$orig_master_port,    &#39;new_master_host=s&#39;  =&gt; \$new_master_host,    &#39;new_master_ip=s&#39;    =&gt; \$new_master_ip,    &#39;new_master_port=i&#39;  =&gt; \$new_master_port,);exit &amp;main();sub main &#123;    print &quot;\n\nIN SCRIPT TEST====$ssh_stop_vip==$ssh_start_vip===\n\n&quot;;    if ( $command eq &quot;stop&quot; || $command eq &quot;stopssh&quot; ) &#123;        my $exit_code = 1;        eval &#123;            print &quot;Disabling the VIP on old master: $orig_master_host \n&quot;;            &amp;stop_vip();            $exit_code = 0;        &#125;;        if ($@) &#123;            warn &quot;Got Error: $@\n&quot;;            exit $exit_code;        &#125;        exit $exit_code;    &#125;    elsif ( $command eq &quot;start&quot; ) &#123;        my $exit_code = 10;        eval &#123;            print &quot;Enabling the VIP - $vip on the new master - $new_master_host \n&quot;;            &amp;start_vip();            $exit_code = 0;        &#125;;        if ($@) &#123;            warn $@;            exit $exit_code;        &#125;        exit $exit_code;    &#125;    elsif ( $command eq &quot;status&quot; ) &#123;        print &quot;Checking the Status of the script.. OK \n&quot;;        exit 0;    &#125;    else &#123;        &amp;usage();        exit 1;    &#125;&#125;sub start_vip() &#123;    `ssh $ssh_user\@$new_master_host \&quot; $ssh_start_vip \&quot;`;&#125;sub stop_vip() &#123;     return 0  unless  ($ssh_user);    `ssh $ssh_user\@$orig_master_host \&quot; $ssh_stop_vip \&quot;`;&#125;sub usage &#123;    print    &quot;Usage: master_ip_failover --command=start|stop|stopssh|status --orig_master_host=host --orig_master_ip=ip              --orig_master_port=port --new_master_host=host --new_master_ip=ip --new_master_port=port\n&quot;;&#125;</code></pre><pre><code>[root@mysql-slave-1023306 scripts]# vim master_ip_online_change</code></pre><blockquote><p><code>master_ip_online_change</code></p></blockquote><pre><code class="perl">#!/usr/bin/env perl use strict;use warnings FATAL =&gt;&#39;all&#39;;use Getopt::Long;##根据实际情况修改my $vip = &#39;10.10.10.200/24&#39;;  # Virtual IP my $key = &quot;0&quot;;my $ssh_start_vip = &quot;/sbin/ifconfig eno16777736:$key $vip&quot;;my $ssh_stop_vip = &quot;/sbin/ifconfig eno16777736:$key down&quot;;my $exit_code = 0;my (  $command,              $orig_master_is_new_slave, $orig_master_host,  $orig_master_ip,       $orig_master_port,         $orig_master_user,  $orig_master_password, $orig_master_ssh_user,     $new_master_host,  $new_master_ip,        $new_master_port,          $new_master_user,  $new_master_password,  $new_master_ssh_user,);GetOptions(  &#39;command=s&#39;                =&gt; \$command,  &#39;orig_master_is_new_slave&#39; =&gt; \$orig_master_is_new_slave,  &#39;orig_master_host=s&#39;       =&gt; \$orig_master_host,  &#39;orig_master_ip=s&#39;         =&gt; \$orig_master_ip,  &#39;orig_master_port=i&#39;       =&gt; \$orig_master_port,  &#39;orig_master_user=s&#39;       =&gt; \$orig_master_user,  &#39;orig_master_password=s&#39;   =&gt; \$orig_master_password,  &#39;orig_master_ssh_user=s&#39;   =&gt; \$orig_master_ssh_user,  &#39;new_master_host=s&#39;        =&gt; \$new_master_host,  &#39;new_master_ip=s&#39;          =&gt; \$new_master_ip,  &#39;new_master_port=i&#39;        =&gt; \$new_master_port,  &#39;new_master_user=s&#39;        =&gt; \$new_master_user,  &#39;new_master_password=s&#39;    =&gt; \$new_master_password,  &#39;new_master_ssh_user=s&#39;    =&gt; \$new_master_ssh_user,);exit &amp;main();sub main &#123;#print &quot;\n\nIN SCRIPT TEST====$ssh_stop_vip==$ssh_start_vip===\n\n&quot;; if ( $command eq &quot;stop&quot; || $command eq &quot;stopssh&quot; ) &#123;        # $orig_master_host, $orig_master_ip, $orig_master_port are passed.         # If you manage master ip address at global catalog database,         # invalidate orig_master_ip here.         my $exit_code = 1;        eval &#123;            print &quot;\n\n\n***************************************************************\n&quot;;            print &quot;Disabling the VIP - $vip on old master: $orig_master_host\n&quot;;            print &quot;***************************************************************\n\n\n\n&quot;;&amp;stop_vip();            $exit_code = 0;        &#125;;        if ($@) &#123;            warn &quot;Got Error: $@\n&quot;;            exit $exit_code;        &#125;        exit $exit_code;&#125;elsif ( $command eq &quot;start&quot; ) &#123;        # all arguments are passed.         # If you manage master ip address at global catalog database,         # activate new_master_ip here.         # You can also grant write access (create user, set read_only=0, etc) here. my $exit_code = 10;        eval &#123;            print &quot;\n\n\n***************************************************************\n&quot;;            print &quot;Enabling the VIP - $vip on new master: $new_master_host \n&quot;;            print &quot;***************************************************************\n\n\n\n&quot;;&amp;start_vip();            $exit_code = 0;        &#125;;        if ($@) &#123;            warn $@;            exit $exit_code;        &#125;        exit $exit_code;&#125;elsif ( $command eq &quot;status&quot; ) &#123;        print &quot;Checking the Status of the script.. OK \n&quot;;        `ssh $orig_master_ssh_user\@$orig_master_host \&quot; $ssh_start_vip \&quot;`;        exit 0;&#125;else &#123;&amp;usage();        exit 1;&#125;&#125;# A simple system call that enable the VIP on the new master sub start_vip() &#123;`ssh $new_master_ssh_user\@$new_master_host \&quot; $ssh_start_vip \&quot;`;&#125;# A simple system call that disable the VIP on the old_master sub stop_vip() &#123;`ssh $orig_master_ssh_user\@$orig_master_host \&quot; $ssh_stop_vip \&quot;`;&#125;sub usage &#123;print&quot;Usage: master_ip_failover –command=start|stop|stopssh|status –orig_master_host=host –orig_master_ip=ip –orig_master_port=po rt –new_master_host=host –new_master_ip=ip –new_master_port=port\n&quot;;&#125;</code></pre><p>利用mha工具检测ssh</p><pre><code>[root@mysql-slave-1023306 scripts]# /usr/local/bin/masterha_check_ssh --conf=/home/mha/app1/conf/app1.confWed Apr 18 18:48:14 2017 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Wed Apr 18 18:48:14 2017 - [info] Reading application default configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 18:48:14 2017 - [info] Reading server configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 18:48:14 2017 - [info] Starting SSH connection tests..Wed Apr 18 18:48:16 2017 - [debug]Wed Apr 18 18:48:14 2017 - [debug]  Connecting via SSH from root@10.10.10.100(10.10.10.100:22) to root@10.10.10.101(10.10.10.101:22)..Wed Apr 18 18:48:15 2017 - [debug]   ok.Wed Apr 18 18:48:15 2017 - [debug]  Connecting via SSH from root@10.10.10.100(10.10.10.100:22) to root@10.10.10.102(10.10.10.102:22)..Wed Apr 18 18:48:15 2017 - [debug]   ok.Wed Apr 18 18:48:17 2017 - [debug]Wed Apr 18 18:48:15 2017 - [debug]  Connecting via SSH from root@10.10.10.101(10.10.10.101:22) to root@10.10.10.100(10.10.10.100:22)..Wed Apr 18 18:48:15 2017 - [debug]   ok.Wed Apr 18 18:48:15 2017 - [debug]  Connecting via SSH from root@10.10.10.101(10.10.10.101:22) to root@10.10.10.102(10.10.10.102:22)..Wed Apr 18 18:48:16 2017 - [debug]   ok.Wed Apr 18 18:48:17 2017 - [debug]Wed Apr 18 18:48:15 2017 - [debug]  Connecting via SSH from root@10.10.10.102(10.10.10.102:22) to root@10.10.10.100(10.10.10.100:22)..Wed Apr 18 18:48:16 2017 - [debug]   ok.Wed Apr 18 18:48:16 2017 - [debug]  Connecting via SSH from root@10.10.10.102(10.10.10.102:22) to root@10.10.10.101(10.10.10.101:22)..Wed Apr 18 18:48:16 2017 - [debug]   ok.Wed Apr 18 18:48:17 2017 - [info] All SSH connection tests passed successfully.</code></pre><p>检测复制状态</p><pre><code>[root@mysql-slave-1023306 scripts]# /usr/local/bin/masterha_check_repl --conf=/home/mha/app1/conf/app1.confWed Apr 18 18:49:23 2017 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Wed Apr 18 18:49:23 2017 - [info] Reading application default configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 18:49:23 2017 - [info] Reading server configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 18:49:23 2017 - [info] MHA::MasterMonitor version 0.57.Wed Apr 18 18:49:24 2017 - [info] GTID failover mode = 1Wed Apr 18 18:49:24 2017 - [info] Dead Servers:Wed Apr 18 18:49:24 2017 - [info] Alive Servers:Wed Apr 18 18:49:24 2017 - [info]   10.10.10.100(10.10.10.100:3306)Wed Apr 18 18:49:24 2017 - [info]   10.10.10.101(10.10.10.101:3306)Wed Apr 18 18:49:24 2017 - [info]   10.10.10.102(10.10.10.102:3306)Wed Apr 18 18:49:24 2017 - [info] Alive Slaves:Wed Apr 18 18:49:24 2017 - [info]   10.10.10.101(10.10.10.101:3306)  Version=5.7.21-log (oldest major version between slaves) log-bin:enabledWed Apr 18 18:49:24 2017 - [info]     GTID ONWed Apr 18 18:49:24 2017 - [info]     Replicating from 10.10.10.100(10.10.10.100:3306)Wed Apr 18 18:49:24 2017 - [info]     Primary candidate for the new Master (candidate_master is set)Wed Apr 18 18:49:24 2017 - [info]   10.10.10.102(10.10.10.102:3306)  Version=5.7.21-log (oldest major version between slaves) log-bin:enabledWed Apr 18 18:49:24 2017 - [info]     GTID ONWed Apr 18 18:49:24 2017 - [info]     Replicating from 10.10.10.100(10.10.10.100:3306)Wed Apr 18 18:49:24 2017 - [info]     Not candidate for the new Master (no_master is set)Wed Apr 18 18:49:24 2017 - [info] Current Alive Master: 10.10.10.100(10.10.10.100:3306)Wed Apr 18 18:49:24 2017 - [info] Checking slave configurations..Wed Apr 18 18:49:24 2017 - [info] Checking replication filtering settings..Wed Apr 18 18:49:24 2017 - [info]  binlog_do_db= , binlog_ignore_db=Wed Apr 18 18:49:24 2017 - [info]  Replication filtering check ok.Wed Apr 18 18:49:24 2017 - [info] GTID (with auto-pos) is supported. Skipping all SSH and Node package checking.Wed Apr 18 18:49:24 2017 - [info] Checking SSH publickey authentication settings on the current master..Wed Apr 18 18:49:24 2017 - [info] HealthCheck: SSH to 10.10.10.100 is reachable.Wed Apr 18 18:49:24 2017 - [info]10.10.10.100(10.10.10.100:3306) (current master)+--10.10.10.101(10.10.10.101:3306)+--10.10.10.102(10.10.10.102:3306)Wed Apr 18 18:49:24 2017 - [info] Checking replication health on 10.10.10.101..Wed Apr 18 18:49:24 2017 - [info]  ok.Wed Apr 18 18:49:24 2017 - [info] Checking replication health on 10.10.10.102..Wed Apr 18 18:49:24 2017 - [info]  ok.Wed Apr 18 18:49:24 2017 - [info] Checking master_ip_failover_script status:Wed Apr 18 18:49:24 2017 - [info]   /home/mha/app1/scripts/master_ip_failover --command=status --ssh_user=root --orig_master_host=10.10.10.100 --orig_master_ip=10.10.10.100 --orig_master_port=3306IN SCRIPT TEST====/sbin/ifconfig eno16777736:0 down==/sbin/ifconfig eno16777736:0 10.10.10.200/24===Checking the Status of the script.. OKWed Apr 18 18:49:24 2017 - [info]  OK.Wed Apr 18 18:49:24 2017 - [warning] shutdown_script is not defined.Wed Apr 18 18:49:24 2017 - [info] Got exit code 0 (Not master dead).MySQL Replication Health is OK.</code></pre><p>在主库添加vip（第一次手动添加）</p><pre><code>[root@mysql-master-1003306 ~]# /sbin/ifconfig eno16777736:0 10.10.10.200/24[root@mysql-master-1003306 ~]# ip addr show  eno167777362: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:ff:c6:cd brd ff:ff:ff:ff:ff:ff    inet 10.10.10.100/24 brd 10.10.10.255 scope global eno16777736       valid_lft forever preferred_lft forever    inet 10.10.10.200/24 brd 10.10.10.255 scope global secondary eno16777736:0       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:feff:c6cd/64 scope link       valid_lft forever preferred_lft forever</code></pre><p>尝试使用vip连接</p><pre><code>[root@mysql-slave-1023306 ~]# mysql -uroot -p -h 10.10.10.200 -P 3306Enter password:ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;mysql-slave-1023306&#39; (using password: YES)##由于root仅允许localhost连接，我们需要创建一个账号用于远程连接</code></pre><p>在master上创建远程连接用户</p><pre><code># mastermysql&gt; grant all privileges on *.* to &#39;user&#39;@&#39;%&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.02 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)</code></pre><p>使用user重新连接</p><pre><code>[root@mysql-slave-1023306 ~]# mysql -uuser -p -h 10.10.10.200 -P 3306Enter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 40Server version: 5.7.21-log MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt;</code></pre><h1 id="验证MHA切换"><a href="#验证MHA切换" class="headerlink" title="验证MHA切换"></a>验证MHA切换</h1><p>启动MHA，使用nohup后台运行</p><pre><code>[root@mysql-slave-1023306 app1]# nohup /usr/local/bin/masterha_manager --conf=/home/mha/app1/conf/app1.conf &amp;&gt; /home/mha/app1/nohup.out &amp;[1] 23028[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_status --conf=/home/mha/app1/conf/app1.confapp1 (pid:23028) is running(0:PING_OK), master:10.10.10.100</code></pre><p>模拟主库宕机，观察会不会切换到slave1上</p><pre><code># master[root@mysql-master-1003306 ~]# service mysqld stopShutting down MySQL............ SUCCESS![root@mysql-master-1003306 ~]# ip addr show eno167777362: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:ff:c6:cd brd ff:ff:ff:ff:ff:ff    inet 10.10.10.100/24 brd 10.10.10.255 scope global eno16777736       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:feff:c6cd/64 scope link       valid_lft forever preferred_lft forever##可以看到vip已经迁移走了</code></pre><p>在slave1上查看</p><pre><code>#slave1[root@mysql-slave-1013306 ~]# ip addr show eno167777362: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:66:1d:d8 brd ff:ff:ff:ff:ff:ff    inet 10.10.10.101/24 brd 10.10.10.255 scope global eno16777736       valid_lft forever preferred_lft forever    inet 10.10.10.200/24 brd 10.10.10.255 scope global secondary eno16777736:0       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:fe66:1dd8/64 scope link       valid_lft forever preferred_lft forever##vip已经迁移到了slave1上</code></pre><p>在slave2上查看复制指向的是哪个master</p><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.101              ##可以看到已经指向到了slave1上                  Master_User: mharepl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000004          Read_Master_Log_Pos: 234               Relay_Log_File: mysql-relay-bin.000002                Relay_Log_Pos: 367        Relay_Master_Log_File: mysql-bin.000004             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 234              Relay_Log_Space: 574              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1013306                  Master_UUID: 8d3e071d-41b8-11e8-aaef-000c29661dd8             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set: 8d3e071d-41b8-11e8-aaef-000c29661dd8:1-4,91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:1-42,94a6d6b6-4280-11e8-a2f7-000c295bc4c5:1-2                Auto_Position: 1         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)</code></pre><p>在切换完成后<code>manager</code>上的MHA进程会停掉，并在工作目录下创建一个<code>*.complete</code>的空文件,再次启动的时候，最好把这个文件删掉；</p><pre><code>[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_status --conf=/home/mha/app1/conf/app1.confapp1 is stopped(2:NOT_RUNNING).[root@mysql-slave-1023306 app1]# lsapp1.failover.compelte conf  manager.log  nohup.out  scripts</code></pre><p>检查复制状态</p><pre><code>[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_repl --conf=/home/mha/app1/conf/app1.confWed Apr 18 20:19:50 2017 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Wed Apr 18 20:19:50 2017 - [info] Reading application default configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 20:19:50 2017 - [info] Reading server configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 20:19:50 2017 - [info] MHA::MasterMonitor version 0.57.Wed Apr 18 20:19:51 2017 - [error][/usr/local/share/perl5/MHA/ServerManager.pm, ln653] There are 2 non-slave servers! MHA manages at most one non-slave server. Check configurations.Wed Apr 18 20:19:51 2017 - [error][/usr/local/share/perl5/MHA/MasterMonitor.pm, ln427] Error happened on checking configurations.  at /usr/local/share/perl5/MHA/MasterMonitor.pm line 329.Wed Apr 18 20:19:51 2017 - [error][/usr/local/share/perl5/MHA/MasterMonitor.pm, ln525] Error happened on monitoring servers.Wed Apr 18 20:19:51 2017 - [info] Got exit code 1 (Not master dead).MySQL Replication Health is NOT OK!</code></pre><p>出现这个的原因是主库宕机，没有指向新的主库，需要手动指向新的主库，也就是slave2；</p><pre><code>[root@mysql-master-1003306 ~]# service mysqld startStarting MySQL. SUCCESS!mysql&gt; CHANGE MASTER TO MASTER_HOST=&#39;10.10.10.101&#39;,MASTER_USER=&#39;mharepl&#39;,MASTER_PASSWORD=&#39;echo123.&#39;,MASTER_PORT=3306,MASTER_AUTO_POSITION=1;Query OK, 0 rows affected, 2 warnings (0.02 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.01 sec)</code></pre><p>再次检查复制状态，显示成功；</p><pre><code>[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_repl --conf=/home/mha/app1/conf/app1.confWed Apr 18 20:23:07 2017 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Wed Apr 18 20:23:07 2017 - [info] Reading application default configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 20:23:07 2017 - [info] Reading server configuration from /home/mha/app1/conf/app1.conf..Wed Apr 18 20:23:07 2017 - [info] MHA::MasterMonitor version 0.57.Wed Apr 18 20:23:08 2017 - [info] GTID failover mode = 1Wed Apr 18 20:23:08 2017 - [info] Dead Servers:Wed Apr 18 20:23:08 2017 - [info] Alive Servers:Wed Apr 18 20:23:08 2017 - [info]   10.10.10.100(10.10.10.100:3306)Wed Apr 18 20:23:08 2017 - [info]   10.10.10.101(10.10.10.101:3306)Wed Apr 18 20:23:08 2017 - [info]   10.10.10.102(10.10.10.102:3306)Wed Apr 18 20:23:08 2017 - [info] Alive Slaves:Wed Apr 18 20:23:08 2017 - [info]   10.10.10.100(10.10.10.100:3306)  Version=5.7.21-log (oldest major version between slaves) log-bin:enabledWed Apr 18 20:23:08 2017 - [info]     GTID ONWed Apr 18 20:23:08 2017 - [info]     Replicating from 10.10.10.101(10.10.10.101:3306)Wed Apr 18 20:23:08 2017 - [info]     Primary candidate for the new Master (candidate_master is set)Wed Apr 18 20:23:08 2017 - [info]   10.10.10.102(10.10.10.102:3306)  Version=5.7.21-log (oldest major version between slaves) log-bin:enabledWed Apr 18 20:23:08 2017 - [info]     GTID ONWed Apr 18 20:23:08 2017 - [info]     Replicating from 10.10.10.101(10.10.10.101:3306)Wed Apr 18 20:23:08 2017 - [info]     Not candidate for the new Master (no_master is set)Wed Apr 18 20:23:08 2017 - [info] Current Alive Master: 10.10.10.101(10.10.10.101:3306)Wed Apr 18 20:23:08 2017 - [info] Checking slave configurations..Wed Apr 18 20:23:08 2017 - [info]  read_only=1 is not set on slave 10.10.10.100(10.10.10.100:3306).Wed Apr 18 20:23:08 2017 - [info] Checking replication filtering settings..Wed Apr 18 20:23:08 2017 - [info]  binlog_do_db= , binlog_ignore_db=Wed Apr 18 20:23:08 2017 - [info]  Replication filtering check ok.Wed Apr 18 20:23:08 2017 - [info] GTID (with auto-pos) is supported. Skipping all SSH and Node package checking.Wed Apr 18 20:23:08 2017 - [info] Checking SSH publickey authentication settings on the current master..Wed Apr 18 20:23:08 2017 - [info] HealthCheck: SSH to 10.10.10.101 is reachable.Wed Apr 18 20:23:08 2017 - [info]10.10.10.101(10.10.10.101:3306) (current master)+--10.10.10.100(10.10.10.100:3306)+--10.10.10.102(10.10.10.102:3306)Wed Apr 18 20:23:08 2017 - [info] Checking replication health on 10.10.10.100..Wed Apr 18 20:23:08 2017 - [info]  ok.Wed Apr 18 20:23:08 2017 - [info] Checking replication health on 10.10.10.102..Wed Apr 18 20:23:08 2017 - [info]  ok.Wed Apr 18 20:23:08 2017 - [info] Checking master_ip_failover_script status:Wed Apr 18 20:23:08 2017 - [info]   /home/mha/app1/scripts/master_ip_failover --command=status --ssh_user=root --orig_master_host=10.10.10.101 --orig_master_ip=10.10.10.101 --orig_master_port=3306IN SCRIPT TEST====/sbin/ifconfig eno16777736:0 down==/sbin/ifconfig eno16777736:0 10.10.10.200/24===Checking the Status of the script.. OKWed Apr 18 20:23:08 2017 - [info]  OK.Wed Apr 18 20:23:08 2017 - [warning] shutdown_script is not defined.Wed Apr 18 20:23:08 2017 - [info] Got exit code 0 (Not master dead).MySQL Replication Health is OK.</code></pre><p>删除complete文件，再起启动MHA</p><pre><code>[root@mysql-slave-1023306 app1]# rm -rf app1.failover.complete[root@mysql-slave-1023306 app1]# nohup /usr/local/bin/masterha_manager --conf=/home/mha/app1/conf/app1.conf &amp;&gt; /home/mha/app1/nohup.out &amp;[1] 23424[root@mysql-slave-1023306 app1]# /usr/local/bin/masterha_check_status --conf=/home/mha/app1/conf/app1.confapp1 (pid:23424) is running(0:PING_OK), master:10.10.10.101</code></pre><p>至此，搭建MHA的过程就结束了；</p><p>还有点内容需要补充，就是之前提到了清理<code>relay log</code>的方法；</p><p>MHA在发生切换过程中，从库在恢复的过程中，依赖于<code>relay log</code>的相关信息，所以我们这里要将<code>relay log</code>的自动清楚设置为OFF，采用手动清楚<code>relay log</code>的方式。</p><p>在默认情况下，从服务器上的中继日志会在SQL线程执行完后被自动删除。但是在MHA环境中，这些中继日志在恢复其它从服务器时可能会被用到，因此需要禁用中继日志的自动清除。改为定期手动清除SQL线程应用完的中继日志。</p><p>在<code>ext3</code>文件系统下，删除大的文件需要一定的时间，这样会导致严重的复制延迟，所以在Linux中，一般都是通过硬链接的方式来删除大文件。</p><p>设置定期清理relay脚本<br><code> MHA节点中包含了</code>purge_relay_logs<code>脚本，它可以为</code>relay log<code>创建硬链接，执行</code>set global relay_log_purge&#x3D;1<code>，等待几秒钟以便SQL线程切换到新的中继日志，再执行</code>set global relay_log_purge&#x3D;0&#96;。</p><p>使用方法：</p><pre><code>[root@mysql-slave-1023306 mysql]# /usr/local/bin/purge_relay_logs --user=mhamanager --password=echo123. --disable_relay_log_purge  --workdir=/home/mysql2017-04-18 20:43:02: purge_relay_logs script started.Found relay_log.info: /data/mysql/relay-log.infoOpening /data/mysql/mysql-relay-bin.000002 ..Opening /data/mysql/mysql-relay-bin.000003 ..Executing SET GLOBAL relay_log_purge=1; FLUSH LOGS; sleeping a few seconds so that SQL thread can delete older relay log files (if it keeps up); SET GLOBAL relay_log_purge=0; .. ok.2017-04-18 20:43:05: All relay log purging operations succeeded.</code></pre><blockquote><p>可以将该命令写到计划任务里面去，不同的slave进行relay log清理的时间最好错开；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> MHA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql备份</title>
      <link href="/2017/04/18/Mysql%E5%A4%87%E4%BB%BD/"/>
      <url>/2017/04/18/Mysql%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>备份的方法可以分为：</p><h1 id="Hot-backup-热备"><a href="#Hot-backup-热备" class="headerlink" title="Hot backup(热备)"></a>Hot backup(热备)</h1><p>Hot backup是指在数据库运行中直接备份，对正在运行的数据库没有任何影响</p><h1 id="Cold-backup（冷备）"><a href="#Cold-backup（冷备）" class="headerlink" title="Cold backup（冷备）"></a>Cold backup（冷备）</h1><p>Cold backup是指在数据库停止的情况下进行备份，只需要拷贝相关的数据库物理文件</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul><li>备份简单，只要拷贝相关文件即可</li><li>备份文件易于在不用操作系统，不同mysql版本上进行恢复</li><li>恢复简单，速度快，不需要执行sql语句和重建索引</li></ul><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul><li>冷备的文件通常比逻辑文件大很</li></ul><h1 id="Warm-backup（温备）"><a href="#Warm-backup（温备）" class="headerlink" title="Warm backup（温备）"></a>Warm backup（温备）</h1><p>Warm backup备份同样是在数据库运行时进行，但是会对当前数据库操作有所影响</p><h1 id="按照备份后文件的内容来分："><a href="#按照备份后文件的内容来分：" class="headerlink" title="按照备份后文件的内容来分："></a>按照备份后文件的内容来分：</h1><ol><li><p>逻辑备份<br>在mysql数据库中，逻辑备份是指备份后的文件内容是可读的，通常是文本文件，内容一般是sql语句，或者是表内的实际数据，如mysqldump和select * into outfile的方法，这类方法的好处是可以看到导出文件的内容，一般适用于数据库的升级，迁移等工作，但是恢复所需要的时间往往较长。</p></li><li><p>裸文件备份<br>裸文件备份是指拷贝数据库的物理文件（xtrabackup），数据库既可以处于运行状态，也可以处于停止状态，这类备份的恢复时间往往比逻辑备份短很多。</p></li></ol><h1 id="按照备份数据库的内容来分："><a href="#按照备份数据库的内容来分：" class="headerlink" title="按照备份数据库的内容来分："></a>按照备份数据库的内容来分：</h1><ol><li><p>完全备份<br>完全备份是指对数据库进行一个完整的备份；</p></li><li><p>增量备份<br>增量备份是指在上次的完全备份基础上，对更新的数据进行备份；</p></li><li><p>日志备份<br>日志备份主要是指对mysql数据库二进制日志的备份，通过对一个完全备份进行二进制日志的重做来完成数据库的point-in-time恢复工作，Mysql数据库复制的原理就是异步实时进行二进制日志重做；</p></li></ol><blockquote><p>mysqldump和load data的备份方式都是逻辑备份<br>xtrabackup是物理备份</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysqldump </tag>
            
            <tag> xtrabackup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制-基于GTID的主从复制</title>
      <link href="/2017/04/17/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%9F%BA%E4%BA%8EGTID%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/04/17/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%9F%BA%E4%BA%8EGTID%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><table><thead><tr><th>host</th><th>ip</th></tr></thead><tbody><tr><td>master</td><td>10.10.10.100</td></tr><tr><td>slave</td><td>10.10.10.101</td></tr></tbody></table><blockquote><p>master配置文件</p></blockquote><pre><code># master[mysqld]server-id=1003306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1    enforce_gtid_consistency=1</code></pre><blockquote><p>slave配置文件</p></blockquote><pre><code># slave[mysqld]server-id=1013306##binloglog-bin=mysql-binsync-binlog=1innodb_support_xa=1binlog_format=row##GTIDgtid_mode=onlog_slave_updates=1enforce_gtid_consistency=1read-only=1    ##保证数据一致性</code></pre><h1 id="导出master上的数据，导入到slave中"><a href="#导出master上的数据，导入到slave中" class="headerlink" title="导出master上的数据，导入到slave中;"></a>导出master上的数据，导入到slave中;</h1><pre><code># master[root@mysql-master-1003306 ~]# mysqldump -uroot -p --single-transaction -A --master-data=2 &gt; all.sqlEnter password:##这里加不加--master-data=2都行，因为复制已经不再是基于position号的形式了。[root@mysql-master-1003306 ~]# scp all.sql 10.10.10.101:/root               #将备份文件拷贝到从库</code></pre><h1 id="从库导入数据"><a href="#从库导入数据" class="headerlink" title="从库导入数据"></a>从库导入数据</h1><pre><code># slave[root@mysql-slave-1013306 ~]# mysql -uroot -p &lt; all.sqlEnter password:ERROR 1840 (HY000) at line 24: @@GLOBAL.GTID_PURGED can only be set when @@GLOBAL.GTID_EXECUTED is empty.##从库导入时报这个错误，是因为从库当前的GLOBAL.GTID_EXECUTED不为空，使用reset master可以重置；mysql&gt; show master status;+------------------+----------+--------------+------------------+----------------------------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                      |+------------------+----------+--------------+------------------+----------------------------------------+| mysql-bin.000002 |      398 |              |                  | 8d3e071d-41b8-11e8-aaef-000c29661dd8:1 |+------------------+----------+--------------+------------------+----------------------------------------+1 row in set (0.00 sec)mysql&gt; reset master;Query OK, 0 rows affected (0.01 sec)mysql&gt;mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      154 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)##再次导入[root@mysql-slave-1013306 ~]# mysql -uroot -p &lt; all.sqlEnter password:##导入成功</code></pre><h1 id="在master上创建复制账号"><a href="#在master上创建复制账号" class="headerlink" title="在master上创建复制账号"></a>在master上创建复制账号</h1><pre><code class="sql">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;repluser&#39;@&#39;10.10.10.%&#39; IDENTIFIED BY &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><h1 id="在slave上开启复制"><a href="#在slave上开启复制" class="headerlink" title="在slave上开启复制"></a>在slave上开启复制</h1><pre><code class="sql"># slavemysql&gt;  CHANGE MASTER TO MASTER_HOST=&#39;10.10.10.100&#39;,MASTER_USER=&#39;repluser&#39;,MASTER_PASSWORD=&#39;echo123.&#39;,MASTER_PORT=3306,MASTER_AUTO_POSITION=1;Query OK, 0 rows affected, 2 warnings (0.04 sec)</code></pre><h1 id="查看主从状态"><a href="#查看主从状态" class="headerlink" title="查看主从状态"></a>查看主从状态</h1><pre><code class="sql"># slavemysql&gt; start slave;Query OK, 0 rows affected (0.06 sec)mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.100                  Master_User: repluser                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000010          Read_Master_Log_Pos: 1719               Relay_Log_File: mysql-relay-bin.000002                Relay_Log_Pos: 1220        Relay_Master_Log_File: mysql-bin.000010             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 1719              Relay_Log_Space: 1427              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1003306                  Master_UUID: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:4-6            Executed_Gtid_Set: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:1-6                Auto_Position: 1         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)</code></pre><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><h2 id="在主库上插入数据"><a href="#在主库上插入数据" class="headerlink" title="在主库上插入数据"></a>在主库上插入数据</h2><pre><code class="sql"># mastermysql&gt; select * from t1;+----+| id |+----+|  1 ||  2 ||  3 |+----+3 rows in set (0.00 sec)mysql&gt; insert into t1 values (4);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into t1 values (5);Query OK, 1 row affected (0.01 sec)</code></pre><h2 id="在从库上查看"><a href="#在从库上查看" class="headerlink" title="在从库上查看"></a>在从库上查看</h2><pre><code class="sql">mysql&gt; select * from t1;+----+| id |+----+|  1 ||  2 ||  3 |+----+3 rows in set (0.00 sec)mysql&gt; select * from t1;+----+| id |+----+|  1 ||  2 ||  3 ||  4 ||  5 |+----+5 rows in set (0.00 sec)</code></pre><h1 id="GTID如何跳过事务冲突："><a href="#GTID如何跳过事务冲突：" class="headerlink" title="GTID如何跳过事务冲突："></a>GTID如何跳过事务冲突：</h1><ul><li>这个功能主要跳过事务，代替原来的set global sql_slave_skip_counter &#x3D; 1。</li><li>由于在这个GTID必须是连续的，正常情况同一个服务器产生的GTID是不会存在空缺的。所以不能简单的skip掉一个事务，只能通过注入空事物的方法替换掉一个实际操作事务。</li></ul><p>注入空事物的方法：</p><ol><li>stop slave;</li><li>set gtid_next&#x3D;’xxxxxxx:N’;   ##这里的xxxxx:N 也就是你的slave sql thread报错的GTID，或者说是你想要跳过的GTID。</li><li>begin;</li><li>commit;</li><li>set gtid_next&#x3D;’AUTOMATIC’;</li><li>start slave;</li></ol><p>例如：</p><pre><code class="sql">mysql&gt; stop slave;Query OK, 0 rows affected (0.02 sec)mysql&gt; set gtid_next=&#39;91daaeb1-3eab-11e8-bbc1-000c29ffc6cd:15&#39;;   ##跳过的GTID号Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;commit;Query OK, 0 rows affected (0.00 sec)Query OK, 0 rows affected (0.01 sec)mysql&gt; set gtid_next=&#39;AUTOMATIC&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> GTID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql体系结构</title>
      <link href="/2017/04/17/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2017/04/17/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p><h1 id="server层"><a href="#server层" class="headerlink" title="server层"></a>server层</h1><ol><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL借口组件</li><li>查询分析器组件 解析sql语句，解析成树状结构</li><li>优化器组件</li><li>缓冲组件</li></ol><h1 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h1><ol start="7"><li>插件式存储引擎</li><li>物理文件</li></ol><h1 id="sql语句执行过程"><a href="#sql语句执行过程" class="headerlink" title="sql语句执行过程"></a>sql语句执行过程</h1><pre><code>sql语句 --&gt; query cache --&gt; 解析器 --&gt; 处理器 --&gt; 优化器 --&gt; 执行计划 --&gt; 存储引擎 --&gt; 获取数据</code></pre><p><img src="/images/sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png"></p><h1 id="innodb存储引擎架构"><a href="#innodb存储引擎架构" class="headerlink" title="innodb存储引擎架构"></a>innodb存储引擎架构</h1><p><img src="/images/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.png"></p><h1 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h1><p><img src="/images/%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8.png"></p><h2 id="逻辑存储单元"><a href="#逻辑存储单元" class="headerlink" title="逻辑存储单元"></a>逻辑存储单元</h2><ul><li>页 16k （oracle中为8k）</li><li>页头：存储事务信息，锁信息，指针，checksum值</li><li>页身：存储实际的行数据，一个页身最多存储7992行数据</li><li>页尾：checksum值，页尾和页身的值必须一致</li><li>区 64个连续的页组成 64*16k&#x3D;1M</li><li>段 一个大数据段由4个区组成 4M</li><li>表空间</li></ul><p>innodb IO的最小单位是页，读取一行数据的时候，将该行数据的整个页读取到内存中国，以提高内存的命中率（内存读 &#x2F;（内存读+磁盘读））</p><h1 id="innodb内存池组成"><a href="#innodb内存池组成" class="headerlink" title="innodb内存池组成"></a>innodb内存池组成</h1><p><img src="/images/innodb%E5%86%85%E5%AD%98%E6%B1%A0.png"></p><h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><ul><li>数据页</li><li>索引页</li><li>插入缓冲</li><li>自适应哈希索引</li><li>锁信息</li><li>数据字典</li></ul><p><code>innodb_buffer_pool_size</code> 定义缓冲池大小</p><p><code>innodb_buffer_pool_instances</code> 定义缓冲池个数</p><p><code>show engine innodb status;</code> 查看大小和个数</p><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>一般的数据库缓冲池通过LRU（latest recently used，最近最少使用）算法来进行管理，即最频繁使用的页在LRU列表的前端，最少使用的在LRU的尾端；</p><p>innodb的缓冲池稍有不同，其在LRU中加入了<code>midpoint</code>位置，新读取的页，放在LRU列表的<code>minpoint</code>位置，<code>minpoint</code>之前的列表称为new列表，之后的称为old列表，可以理解new列表里面的页都是最为活跃的热点数据；</p><p><code>innodb_old_blocks_pct</code>来控制<code>midpoint</code>的位置，值是百分比</p><p><code>nnodb_old_blocks_time</code>用于表示页读到<code>midpoint</code>后，需要等待多久才会被加入到LRU列表的热端，这样做的好处是如果一读到<code>minpoint</code>就放到热端，可能会被其他查询给挤出LRU列表，这种查询一般是作为索引或数据的扫描工作，并不是热点数据，所以需要有个时间来进行控制。</p><h2 id="重做日志缓冲区"><a href="#重做日志缓冲区" class="headerlink" title="重做日志缓冲区"></a>重做日志缓冲区</h2><p>innodb存储引擎先将重做日志放在这个缓冲区，然后按照一定频率将其刷新到重做日志文件，重做日主缓冲区一般不需要设置得非常大，因为一般每一秒都会有重做日志缓存刷新到日志文件，只需要保证每秒产生的事务量在这个缓冲区大小内即可。</p><p><code>innodb_log_buffer_size</code>控制重做日志缓冲区大小，默认为8M；</p><h2 id="额外缓存池"><a href="#额外缓存池" class="headerlink" title="额外缓存池"></a>额外缓存池</h2><p>在对一些数据结构本身进行内存的分配时，需要从额外的内存池中申请内存，当该区域不够的时候，会从缓冲区中进行申请。一般申请了很大的innodb缓冲池时，也应该考虑相应的增加这个值。</p><h1 id="innodb后台线程"><a href="#innodb后台线程" class="headerlink" title="innodb后台线程"></a>innodb后台线程</h1><h2 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h2><p>核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓存、undo页的回收等；</p><p>loop 主循环（繁忙）和 background loop 后台循环（空闲）切换操作</p><h2 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h2><p>IO Thread用AIO（异步IO）来处理IO请求，这样极大的提高了数据库的性能。innodb中分别有4个IO Thread，分别是write thread（4个）、read thread（4个）、insert buffer thread（1个）、log thread（1个）；</p><p><code>innodb_read_io_threads</code>、<code>innodb_write_io_threads</code>参数进行设置</p><p><code>show variables like &#39;innodb_%_io_threads&#39;;</code></p><h2 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h2><p>事务提交后，undo log可能不再需要，因此需要purge thread来回收已经分配使用并分配的undo页</p><p><code>innod_purge_threads</code>来控制purge thread的个数；</p><h2 id="Page-cleaner-Thread"><a href="#Page-cleaner-Thread" class="headerlink" title="Page cleaner Thread"></a>Page cleaner Thread</h2><p>将脏页的刷新操作放到单独的线程中来完成（innodb1.2x之前的版本，脏页刷新是由master thread来完成的），目的是减小原master thread的工作及对于用户查询线程的阻塞，进一步提高innodb的性能；</p><h1 id="innodb内存刷新机制"><a href="#innodb内存刷新机制" class="headerlink" title="innodb内存刷新机制"></a>innodb内存刷新机制</h1><p>日志先行策略，先写日志，再写文件。</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>每个InnoDB存储引擎至少有1个redo log文件组，每个文件组下至少有2个redo log文件。为了得到更高的可靠性，可以设置多个mirrored log group，将不同的文件组放在不同的磁盘上。日志组中每个redo log文件的大小一致，并以循环方式使用。InnoDB存储引擎先写redo log文件1，当达到文件的最后是，会切换至文件2，当文件2也被写满时，会再切换到文件1中。</p><p><code>innodb_log_file_size</code> 参数指定了redo log文件的大小；</p><p><code>innodb_log_files_in_group</code> 参数指定了redo log文件组中redo log文件的数量，默认为2；</p><p><code>innodb_mirrored_log_groups</code> 参数指定了日志镜像文件组的数量，默认为1，代表只有一个文件组，没有镜像；</p><p><code>innodb_log_group_home_dir</code> 参数指定了日志文件组所在路径，默认在数据库路径下。</p><p><code>innodb_flush_log_at_trx_commit</code> 参数决定redo log的刷新机制</p><ul><li>0：每隔1秒刷新一次</li><li>1：实时刷新（默认）</li><li>2：交由操作系统管理</li></ul><p>试想，当文件2写满了，切换到1的时候，覆盖1里面的内容，那之前的redo log不是没有了吗，这时候引入<code>checkpoint</code>概念，当发生日志文件切换的时候，产生checkpoint，将缓冲区里的脏数据刷回磁盘。这是其中一个脏页刷回磁盘的条件。还有一个是通过<code>innodb_max_dirty_pages_pct</code>参数（脏页占缓冲区的比率，默认75%，建议设置成20%-50%）来控制脏页的刷新。</p><h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><p><code>sync_binlog</code>参数决定bin log刷新机制</p><ul><li>1：实时刷新（默认）</li><li>0：交由操作系统管理</li><li>(2，3，4……n)：n个事务刷新一次</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql存储引擎类型</title>
      <link href="/2017/04/17/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/04/17/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h1><ol><li>支持事务，面向在线事务处理（OLTP）方面的应用，支持行锁（锁粒度），支持外键；</li><li>通过多版本并发控制MVCC来获得高并发性，并且实现了sql标准的4种隔离级别（默认为<code>repeatable read</code>可重复读）；</li><li>提供插入缓冲（insert buffer），二次写（double write），自适应哈斯索引（ahi），预读（read ahead）；</li><li>对表中数据的存储，innodb采用clustered。每张表的存储按逐渐的顺序存放，如果没有显示的为飚定义主键，innodb会为每一张行生成一个6字节的rowid，作为主键</li></ol><ul><li>.ibd innodb数据文件，索引也存在里面，既缓存数据，也缓存索引</li><li>.frm 表结构文件</li></ul><h1 id="myisam"><a href="#myisam" class="headerlink" title="myisam"></a>myisam</h1><ol><li>不支持事务，表锁（锁粒度）、全文索引，对OLAP在线分析处理，操作速度快；</li><li>myisam存储引擎表由MYD和MYI组成，MYD存放数据文件，MYI存放索引文件；</li><li>从mysql5.0开始，mysql默认支持256T单表数据</li><li>对于myisam存储引擎表，mysql数据库只缓存其索引文件，数据文件的缓存交由硝唑系统本身来完成，区别在于使用LRU算法缓存数据的大部分数据库；</li></ol><ul><li>select count(*) 查询 myisam快 innodb慢</li><li>myisam有个计数器，直接读取计数器的数据</li><li>innodb需要全表扫描</li></ul><h1 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h1><ol><li>数据放在内存中，数据库重启或掉电，表中的数据将丢失</li><li>只支持表锁，速度非常快，哈希索引，并发性能差</li><li>不支持text和blob列类型，一般用于创建临时表</li></ol><h1 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h1><ol><li>只支持insert和select操作</li><li>使用zlib算法将数据行（row）进行压缩后存储，压缩比可达1:10</li><li>适合存储归档数据，如日志信息</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>还有其他存储引擎，比如：</p><p>Merge、CSV、Sphinx、infobright、Federated、NDB等</p><p><img src="/images/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%AF%94%E8%BE%83.png"></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB Redo Flush及脏页刷新机制深入分析</title>
      <link href="/2017/04/16/InnoDB-Redo-Flush%E5%8F%8A%E8%84%8F%E9%A1%B5%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2017/04/16/InnoDB-Redo-Flush%E5%8F%8A%E8%84%8F%E9%A1%B5%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>我们知道InnoDB采用<code>Write Ahead Log</code>策略来防止宕机数据丢失，即事务提交时，先写重做日志，再修改内存数据页，这样就产生了脏页。既然有重做日志保证数据持久性，查询时也可以直接从缓冲池页中取数据，那为什么还要刷新脏页到磁盘呢？如果重做日志可以无限增大，同时缓冲池足够大，能够缓存所有数据，那么是不需要将缓冲池中的脏页刷新到磁盘。但是，通常会有以下几个问题：</p><ul><li>服务器内存有限，缓冲池不够用，无法缓存全部数据</li><li>重做日志无限增大成本要求太高</li><li>宕机时如果重做全部日志恢复时间过长</li></ul><p>事实上，当数据库宕机时，数据库不需要重做所有的日志，只需要执行上次刷入点之后的日志。这个点就叫做<code>Checkpoint</code>，它解决了以上的问题：</p><ul><li>缩短数据库恢复时间</li><li>缓冲池不够用时，将脏页刷新到磁盘</li><li>重做日志不可用时，刷新脏页</li></ul><p>重做日志被设计成可循环使用，当日志文件写满时，重做日志中对应数据已经被刷新到磁盘的那部分不再需要的日志可以被覆盖重用。</p><p>InnoDB引擎通过LSN(Log Sequence Number)来标记版本，LSN是日志空间中每条日志的结束点，用字节偏移量来表示。每个page有LSN，redo log也有LSN，Checkpoint也有LSN。可以通过命令show engine innodb status来观察：</p><pre><code class="sql">mysql&gt; show engine innodb status\G;LOG---Log sequence number 2584569Log flushed up to   2584569Pages flushed up to 2584569Last checkpoint at  25845600 pending log flushes, 0 pending chkp writes67 log i/o&#39;s done, 0.00 log i/o&#39;s/second</code></pre><p><code>Checkpoint</code>机制每次刷新多少页，从哪里取脏页，什么时间触发刷新？这些都是很复杂的。有两种<code>Checkpoint</code>，分别为：</p><ul><li>Sharp Checkpoint</li><li>Fuzzy Checkpoint</li></ul><p><code>Sharp Checkpoint</code>发生在关闭数据库时，将所有脏页刷回磁盘。</p><p>在运行时使用<code>Fuzzy Checkpoint</code>进行部分脏页的刷新。部分脏页刷新有以下几种：</p><ul><li>Master Thread Checkpoint</li><li>FLUSH_LRU_LIST Checkpoint</li><li>Async&#x2F;Sync Flush Checkpoint</li><li>Dirty Page too much Checkpoint</li></ul><h2 id="Master-Thread-Checkpoint"><a href="#Master-Thread-Checkpoint" class="headerlink" title="Master Thread Checkpoint"></a>Master Thread Checkpoint</h2><p><code>Master Thread</code>以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。这个过程是异步的，不会阻塞查询线程。</p><h2 id="Flush-LRU-List-Checkpoint"><a href="#Flush-LRU-List-Checkpoint" class="headerlink" title="Flush LRU List Checkpoint"></a>Flush LRU List Checkpoint</h2><p>InnoDB要保证<code>LRU</code>列表中有100左右空闲页可使用。在<code>InnoDB1.1.X</code>版本前，要检查<code>LRU</code>中是否有足够的页用于用户查询操作线程，如果没有，会将<code>LRU</code>列表尾端的页淘汰，如果被淘汰的页中有脏页，会强制执行<code>Checkpoint</code>刷回脏页数据到磁盘，显然这会阻塞用户查询线程。从<code>InnoDB1.2.X</code>版本开始，这个检查放到单独的<code>Page Cleaner Thread</code>中进行，并且用户可以通过<code>innodb_lru_scan_depth</code>控制LRU列表中可用页的数量，默认值为1024。</p><h2 id="Async-Sync-Flush-Checkpoint"><a href="#Async-Sync-Flush-Checkpoint" class="headerlink" title="Async&#x2F;Sync Flush Checkpoint"></a>Async&#x2F;Sync Flush Checkpoint</h2><p>是指重做日志文件不可用时，需要强制将脏页列表中的一些页刷新回磁盘。这可以保证重做日志文件可循环使用。在<code>InnoDB1.2.X</code>版本之前，<code>Async Flush Checkpoint</code>会阻塞发现问题的用户查询线程，<code>Sync Flush Checkpoint</code>会阻塞所有查询线程。<code>InnoDB1.2.X</code>之后放到单独的<code>Page Cleaner Thread</code>。</p><h2 id="Dirty-Page-Too-Much-Checkpoint"><a href="#Dirty-Page-Too-Much-Checkpoint" class="headerlink" title="Dirty Page Too Much Checkpoint"></a>Dirty Page Too Much Checkpoint</h2><p>脏页数量太多时，InnoDB引擎会强制进行<code>Checkpoint</code>。目的还是为了保证缓冲池中有足够可用的空闲页。其可以通过参数<code>innodb_max_dirty_pages_pct</code>来设置，默认为<code>75%</code>：</p><pre><code class="sql">mysql&gt; show variables like &#39;innodb_max_dirty_pages_pct&#39;;+----------------------------+-----------+| Variable_name              | Value     |+----------------------------+-----------+| innodb_max_dirty_pages_pct | 75.000000 |+----------------------------+-----------+1 row in set (0.00 sec)</code></pre><p>以上是脏页刷新的几种触发机制，接下来，细说一下日志机制及其中第3点<code>Async/Sync flush checkpoint</code>原理。</p><h2 id="Log及Checkpoint简介"><a href="#Log及Checkpoint简介" class="headerlink" title="Log及Checkpoint简介"></a>Log及Checkpoint简介</h2><p>Innodb的事务日志是指Redo log，简称Log,保存在日志文件<code>ib_logfile</code>里面。Innodb还有另外一个日志Undo log，但Undo log是存放在共享表空间里面的（<code>ibdata</code>文件）。</p><p>由于Log和Checkpoint紧密相关，因此将这两部分合在一起分析。</p><blockquote><p>名词解释：LSN，日志序列号，Innodb的日志序列号是一个64位的整型。</p></blockquote><h3 id="Log写入"><a href="#Log写入" class="headerlink" title="Log写入"></a>Log写入</h3><p>LSN实际上对应日志文件的偏移量，新的LSN＝旧的LSN + 写入的日志大小。举例如下：</p><p>LSN＝1G，日志文件大小总共为600M，本次写入512字节，则实际写入操作为：</p><ul><li><p>— 求出偏移量：由于LSN数值远大于日志文件大小，因此通过取余方式，得到偏移量为400M；</p></li><li><p>— 写入日志：找到偏移400M的位置，写入512字节日志内容，下一个事务的LSN就是1000000512；</p></li></ul><h3 id="Checkpoint写入"><a href="#Checkpoint写入" class="headerlink" title="Checkpoint写入"></a>Checkpoint写入</h3><p>Innodb实现了<code>Fuzzy Checkpoint</code>的机制，每次取到最老的脏页，然后确保此脏页对应的LSN之前的LSN都已经写入日志文件，再将此脏页的LSN作为Checkpoint点记录到日志文件，意思就是“此LSN之前的LSN对应的日志和数据都已经写入磁盘文件”。恢复数据文件的时候，Innodb扫描日志文件，当发现LSN小于Checkpoint对应的LSN，就认为恢复已经完成。</p><p>Checkpoint写入的位置在日志文件开头固定的偏移量处，即每次写Checkpoint都覆盖之前的Checkpoint信息。</p><h1 id="Flush刷新流程及原理介绍"><a href="#Flush刷新流程及原理介绍" class="headerlink" title="Flush刷新流程及原理介绍"></a>Flush刷新流程及原理介绍</h1><p>由于Checkpoint和日志紧密相关，将日志和Checkpoint一起说明，详细的实现机制如下：<br><img src="/images/innodblog.gif"><br>如上图所示，Innodb的一条事务日志共经历4个阶段：</p><ol><li>创建阶段：事务创建一条日志；</li><li>日志刷盘：日志写入到磁盘上的日志文件；</li><li>数据刷盘：日志对应的脏页数据写入到磁盘上的数据文件；</li><li>写CKP：日志被当作Checkpoint写入日志文件；</li></ol><p>对应这4个阶段，系统记录了4个日志相关的信息，用于其它各种处理使用：</p><ul><li><p><code>Log sequence number</code>（LSN1）：当前系统LSN最大值，新的事务日志LSN将在此基础上生成（LSN1+新日志的大小）；</p></li><li><p><code>Log flushed up to</code>（LSN2）：当前已经写入日志文件的LSN；</p></li><li><p><code>Pages flushed up to</code>（LSN3）：当前最旧的脏页数据对应的LSN，写Checkpoint的时候直接将此LSN写入到日志文件；</p></li><li><p><code>Last checkpoint at</code>（LSN4）：当前已经写入Checkpoint的LSN；</p></li></ul><p>对于系统来说，以上4个LSN是递减的，即： LSN1&gt;&#x3D;LSN2&gt;&#x3D;LSN3&gt;&#x3D;LSN4.</p><p>具体的样例如下（使用<code>show engine innodb status \G</code>命令查看）</p><pre><code class="sql">mysql&gt; show engine innodb status\G;LOG---Log sequence number 1475999669Log flushed up to   1475999669Pages flushed up to 1475999669Last checkpoint at  14759996600 pending log flushes, 0 pending chkp writes171 log i/o&#39;s done, 0.00 log i/o&#39;s/second----------------------</code></pre><h2 id="Async-Sync-Flush-Checkpoint原理"><a href="#Async-Sync-Flush-Checkpoint原理" class="headerlink" title="Async&#x2F;Sync Flush Checkpoint原理"></a>Async&#x2F;Sync Flush Checkpoint原理</h2><p>Innodb的数据并不是实时写盘的，为了避免宕机时数据丢失，保证数据的ACID属性，Innodb至少要保证数据对应的日志不能丢失。对于不同的情况，Innodb采取不同的对策：</p><ol><li>宕机导致日志丢失</li></ol><p>Innodb有日志刷盘机制，可以通过<code>innodb_flush_log_at_trx_commit</code>参数进行控制；</p><ol start="2"><li>日志覆盖导致日志丢失</li></ol><p>Innodb日志文件大小是固定的，写入的时候通过取余来计算偏移量，这样存在两个LSN写入到同一位置的可能，后面写的把前面写得就覆盖了，以“写入机制”章节的样例为例，<code>LSN＝100000000</code>和<code>LSN＝1600000000</code>两个日志的偏移量是相同的了。这种情况下，为了保证数据一致性，必须要求<code>LSN=1000000000</code>对应的脏页数据都已经刷到磁盘中，也就是要求Last checkpoint对应的LSN一定要大于<code>1000000000</code>，否则覆盖后日志也没有了，数据也没有刷盘，一旦宕机，数据就丢失了。</p><p>为了解决第二种情况导致数据丢失的问题，Innodb实现了一套日志保护机制，详细实现如下：</p><p><img src="/images/innodblog2.gif"></p><p>上图中，直线代表日志空间（Log cap，约等于日志文件总大小*0.8，0.8是一个安全系数)，Ckp age和Buf age是两个浮动的点，Buf async、Buf sync、Ckp async、Ckp sync是几个固定的点。各个概念的含义如下：</p><table><thead><tr><th>概念</th><th>计算</th><th>含义</th></tr></thead><tbody><tr><td>Ckp age</td><td>LSN1- LSN4</td><td>还没有做Checkpoint的日志范围，若Ckp age超过日志空间，说明被覆盖的日志（LSN1－LSN4－Log cap）对应日志和数据“可能”还没有刷到磁盘上</td></tr><tr><td>Buf age</td><td>LSN1- LSN3</td><td>还没有将脏页刷盘的日志的范围，若Buf age超过日志空间，说明被覆盖的日志（LSN1－LSN3－Log cap）对应数据“肯定”还没有刷到磁盘上</td></tr><tr><td>Buf async</td><td>日志空间大小 * 7&#x2F;8</td><td>强制将Buf age-Buf async的脏页刷盘，此时事务还可以继续执行，所以为async，对事务的执行速度没有直接影响（有间接影响，例如CPU和磁盘更忙了，事务的执行速度可能受到影响）</td></tr><tr><td>Buf sync</td><td>日志空间大小 * 15&#x2F;16</td><td>强制将2*(Buf age-Buf async)的脏页刷盘，此时事务停止执行，所以为sync，由于有大量的脏页刷盘，因此阻塞的时间比Ckp sync要长。</td></tr><tr><td>Ckp async</td><td>日志空间大小 * 31&#x2F;32</td><td>强制写Checkpoint，此时事务还可以继续执行，所以为async，对事务的执行速度没有影响（间接影响也不大，因为写Checkpoint的操作比较简单）</td></tr><tr><td>Ckp sync</td><td>日志空间大小 * 64&#x2F;64</td><td>强制写Checkpoint，此时事务停止执行，所以为sync，但由于写Checkpoint的操作比较简单，即使阻塞，时间也很短</td></tr></tbody></table><p>当事务执行速度大于脏页刷盘速度时，<code>Ckp age</code>和<code>Buf age</code>会逐步增长，当达到<code>async</code>点的时候，强制进行脏页刷盘或者写Checkpoint，如果这样做还是赶不上事务执行的速度，则为了避免数据丢失，到达<code>sync</code>点的时候，会阻塞其它所有的事务，专门进行脏页刷盘或者写Checkpoint。</p><p>因此从理论上来说,只要事务执行速度大于脏页刷盘速度，最终都会触发日志保护机制，进而将事务阻塞，导致MySQL操作挂起。</p><p>由于写Checkpoint本身的操作相比写脏页要简单，耗费时间也要少得多，且<code>Ckp sync</code>点在<code>Buf sync</code>点之后，因此绝大部分的阻塞都是阻塞在了<code>Buf sync</code>点，这也是当事务阻塞的时候，IO很高的原因，因为这个时候在不断的刷脏页数据到磁盘。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制-异步主从复制</title>
      <link href="/2017/04/14/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%BC%82%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/04/14/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%BC%82%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><table><thead><tr><th>角色</th><th>ip</th><th></th></tr></thead><tbody><tr><td>master</td><td>10.10.10.100</td><td>存在一个test库，里面有张t1表</td></tr><tr><td>slave</td><td>10.10.10.101</td><td>空库</td></tr></tbody></table><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><ul><li>master</li></ul><pre><code># master[mysqld]server-id=1003306                     ##server-id要唯一，最好以ip地址和端口号命名log-bin=mysql-bin                     ##开启二进制日志，必须要sync-binlog=1                         ##日志刷新模式，按需修改binlog_format=row                     ##日志格式最好用row，statement可能会有数据丢失</code></pre><ul><li>slave</li></ul><pre><code># slave[mysqld]server-id=1013306                    ##server-id必须唯一log-bin=mysql-bin                    ##一般来说从库不需要开启binlog，如果有特殊需要，如级联方式的复制，需要开启sync-binlog=1binlog_format=rowlog_slave_updates=1                  ##控制slave是否把master的binlog写入自己的binlog中，级联方式需要开启relay-log=mysql-relay-bin            ##中继日志，不写则以主机名命名，建议写上read-only=1                          ##设置从库只读，避免数据不一致的发生</code></pre><h1 id="导出master上的数据，导入到slave中"><a href="#导出master上的数据，导入到slave中" class="headerlink" title="导出master上的数据，导入到slave中"></a>导出master上的数据，导入到slave中</h1><pre><code># master[root@mysql-master-1003306 ~]# mysqldump -uroot -p --single-transaction -A --master-data=2 &gt; all.sql## --master-data=2 表示在备份文件中记录当前备份的二进制日志文件和position号-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000007&#39;, MASTER_LOG_POS=1744;  ##记下这一行，后面会用到[root@mysql-master-1003306 ~]# scp all.sql 10.10.10.101:/root               #将备份文件拷贝到从库</code></pre><h1 id="从库导入数据"><a href="#从库导入数据" class="headerlink" title="从库导入数据"></a>从库导入数据</h1><pre><code># slave[root@mysql-slave-1013306 ~]# mysql -uroot -p &lt; all.sql              ##导入数据Enter password:</code></pre><blockquote><p>导出数据也可以使用<code>xtrabackup</code>来进行，<code>xtrabackup</code>导出后也可以查到日志文件和<code>position</code>号，基于那里进行复制也可以；</p></blockquote><h1 id="在master上创建复制账号"><a href="#在master上创建复制账号" class="headerlink" title="在master上创建复制账号"></a>在master上创建复制账号</h1><pre><code class="sql"># mastermysql&gt; grant replication slave on *.* to &#39;repl&#39;@&#39;10.10.10.%&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.06 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec)</code></pre><h1 id="在slave上开启复制"><a href="#在slave上开启复制" class="headerlink" title="在slave上开启复制"></a>在slave上开启复制</h1><pre><code class="sql"># slavemysql&gt; change master to master_host=&#39;10.10.10.100&#39;,master_user=&#39;repl&#39;,master_password=&#39;echo123.&#39;,master_port=3306,master_log_file=&#39;mysql-bin.000007&#39;,master_log_pos=1744;Query OK, 0 rows affected, 2 warnings (0.08 sec)## master_log_file=&#39;mysql-bin.000007&#39;,master_log_pos=1744 指定二进制日志号和position号，从库将从这里开始进行复制mysql&gt; start slave;Query OK, 0 rows affected (0.10 sec)</code></pre><h1 id="查看主从状态"><a href="#查看主从状态" class="headerlink" title="查看主从状态"></a>查看主从状态</h1><pre><code># slavemysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 10.10.10.100                  Master_User: repl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000008          Read_Master_Log_Pos: 1365               Relay_Log_File: mysql-relay-bin.000003                Relay_Log_Pos: 1578        Relay_Master_Log_File: mysql-bin.000008             Slave_IO_Running: Yes                       ##yes表示正常            Slave_SQL_Running: Yes                       ##yes表示正常              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 1365              Relay_Log_Space: 1951              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1003306                  Master_UUID: 91daaeb1-3eab-11e8-bbc1-000c29ffc6cd             Master_Info_File: /data/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: 0         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)</code></pre><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><h2 id="在主库上插入数据"><a href="#在主库上插入数据" class="headerlink" title="在主库上插入数据"></a>在主库上插入数据</h2><pre><code class="sql">mysql&gt; select * from t1;+------+| id   |+------+|    1 ||    2 ||    3 ||    4 ||    5 ||    6 ||    7 ||    8 |+------+8 rows in set (0.00 sec)mysql&gt; insert into t1 values (9);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into t1 values (10);Query OK, 1 row affected (0.02 sec)</code></pre><h2 id="在从库上查看"><a href="#在从库上查看" class="headerlink" title="在从库上查看"></a>在从库上查看</h2><pre><code class="sql">mysql&gt; select * from t1;+------+| id   |+------+|    1 ||    2 ||    3 ||    4 ||    5 ||    6 ||    7 ||    8 ||    9 ||   10 |+------+10 rows in set (0.00 sec)</code></pre><blockquote><p>使用<code>reset slave all</code>可以清空主从配置；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制-半同步主从复制</title>
      <link href="/2017/04/14/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%8D%8A%E5%90%8C%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/04/14/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%8D%8A%E5%90%8C%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>半同步复制可以直接在异步复制的基础上完成，参考<a href="https://www.baihuzi.com/2017/04/14/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%BC%82%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">异步主从复制</a></p></blockquote><h1 id="开启半同步主从复制"><a href="#开启半同步主从复制" class="headerlink" title="开启半同步主从复制"></a>开启半同步主从复制</h1><h2 id="先检查是否支持动态安装插件"><a href="#先检查是否支持动态安装插件" class="headerlink" title="先检查是否支持动态安装插件"></a>先检查是否支持动态安装插件</h2><pre><code class="sql">mysql&gt; select @@have_dynamic_loading    -&gt; ;+------------------------+| @@have_dynamic_loading |+------------------------+| YES                    |+------------------------+1 row in set (0.00 sec)</code></pre><h2 id="查看插件库的路径"><a href="#查看插件库的路径" class="headerlink" title="查看插件库的路径"></a>查看插件库的路径</h2><pre><code class="sql">mysql&gt; show variables like &#39;plugin_dir&#39;;+---------------+------------------------------+| Variable_name | Value                        |+---------------+------------------------------+| plugin_dir    | /usr/local/mysql/lib/plugin/ |+---------------+------------------------------+1 row in set (0.00 sec)</code></pre><h2 id="有这个两个表示支持在线安装插件，然后在master和slave上同时安装插件"><a href="#有这个两个表示支持在线安装插件，然后在master和slave上同时安装插件" class="headerlink" title="有这个两个表示支持在线安装插件，然后在master和slave上同时安装插件"></a>有这个两个表示支持在线安装插件，然后在master和slave上同时安装插件</h2><ul><li>master</li></ul><pre><code class="sql"># mastermysql&gt; install plugin rpl_semi_sync_master SONAME &#39;semisync_master.so&#39;;Query OK, 0 rows affected (0.10 sec)mysql&gt; select * from mysql.plugin;+----------------------+--------------------+| name                 | dl                 |+----------------------+--------------------+| rpl_semi_sync_master | semisync_master.so |+----------------------+--------------------+1 row in set (0.00 sec)mysql&gt; set global rpl_semi_sync_master_enabled=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; show status like &#39;%semi_sync%&#39;;+--------------------------------------------+-------+| Variable_name                              | Value |+--------------------------------------------+-------+| Rpl_semi_sync_master_clients               | 0     || Rpl_semi_sync_master_net_avg_wait_time     | 0     || Rpl_semi_sync_master_net_wait_time         | 0     || Rpl_semi_sync_master_net_waits             | 0     || Rpl_semi_sync_master_no_times              | 0     || Rpl_semi_sync_master_no_tx                 | 0     || Rpl_semi_sync_master_status                | ON    || Rpl_semi_sync_master_timefunc_failures     | 0     || Rpl_semi_sync_master_tx_avg_wait_time      | 0     || Rpl_semi_sync_master_tx_wait_time          | 0     || Rpl_semi_sync_master_tx_waits              | 0     || Rpl_semi_sync_master_wait_pos_backtraverse | 0     || Rpl_semi_sync_master_wait_sessions         | 0     || Rpl_semi_sync_master_yes_tx                | 0     |+--------------------------------------------+-------+14 rows in set (0.01 sec)</code></pre><ul><li>slave</li></ul><pre><code class="sql"># slavemysql&gt; install plugin rpl_semi_sync_slave SONAME &#39;semisync_slave.so&#39;;Query OK, 0 rows affected (0.02 sec)mysql&gt; select * from mysql.plugin;+---------------------+-------------------+| name                | dl                |+---------------------+-------------------+| rpl_semi_sync_slave | semisync_slave.so |+---------------------+-------------------+1 row in set (0.00 sec)mysql&gt; set global rpl_semi_sync_slave_enabled=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; show status like &#39;%semi_sync%&#39;;+----------------------------+-------+| Variable_name              | Value |+----------------------------+-------+| Rpl_semi_sync_slave_status | OFF   |+----------------------------+-------+1 row in set (0.00 sec)## 开启了半同步，为什么还是off呢，是由于我们之前slave是在运行状态，将其重启下就可以了！mysql&gt; stop slave;Query OK, 0 rows affected (0.00 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.01 sec)mysql&gt; show status like &#39;%semi_sync%&#39;;+----------------------------+-------+| Variable_name              | Value |+----------------------------+-------+| Rpl_semi_sync_slave_status | ON    |+----------------------------+-------+1 row in set (0.01 sec)</code></pre><p>查看master上的状态</p><pre><code class="sql">mysql&gt; show status like &#39;%semi%&#39;;+--------------------------------------------+-------+| Variable_name                              | Value |+--------------------------------------------+-------+| Rpl_semi_sync_master_clients               | 1     || Rpl_semi_sync_master_net_avg_wait_time     | 0     || net_wait_time         | 0     || Rpl_semi_sync_master_net_waits             | 0     || Rpl_semi_sync_master_no_times              | 0     || Rpl_semi_sync_master_no_tx                 | 0     || Rpl_semi_sync_master_status                | ON    || Rpl_semi_sync_master_timefunc_failures     | 0     || Rpl_semi_sync_master_tx_avg_wait_time      | 0     || Rpl_semi_sync_master_tx_wait_time          | 0     || Rpl_semi_sync_master_tx_waits              | 0     || Rpl_semi_sync_master_wait_pos_backtraverse | 0     || Rpl_semi_sync_master_wait_sessions         | 0     || Rpl_semi_sync_master_yes_tx                | 0     |+--------------------------------------------+-------+14 rows in set (0.00 sec)#Rpl_semi_sync_master_clients 表示有几台slave连接到了这台master上，有几台，数字就是几；</code></pre><p>将配置写入my.cnf中，避免重启失效</p><ul><li>master</li></ul><pre><code>[mysqld]rpl_semi_sync_master_enabled=1rpl_semi_sync_master_timeout=10000        ##配置超时多少毫秒切换到异同步复制</code></pre><ul><li>slave</li></ul><pre><code>[mysqld]rpl_semi_sync_slave_enabled=1</code></pre><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>将 slave 的io thread 停掉，那么将在10秒后切换到异步复制（上面配置文件配置的10秒），也就是插入操作将卡住10秒才插入成功</p><ul><li>slave</li></ul><pre><code class="sql"># slavemysql&gt; stop slave io_thread;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; show warnings;+-------+------+-----------------------------------------------------------+| Level | Code | Message                                                   |+-------+------+-----------------------------------------------------------+| Note  | 3084 | Replication thread(s) for channel &#39;&#39; are already stopped. |+-------+------+-----------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; show status like &#39;%semi%&#39;;+----------------------------+-------+| Variable_name              | Value |+----------------------------+-------+| Rpl_semi_sync_slave_status | OFF   |+----------------------------+-------+1 row in set (0.00 sec)</code></pre><ul><li>slave</li></ul><pre><code class="sql"># mastermysql&gt; insert into t1 values(17);Query OK, 1 row affected (10.01 sec)           ##可以看到花了10秒才插入成功，此时就切换到了异步复制</code></pre><p>切换到异步复制后，系统不会自动切回半同步，需要手动切，切得方式很简单，就是<code>stop slave</code>；<code>start slave</code>；</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制概述</title>
      <link href="/2017/04/13/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2017/04/13/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL主从复制概述"><a href="#MySQL主从复制概述" class="headerlink" title="MySQL主从复制概述"></a>MySQL主从复制概述</h1><p>复制是mysql数据库提供的一种高可用、高性能的解决方案，一般用来建立大型的应用；</p><p>mysql支持单向，双向，链式级联，异步复制,半同步制(mysql5.5版本之后)，复制过程中,一台服务器当主<code>master</code>，而一个或者多个服务器<code>slave</code>；</p><p>复制可以是单向：<code>M --&gt; S</code>,也可以双向<code>M &lt;--&gt; M</code></p><p>如设置了链式级联复制，那么从服务器本身除了充当<code>slave</code>之外，还是其下面从服务器的主服务器，结构如同<code>M --&gt; S1 --&gt; S2 --&gt; S3</code> 的复制形式</p><h2 id="单向主从复制"><a href="#单向主从复制" class="headerlink" title="单向主从复制"></a>单向主从复制</h2><pre><code>master  --&gt;  slave</code></pre><h2 id="一主多从模式"><a href="#一主多从模式" class="headerlink" title="一主多从模式"></a>一主多从模式</h2><pre><code>        -------slave1        |master——|------slave2        |        -------slave3</code></pre><h2 id="线性级联模式"><a href="#线性级联模式" class="headerlink" title="线性级联模式"></a>线性级联模式</h2><pre><code>master --&gt; slave1 --&gt; salve2 --&gt; slave3</code></pre><h2 id="双主模式，互为主从"><a href="#双主模式，互为主从" class="headerlink" title="双主模式，互为主从"></a>双主模式，互为主从</h2><pre><code>master &lt;--&gt; master</code></pre><h2 id="混用"><a href="#混用" class="headerlink" title="混用"></a>混用</h2><pre><code>master &lt;--&gt; master   | slave</code></pre><h1 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="mysql主从复制原理"></a>mysql主从复制原理</h1><p><img src="/images/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt="mysql主从复制"></p><h1 id="复制三个步骤"><a href="#复制三个步骤" class="headerlink" title="复制三个步骤"></a>复制三个步骤</h1><ol><li>主服务器将数据更新记录到二进制日志中；</li><li>从服务器把主服务器的二进制日志拷贝到自己的中继日志中；</li><li>从服务器重做中继日志中的时间，把更新应用到自己的数据库上；</li></ol><h2 id="主服务器中的线程"><a href="#主服务器中的线程" class="headerlink" title="主服务器中的线程"></a>主服务器中的线程</h2><ul><li><p>I&#x2F;O线程</p><p>接收到从库发来的请求后，负责给从库发送二进制日志；</p></li></ul><h2 id="从库中的线程"><a href="#从库中的线程" class="headerlink" title="从库中的线程"></a>从库中的线程</h2><ul><li><p>I&#x2F;O线程</p><p>接收主库发来的二进制日志，并将其保存在自己的中继日志中</p></li><li><p>sql线程</p><p>来复制中继日志中的日志</p></li></ul><h2 id="主动复制分为异步复制、半同步复制和基于GTID的复制；"><a href="#主动复制分为异步复制、半同步复制和基于GTID的复制；" class="headerlink" title="主动复制分为异步复制、半同步复制和基于GTID的复制；"></a>主动复制分为异步复制、半同步复制和基于GTID的复制；</h2><ul><li>异步复制：MySQL复制默认是异步复制，<code>Master</code>将事件写入<code>binlog</code>，但并不知道<code>Slave</code>是否或何时已经接收且已处理。在异步复制的机制的情况下，如果<code>Master</code>宕机，事务在<code>Master</code>上已提交，但很可能这些事务没有传到任何的<code>Slave</code>上。假设有<code>Master-&gt;Salve</code>故障转移的机制，此时<code>Slave</code>也可能会丢失事务。&#96;</li><li>半同步复制：当<code>Slave</code>主机连接到<code>Master</code>时，能够查看其是否处于半同步复制的机制，当<code>Master</code>上开启半同步复制的功能时，至少应该有一个<code>Slave</code>开启其功能。此时，一个线程在<code>Master</code>上提交事务将受到阻塞，直到得知一个已开启半同步复制功能的<code>Slave</code>已收到此事务的所有事件，或等待超时。当一个事务的事件都已写入其<code>relay-log</code>中且已刷新到磁盘上，<code>Slave</code>才会告知已收到，如果等待超时，也就是Master没被告知已收到，此时<code>Master</code>会自动转换为异步复制的机制。当至少一个半同步的<code>Slave</code>赶上了，<code>Master</code>与其<code>Slave</code>自动转换为半同步复制的机制。半同步复制的功能要在<code>Master</code>，<code>Slave</code>都开启，半同步复制才会起作用；否则，只开启一边，它依然为异步复制</li></ul><p><img src="/images/%E5%8D%8A%E5%90%8C%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt="半同步主从复制"></p><h1 id="主从复制应用场景"><a href="#主从复制应用场景" class="headerlink" title="主从复制应用场景"></a>主从复制应用场景</h1><ul><li>主从复制有利于数据库架构的健壮性，提升访问速度，易于管理；</li><li>主从服务器互为备份</li><li>M-S服务器架构的设置，可以大大的加强数据库架构的健壮性，当主库出现问题，可以切换到从库，从而不影响正常生产业务的进行；</li><li>主从复制读写分离分担网站压力</li><li>主从服务器架构通过程序(php,java）对客户端的请求实现读写分离，在从服务器上仅仅处理用户的select查询请求，降低用户查询响应时间，以及读写操作同时在主服务器带来的压力；</li></ul><h1 id="GTID主从复制"><a href="#GTID主从复制" class="headerlink" title="GTID主从复制"></a>GTID主从复制</h1><h2 id="GTID的概述："><a href="#GTID的概述：" class="headerlink" title="GTID的概述："></a>GTID的概述：</h2><ol><li>全局事物标识：global transaction identifieds。</li><li>GTID事物是全局唯一性的，且一个事务对应一个GTID。</li><li>一个GTID在一个服务器上只执行一次，避免重复执行导致数据混乱或者主从不一致。</li><li>GTID用来代替classic的复制方法，不在使用binlog+pos开启复制。而是使用master_auto_postion&#x3D;1的方式自动匹配GTID断点进行复制。</li><li>MySQL-5.6.5开始支持的，MySQL-5.6.10后开始完善。</li><li>在传统的slave端，binlog是不用开启的，但是在GTID中，slave端的binlog是必须开启的，目的是记录执行过的GTID（强制）</li></ol><h2 id="GTID的组成部分："><a href="#GTID的组成部分：" class="headerlink" title="GTID的组成部分："></a>GTID的组成部分：</h2><ol><li>前面是server_uuid：后面是一个序列号</li><li>例如：server_uuid：sequence number</li><li>7800a22c-95ae-11e4-983d-080027de205a:10</li><li>UUID：每个mysql实例的唯一ID，由于会传递到slave，所以也可以理解为源ID。</li><li>Sequence number：在每台MySQL服务器上都是从1开始自增长的序列，一个数值对应一个事务。</li></ol><h2 id="GTID比传统复制的优势："><a href="#GTID比传统复制的优势：" class="headerlink" title="GTID比传统复制的优势："></a>GTID比传统复制的优势：</h2><ol><li>更简单的实现failover，不用以前那样在需要找log_file和log_Pos。</li><li>更简单的搭建主从复制。</li><li>比传统复制更加安全。</li><li>GTID是连续没有空洞的，因此主从库出现数据冲突时，可以用添加空事物的方式进行跳过。</li></ol><h2 id="GTID的工作原理："><a href="#GTID的工作原理：" class="headerlink" title="GTID的工作原理："></a>GTID的工作原理：</h2><ol><li>master更新数据时，会在事务前产生GTID，一同记录到binlog日志中。</li><li>slave端的i&#x2F;o 线程将变更的binlog，写入到本地的relay log中。</li><li>sql线程从relay log中获取GTID，然后对比slave端的binlog是否有记录。</li><li>如果有记录，说明该GTID的事务已经执行，slave会忽略。</li><li>如果没有记录，slave就会从relay log中执行该GTID的事务，并记录到binlog。</li><li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有就用全部扫描。</li></ol><h2 id="GTID的限制："><a href="#GTID的限制：" class="headerlink" title="GTID的限制："></a>GTID的限制：</h2><ol><li>不支持非事务引擎（从库报错，stopslave; start slave; 忽略）</li><li>不支持create table … select 语句复制（主库直接报错）</li><li>不允许在一个SQL同时更新一个事务引擎和非事务引擎的表</li><li>在一个复制组中，必须要求统一开启CTID或是关闭GTID</li><li>开启DTID需要重启（5.7中可能不需要）</li><li>开启DTID后，就不在使用原来的传统的复制方式</li><li>对于createtemporary table 和drop temporary table语句不支持</li><li>不支持sql_slave_skip_counter</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> GTID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xtrabackup备份原理</title>
      <link href="/2017/04/12/xtrabackup%E5%A4%87%E4%BB%BD%E5%8E%9F%E7%90%86/"/>
      <url>/2017/04/12/xtrabackup%E5%A4%87%E4%BB%BD%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="xtrabackup备份原理"><a href="#xtrabackup备份原理" class="headerlink" title="xtrabackup备份原理"></a>xtrabackup备份原理</h1><p>流程图</p><p><img src="/images/PXB-backup-procedure.png" alt="PXB-backup-procedure.png"></p><p><code>xtrabackup</code>是用来备份<code>InnoDB</code>表的，不能备份非<code>InnoDB</code>表，和<code>mysqld server</code>没有交互；</p><p><code>innobackupex</code>脚本用来备份非 <code>InnoDB</code>表，同时会调用<code>xtrabackup</code>命令来备份<code>InnoDB</code>表，还会和<code>mysqld server</code>发送命令进行交互，如加读锁（FTWRL）、获取位点（SHOW SLAVE STATUS）等。</p><p>简单来说，<code>innobackupex</code>在<code>xtrabackup</code>之上做了一层封装。一般情况下，我们是希望能备份<code>MyISAM</code>表的，虽然我们可能自己不用<code>MyISAM</code>表，但是<code>mysql</code>库下的系统表是 MyISAM 的，因此备份基本都通过innobackupex命令进行；另外一个原因是我们可能需要保存位点信息。</p><h2 id="备份过程"><a href="#备份过程" class="headerlink" title="备份过程"></a>备份过程</h2><ol><li>innobackupex 在启动后，会先 fork 一个进程，启动 xtrabackup进程，然后就等待 xtrabackup 备份完 ibd 数据文件；</li><li>xtrabackup 在备份 InnoDB 相关数据时，是有2种线程的，1种是 redo 拷贝线程，负责拷贝 redo 文件，1种是 ibd 拷贝线程，负责拷贝 ibd 文件；redo 拷贝线程只有一个，在 ibd 拷贝线程之前启动，在 ibd 线程结束后结束（并不是马上结束，而是等到非innodb存储引擎表备份完再结束，这里强调的是先后顺序）。</li><li>xtrabackup 进程开始执行后，先启动 redo 拷贝线程，从最新的 checkpoint 点开始顺序拷贝 redo 日志；然后再启动 ibd 数据拷贝线程，在 xtrabackup 拷贝 ibd 过程中，innobackupex 进程一直处于等待状态（等待文件被创建）。</li><li>xtrabackup 拷贝完成idb后，通知 innobackupex（通过创建文件），同时自己进入等待（redo 线程仍然继续拷贝）;</li><li>innobackupex 收到 xtrabackup 通知后，执行FLUSH TABLES WITH READ LOCK (FTWRL)，取得一致性位点，然后开始备份非 InnoDB 文件（包括 frm、MYD、MYI、CSV、opt、par等）。拷贝非 InnoDB 文件过程中，因为数据库处于全局只读状态，如果在业务的主库备份的话，要特别小心，非 InnoDB 表（主要是MyISAM）比较多的话整库只读时间就会比较长，这个影响一定要评估到。</li><li>当 innobackupex 拷贝完所有非 InnoDB 表文件后，通知 xtrabackup（通过删文件） ，同时自己进入等待（等待另一个文件被创建）；xtrabackup 收到 innobackupex 备份完非 InnoDB 通知后，就停止 redo 拷贝线程，然后通知 innobackupex redo log 拷贝完成（通过创建文件）；</li><li>innobackupex 收到 redo 备份完成通知后，就开始解锁，执行 UNLOCK TABLES；</li><li>最后 innobackupex 和 xtrabackup 进程各自完成收尾工作，如资源的释放、写备份元数据信息等，innobackupex 等待 xtrabackup 子进程结束后退出。</li></ol><h2 id="恢复过程"><a href="#恢复过程" class="headerlink" title="恢复过程"></a>恢复过程</h2><p>如果看恢复备份集的日志，会发现和 mysqld 启动时非常相似，其实备份集的恢复就是类似 mysqld crash后，做一次 crash recover。</p><p>恢复的目的是把备份集中的数据恢复到一个一致性位点，所谓一致就是指原数据库某一时间点各引擎数据的状态，比如 MyISAM 中的数据对应的是 15:00 时间点的，InnoDB 中的数据对应的是 15:20 的，这种状态的数据就是不一致的。PXB 备份集对应的一致点，就是备份时FTWRL的时间点，恢复出来的数据，就对应原数据库FTWRL时的状态。</p><p>因为备份时 FTWRL 后，数据库是处于只读的，非 InnoDB 数据是在持有全局读锁情况下拷贝的，所以非 InnoDB 数据本身就对应 FTWRL 时间点；InnoDB 的 ibd 文件拷贝是在 FTWRL 前做的，拷贝出来的不同 ibd 文件最后更新时间点是不一样的，这种状态的 ibd 文件是不能直接用的，但是 redo log 是从备份开始一直持续拷贝的，最后的 redo 日志点是在持有 FTWRL 后取得的，所以最终通过 redo 应用后的 ibd 数据时间点也是和 FTWRL 一致的。</p><p>所以恢复过程只涉及 InnoDB 文件的恢复，非 InnoDB 数据是不动的。备份恢复完成后，就可以把数据文件拷贝到对应的目录，然后通过mysqld来启动了。</p><p>备份过程中产生的事务会被备份出来，提交了的前滚，未提交的回滚，保持数据的一致性；</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xtrabackup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xtrabackup备份实操</title>
      <link href="/2017/04/12/xtrabackup%E5%A4%87%E4%BB%BD%E5%AE%9E%E6%93%8D/"/>
      <url>/2017/04/12/xtrabackup%E5%A4%87%E4%BB%BD%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="xtrabackup备份实操"><a href="#xtrabackup备份实操" class="headerlink" title="xtrabackup备份实操"></a>xtrabackup备份实操</h1><p>下载安装xtrabackup</p><pre><code>[root@lyucan ~]# wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.5/binary/tarball/percona-xtrabackup-2.4.5-Linux-x86_64.tar.gz[root@lyucan ~]# tar -xf percona-xtrabackup-2.4.5-Linux-x86_64.tar.gz[root@lyucan ~]# mv percona-xtrabackup-2.4.5-Linux-x86_64 percona-xtrabackup#无需编译，可直接使用</code></pre><p>创建备份用户</p><pre><code class="sql">mysql&gt; create user pxb@&#39;localhost&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt;  grant reload,process,lock tables,replication client on *.* to pxb@localhost;Query OK, 0 rows affected (0.00 sec)</code></pre><p>创建备份存放目录</p><pre><code>[root@lyucan ~]# mkdir -p /data/xtrabackup</code></pre><h2 id="全量备份与恢复"><a href="#全量备份与恢复" class="headerlink" title="全量备份与恢复"></a>全量备份与恢复</h2><p>全量备份</p><pre><code>[root@lyucan ~]# cd percona-xtrabackup/[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --no-timestamp /data/xtrabackup/all-20180410-bak......180410 23:11:42 Executing FLUSH NO_WRITE_TO_BINLOG ENGINE LOGS...xtrabackup: The latest check point (for incremental): &#39;1475999660&#39;xtrabackup: Stopping log copying thread..180410 23:11:42 &gt;&gt; log scanned up to (1475999669)180410 23:11:42 Executing UNLOCK TABLES180410 23:11:42 All tables unlocked180410 23:11:42 [00] Copying ib_buffer_pool to /data/xtrabackup/all-20180410-bak/ib_buffer_pool180410 23:11:42 [00]        ...done180410 23:11:42 Backup created in directory &#39;/data/xtrabackup/all-20180410-bak&#39;MySQL binlog position: filename &#39;mysql-bin.000004&#39;, position &#39;8623&#39;180410 23:11:42 [00] Writing backup-my.cnf180410 23:11:42 [00]        ...done180410 23:11:42 [00] Writing xtrabackup_info180410 23:11:42 [00]        ...donextrabackup: Transaction log of lsn (1475999660) to (1475999669) was copied.180410 23:11:42 completed OK!</code></pre><p>查看备份文件</p><pre><code>[root@lyucan all-20180410-bak]# cd /data/xtrabackup/all-20180410-bak/[root@lyucan all-20180410-bak]# lltotal 77876-rw-r-----. 1 root root      425 Apr 10 23:11 backup-my.cnfdrwxr-x---. 2 root root       49 Apr 10 23:11 dbtest-rw-r-----. 1 root root      503 Apr 10 23:11 ib_buffer_pool-rw-r-----. 1 root root 79691776 Apr 10 23:11 ibdata1drwxr-x---. 2 root root     4096 Apr 10 23:11 mysqldrwxr-x---. 2 root root     8192 Apr 10 23:11 performance_schemadrwxr-x---. 2 root root     8192 Apr 10 23:11 sysdrwxr-x---. 2 root root       45 Apr 10 23:11 test-rw-r-----. 1 root root       22 Apr 10 23:11 xtrabackup_binlog_info-rw-r-----. 1 root root      119 Apr 10 23:11 xtrabackup_checkpoints-rw-r-----. 1 root root      560 Apr 10 23:11 xtrabackup_info-rw-r-----. 1 root root     2560 Apr 10 23:11 xtrabackup_logfile</code></pre><p>xtrabackup_binlog_info 文件记录了备份完成时binlog的position；</p><pre><code>[root@lyucan all-20180410-bak]# cat xtrabackup_binlog_infomysql-bin.000004     8623</code></pre><p><code>xtrabackup_checkpoints</code>记录了备份的起始lsn号和最后的lsn号</p><pre><code>[root@lyucan all-20180410-bak]# cat xtrabackup_checkpointsbackup_type = full-backuped             ##full-backuped表示全备from_lsn = 0                            ##全备lsn号一定是从0开始to_lsn = 1475999660last_lsn = 1475999669compact = 0recover_binlog_info = 0</code></pre><p><code>xtrabackup_info</code>记录了备份的信息，时间，命令，版本等；</p><pre><code>[root@lyucan all-20180410-bak]# cat xtrabackup_infouuid = 79f03ea9-3cd1-11e8-bf94-da8255dea6c5name =tool_name = innobackupextool_command = --defaults-file=/etc/my.cnf --user=pxb --password=... --socket=/tmp/mysql.sock --no-timestamp /data/xtrabackup/all-20180410-baktool_version = 2.4.5ibbackup_version = 2.4.5server_version = 5.7.21-logstart_time = 2018-04-10 23:11:39end_time = 2018-04-10 23:11:42lock_time = 0binlog_pos = filename &#39;mysql-bin.000004&#39;, position &#39;8623&#39;innodb_from_lsn = 0innodb_to_lsn = 1475999660partial = Nincremental = Nformat = filecompact = Ncompressed = Nencrypted = N</code></pre><p>全量恢复</p><pre><code>[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log  /data/xtrabackup/all-20180410-bak......InnoDB: Starting crash recovery.InnoDB: xtrabackup: Last MySQL binlog file position 8129, file name mysql-bin.000004InnoDB: Removed temporary tablespace data file: &quot;ibtmp1&quot;InnoDB: Creating shared tablespace for temporary tablesInnoDB: Setting file &#39;./ibtmp1&#39; size to 12 MB. Physically writing the file full; Please wait ...InnoDB: File &#39;./ibtmp1&#39; size is now 12 MB.InnoDB: 96 redo rollback segment(s) found. 1 redo rollback segment(s) are active.InnoDB: 32 non-redo rollback segment(s) are active.InnoDB: 5.7.13 started; log sequence number 1475999765xtrabackup: starting shutdown with innodb_fast_shutdown = 1InnoDB: FTS optimize thread exiting.InnoDB: Starting shutdown...InnoDB: Shutdown completed; log sequence number 1475999793180410 23:36:27 completed OK!</code></pre><p>这一步的<code>--apply-log</code>的作用是将备份的事务进行前滚（redo）或回滚（undo），将已提交的前滚，未提交的回滚，达到数据的一致性；这个一致性的时间点就是备份过程中FTWRL锁表的时间点。</p><p>应用备份库</p><pre><code>#停掉当前库[root@lyucan xtrabackup]# service mysqld stopShutting down MySQL.... SUCCESS!#将当前库重命名[root@lyucan data]# mv /data/mysql/  /data/mysql_bak_20180410#将备份库重命名为mysql[root@lyucan data]# mv /data/xtrabackup/all-20180410-bak/  /data/mysql#修改权限[root@lyucan data]# chown mysql:mysql -R /data/mysql/#启动数据库[root@lyucan data]# service mysqld startStarting MySQL.. SUCCESS!</code></pre><p>要完全恢复数据库，还要结合二进制日志进行恢复；</p><h2 id="增量备份与恢复"><a href="#增量备份与恢复" class="headerlink" title="增量备份与恢复"></a>增量备份与恢复</h2><p>增量备份</p><pre><code>#首先进行一次全备[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --no-timestamp /data/xtrabackup/all-20180410-bak#进行一次增备，基于第一次的全备[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --no-timestamp --user=pxb --password=echo123. --socket=/tmp/mysql.sock --incremental --incremental-basedir=/data/xtrabackup/all-20180410-bak  /data/xtrabackup/incremental-20180411-bak--incremental：表示是增备--incremental-basedir：基于哪个备份进行增备#再进行一次增备，基于第二次的增备[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --no-timestamp --user=pxb --password=echo123. --socket=/tmp/mysql.sock --incremental --incremental-basedir=/data/xtrabackup/incremental-20180411-bak  /data/xtrabackup/incremental-20180412-bak</code></pre><p>查看三次的备份文件</p><p>checkpoint</p><pre><code>[root@lyucan xtrabackup]# cat /data/xtrabackup/all-20180410-bak/xtrabackup_checkpointsbackup_type = full-backuped             ##全备from_lsn = 0to_lsn = 1476007364last_lsn = 1476007373compact = 0recover_binlog_info = 0[root@lyucan xtrabackup]# cat /data/xtrabackup/incremental-20180411-bak/xtrabackup_checkpointsbackup_type = incremental               ##增备from_lsn = 1476007364to_lsn = 1476011232last_lsn = 1476011241compact = 0recover_binlog_info = 0[root@lyucan xtrabackup]# cat /data/xtrabackup/incremental-20180412-bak/xtrabackup_checkpointsbackup_type = incremental              ##增备from_lsn = 1476011232to_lsn = 1476015084last_lsn = 1476015093compact = 0recover_binlog_info = 0##可以看到lsn号都是连续的binlog_info[root@lyucan xtrabackup]# cat /data/xtrabackup/all-20180410-bak/xtrabackup_binlog_infomysql-bin.000005     479[root@lyucan xtrabackup]# cat /data/xtrabackup/incremental-20180411-bak/xtrabackup_binlog_infomysql-bin.000005     645[root@lyucan xtrabackup]# cat /data/xtrabackup/incremental-20180412-bak/xtrabackup_binlog_infomysql-bin.000005     811</code></pre><p>增备恢复</p><pre><code>##恢复第一个全备，加上--redo-only，表示只进行前滚[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log --redo-only  /data/xtrabackup/all-20180410-bak##将20180411增量备份加到全量备份上，使用--incremental-dir= 来指定增量备份[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log --redo-only  /data/xtrabackup/all-20180410-bak  --incremental-dir=/data/xtrabackup/incremental-20180411-bak##将20180412增量备份加到全量备份上，使用--incremental-dir= 来指定增量备份[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log --redo-only  /data/xtrabackup/all-20180410-bak  --incremental-dir=/data/xtrabackup/incremental-20180412-bak##将所有增量备份加到全备上后，再进行全备的恢复，回归到全量备份，此时没有--redo-only；[root@lyucan percona-xtrabackup]# ./bin/innobackupex --defaults-file=/etc/my.cnf --user=pxb --password=echo123. --socket=/tmp/mysql.sock --apply-log  /data/xtrabackup/all-20180410-bak</code></pre><p>应用备份库</p><pre><code>#停掉当前库[root@lyucan xtrabackup]# service mysqld stopShutting down MySQL.... SUCCESS!#将当前库重命名[root@lyucan data]# mv /data/mysql/  /data/mysql_bak_20180410#将备份库重命名为mysql[root@lyucan data]# mv /data/xtrabackup/all-20180410-bak/  /data/mysql#修改权限[root@lyucan data]# chown mysql:mysql -R /data/mysql/#启动数据库[root@lyucan data]# service mysqld startStarting MySQL.. SUCCESS!</code></pre><p><strong>还是那句话，如果要进行完全数据恢复，还需要结合二进制日志进行数据恢复；</strong></p><p><strong>很简单，根据备份里面记录的xtrabackup_binlog_info，进行原库二进制日志的恢复；</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xtrabackup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-5.7 安装</title>
      <link href="/2017/04/08/Mysql-5-7-%E5%AE%89%E8%A3%85/"/>
      <url>/2017/04/08/Mysql-5-7-%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="安装前说明"><a href="#安装前说明" class="headerlink" title="安装前说明"></a>安装前说明</h1><p>如果机器上已经有了mysql或者MariaDB，先卸载再安装；</p><pre><code>[root@lyucan ~]# rpm -e mariadb-libs-5.5.41-2.el7_0.x86_64 --nodeps</code></pre><h1 id="创建mysql用户"><a href="#创建mysql用户" class="headerlink" title="创建mysql用户"></a>创建mysql用户</h1><pre><code>[root@lyucan ~]# useradd mysql</code></pre><h1 id="下载软件包并解压授权"><a href="#下载软件包并解压授权" class="headerlink" title="下载软件包并解压授权"></a>下载软件包并解压授权</h1><pre><code>[root@lyucan ~]# wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz[root@lyucan ~]# tar -xf mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz -C /usr/local/[root@lyucan ~]# mv /usr/local/mysql-5.7.21-linux-glibc2.12-x86_64/ /usr/local/mysql[root@lyucan ~]# chown mysql:mysql /usr/local/mysql/</code></pre><h1 id="创建数据目录"><a href="#创建数据目录" class="headerlink" title="创建数据目录"></a>创建数据目录</h1><pre><code>[root@lyucan ~]# mkdir /data/mysql -p[root@lyucan ~]# chown -R mysql:mysql /data/mysql/</code></pre><h1 id="创建my-cnf配置文件"><a href="#创建my-cnf配置文件" class="headerlink" title="创建my.cnf配置文件"></a>创建my.cnf配置文件</h1><p>mysql5.7没有默认的my_default.cnf文件，需要自己手动创建，下面这个是一个简单的模板；</p><pre><code>[root@lyucan mysql]# vim /etc/my.cnf[client]port = 3306socket = /tmp/mysql.sock[mysqld]character_set_server=utf8init_connect=&#39;SET NAMES utf8&#39;basedir=/usr/local/mysqldatadir=/data/mysql/socket=/tmp/mysql.socklog-error=/usr/local/mysql/mysqld.errpid-file=/usr/local/mysql/mysqld.pid#不区分大小写lower_case_table_names = 1#sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION#max_connections=5000##修改my.cnf权限[mysql@lyucan ~]$ chown mysql:mysql /etc/my.cnf</code></pre><h1 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h1><pre><code>[root@lyucan bin]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql#这条命令没有输出，但是会创建一个临时的root密码，在上面配置文件定义的/usr/local/mysql/mysqld.err文件中，如下所示，临时密码为 5SEAgHPPqK&lt;u[root@lyucan ~]# cat /usr/local/mysql/mysqld.err2017-04-08T16:39:16.991943Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2017-04-08T16:39:17.284209Z 0 [Warning] InnoDB: New log files created, LSN=457902017-04-08T16:39:17.337845Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2017-04-08T16:39:17.395477Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 61308035-3b4b-11e8-9bb4-da8255dea6c5.2017-04-08T16:39:17.396765Z 0 [Warning] Gtid table is not ready to be used. Table &#39;mysql.gtid_executed&#39; cannot be opened.2017-04-08T16:39:17.397767Z 1 [Note] A temporary password is generated for root@localhost: 5SEAgHPPqK&lt;u</code></pre><blockquote><p>上面的<code>root@localhost: 5SEAgHPPqK&lt;u</code>需要记住，后面需要用到</p></blockquote><h1 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h1><pre><code>[root@lyucan support-files]# cd /usr/local/mysql/support-files/[root@lyucan support-files]# ./mysql.server startStarting MySQL. SUCCESS!</code></pre><h1 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h1><pre><code>[root@lyucan support-files]# cd /usr/local/mysql/bin/[root@lyucan bin]# ./mysql -uroot -pEnter password:                 ##这里的密码就是上面的临时root密码 5SEAgHPPqK&lt;uWelcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.7.21Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt;</code></pre><h1 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h1><pre><code class="sql">mysql&gt; set password=password(&#39;root123&#39;);Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><h1 id="安装后操作"><a href="#安装后操作" class="headerlink" title="安装后操作"></a>安装后操作</h1><pre><code>#设置开机自启动；[root@lyucan bin]# cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld[root@lyucan bin]# chkconfig --add mysqld[root@lyucan bin]# chkconfig mysqld on#当复制到/etc/init.d/mysqld后，可以使用service mysqld start|stop的方式启停；[root@lyucan bin]# service mysqld statusSUCCESS! MySQL running (25732)[root@lyucan bin]# service mysqld stopShutting down MySQL.. SUCCESS![root@lyucan bin]# service mysqld startStarting MySQL. SUCCESS!#将mysql工具的命令添加到PATH环境变量里面去，使用的时候就不用使用绝对路径；[root@lyucan bin]# echo &quot;export PATH=$PATH:/usr/local/mysql/bin&quot; &gt;&gt; /etc/profile[root@lyucan bin]# source /etc/profile</code></pre><h1 id="创建远程连接用户"><a href="#创建远程连接用户" class="headerlink" title="创建远程连接用户"></a>创建远程连接用户</h1><pre><code class="sql">mysql&gt; grant all privileges on *.* to &#39;lyucan&#39;@&#39;%&#39; identified by &#39;echo123.&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)</code></pre><h1 id="远程连接检测"><a href="#远程连接检测" class="headerlink" title="远程连接检测"></a>远程连接检测</h1><p>注意放通或关掉防火墙</p><pre><code>[root@lyucan ~]# firewall-cmd --permanent --add-service=mysqlsuccess[root@lyucan ~]# firewall-cmd --reloadsuccess</code></pre><p><img src="/images/mysql%E5%AE%89%E8%A3%85.png" alt="mysql安装"></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
